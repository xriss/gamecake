
const char* wetgenes_cache_lua_mods[]={

"fenestra.widget.skin","-- copy all globals into locals, some locals are renamed to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,luaload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local bit=require('bit')\n"
"local gl=require('gl')\n"
"local grd=require('grd')\n"
"\n"
"\n"
"local apps=apps\n"
"\n"
"local function explode_color(c)\n"
"\n"
"	local r,g,b,a\n"
"	\n"
"	a=bit.band(bit.rshift(c,24),0xff)\n"
"	r=bit.band(bit.rshift(c,16),0xff)\n"
"	g=bit.band(bit.rshift(c, 8),0xff)\n"
"	b=bit.band(c,0xff)\n"
"\n"
"	return r/0xff,g/0xff,b/0xff,a/0xff\n"
"end\n"
"\n"
"local function implode_color(r,g,b,a)\n"
"\n"
"	if type(r)==\"table\" then a=r[4] b=r[3] g=r[2] r=r[1] end -- convert from table?\n"
"	\n"
"	local c\n"
"	\n"
"	c=             bit.band(b*0xff,0xff)\n"
"	c=c+bit.lshift(bit.band(g*0xff,0xff),8)\n"
"	c=c+bit.lshift(bit.band(r*0xff,0xff),16)\n"
"	c=c+bit.lshift(bit.band(a*0xff,0xff),24)\n"
"\n"
"	return c\n"
"end\n"
"\n"
"\n"
"\n"
"module(\"fenestra.widget.skin\")\n"
"\n"
"local mode=nil\n"
"local texs={}\n"
"\n"
"local margin=0 -- whitespace\n"
"local border=0 -- solidspace\n"
"--\n"
"-- unload a skin, go back to the \"builtin\" default\n"
"--\n"
"function unload(win)\n"
"\n"
"	mode=nil\n"
"	texs={}\n"
"	\n"
"end\n"
"\n"
"\n"
"--\n"
"-- load a skin\n"
"--\n"
"function load(win,name)\n"
"\n"
"	unload(win)\n"
"\n"
"	if name then -- load a named skin\n"
"	\n"
"		if name==\"test\" then\n"
"			mode=name\n"
"\n"
"			texs.border=win.tex( grd.create(\"GRD_FMT_U8_BGRA\",apps.dir..\"data/skins/test/border.png\") )\n"
"			\n"
"			texs.buttof=win.tex( grd.create(\"GRD_FMT_U8_BGRA\",apps.dir..\"data/skins/test/buttof.png\") )\n"
"			texs.button=win.tex( grd.create(\"GRD_FMT_U8_BGRA\",apps.dir..\"data/skins/test/button.png\") )\n"
"			texs.buttin=win.tex( grd.create(\"GRD_FMT_U8_BGRA\",apps.dir..\"data/skins/test/buttin.png\") )\n"
"		\n"
"			margin=15\n"
"			border=0\n"
"		end\n"
"			\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"function draw33(tw,th, mw,mh, vxs,vys, vw,vh)\n"
"		\n"
"--		local vw,vh=512,52\n"
"--		local mw,mh=24,24\n"
"\n"
"		if mw*2 > vw then mw=vw/2 end\n"
"		if mh*2 > vh then mh=vh/2 end\n"
"\n"
"		\n"
"		local tww={mw/tw,(tw-2*mw)/tw,mw/tw}\n"
"		local thh={mh/th,(th-2*mh)/th,mh/th}\n"
"		local vww={mw,vw-2*mw,mw}\n"
"		local vhh={mh,vh-2*mh,mh}\n"
"		\n"
"		gl.Disable(gl.DEPTH_TEST)\n"
"		gl.Disable(gl.LIGHTING)\n"
"		gl.Disable(gl.CULL_FACE)\n"
"		gl.Enable(gl.TEXTURE_2D)\n"
"\n"
"\n"
"		gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR)\n"
"		gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)\n"
"\n"
"\n"
"		gl.Begin(gl.QUADS)\n"
"--			gl.Color({1,1,1,1})\n"
"			\n"
"			local function drawbox( tx,ty, vx,vy , txp,typ, vxp,vyp )\n"
"				gl.TexCoord(tx    ,ty)     gl.Vertex(vx,    vy)\n"
"				gl.TexCoord(tx+txp,ty)     gl.Vertex(vx+vxp,vy)\n"
"				gl.TexCoord(tx+txp,ty+typ) gl.Vertex(vx+vxp,vy+vyp)\n"
"				gl.TexCoord(tx    ,ty+typ) gl.Vertex(vx,    vy+vyp)\n"
"			end\n"
"			\n"
"		local tx,ty=0,0\n"
"		local vx,vy=vxs,vys-- -vw/2,vh/2\n"
"\n"
"			for iy=1,3 do\n"
"				tx=0\n"
"				vx=vxs-- -vw/2\n"
"				for ix=1,3 do\n"
"\n"
"					drawbox( tx,ty, vx,vy , tww[ix],thh[iy], vww[ix],-vhh[iy] )\n"
"\n"
"					tx=tx+tww[ix]\n"
"					vx=vx+vww[ix]\n"
"				end\n"
"				ty=ty+thh[iy]\n"
"				vy=vy-vhh[iy]\n"
"			end\n"
"			\n"
"		gl.End()\n"
"\n"
"\n"
"end\n"
"\n"
"--\n"
"-- add meta functions\n"
"--\n"
"function setup(def)\n"
"\n"
"--	load(def.win,\"test\")\n"
"\n"
"\n"
"	local master=def.master\n"
"	local meta=def.meta\n"
"	local win=def.win\n"
"	local font=def.font\n"
"	\n"
"--\n"
"-- display this widget and its sub widgets\n"
"--\n"
"	function meta.draw(widget)\n"
"		\n"
"		if debug_hook then debug_hook(\"draw\",widget) end\n"
"		\n"
"		\n"
"\n"
"		-- draw rectangle\n"
"\n"
"\n"
"		gl.PopMatrix() -- expect the base to be pushed\n"
"		gl.PushMatrix()\n"
"		\n"
"		gl.Translate(widget.pxd,widget.pyd,0)\n"
"		\n"
"		if widget.fbo then\n"
"			if widget.fbo.width~=widget.sx or widget.fbo.height~=widget.sy then -- resize so we need a new fbo\n"
"				widget.fbo:clean()\n"
"				widget.fbo=nil\n"
"			end\n"
"			if not widget.fbo then -- allocate a new fbo\n"
"print(\"new fbo\",widget.sx,widget.sy)\n"
"				widget.fbo=_G.win.fbo(widget.sx,widget.sy,0)\n"
"				widget.dirty=true -- flag redraw\n"
"			end\n"
"				\n"
"		end\n"
"\n"
"if ( not widget.fbo ) or widget.dirty then -- if no fbo and then we are always dirty... Dirty, dirty, dirty.\n"
"\n"
"		if widget.fbo then\n"
"--print(\"into fbo\")\n"
"			\n"
"			gl.MatrixMode(gl.PROJECTION)\n"
"			gl.PushMatrix()\n"
"\n"
"			widget.fbo:bind()\n"
"			\n"
"--			gl.ClearColor(14/15,14/15,14/15,1)\n"
"			gl.ClearColor(0,0,0,0)\n"
"			gl.Clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT)\n"
"\n"
"			win.project23d(widget.sx/widget.sy,1,1024)\n"
"						\n"
"			gl.MatrixMode(gl.MODELVIEW)\n"
"			gl.LoadIdentity()\n"
"			gl.Translate(-widget.sx/2,widget.sy/2,-widget.sy/2)\n"
"			gl.Translate(-widget.pxd,-widget.pyd,0)\n"
"\n"
"			if widget.pan_px and widget.pan_py then -- fidle everything\n"
"				gl.Translate(widget.pan_px,widget.pan_py,0)\n"
"			end\n"
"						\n"
"			gl.PushMatrix() -- put new base matrix onto stack\n"
"		end\n"
"		\n"
"		widget.dirty=nil\n"
"				\n"
"		gl.Disable(gl.LIGHTING)\n"
"		gl.Disable(gl.DEPTH_TEST)\n"
"		gl.Disable(gl.CULL_FACE)\n"
"		gl.Disable(gl.TEXTURE_2D)\n"
"		\n"
"		local txp,typ=0,0\n"
"		\n"
"		if widget.color then\n"
"		\n"
"			if widget.highlight==\"shrink\" then\n"
"			\n"
"				gl.Color( explode_color(widget.color))\n"
"					\n"
"				if master.over==widget then\n"
"					gl.Translate(widget.hx/16,-widget.hy/16,0)\n"
"					gl.Scale(7/8,7/8,1)\n"
"				end\n"
"			\n"
"			elseif widget.highlight==\"none\" then\n"
"			\n"
"				gl.Color( explode_color(widget.color))\n"
"				\n"
"			elseif widget.highlight==\"text\" then\n"
"			\n"
"				gl.Color( explode_color(widget.color))\n"
"				\n"
"			else -- default is to darken everything slightly when it is not the active widget\n"
"			\n"
"				if master.over==widget then\n"
"					gl.Color( explode_color(widget.color))\n"
"				else\n"
"					local c={explode_color(widget.color)}\n"
"					c[3]=c[3]*14/15\n"
"					c[2]=c[2]*14/15\n"
"					c[1]=c[1]*14/15\n"
"					gl.Color( c )\n"
"				end\n"
"				\n"
"			end\n"
"			\n"
"			local hx=widget.hx\n"
"			local hy=widget.hy\n"
"			local bb=2\n"
"			local tl={1,1,1,0.25}\n"
"			local br={0,0,0,0.25}\n"
"			\n"
"			if ( master.active==widget and master.over==widget ) or widget.state==\"selected\" then\n"
"				tl,br=br,tl\n"
"				txp=1\n"
"				typ=1\n"
"			end\n"
"			\n"
"			if mode then\n"
"			\n"
"				if ( master.active==widget and master.over==widget ) or widget.state==\"selected\" then\n"
"					texs.buttin:bind()\n"
"					txp=0\n"
"					typ=-1\n"
"				else\n"
"					texs.button:bind()\n"
"					txp=0\n"
"					typ=-2\n"
"				end\n"
"				\n"
"				if widget.class==\"string\" then -- hack\n"
"					texs.border:bind()\n"
"				end\n"
"			\n"
"				draw33(128,128, 24,24, 0-margin,0+margin, hx+(margin*2),hy+(margin*2))\n"
"			\n"
"			else -- builtin\n"
"			\n"
"				gl.Begin(gl.QUADS)\n"
"					gl.Vertex(  0,   0)\n"
"					gl.Vertex( hx,   0)\n"
"					gl.Vertex( hx, -hy)\n"
"					gl.Vertex(  0, -hy)\n"
"				gl.End()\n"
"				gl.Color( tl )\n"
"				gl.Begin(gl.QUADS)\n"
"					gl.Vertex(  0,   0  )\n"
"					gl.Vertex( hx,   0  )\n"
"					gl.Vertex( hx-bb, -bb)\n"
"					gl.Vertex(  0+bb, -bb)\n"
"					\n"
"					gl.Vertex(  0,    0   )\n"
"					gl.Vertex(  0+bb, -bb )\n"
"					gl.Vertex(  0+bb, -hy+bb)\n"
"					gl.Vertex(  0,    -hy  )\n"
"				gl.End()\n"
"				gl.Color( br )\n"
"				gl.Begin(gl.QUADS)\n"
"					gl.Vertex( hx,   -hy  )\n"
"					gl.Vertex(  0,   -hy  )\n"
"					gl.Vertex(  0+bb, -hy+bb)\n"
"					gl.Vertex( hx-bb, -hy+bb)\n"
"					\n"
"					gl.Vertex(  hx,    0   )\n"
"					gl.Vertex(  hx,    -hy  )\n"
"					gl.Vertex(  hx-bb, -hy+bb)\n"
"					gl.Vertex(  hx-bb, -bb )\n"
"				gl.End()\n"
"			end\n"
"			\n"
"		end\n"
"		\n"
"		if widget.text then\n"
"		\n"
"			local tx,ty=font.size(widget.text,widget.text_size)\n"
"			\n"
"			local c=widget.text_color\n"
"			\n"
"			if widget.text_color_over then\n"
"				if master.over==widget then\n"
"					c=widget.text_color_over\n"
"				end\n"
"			end\n"
"			\n"
"			if widget.text_align==\"left\" then\n"
"				tx=0\n"
"				ty=0			\n"
"			elseif widget.text_align==\"right\" then\n"
"				tx=(widget.hx-tx)\n"
"				ty=(widget.hy-ty)			\n"
"			else\n"
"				tx=(widget.hx-tx)/2\n"
"				ty=(widget.hy-ty)/2\n"
"			end\n"
"			\n"
"			tx=tx+txp\n"
"			ty=ty+typ\n"
"			\n"
"			widget.text_x=tx\n"
"			widget.text_y=ty\n"
"\n"
"			font.set(tx,-ty,c,widget.text_size)\n"
"			font.draw(widget.text)\n"
"		\n"
"\n"
"				if widget.class==\"textedit\" then -- hack\n"
"					if widget.master.focus==widget then --only draw curser in active widget\n"
"						local sw=font.size(widget.text:sub(1,widget.line_idx))\n"
"						gl.Enable(gl.COLOR_MATERIAL)\n"
"						win.flat_rect(\n"
"							tx+sw+0,-ty,\n"
"							tx+sw+2,-ty-widget.text_size,\n"
"							widget.master.throb*256*256*256)\n"
"						gl.Disable(gl.COLOR_MATERIAL)\n"
"							\n"
"					end\n"
"				end\n"
"\n"
"		end\n"
"		\n"
"		for i,v in ipairs(widget) do\n"
"			if not v.fbo or not v.dirty then -- terminate recursion at dirty fbo\n"
"				v:draw()\n"
"			end\n"
"		end\n"
"\n"
"		if widget.fbo then -- we have drawn into the fbo\n"
"			\n"
"			gl.MatrixMode(gl.PROJECTION)\n"
"			gl.PopMatrix()\n"
"			\n"
"			gl.MatrixMode(gl.MODELVIEW)\n"
"			gl.PopMatrix()\n"
"			\n"
"			win.fbo_bind()\n"
"		end\n"
"		\n"
"else -- we can only draw once\n"
"\n"
"		if widget.fbo then -- we need to draw our cached fbo\n"
"		\n"
"			gl.Disable(gl.LIGHTING)\n"
"			gl.Disable(gl.DEPTH_TEST)\n"
"			gl.Disable(gl.CULL_FACE)\n"
"			gl.Disable(gl.TEXTURE_2D)\n"
"		\n"
"			gl.Translate(widget.sx/2,-widget.sy/2,0)\n"
"			gl.Color(1,1,1,1)\n"
"			widget.fbo:draw()\n"
"--print(\"draw fbo\")\n"
"		end\n"
"		\n"
"end\n"
"	\n"
"		\n"
"		return widget\n"
"	end\n"
"\n"
"\n"
"\n"
"end\n"
"",

"simpxml","\n"
"local table=table\n"
"local string=string\n"
"\n"
"local pairs=pairs\n"
"local ipairs=ipairs\n"
"\n"
"local type=type\n"
"\n"
"local tostring=tostring\n"
"local print=print\n"
"\n"
"module(...)\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- some old simple xml parsing code, found here and fixed up a little :)\n"
"--\n"
"-- http://lua-users.org/lists/lua-l/2002-06/msg00040.html\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- auxiliar function to parse tag attributes\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function parse_args(s,label)\n"
"  local arg = {}\n"
"  arg[0]=string.lower(label or \"?\")\n"
"  string.gsub(s, \"([%w_]+)%s*=%s*([\\\"'])(.-)%2\", function (w, _, a)\n"
"    arg[string.lower(w)] = a\n"
"  end)\n"
"  return arg\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- string \"s\" is a string with XML marks. This function parses the string\n"
"-- and returns the resulting tree.\n"
"--\n"
"-- simple but will parse small data xml files just fine and thats what im using it for\n"
"--\n"
"-- it is very easy to produce a valid xml file that will break this\n"
"-- however as long as you are just using tags/data and especially if you control the creation\n"
"-- everything will be peachy\n"
"--\n"
"-- by putting the tag name in [0] we can use the string namespace for all attributes\n"
"--\n"
"-- [0] == tag name (lowercase)\n"
"-- [1++] == contained strings or tables (sub tags)\n"
"-- [string] == attributes (indexe strings will be converted to lowercase)\n"
"--\n"
"-- all string keys are attributes associated with the tag\n"
"-- all numerical keys are sub tags/strings except [0] which is the tag name\n"
"--\n"
"-- see the other functions here for how to simply step through this tree\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function parse(s)\n"
"  local stack = {}\n"
"  local top = {}\n"
"  table.insert(stack, top)\n"
"  local i = 1\n"
"  local ni,j,c,label,args, empty = string.find(s, \"<%?(%/?)([%w_]+)(.-)(%/?)%?>\")\n"
"  \n"
"  while ni do\n"
"    local text = string.sub(s, i, ni-1)\n"
"    if not string.find(text, \"^%s*$\") then\n"
"      table.insert(top, text)\n"
"    end\n"
"    if empty == \"/\" then  -- empty element tag\n"
"      table.insert(top, parse_args(args,label) )\n"
"    elseif c == \"\" then   -- start tag\n"
"      top = parse_args(args,label)\n"
"      table.insert(stack, top)   -- new level\n"
"    else  -- end tag\n"
"      local toclose = table.remove(stack)  -- remove top\n"
"      top = stack[#stack]\n"
"      if #stack < 1 then\n"
"        assert(false,\"Tag <\"..label..\"> not matched \")\n"
"      end\n"
"      if toclose[0] ~= label then\n"
"	    assert(false,\"Tag <\"..(toclose[0] or \"?\")..\"> doesnt match <\"..(label or \"?\")..\">.\")\n"
"      end\n"
"      table.insert(top, toclose)\n"
"    end \n"
"    i = j+1\n"
"    ni,j,c,label,args, empty = string.find(s, \"<(%/?)([%w_]+)(.-)(%/?)>\", j)\n"
"  end\n"
"  local text = string.sub(s, i)\n"
"  if not string.find(text, \"^%s*$\") then\n"
"    table.insert(stack[#stack], text)\n"
"  end\n"
"  return stack[2]\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- find the first child tag of the given type\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function child(parent,name)\n"
"\n"
"	if type(name)==\"table\" then -- sub sub sub lookup\n"
"	\n"
"		local ret=parent\n"
"		for i,v in ipairs(name) do\n"
"			if not ret then return nil end\n"
"			ret=child(ret,v)\n"
"		end\n"
"		return ret\n"
"		\n"
"	else\n"
"		name=string.lower(name)\n"
"\n"
"		for i,v in ipairs(parent) do\n"
"			if type(v)==\"table\" and v[0] and string.lower(v[0])==name then return v end\n"
"		end\n"
"\n"
"	end\n"
"	\n"
"	return nil\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert an xml tree to an xml string that could then be output to a file\n"
"--\n"
"-- again, best used with small data sets only please :)\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function tree_to_string(tree)\n"
"\n"
"	local t={}\n"
"	function out(s) t[#t+1]=tostring(s) end\n"
"	local indent=-1\n"
"	\n"
"	local function dosub(l)\n"
"		indent=indent+1\n"
"	\n"
"		local tabs=\"\"\n"
"		if indent>0 then tabs=string.rep(\" \",indent) end\n"
"	\n"
"		out(tabs)\n"
"		out(\"<\"..l[0])\n"
"		local ns={}\n"
"		for i,v in pairs(l) do\n"
"			if type(i)==\"string\" then --find attributes\n"
"				ns[#ns+1]=i\n"
"			end\n"
"		end\n"
"		table.sort(ns) -- ascii sort attributes\n"
"		for i=1,#ns do\n"
"			out(\" \"..ns[i]..\"=\\\"\"..l[ ns[i] ]..\"\\\"\")\n"
"		end\n"
"		if not l[1] then -- no children\n"
"			out(\" />\\n"
"\")\n"
"		else\n"
"			out(\">\\n"
"\")\n"
"			\n"
"			for i=1,#l do\n"
"				if type(l[i])==\"table\" then\n"
"					dosub(l[i])\n"
"				else\n"
"					out(l[i])\n"
"				end\n"
"			end\n"
"			\n"
"			out(tabs)\n"
"			out(\"</\"..l[0]..\">\\n"
"\")\n"
"		end\n"
"\n"
"		indent=indent-1\n"
"	end\n"
"-- the top chunk is an xml version string and possibly some text\n"
"-- skip that bit, just output its chunks with this standard xml header\n"
"	out([[<?xml version=\"1.0\" standalone=\"no\" ?>]])\n"
"	out(\"\\n"
"\")\n"
"	for i=1,#tree do\n"
"		if type(tree[i])==\"table\" then\n"
"			dosub(tree[i])\n"
"		end\n"
"	end\n"
"\n"
"	return table.concat(t)\n"
"end\n"
"",

"fenestra.data","\n"
"\n"
"local hex=function(str) return tonumber(str,16) end\n"
"\n"
"local io=io\n"
"local string=string\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local math=math\n"
"local loadstring=loadstring\n"
"local pcall=pcall\n"
"\n"
"-- imported global functions\n"
"local sub = string.sub\n"
"local match = string.match\n"
"local find = string.find\n"
"local push = table.insert\n"
"local pop = table.remove\n"
"local append = table.insert\n"
"local concat = table.concat\n"
"local floor = math.floor\n"
"local write = io.write\n"
"local read = io.read\n"
"local type = type\n"
"local setfenv = setfenv\n"
"local tostring=tostring\n"
"local pairs=pairs\n"
"local ipairs=ipairs\n"
"local unpack=unpack\n"
"\n"
"local _G = _G\n"
"\n"
"local apps=apps\n"
"local wldir=apps.dir or \"\"\n"
"\n"
"module(\"fenestra.data\")\n"
"\n"
"\n"
"\n"
"function setup(fenestra)\n"
"\n"
"	local print=fenestra._g.print\n"
"	\n"
"	local it={}\n"
"	\n"
"	function it.clean()\n"
"\n"
"	end\n"
"	\n"
"	function it.load(fname)\n"
"\n"
"		local fp=io.open(wldir..fname,\"rb\")\n"
"		local dat=fp:read(\"*all\")\n"
"		fp:close();\n"
"		\n"
"		\n"
"		return fenestra.load(dat)\n"
"\n"
"	end\n"
"	\n"
"	return it\n"
"end\n"
"",

"socket.url","-----------------------------------------------------------------------------\n"
"-- URI parsing, composition and relative URL resolution\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: url.lua,v 1.38 2006/04/03 04:45:42 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module\n"
"-----------------------------------------------------------------------------\n"
"local string = require(\"string\")\n"
"local base = _G\n"
"local table = require(\"table\")\n"
"module(\"socket.url\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Module version\n"
"-----------------------------------------------------------------------------\n"
"_VERSION = \"URL 1.0.1\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Encodes a string into its escaped hexadecimal representation\n"
"-- Input\n"
"--   s: binary string to be encoded\n"
"-- Returns\n"
"--   escaped representation of string binary\n"
"-----------------------------------------------------------------------------\n"
"function escape(s)\n"
"    return string.gsub(s, \"([^A-Za-z0-9_])\", function(c)\n"
"        return string.format(\"%%%02x\", string.byte(c))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Protects a path segment, to prevent it from interfering with the\n"
"-- url parsing.\n"
"-- Input\n"
"--   s: binary string to be encoded\n"
"-- Returns\n"
"--   escaped representation of string binary\n"
"-----------------------------------------------------------------------------\n"
"local function make_set(t)\n"
"	local s = {}\n"
"	for i,v in base.ipairs(t) do\n"
"		s[t[i]] = 1\n"
"	end\n"
"	return s\n"
"end\n"
"\n"
"-- these are allowed withing a path segment, along with alphanum\n"
"-- other characters must be escaped\n"
"local segment_set = make_set {\n"
"    \"-\", \"_\", \".\", \"!\", \"~\", \"*\", \"'\", \"(\",\n"
"	\")\", \":\", \"@\", \"&\", \"=\", \"+\", \"$\", \",\",\n"
"}\n"
"\n"
"local function protect_segment(s)\n"
"	return string.gsub(s, \"([^A-Za-z0-9_])\", function (c)\n"
"		if segment_set[c] then return c\n"
"		else return string.format(\"%%%02x\", string.byte(c)) end\n"
"	end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Encodes a string into its escaped hexadecimal representation\n"
"-- Input\n"
"--   s: binary string to be encoded\n"
"-- Returns\n"
"--   escaped representation of string binary\n"
"-----------------------------------------------------------------------------\n"
"function unescape(s)\n"
"    return string.gsub(s, \"%%(%x%x)\", function(hex)\n"
"        return string.char(base.tonumber(hex, 16))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Builds a path from a base path and a relative path\n"
"-- Input\n"
"--   base_path\n"
"--   relative_path\n"
"-- Returns\n"
"--   corresponding absolute path\n"
"-----------------------------------------------------------------------------\n"
"local function absolute_path(base_path, relative_path)\n"
"    if string.sub(relative_path, 1, 1) == \"/\" then return relative_path end\n"
"    local path = string.gsub(base_path, \"[^/]*$\", \"\")\n"
"    path = path .. relative_path\n"
"    path = string.gsub(path, \"([^/]*%./)\", function (s)\n"
"        if s ~= \"./\" then return s else return \"\" end\n"
"    end)\n"
"    path = string.gsub(path, \"/%.$\", \"/\")\n"
"    local reduced\n"
"    while reduced ~= path do\n"
"        reduced = path\n"
"        path = string.gsub(reduced, \"([^/]*/%.%./)\", function (s)\n"
"            if s ~= \"../../\" then return \"\" else return s end\n"
"        end)\n"
"    end\n"
"    path = string.gsub(reduced, \"([^/]*/%.%.)$\", function (s)\n"
"        if s ~= \"../..\" then return \"\" else return s end\n"
"    end)\n"
"    return path\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Parses a url and returns a table with all its parts according to RFC 2396\n"
"-- The following grammar describes the names given to the URL parts\n"
"-- <url> ::= <scheme>://<authority>/<path>;<params>?<query>#<fragment>\n"
"-- <authority> ::= <userinfo>@<host>:<port>\n"
"-- <userinfo> ::= <user>[:<password>]\n"
"-- <path> :: = {<segment>/}<segment>\n"
"-- Input\n"
"--   url: uniform resource locator of request\n"
"--   default: table with default values for each field\n"
"-- Returns\n"
"--   table with the following fields, where RFC naming conventions have\n"
"--   been preserved:\n"
"--     scheme, authority, userinfo, user, password, host, port,\n"
"--     path, params, query, fragment\n"
"-- Obs:\n"
"--   the leading '/' in {/<path>} is considered part of <path>\n"
"-----------------------------------------------------------------------------\n"
"function parse(url, default)\n"
"    -- initialize default parameters\n"
"    local parsed = {}\n"
"    for i,v in base.pairs(default or parsed) do parsed[i] = v end\n"
"    -- empty url is parsed to nil\n"
"    if not url or url == \"\" then return nil, \"invalid url\" end\n"
"    -- remove whitespace\n"
"    -- url = string.gsub(url, \"%s\", \"\")\n"
"    -- get fragment\n"
"    url = string.gsub(url, \"#(.*)$\", function(f)\n"
"        parsed.fragment = f\n"
"        return \"\"\n"
"    end)\n"
"    -- get scheme\n"
"    url = string.gsub(url, \"^([%w][%w%+%-%.]*)%:\",\n"
"        function(s) parsed.scheme = s; return \"\" end)\n"
"    -- get authority\n"
"    url = string.gsub(url, \"^//([^/]*)\", function(n)\n"
"        parsed.authority = n\n"
"        return \"\"\n"
"    end)\n"
"    -- get query stringing\n"
"    url = string.gsub(url, \"%?(.*)\", function(q)\n"
"        parsed.query = q\n"
"        return \"\"\n"
"    end)\n"
"    -- get params\n"
"    url = string.gsub(url, \"%;(.*)\", function(p)\n"
"        parsed.params = p\n"
"        return \"\"\n"
"    end)\n"
"    -- path is whatever was left\n"
"    if url ~= \"\" then parsed.path = url end\n"
"    local authority = parsed.authority\n"
"    if not authority then return parsed end\n"
"    authority = string.gsub(authority,\"^([^@]*)@\",\n"
"        function(u) parsed.userinfo = u; return \"\" end)\n"
"    authority = string.gsub(authority, \":([^:]*)$\",\n"
"        function(p) parsed.port = p; return \"\" end)\n"
"    if authority ~= \"\" then parsed.host = authority end\n"
"    local userinfo = parsed.userinfo\n"
"    if not userinfo then return parsed end\n"
"    userinfo = string.gsub(userinfo, \":([^:]*)$\",\n"
"        function(p) parsed.password = p; return \"\" end)\n"
"    parsed.user = userinfo\n"
"    return parsed\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Rebuilds a parsed URL from its components.\n"
"-- Components are protected if any reserved or unallowed characters are found\n"
"-- Input\n"
"--   parsed: parsed URL, as returned by parse\n"
"-- Returns\n"
"--   a stringing with the corresponding URL\n"
"-----------------------------------------------------------------------------\n"
"function build(parsed)\n"
"    local ppath = parse_path(parsed.path or \"\")\n"
"    local url = build_path(ppath)\n"
"    if parsed.params then url = url .. \";\" .. parsed.params end\n"
"    if parsed.query then url = url .. \"?\" .. parsed.query end\n"
"	local authority = parsed.authority\n"
"	if parsed.host then\n"
"		authority = parsed.host\n"
"		if parsed.port then authority = authority .. \":\" .. parsed.port end\n"
"		local userinfo = parsed.userinfo\n"
"		if parsed.user then\n"
"			userinfo = parsed.user\n"
"			if parsed.password then\n"
"				userinfo = userinfo .. \":\" .. parsed.password\n"
"			end\n"
"		end\n"
"		if userinfo then authority = userinfo .. \"@\" .. authority end\n"
"	end\n"
"    if authority then url = \"//\" .. authority .. url end\n"
"    if parsed.scheme then url = parsed.scheme .. \":\" .. url end\n"
"    if parsed.fragment then url = url .. \"#\" .. parsed.fragment end\n"
"    -- url = string.gsub(url, \"%s\", \"\")\n"
"    return url\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Builds a absolute URL from a base and a relative URL according to RFC 2396\n"
"-- Input\n"
"--   base_url\n"
"--   relative_url\n"
"-- Returns\n"
"--   corresponding absolute url\n"
"-----------------------------------------------------------------------------\n"
"function absolute(base_url, relative_url)\n"
"    if base.type(base_url) == \"table\" then\n"
"        base_parsed = base_url\n"
"        base_url = build(base_parsed)\n"
"    else\n"
"        base_parsed = parse(base_url)\n"
"    end\n"
"    local relative_parsed = parse(relative_url)\n"
"    if not base_parsed then return relative_url\n"
"    elseif not relative_parsed then return base_url\n"
"    elseif relative_parsed.scheme then return relative_url\n"
"    else\n"
"        relative_parsed.scheme = base_parsed.scheme\n"
"        if not relative_parsed.authority then\n"
"            relative_parsed.authority = base_parsed.authority\n"
"            if not relative_parsed.path then\n"
"                relative_parsed.path = base_parsed.path\n"
"                if not relative_parsed.params then\n"
"                    relative_parsed.params = base_parsed.params\n"
"                    if not relative_parsed.query then\n"
"                        relative_parsed.query = base_parsed.query\n"
"                    end\n"
"                end\n"
"            else    \n"
"                relative_parsed.path = absolute_path(base_parsed.path or \"\",\n"
"                    relative_parsed.path)\n"
"            end\n"
"        end\n"
"        return build(relative_parsed)\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Breaks a path into its segments, unescaping the segments\n"
"-- Input\n"
"--   path\n"
"-- Returns\n"
"--   segment: a table with one entry per segment\n"
"-----------------------------------------------------------------------------\n"
"function parse_path(path)\n"
"	local parsed = {}\n"
"	path = path or \"\"\n"
"	--path = string.gsub(path, \"%s\", \"\")\n"
"	string.gsub(path, \"([^/]+)\", function (s) table.insert(parsed, s) end)\n"
"	for i = 1, table.getn(parsed) do\n"
"		parsed[i] = unescape(parsed[i])\n"
"	end\n"
"	if string.sub(path, 1, 1) == \"/\" then parsed.is_absolute = 1 end\n"
"	if string.sub(path, -1, -1) == \"/\" then parsed.is_directory = 1 end\n"
"	return parsed\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Builds a path component from its segments, escaping protected characters.\n"
"-- Input\n"
"--   parsed: path segments\n"
"--   unsafe: if true, segments are not protected before path is built\n"
"-- Returns\n"
"--   path: corresponding path stringing\n"
"-----------------------------------------------------------------------------\n"
"function build_path(parsed, unsafe)\n"
"	local path = \"\"\n"
"	local n = table.getn(parsed)\n"
"	if unsafe then\n"
"		for i = 1, n-1 do\n"
"			path = path .. parsed[i]\n"
"			path = path .. \"/\"\n"
"		end\n"
"		if n > 0 then\n"
"			path = path .. parsed[n]\n"
"			if parsed.is_directory then path = path .. \"/\" end\n"
"		end\n"
"	else\n"
"		for i = 1, n-1 do\n"
"			path = path .. protect_segment(parsed[i])\n"
"			path = path .. \"/\"\n"
"		end\n"
"		if n > 0 then\n"
"			path = path .. protect_segment(parsed[n])\n"
"			if parsed.is_directory then path = path .. \"/\" end\n"
"		end\n"
"	end\n"
"	if parsed.is_absolute then path = \"/\" .. path end\n"
"	return path\n"
"end\n"
"",

"fenestra.widget.master","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"-- widget class master\n"
"-- the master widget\n"
"\n"
"\n"
"\n"
"local gl=require('gl')\n"
"\n"
"module(\"fenestra.widget.master\")\n"
"\n"
"--\n"
"-- add meta functions\n"
"--\n"
"function setup(widget,def)\n"
"\n"
"	local master=widget\n"
"	local meta=widget.meta\n"
"--	local win=def.win\n"
"\n"
"	master.throb=0\n"
"	master.fbo=_G.win.fbo(0,0,0) -- use an fbo\n"
"\n"
"-- the master gets some special overloaded functions to do a few more things\n"
"	function master.update(widget)\n"
"		widget.throb=widget.throb-4\n"
"		if widget.throb<0 then widget.throb=255 end\n"
"\n"
"		meta.update(widget)\n"
"	end\n"
"	\n"
"	function master.layout(widget)\n"
"		meta.layout(widget)\n"
"		master.remouse(widget)\n"
"	end\n"
"\n"
"	local dirty_fbos={}\n"
"	local find_dirty_fbos\n"
"	find_dirty_fbos=function(widget)\n"
"		if widget.fbo and widget.dirty then\n"
"			dirty_fbos[ #dirty_fbos+1 ]=widget\n"
"		end\n"
"		for i,v in ipairs(widget) do\n"
"			find_dirty_fbos(v)\n"
"		end\n"
"	end\n"
"	\n"
"	function master.draw(widget)\n"
"		dirty_fbos={}\n"
"		find_dirty_fbos(widget)\n"
"	\n"
"		gl.Disable(gl.CULL_FACE)\n"
"		gl.Disable(gl.LIGHTING)\n"
"		gl.Disable(gl.DEPTH_TEST)\n"
"		gl.PushMatrix()\n"
"		\n"
"		if #dirty_fbos>0 then\n"
"			for i=#dirty_fbos,1,-1 do -- call in reverse so sub fbos can work\n"
"				meta.draw(dirty_fbos[i]) -- dirty, so this only builds the fbo\n"
"			end\n"
"		end\n"
"		\n"
"		meta.draw(widget)\n"
"		\n"
"		gl.PopMatrix()\n"
"--		gl.Enable(\"DEPTH_TEST\")\n"
"--		gl.Enable(\"LIGHTING\")\n"
"	end\n"
"	\n"
"--\n"
"-- handle key input\n"
"--\n"
"	function master.key(widget,ascii,key,act)\n"
"\n"
"		if master.focus then -- key focus\n"
"		\n"
"			master.focus:key(ascii,key,act)\n"
"		end\n"
"\n"
"	end\n"
"\n"
"--\n"
"-- set the mouse position to its last position\n"
"-- call this after adding/removing widgets to make sure they highlight properly\n"
"--	\n"
"	function master.remouse(widget)\n"
"		local p=widget.last_mouse_position or {0,0}\n"
"		widget.mouse(widget,nil,p[1],p[2],nil)\n"
"	end\n"
"--\n"
"-- handle mouse input\n"
"--	\n"
"	function master.mouse(widget,act,x,y,key)\n"
"	\n"
"		master.last_mouse_position={x,y}\n"
"	\n"
"--		if widget.state==\"ready\" then\n"
"		\n"
"			if master.active and (master.active.parent.class==\"slide\" or master.active.parent.class==\"oldslide\") then -- slide :)\n"
"			\n"
"				local w=master.active\n"
"				local p=master.active.parent\n"
"				\n"
"				local minx=p.pxd\n"
"				local miny=p.pyd-p.hy+w.hy\n"
"				local maxx=p.pxd+p.hx-w.hx\n"
"				local maxy=p.pyd\n"
"				\n"
"				w.pxd=x-master.active_x\n"
"				w.pyd=y-master.active_y\n"
"				\n"
"				if w.pxd<minx then w.pxd=minx end\n"
"				if w.pxd>maxx then w.pxd=maxx end\n"
"				if w.pyd<miny then w.pyd=miny end\n"
"				if w.pyd>maxy then w.pyd=maxy end\n"
"				\n"
"				w.px=w.pxd-p.pxd\n"
"				w.py=p.pyd-w.pyd\n"
"			\n"
"				w:call_hook(\"slide\")\n"
"				\n"
"				w:set_dirty()\n"
"\n"
"			end\n"
"			\n"
"			local old_active=master.active\n"
"			local old_over=master.over\n"
"			for i,v in ipairs(widget) do\n"
"				meta.mouse(v,act,x,y,key)\n"
"			end\n"
"			\n"
"			if act==\"up\" then\n"
"				master.active=nil\n"
"			end\n"
"			\n"
"--mark as dirty\n"
"			if master.active~=old_active then\n"
"				if master.active then master.active:set_dirty() end\n"
"				if old_active then old_active:set_dirty() end\n"
"			end\n"
"			if master.over~=old_over then\n"
"				if master.over then master.over:set_dirty() end\n"
"				if old_over then old_over:set_dirty() end\n"
"			end\n"
"			\n"
"--		end\n"
"	end\n"
"--\n"
"end\n"
"",

"fenestra.widget.text","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"module(\"fenestra.widget.text\")\n"
"\n"
"\n"
"function mouse(widget,act,x,y,key)\n"
"--	widget.master.focus=widget\n"
"	return widget.meta.mouse(widget,act,x,y,key)\n"
"end\n"
"\n"
"\n"
"function key(widget,ascii,key,act)\n"
"	return widget.meta.key(widget,ascii,key,act)\n"
"end\n"
"\n"
"\n"
"function update(widget)\n"
"\n"
"	if widget.data then\n"
"		widget.text=widget.data:get_string()\n"
"	end\n"
"\n"
"	return widget.meta.update(widget)\n"
"end\n"
"\n"
"function draw(widget)\n"
"	return widget.meta.draw(widget)\n"
"end\n"
"\n"
"\n"
"function setup(widget,def)\n"
"--	local it={}\n"
"--	widget.button=it\n"
"	widget.class=\"text\"\n"
"	\n"
"	widget.key=key\n"
"	widget.mouse=mouse\n"
"	widget.update=update\n"
"	widget.draw=draw\n"
"\n"
"	return widget\n"
"end\n"
"",

"mime","-----------------------------------------------------------------------------\n"
"-- MIME support for the Lua language.\n"
"-- Author: Diego Nehab\n"
"-- Conforming to RFCs 2045-2049\n"
"-- RCS ID: $Id: mime.lua,v 1.29 2007/06/11 23:44:54 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local ltn12 = require(\"ltn12\")\n"
"local mime = require(\"mime.core\")\n"
"local io = require(\"io\")\n"
"local string = require(\"string\")\n"
"module(\"mime\")\n"
"\n"
"-- encode, decode and wrap algorithm tables\n"
"encodet = {}\n"
"decodet = {}\n"
"wrapt = {}\n"
"\n"
"-- creates a function that chooses a filter by name from a given table\n"
"local function choose(table)\n"
"    return function(name, opt1, opt2)\n"
"        if base.type(name) ~= \"string\" then\n"
"            name, opt1, opt2 = \"default\", name, opt1\n"
"        end\n"
"        local f = table[name or \"nil\"]\n"
"        if not f then \n"
"            base.error(\"unknown key (\" .. base.tostring(name) .. \")\", 3)\n"
"        else return f(opt1, opt2) end\n"
"    end\n"
"end\n"
"\n"
"-- define the encoding filters\n"
"encodet['base64'] = function()\n"
"    return ltn12.filter.cycle(b64, \"\")\n"
"end\n"
"\n"
"encodet['quoted-printable'] = function(mode)\n"
"    return ltn12.filter.cycle(qp, \"\",\n"
"        (mode == \"binary\") and \"=0D=0A\" or \"\\r\\n"
"\")\n"
"end\n"
"\n"
"-- define the decoding filters\n"
"decodet['base64'] = function()\n"
"    return ltn12.filter.cycle(unb64, \"\")\n"
"end\n"
"\n"
"decodet['quoted-printable'] = function()\n"
"    return ltn12.filter.cycle(unqp, \"\")\n"
"end\n"
"\n"
"local function format(chunk)\n"
"    if chunk then\n"
"        if chunk == \"\" then return \"''\"\n"
"        else return string.len(chunk) end\n"
"    else return \"nil\" end\n"
"end\n"
"\n"
"-- define the line-wrap filters\n"
"wrapt['text'] = function(length)\n"
"    length = length or 76\n"
"    return ltn12.filter.cycle(wrp, length, length)\n"
"end\n"
"wrapt['base64'] = wrapt['text']\n"
"wrapt['default'] = wrapt['text']\n"
"\n"
"wrapt['quoted-printable'] = function()\n"
"    return ltn12.filter.cycle(qpwrp, 76, 76)\n"
"end\n"
"\n"
"-- function that choose the encoding, decoding or wrap algorithm\n"
"encode = choose(encodet)\n"
"decode = choose(decodet)\n"
"wrap = choose(wrapt)\n"
"\n"
"-- define the end-of-line normalization filter\n"
"function normalize(marker)\n"
"    return ltn12.filter.cycle(eol, 0, marker)\n"
"end\n"
"\n"
"-- high level stuffing filter\n"
"function stuff()\n"
"    return ltn12.filter.cycle(dot, 2)\n"
"end\n"
"",

"wetgenes.sandbox","\r--local log=require(\"wetgenes.aelua.log\").log\r\rlocal string=string\rlocal table=table\r\rlocal type=type\rlocal pairs=pairs\rlocal ipairs=ipairs\rlocal tostring=tostring\rlocal setmetatable=setmetatable\r\r--\r-- Simple sandboxing of lua functions\r--\r\r\r-- make a table to be used as a reasonably \"safe\" environment\r-- code can still lock up in loops or allocate too much memory\r-- but it doesnt get to jump out of its sandbox\r\rlocal function local_make_env_safe()\rlocal env={\r	assert=assert,\r	error=error,\r	ipairs=ipairs,\r	pairs=pairs,\r	next=next,\r	pcall=pcall,\r	select=select,\r	tonumber=tonumber,\r	tostring=tostring,\r	type=type,\r	unpack=unpack,\r	xpcall=xpcall,\r	coroutine={\r		create=coroutine.create,\r		resume=coroutine.resume,\r		running=coroutine.running,\r		status=coroutine.status,\r		wrap=coroutine.wrap,\r		yield=coroutine.yield,\r	},\r	table={\r		concat=table.concat,\r		insert=table.insert,\r		maxn=table.maxn,\r		remove=table.remove,\r		sort=table.sort,\r	},\r	string={\r		byte=string.byte,\r		char=string.char,\r		find=string.find,\r		format=string.format,\r		gmatch=string.gmatch,\r		gsub=string.gsub,\r		len=string.len,\r		lower=string.lower,\r		match=string.match,\r		rep=string.rep,\r		reverse=string.reverse,\r		sub=string.sub,\r		upper=string.upper,\r	},\r	math={\r		abs=math.abs,\r		acos=math.acos,\r		asin=math.asin,\r		atan=math.atan,\r		atan2=math.atan2,\r		ceil=math.ceil,\r		cos=math.cos,\r		cosh=math.cosh,\r		deg=math.deg,\r		exp=math.exp,\r		floor=math.floor,\r		fmod=math.fmod,\r		frexp=math.frexp,\r		huge=math.huge,\r		ldexp=math.ldexp,\r		log=math.log,\r		log10=math.log10,\r		max=math.max,\r		min=math.min,\r		modf=math.modf,\r		pi=math.pi,\r		pow=math.pow,\r		rad=math.rad,\r		random=math.random, -- should replace with sandboxed versions\r		randomseed=math.randomseed, -- should replace with sandboxed versions\r		sin=math.sin,\r		sinh=math.sinh,\r		sqrt=math.sqrt,\r		tan=math.tan,\r		tanh=math.tanh,\r	},\r	os={\r		clock=os.clock,\r		date=os.date, -- this can go boom in some situations?\r		difftime=os.difftime,\r		time=os.time,\r	},\r}\r\r-- a modified loadstring that can set its function environment\r-- setfenv is probably quite dangerous to expose, too much opportunity for\r-- mischief on any function the sandbox code is given access to\r-- it is however safe in this use since its your function that was just\r-- loadstringed\r	env.loadstring=function(s,newenv)\r		local f,e=loadstring(s)\r		if f then setfenv(f,newenv or env) end\r		return f,e\r	end\r\r	return env\rend\r\r\r\rmodule(\"wetgenes.sandbox\")\r\r--\r-- get a functional environment full of useful but \"safe\" functions\r--\rfunction make_env(opts)\r\rlocal env=local_make_env_safe()\r\r	return env\rend\r\r",

"fenestra.widget.button","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"module(\"fenestra.widget.button\")\n"
"\n"
"\n"
"function mouse(widget,act,x,y,key)\n"
"--	widget.master.focus=widget\n"
"	return widget.meta.mouse(widget,act,x,y,key)\n"
"end\n"
"\n"
"\n"
"function key(widget,ascii,key,act)\n"
"	return widget.meta.key(widget,ascii,key,act)\n"
"end\n"
"\n"
"\n"
"function update(widget)\n"
"\n"
"	if widget.data then\n"
"		widget.text=widget.data:get_string()\n"
"	end\n"
"\n"
"	return widget.meta.update(widget)\n"
"end\n"
"\n"
"function draw(widget)\n"
"	return widget.meta.draw(widget)\n"
"end\n"
"\n"
"\n"
"function setup(widget,def)\n"
"--	local it={}\n"
"--	widget.button=it\n"
"	widget.class=\"button\"\n"
"	\n"
"	widget.key=key\n"
"	widget.mouse=mouse\n"
"	widget.update=update\n"
"	widget.draw=draw\n"
"\n"
"	return widget\n"
"end\n"
"",

"socket.http","-----------------------------------------------------------------------------\n"
"-- HTTP/1.1 client support for the Lua language.\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: http.lua,v 1.70 2007/03/12 04:08:40 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-------------------------------------------------------------------------------\n"
"local socket = require(\"socket\")\n"
"local url = require(\"socket.url\")\n"
"local ltn12 = require(\"ltn12\")\n"
"local mime = require(\"mime\")\n"
"local string = require(\"string\")\n"
"local base = _G\n"
"local table = require(\"table\")\n"
"module(\"socket.http\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Program constants\n"
"-----------------------------------------------------------------------------\n"
"-- connection timeout in seconds\n"
"TIMEOUT = 60\n"
"-- default port for document retrieval\n"
"PORT = 80\n"
"-- user agent field sent in request\n"
"USERAGENT = socket._VERSION\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Reads MIME headers from a connection, unfolding where needed\n"
"-----------------------------------------------------------------------------\n"
"local function receiveheaders(sock, headers)\n"
"    local line, name, value, err\n"
"    headers = headers or {}\n"
"    -- get first line\n"
"    line, err = sock:receive()\n"
"    if err then return nil, err end\n"
"    -- headers go until a blank line is found\n"
"    while line ~= \"\" do\n"
"        -- get field-name and value\n"
"        name, value = socket.skip(2, string.find(line, \"^(.-):%s*(.*)\"))\n"
"        if not (name and value) then return nil, \"malformed reponse headers\" end\n"
"        name = string.lower(name)\n"
"        -- get next line (value might be folded)\n"
"        line, err  = sock:receive()\n"
"        if err then return nil, err end\n"
"        -- unfold any folded values\n"
"        while string.find(line, \"^%s\") do\n"
"            value = value .. line\n"
"            line = sock:receive()\n"
"            if err then return nil, err end\n"
"        end\n"
"        -- save pair in table\n"
"        if headers[name] then headers[name] = headers[name] .. \", \" .. value\n"
"        else headers[name] = value end\n"
"    end\n"
"    return headers\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Extra sources and sinks\n"
"-----------------------------------------------------------------------------\n"
"socket.sourcet[\"http-chunked\"] = function(sock, headers)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function()\n"
"            -- get chunk size, skip extention\n"
"            local line, err = sock:receive()\n"
"            if err then return nil, err end\n"
"            local size = base.tonumber(string.gsub(line, \";.*\", \"\"), 16)\n"
"            if not size then return nil, \"invalid chunk size\" end\n"
"            -- was it the last chunk?\n"
"            if size > 0 then\n"
"                -- if not, get chunk and skip terminating CRLF\n"
"                local chunk, err, part = sock:receive(size)\n"
"                if chunk then sock:receive() end\n"
"                return chunk, err\n"
"            else\n"
"                -- if it was, read trailers into headers table\n"
"                headers, err = receiveheaders(sock, headers)\n"
"                if not headers then return nil, err end\n"
"            end\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"socket.sinkt[\"http-chunked\"] = function(sock)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function(self, chunk, err)\n"
"            if not chunk then return sock:send(\"0\\r\\n"
"\\r\\n"
"\") end\n"
"            local size = string.format(\"%X\\r\\n"
"\", string.len(chunk))\n"
"            return sock:send(size ..  chunk .. \"\\r\\n"
"\")\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Low level HTTP API\n"
"-----------------------------------------------------------------------------\n"
"local metat = { __index = {} }\n"
"\n"
"function open(host, port, create)\n"
"    -- create socket with user connect function, or with default\n"
"    local c = socket.try((create or socket.tcp)())\n"
"    local h = base.setmetatable({ c = c }, metat)\n"
"    -- create finalized try\n"
"    h.try = socket.newtry(function() h:close() end)\n"
"    -- set timeout before connecting\n"
"    h.try(c:settimeout(TIMEOUT))\n"
"    h.try(c:connect(host, port or PORT))\n"
"    -- here everything worked\n"
"    return h\n"
"end\n"
"\n"
"function metat.__index:sendrequestline(method, uri)\n"
"    local reqline = string.format(\"%s %s HTTP/1.1\\r\\n"
"\", method or \"GET\", uri)\n"
"    return self.try(self.c:send(reqline))\n"
"end\n"
"\n"
"function metat.__index:sendheaders(headers)\n"
"    local h = \"\\r\\n"
"\"\n"
"    for i, v in base.pairs(headers) do\n"
"        h = i .. \": \" .. v .. \"\\r\\n"
"\" .. h\n"
"    end\n"
"    self.try(self.c:send(h))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:sendbody(headers, source, step)\n"
"    source = source or ltn12.source.empty()\n"
"    step = step or ltn12.pump.step\n"
"    -- if we don't know the size in advance, send chunked and hope for the best\n"
"    local mode = \"http-chunked\"\n"
"    if headers[\"content-length\"] then mode = \"keep-open\" end\n"
"    return self.try(ltn12.pump.all(source, socket.sink(mode, self.c), step))\n"
"end\n"
"\n"
"function metat.__index:receivestatusline()\n"
"    local status = self.try(self.c:receive())\n"
"    local code = socket.skip(2, string.find(status, \"HTTP/%d*%.%d* (%d%d%d)\"))\n"
"    return self.try(base.tonumber(code), status)\n"
"end\n"
"\n"
"function metat.__index:receiveheaders()\n"
"    return self.try(receiveheaders(self.c))\n"
"end\n"
"\n"
"function metat.__index:receivebody(headers, sink, step)\n"
"    sink = sink or ltn12.sink.null()\n"
"    step = step or ltn12.pump.step\n"
"    local length = base.tonumber(headers[\"content-length\"])\n"
"    local t = headers[\"transfer-encoding\"] -- shortcut\n"
"    local mode = \"default\" -- connection close\n"
"    if t and t ~= \"identity\" then mode = \"http-chunked\"\n"
"    elseif base.tonumber(headers[\"content-length\"]) then mode = \"by-length\" end\n"
"    return self.try(ltn12.pump.all(socket.source(mode, self.c, length),\n"
"        sink, step))\n"
"end\n"
"\n"
"function metat.__index:close()\n"
"    return self.c:close()\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- High level HTTP API\n"
"-----------------------------------------------------------------------------\n"
"local function adjusturi(reqt)\n"
"    local u = reqt\n"
"    -- if there is a proxy, we need the full url. otherwise, just a part.\n"
"    if not reqt.proxy and not PROXY then\n"
"        u = {\n"
"           path = socket.try(reqt.path, \"invalid path 'nil'\"),\n"
"           params = reqt.params,\n"
"           query = reqt.query,\n"
"           fragment = reqt.fragment\n"
"        }\n"
"    end\n"
"    return url.build(u)\n"
"end\n"
"\n"
"local function adjustproxy(reqt)\n"
"    local proxy = reqt.proxy or PROXY\n"
"    if proxy then\n"
"        proxy = url.parse(proxy)\n"
"        return proxy.host, proxy.port or 3128\n"
"    else\n"
"        return reqt.host, reqt.port\n"
"    end\n"
"end\n"
"\n"
"local function adjustheaders(reqt)\n"
"    -- default headers\n"
"    local lower = {\n"
"        [\"user-agent\"] = USERAGENT,\n"
"        [\"host\"] = reqt.host,\n"
"        [\"connection\"] = \"close, TE\",\n"
"        [\"te\"] = \"trailers\"\n"
"    }\n"
"    -- if we have authentication information, pass it along\n"
"    if reqt.user and reqt.password then\n"
"        lower[\"authorization\"] = \n"
"            \"Basic \" ..  (mime.b64(reqt.user .. \":\" .. reqt.password))\n"
"    end\n"
"    -- override with user headers\n"
"    for i,v in base.pairs(reqt.headers or lower) do\n"
"        lower[string.lower(i)] = v\n"
"    end\n"
"    return lower\n"
"end\n"
"\n"
"-- default url parts\n"
"local default = {\n"
"    host = \"\",\n"
"    port = PORT,\n"
"    path =\"/\",\n"
"    scheme = \"http\"\n"
"}\n"
"\n"
"local function adjustrequest(reqt)\n"
"    -- parse url if provided\n"
"    local nreqt = reqt.url and url.parse(reqt.url, default) or {}\n"
"    -- explicit components override url\n"
"    for i,v in base.pairs(reqt) do nreqt[i] = v end\n"
"    if nreqt.port == \"\" then nreqt.port = 80 end\n"
"    socket.try(nreqt.host and nreqt.host ~= \"\", \n"
"        \"invalid host '\" .. base.tostring(nreqt.host) .. \"'\")\n"
"    -- compute uri if user hasn't overriden\n"
"    nreqt.uri = reqt.uri or adjusturi(nreqt)\n"
"    -- ajust host and port if there is a proxy\n"
"    nreqt.host, nreqt.port = adjustproxy(nreqt)\n"
"    -- adjust headers in request\n"
"    nreqt.headers = adjustheaders(nreqt)\n"
"    return nreqt\n"
"end\n"
"\n"
"local function shouldredirect(reqt, code, headers)\n"
"    return headers.location and\n"
"           string.gsub(headers.location, \"%s\", \"\") ~= \"\" and\n"
"           (reqt.redirect ~= false) and\n"
"           (code == 301 or code == 302) and\n"
"           (not reqt.method or reqt.method == \"GET\" or reqt.method == \"HEAD\")\n"
"           and (not reqt.nredirects or reqt.nredirects < 5)\n"
"end\n"
"\n"
"local function shouldreceivebody(reqt, code)\n"
"    if reqt.method == \"HEAD\" then return nil end\n"
"    if code == 204 or code == 304 then return nil end\n"
"    if code >= 100 and code < 200 then return nil end\n"
"    return 1\n"
"end\n"
"\n"
"-- forward declarations\n"
"local trequest, tredirect\n"
"\n"
"function tredirect(reqt, location)\n"
"    local result, code, headers, status = trequest {\n"
"        -- the RFC says the redirect URL has to be absolute, but some\n"
"        -- servers do not respect that\n"
"        url = url.absolute(reqt.url, location),\n"
"        source = reqt.source,\n"
"        sink = reqt.sink,\n"
"        headers = reqt.headers,\n"
"        proxy = reqt.proxy, \n"
"        nredirects = (reqt.nredirects or 0) + 1,\n"
"        create = reqt.create\n"
"    }   \n"
"    -- pass location header back as a hint we redirected\n"
"    headers.location = headers.location or location\n"
"    return result, code, headers, status\n"
"end\n"
"\n"
"function trequest(reqt)\n"
"    -- we loop until we get what we want, or\n"
"    -- until we are sure there is no way to get it\n"
"    local nreqt = adjustrequest(reqt)\n"
"    local h = open(nreqt.host, nreqt.port, nreqt.create)\n"
"    -- send request line and headers\n"
"    h:sendrequestline(nreqt.method, nreqt.uri)\n"
"    h:sendheaders(nreqt.headers)\n"
"    local code = 100 \n"
"    local headers, status\n"
"    -- if there is a body, check for server status\n"
"    if nreqt.source then\n"
"        h:sendbody(nreqt.headers, nreqt.source, nreqt.step) \n"
"    end\n"
"    -- ignore any 100-continue messages\n"
"    while code == 100 do \n"
"        code, status = h:receivestatusline()\n"
"        headers = h:receiveheaders()\n"
"    end\n"
"    -- at this point we should have a honest reply from the server\n"
"    -- we can't redirect if we already used the source, so we report the error \n"
"    if shouldredirect(nreqt, code, headers) and not nreqt.source then\n"
"        h:close()\n"
"        return tredirect(reqt, headers.location)\n"
"    end\n"
"    -- here we are finally done\n"
"    if shouldreceivebody(nreqt, code) then\n"
"        h:receivebody(headers, nreqt.sink, nreqt.step)\n"
"    end\n"
"    h:close()\n"
"    return 1, code, headers, status\n"
"end\n"
"\n"
"local function srequest(u, b)\n"
"    local t = {}\n"
"    local reqt = {\n"
"        url = u,\n"
"        sink = ltn12.sink.table(t)\n"
"    }\n"
"    if b then\n"
"        reqt.source = ltn12.source.string(b)\n"
"        reqt.headers = {\n"
"            [\"content-length\"] = string.len(b),\n"
"            [\"content-type\"] = \"application/x-www-form-urlencoded\"\n"
"        }\n"
"        reqt.method = \"POST\"\n"
"    end\n"
"    local code, headers, status = socket.skip(1, trequest(reqt))\n"
"    return table.concat(t), code, headers, status\n"
"end\n"
"\n"
"request = socket.protect(function(reqt, body)\n"
"    if base.type(reqt) == \"string\" then return srequest(reqt, body)\n"
"    else return trequest(reqt) end\n"
"end)\n"
"",

"wetgenes.pp","--+-----------------------------------------------------------------------------------------------------------------+--\n"
"--\n"
"-- (C) Kriss Daniels 2005 http://www.XIXs.com\n"
"--\n"
"-- This file made available under the terms of The MIT License : http://www.opensource.org/licenses/mit-license.php\n"
"--\n"
"-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n"
"--\n"
"-- The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n"
"--\n"
"-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
"--\n"
"--+-----------------------------------------------------------------------------------------------------------------+--\n"
"\n"
"local up_G=_G\n"
"\n"
"local print=print\n"
"local io=io\n"
"local table=table\n"
"local string=string\n"
"local loadfile=loadfile\n"
"local loadstring=loadstring\n"
"local assert=assert\n"
"local pcall=pcall\n"
"local xpcall=xpcall\n"
"\n"
"local setmetatable=setmetatable\n"
"local getfenv=getfenv\n"
"local setfenv=setfenv\n"
"\n"
"module(\"wetgenes.pp\")\n"
"\n"
"\n"
"\n"
"--\n"
"--\n"
"-- Create a lua program from an input file.\n"
"--\n"
"-- This can then be parsed and run to produce a preprocesed outputfile\n"
"--\n"
"--\n"
"\n"
"-- #() can be used anywhere except at the start of a line to inject the text between () as a small chunk of lua\n"
"-- # can be used at the start of the line to inject the rest of the line as lua\n"
"-- #include \"fname\" is a piece of magic that injects the given file into the output\n"
"-- #( at the start of the line denotes the begining of a pure lua block, rest of line is ignored\n"
"-- #) at the start of the line denotes the end of a pure lua block, rest of line is ignored\n"
"-- a pure lua block is needed for multiline table definitions otherwise the line numbering system breaks things\n"
"--\n"
"-- returns a table of strings which can be table.concat into a string result\n"
"\n"
"function ppload(filename,chunk)\n"
"\n"
"local included\n"
"\n"
"local file\n"
"local temp\n"
"local line_num\n"
"local new_filename\n"
"local lua_block_insert\n"
"\n"
"\n"
"	lua_block_insert=false\n"
"\n"
"	if chunk then -- we are a sub build\n"
"\n"
"		included=true\n"
"\n"
"	else\n"
"\n"
"		included=false\n"
"\n"
"		chunk = {n=0}\n"
"\n"
"	end\n"
"\n"
"\n"
"\n"
"	file=io.open(filename,\"r\")\n"
"	\n"
"	assert(file,\"failed to load \"..filename)\n"
"\n"
"	if not included then\n"
"\n"
"		table.insert(chunk,\"-- A lua file that builds a preprocesed file as a table\\n"
"\")\n"
"		table.insert(chunk,\"\\n"
"\")\n"
"		table.insert(chunk,\"pp_output_table = {n=0}\\n"
"\")\n"
"		table.insert(chunk,\"local _out_ti=table.insert\\n"
"\")\n"
"		table.insert(chunk,\"local _out_tt=pp_output_table\\n"
"\")\n"
"		table.insert(chunk,\"local _out_do=function(s)\\n"
"\")\n"
"		table.insert(chunk,\"	_out_ti(_out_tt,s)\\n"
"\")\n"
"		table.insert(chunk,\"	for i in string.gfind(s,'\\\\n"
"') do -- count outputlines\\n"
"\")\n"
"		table.insert(chunk,\"		_lo=_lo+1\\n"
"\")\n"
"		table.insert(chunk,\"		if _lo_break then -- so we can break on line\\n"
"\")\n"
"		table.insert(chunk,\"			assert(_lo<_lo_break,'user line break')\\n"
"\")\n"
"		table.insert(chunk,\"		end\\n"
"\")\n"
"		table.insert(chunk,\"	end\\n"
"\")\n"
"		table.insert(chunk,\"end\\n"
"\")\n"
"		table.insert(chunk,\"_lo=0\\n"
"\")\n"
"		table.insert(chunk,\"local _out=function(...) for i,v in ipairs(arg) do _out_do(v) end end\\n"
"\")\n"
"\n"
"	end\n"
"\n"
"	table.insert(chunk,\"\\n"
"\")\n"
"	table.insert(chunk,\"_file='\"..filename..\"'\\n"
"\")\n"
"	table.insert(chunk,\"\\n"
"\")\n"
"\n"
"	line_num=1\n"
"	for line in file:lines() do\n"
"\n"
"		if lua_block_insert==false then\n"
"		\n"
"			table.insert(chunk, string.format('_l=%4d; ', line_num))\n"
"		end\n"
"		\n"
"		\n"
"		if string.find(line, \"^#%(\") then\n"
"		\n"
"			lua_block_insert=true\n"
"			table.insert(chunk, \"\\n"
"\")\n"
"			\n"
"		elseif string.find(line, \"^#%)\") then\n"
"		\n"
"			lua_block_insert=false\n"
"			table.insert(chunk, \"\\n"
"\")\n"
"			\n"
"		elseif string.find(line, \"^#dofile\") then\n"
"\n"
"			_,_,new_filename=string.find(line, \"^#dofile%s\\\"([%w%p]+)\\\"\")\n"
"\n"
"			new_filename=pp_input_cd..new_filename\n"
"\n"
"			table.insert(chunk, \"--Including \"..new_filename..\"\\n"
"\")\n"
"			\n"
"			local fp=io.open(new_filename,\"r\")\n"
"			local d=fp:read(\"*all\")\n"
"			table.insert(chunk,d)\n"
"\n"
"			table.insert(chunk,\"\\n"
"\")\n"
"			table.insert(chunk,\"_file='\"..filename..\"'\\n"
"\")\n"
"			table.insert(chunk,\"\\n"
"\")\n"
"\n"
"		elseif string.find(line, \"^#include\") then\n"
"\n"
"			_,_,new_filename=string.find(line, \"^#include%s\\\"([%w%p]+)\\\"\")\n"
"\n"
"			new_filename=pp_input_cd..new_filename\n"
"\n"
"			table.insert(chunk, \"--Including \"..new_filename..\"\\n"
"\")\n"
"\n"
"			ppload(new_filename,chunk)\n"
"\n"
"			table.insert(chunk,\"\\n"
"\")\n"
"			table.insert(chunk,\"_file='\"..filename..\"'\\n"
"\")\n"
"			table.insert(chunk,\"\\n"
"\")\n"
"\n"
"		elseif string.find(line, \"^#\") then\n"
"\n"
"			table.insert(chunk, string.sub(line, 2) .. \"\\n"
"\")\n"
"\n"
"		else\n"
"		\n"
"			if lua_block_insert then\n"
"			\n"
"				table.insert(chunk, line .. \"\\n"
"\")\n"
"			\n"
"			else\n"
"\n"
"			local last = 1\n"
"\n"
"				for text, expr, index in string.gfind(line, \"(.-)#(%b())()\") do \n"
"\n"
"					last = index\n"
"\n"
"					if text ~= \"\" then\n"
"\n"
"						table.insert(chunk, string.format('_out %q ', text))\n"
"\n"
"					end\n"
"\n"
"					table.insert(chunk, string.format('_out%s ', expr))\n"
"\n"
"				end\n"
"\n"
"-- gsub to remove ugly line ends and replace with \\n"
" to make file more readable\n"
"temp=string.gsub(string.sub(line, last),\"\\n"
"\",\"\\\\n"
"\")\n"
"temp=string.gsub(temp,\"\\r\",\"\")\n"
"temp=string.format('_out %q\\n"
"',temp..\"\\n"
"\")\n"
"\n"
"				table.insert(chunk, temp)\n"
"				\n"
"			end\n"
"\n"
"		end\n"
"\n"
"		line_num=line_num+1\n"
"	end\n"
"\n"
"	file:close()\n"
"\n"
"	if not included then\n"
"	\n"
"		table.insert(chunk,\"\\n"
"return pp_output_table\\n"
"\")\n"
"	end\n"
"\n"
"  return chunk\n"
"end\n"
"\n"
"\n"
"function loadsave(fname_in,fname_out)\n"
"\n"
"pp_input_cd=\"\"\n"
"\n"
"\n"
"pp_input_table={}\n"
"pp_input_string=\"\"\n"
"pp_input_lua=function() end\n"
"\n"
"pp_output_table={}\n"
"pp_output_string=\"\"\n"
"\n"
"\n"
"\n"
"print ( \"Lua pre processing \" .. fname_in .. \" into \" .. fname_out .. \"\" )\n"
"\n"
"\n"
"-- create input table, and its string\n"
"\n"
"pp_input_table=ppload(fname_in)\n"
"\n"
"pp_input_string=table.concat(pp_input_table)\n"
"\n"
"\n"
"-- output the lua program string to a file along with the output to aid with debuging,\n"
"-- any lua errors will hopefully be more meaningfull this way\n"
"\n"
"\n"
"--[[\n"
"local fp\n"
"	fp=io.open(fname_out..\".lua\",\"w\")\n"
"	fp:write(pp_input_string)\n"
"	fp:close()\n"
"	fp=null\n"
"\n"
"-- load that string back in and run it to produce an output table\n"
"pp_input_lua,_msg=loadfile(fname_out..\".lua\")\n"
"]]\n"
"\n"
"\n"
"pp_input_lua,_msg=loadstring(pp_input_string)\n"
"\n"
"\n"
"assert(pp_input_lua,\".\\n"
".\\n"
"\"..( _msg or \"\" )..\"\\n"
".\\n"
".\\n"
"\")\n"
"\n"
"local newfenv = {}        -- create new environment just for this file\n"
"setmetatable(newfenv, {__index = up_G}) -- allow global access we are not trying to sandbox\n"
"setfenv(pp_input_lua, newfenv)    -- change this functions environment from the global one\n"
"\n"
"\n"
"local ret,_msg,_ret\n"
"\n"
"\n"
"	_lo_break=null\n"
"	\n"
"	ret,_ret=pcall(pp_input_lua)	-- not sure about scope here...\n"
"			\n"
"\n"
"	if ret~=true then\n"
"\n"
"		print('.\\n"
".\\n"
"')\n"
"		print(string.format('%s(%d):PP file location\\n"
"',_file or \"unknown\",_l or -1))\n"
"		assert(null,_ret..'\\n"
".\\n"
".\\n"
"')\n"
"\n"
"	end\n"
"\n"
"-- write that table out as a string to the destination file\n"
"\n"
"\n"
"pp_output_string=table.concat(_ret)\n"
"\n"
"local fp\n"
"	fp=io.open(fname_out,\"w\")\n"
"	fp:write(pp_output_string)\n"
"	fp:close()\n"
"	fp=null\n"
"\n"
"end\n"
"\n"
"",

"fenestra.widget.meta","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- generic default widget functions\n"
"\n"
"\n"
"module(\"fenestra.widget.meta\")\n"
"\n"
"-- available widget classes\n"
"classes={\n"
"\n"
"-- base classes\n"
"\n"
"	[\"master\"]=require(\"fenestra.widget.master\"),\n"
"	[\"button\"]=require(\"fenestra.widget.button\"),\n"
"	[\"drag\"]=require(\"fenestra.widget.drag\"),\n"
"	[\"text\"]=require(\"fenestra.widget.text\"),\n"
"	[\"textedit\"]=require(\"fenestra.widget.textedit\"),\n"
"\n"
"--classes built out of the base classes\n"
"\n"
"	[\"pan\"]=require(\"fenestra.widget.pan\"),\n"
"	[\"slide\"]=require(\"fenestra.widget.slide\"),\n"
"\n"
"	[\"scroll\"]=require(\"fenestra.widget.scroll\"),\n"
"\n"
"}\n"
"\n"
"--\n"
"-- add meta functions\n"
"--\n"
"function setup(def)\n"
"\n"
"--	local master=def.master\n"
"	local meta=def.meta\n"
"	local win=def.win\n"
"\n"
"-- set a dirty flag on this and all parents, this has a smart break, as if a child is dirty\n"
"-- then its parent must also be\n"
"-- the dirty flag is cleared on draw\n"
"	function meta.set_dirty(widget)\n"
"		widget.dirty=true\n"
"		while (widget.parent ~= widget) and not widget.parent.dirty do\n"
"			widget=widget.parent\n"
"			widget.dirty=true\n"
"		end\n"
"	end\n"
"\n"
"	function meta.call_hook(widget,hook,dat)\n"
"		if widget.hooks and widget.hooks[hook] then -- either local hooks\n"
"			widget.hooks[hook](widget,dat)\n"
"		elseif widget.master.hooks and widget.master.hooks[hook] then -- or a master hook\n"
"			widget.master.hooks[hook](widget,dat)\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- add a new widget as a child to this one\n"
"--\n"
"	function meta.add(parent,def)\n"
"		\n"
"		local widget={}\n"
"		setmetatable(widget,meta)\n"
"		table.insert(parent,widget)\n"
"		widget.parent=parent\n"
"		widget.master=parent.master\n"
"		widget:setup(def)\n"
"		widget.meta=meta		\n"
"		return widget\n"
"	end\n"
"	\n"
"--\n"
"-- remove from parent\n"
"--\n"
"	function meta.remove(widget)\n"
"	\n"
"		if widget.parent then\n"
"			for i,v in ipairs(widget.parent) do\n"
"				if v==widget then\n"
"					table.remove(widget.parent,i)\n"
"				end\n"
"			end\n"
"			widget.parent=nil\n"
"		end\n"
"		\n"
"	end	\n"
"--\n"
"-- add a previosuly created widget as a child to this widget\n"
"-- the widget will be forcibly removed...\n"
"--\n"
"	function meta.insert(parent,widget)\n"
"	\n"
"		meta.remove(widget) -- make sure we dont end up in two parents\n"
"		\n"
"		table.insert(parent,widget)\n"
"		widget.parent=parent\n"
"		widget.master=parent.master\n"
"		\n"
"		return widget\n"
"	end\n"
"\n"
"--\n"
"-- initial setup\n"
"--def\n"
"	function meta.setup(widget,def)\n"
"	\n"
"		widget.state=\"none\"\n"
"		\n"
"		widget.meta=meta\n"
"		\n"
"		widget.data=def.data -- this widget is synced with this data\n"
"		\n"
"		widget.class=def.class\n"
"		widget.highlight=def.highlight\n"
"		\n"
"		widget.id=def.id\n"
"		widget.user=def.user\n"
"		widget.hooks=def.hooks\n"
"		\n"
"		widget.sx=def.sx or def.hx or 1 -- (ratio)size for layout code\n"
"		widget.sy=def.sy or def.hy or 1 -- use hx and hy if its provided\n"
"		\n"
"		widget.mx=def.mx or 0 -- max (ratio)size for layout code\n"
"		widget.my=def.my or 0\n"
"		\n"
"\n"
"		\n"
"		-- if set these will generate rx,ry\n"
"		widget.pxf=def.pxf      -- local position, for sliders etc, goes from 0-1 \n"
"		widget.pyf=def.pyf      -- fractional position within container\n"
"\n"
"		widget.px=def.px or 0 -- relative pixel position (may auto generate)\n"
"		widget.py=def.py or 0\n"
"		\n"
"		widget.pxd=def.pxd or 0 -- absolute pixel position (very probably auto generated)\n"
"		widget.pyd=def.pyd or 0\n"
"		\n"
"		widget.pa=def.pa or 0 -- display rotation angle, possibly\n"
"\n"
"		\n"
"		-- if set these will generate hx,hy\n"
"		widget.hxf=def.hxf	  -- optional relative local size of container, possibly best not to use\n"
"		widget.hyf=def.hyf	  -- it does not have a default so may not be set\n"
"		\n"
"		widget.hx=def.hx or 0 -- absolute pixel size (may auto generate)\n"
"		widget.hy=def.hy or 0\n"
"		\n"
"		widget.hx_max=def.hx_max -- clip maximum layout size\n"
"		widget.hy_max=def.hy_max		\n"
"				\n"
"		widget.color=def.color\n"
"		widget.text_color=def.text_color or widget.master.text_color or 0xff000000 -- black text\n"
"		widget.text_size=def.text_size or widget.master.text_size or 16 -- quite chunky text by default\n"
"		\n"
"		widget.text_color_over=def.text_color_over -- if set, switch text color on hover\n"
"		widget.text_align=def.text_align -- default is center\n"
"		\n"
"		widget.text=def.text -- display this text on the button\n"
"		\n"
"		if widget.color or widget.text then widget.solid=true end\n"
"		widget.solid=widget.solid or def.solid\n"
"		\n"
"		if widget.class and classes[widget.class] then -- got a class, call its setup, its setup can override other functions\n"
"			classes[widget.class].setup(widget,def)\n"
"		end\n"
"		\n"
"		if widget.master.ids and widget.id then widget.master.ids[widget.id]=widget end -- lookup by id\n"
"		\n"
"		widget:set_dirty()\n"
"		\n"
"		return widget\n"
"	end\n"
"--\n"
"-- and final cleanup\n"
"--\n"
"	function meta.clean(widget)\n"
"		widget:set_dirty()\n"
"		if widget.master.ids and widget.id then widget.master.ids[widget.id]=nil end -- remove id lookup\n"
"		if widget.fbo then widget.fbo:clean() end\n"
"		return widget\n"
"	end\n"
"--\n"
"-- live adjustment\n"
"--\n"
"	function meta.get(widget,val,...)\n"
"	\n"
"		if val==\"slide\" then\n"
"		\n"
"			local x=(widget.pxd-widget.parent.pxd) / (widget.parent.hx-widget.hx)\n"
"			local y=(widget.pyd-widget.parent.pyd) / (widget.parent.hy-widget.hy)\n"
"			\n"
"			\n"
"			return x,y\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	function meta.set(widget,val,...)\n"
"	local t={...}\n"
"	\n"
"		if val==\"slide\" then\n"
"			for i,v in ipairs(widget) do\n"
"			\n"
"				if type(t[1])==\"table\" then\n"
"					v.pxf=t[1][1] or v.pxf or 0\n"
"					v.pyf=t[1][2] or v.pyf or 0\n"
"				else\n"
"					v.pxf=t[1] or v.pxf or 0\n"
"					v.pyf=t[2] or v.pyf or 0\n"
"				end\n"
"				\n"
"--print(\"SET\",v.pxf,v.pyf)\n"
"\n"
"				v.px=(widget.hx-v.hx)*v.pxf -- local position relative to parents size\n"
"				v.py=(widget.hy-v.hy)*v.pyf\n"
"				\n"
"				v.pxd=widget.pxd+v.px -- absolute\n"
"				v.pyd=widget.pyd-v.py\n"
"				\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"--\n"
"-- initial layout of widgets, to put them into reasonable positions\n"
"--\n"
"	function meta.layout(widget)\n"
"--print(widget.class)\n"
"		if widget.class==\"flow\" or widget.class==\"hx\" then -- hx will be removed\n"
"			meta.layout_flow(widget)\n"
"		elseif widget.class==\"fill\" or widget.class==\"pan\" then\n"
"			meta.layout_fill(widget)\n"
"		elseif widget.class==\"slide\" or widget.class==\"pad\" then\n"
"			meta.layout_padding(widget)\n"
"		elseif widget.class==\"master\" or widget.class==\"abs\" then\n"
"			meta.layout_base(widget)\n"
"		else\n"
"			meta.layout_base(widget)\n"
"		end\n"
"	end\n"
"	\n"
"	function meta.layout_none(widget)\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"	function meta.layout_padding(widget)\n"
"		for i,v in ipairs(widget) do\n"
"\n"
"			if v.hxf then v.hx=widget.hx*v.hxf end -- generate size as a fraction of parent\n"
"			if v.hyf then v.hy=widget.hy*v.hyf end\n"
"			\n"
"			v.px=(widget.hx-v.hx)*v.pxf -- local position relative to parents size\n"
"			v.py=(widget.hy-v.hy)*v.pyf\n"
"\n"
"			v.pxd=widget.pxd+v.px -- local absolute position\n"
"			v.pyd=widget.pyd-v.py\n"
"\n"
"		end\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"\n"
"	function meta.layout_base(widget)\n"
"		for i,v in ipairs(widget) do\n"
"		\n"
"			if v.hxf then v.hx=widget.hx*v.hxf end -- generate size as a fraction of parent\n"
"			if v.hyf then v.hy=widget.hy*v.hyf end\n"
"			\n"
"			if v.pxf then v.px=(widget.hx)*v.pxf end -- local position relative to parents size\n"
"			if v.pyf then v.py=(widget.hy)*v.pyf end\n"
"\n"
"			v.pxd=widget.pxd+v.px -- absolute position\n"
"			v.pyd=widget.pyd-v.py\n"
"			\n"
"		end\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"\n"
"-- this is a fixed layout that works kind of like text\n"
"-- we do not adjust the hx,hy size of sub widgets\n"
"-- we just place them left to right top to bottom\n"
"-- finally we resize this widget to fit its content\n"
"-- the widgets sx,sy is used as default hx,hy for layout\n"
"	function meta.layout_fill(widget)\n"
"		\n"
"		local hx,hy=0,0\n"
"		local my=0\n"
"		local mhx,mhy=0,0\n"
"		function addone(w)\n"
"			w.px=hx\n"
"			w.py=hy\n"
"			hx=hx+w.hx\n"
"			if hx > mhx then mhx=hx end -- max x total size\n"
"			if w.hy > my then my=w.hy end -- max y size for this line\n"
"--print(w.id or \"?\",w.px,w.py,w.hx,w.hy)\n"
"		end\n"
"		\n"
"		function endoflines()\n"
"			widget.hx=mhx\n"
"			widget.hy=mhy\n"
"		end\n"
"		\n"
"		function endofline()\n"
"			hx=0\n"
"			hy=hy+my\n"
"			my=0\n"
"			mhy=hy\n"
"		end\n"
"		\n"
"		if #widget>0 then\n"
"		\n"
"			widget.hx=widget.sx -- use sx,sy as the base fill size\n"
"			widget.hy=widget.sy\n"
"		\n"
"			for i,w in ipairs(widget) do\n"
"			\n"
"				if hx+w.hx>widget.hx then\n"
"					if hx==0 then -- need one item per line so add it anyway\n"
"						addone(w)\n"
"						endofline()\n"
"					else -- skip this one, push it onto nextline\n"
"						endofline()\n"
"						addone(w)\n"
"					end\n"
"				else -- it fits so just add\n"
"					addone(w)\n"
"				end\n"
"			end\n"
"\n"
"			if hx>0 then endofline() end -- final end of line\n"
"			\n"
"			endoflines()\n"
"			\n"
"		end\n"
"		\n"
"		for i,v in ipairs(widget) do\n"
"			v.pxd=widget.pxd+v.px\n"
"			v.pyd=widget.pyd-v.py\n"
"		end\n"
"\n"
"-- layout sub sub widgets	\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"-- this is the magical layout that works like text\n"
"-- except things expand to fit the area\n"
"-- use sx,sy and mx,my to control what ends up where\n"
"	function meta.layout_flow(widget)\n"
"		local sx,sy=0,0\n"
"		local my=0\n"
"		local line=1\n"
"		\n"
"		function endoflines()\n"
"			local y=0\n"
"			for i,v in ipairs(widget) do\n"
"				v.hy=v.sy*widget.hy/sy\n"
"				if v.hy_max and v.hy > v.hy_max then v.hy = v.hy_max end\n"
"				v.py=y\n"
"				if v.endofline then y=y+v.hy end\n"
"--print(v.px..\",\"..v.py..\" - \"..v.hx..\",\"..v.hy)\n"
"			end\n"
"		end\n"
"		\n"
"		function endofline(i)\n"
"			local x=0\n"
"			for i=line,i do -- final line layout\n"
"				local v=widget[i]\n"
"				v.sy=my\n"
"				v.hx=v.sx*widget.hx/sx\n"
"				if v.hx_max and v.hx > v.hx_max then v.hx = v.hx_max end\n"
"				v.px=x\n"
"				x=x+v.hx\n"
"			end\n"
"			widget[i].endofline=true\n"
"			sx=0\n"
"			sy=sy+my\n"
"			my=0\n"
"			line=i+1\n"
"		end\n"
"		\n"
"		if #widget>0 then\n"
"			for i,v in ipairs(widget) do\n"
"			\n"
"				v.endofline=false\n"
"				if sx+v.sx>widget.mx then\n"
"					if sx==0 then -- only one on line\n"
"						if v.sy>my then my=v.sy end\n"
"						sx=sx+v.sx				\n"
"						endofline(i)\n"
"					else -- skip this one, push onto nextline\n"
"						endofline(i-1)\n"
"						if v.sy>my then my=v.sy end\n"
"						sx=sx+v.sx				\n"
"					end\n"
"				else\n"
"					if v.sy>my then my=v.sy end\n"
"					sx=sx+v.sx				\n"
"				end\n"
"			end\n"
"\n"
"			endofline(#widget)\n"
"			endoflines()\n"
"		end\n"
"		\n"
"		for i,v in ipairs(widget) do\n"
"			v.pxd=widget.pxd+v.px\n"
"			v.pyd=widget.pyd-v.py\n"
"		end\n"
"\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"--\n"
"-- handle key input\n"
"--\n"
"	function meta.key(widget,ascii,key,act)\n"
"	end\n"
"	\n"
"--\n"
"-- handle mouse input\n"
"--\n"
"	function meta.mouse(widget,act,x,y,key)\n"
"	\n"
"--print(x..\",\"..y..\" : \"..widget.px..\",\"..widget.py)\n"
"\n"
"		if widget.pan_px then x=x-widget.pan_px end\n"
"		if widget.pan_py then y=y-widget.pan_py end\n"
"\n"
"		if widget.solid and x>=widget.pxd and x<widget.pxd+widget.hx and y<=widget.pyd and y>widget.pyd-widget.hy then\n"
"		\n"
"			if act==\"down\" then\n"
"-- only set if null or our parent...\n"
"				if not widget.master.active or widget.master.active==widget.parent then\n"
"					widget.master.active=widget\n"
"					widget.master.active_x=x-widget.pxd\n"
"					widget.master.active_y=y-widget.pyd\n"
"				end\n"
"			end\n"
"			if act==\"up\" then\n"
"				if widget.master.active and widget.master.active==widget then -- widget clicked\n"
"					widget:call_hook(\"click\")\n"
"				end\n"
"			end\n"
"\n"
"			if not widget.master.active or widget.master.active==widget then -- over widget\n"
"				widget.master.over=widget\n"
"			end\n"
"		else\n"
"		\n"
"			if widget.master.over==widget then\n"
"				widget.master.over=nil\n"
"			end\n"
"		end\n"
"	\n"
"		for i,v in ipairs(widget) do\n"
"			v:mouse(act,x,y,key)\n"
"		end\n"
"	end\n"
"	\n"
"--\n"
"-- update this widget and its sub widgets\n"
"--\n"
"	function meta.update(widget)\n"
"	\n"
"		for i,v in ipairs(widget) do\n"
"			v:update()\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- remove all children of this widget\n"
"--\n"
"	function meta.remove_all(widget)\n"
"	\n"
"		local len=#widget\n"
"		for i=1,len do\n"
"			widget[i]=nil\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- clean and remove all children of this widget\n"
"--\n"
"	function meta.clean_all(widget)\n"
"	\n"
"		for i,v in ipairs(widget) do\n"
"			v:clean_all()\n"
"		end\n"
"		\n"
"		local len=#widget\n"
"		for i=1,len do\n"
"			widget[i]:clean()\n"
"			widget[i]=nil\n"
"		end\n"
"	end\n"
"\n"
"end\n"
"",

"wetgenes.cgilua.mysqljson","\n"
"-- handle mostly opaque data stored in a mysql database\n"
"-- json is the easy/suported data format across various \"web\" languages i use ( as2/as3/jscript/lua/php )\n"
"-- so the data is serialised in json format\n"
"\n"
"local tonumber=tonumber\n"
"\n"
"\n"
"local sql=require(\"wetgenes.cgilua.mysql\")\n"
"local json=require(\"wetgenes.json\")\n"
"\n"
"\n"
"local cgi = wetgenes.cgilua or require(\"wetgenes.cgilua\")\n"
"local cfg = cfg\n"
"\n"
"\n"
"local cgilua=cgilua\n"
"\n"
"local os=os\n"
"\n"
"\n"
"\n"
"local dbg=dbg or function(s) cgilua.errorlog(s) end\n"
"\n"
"\n"
"\n"
"module(\"wetgenes.cgilua.mysqljson\")\n"
"\n"
"\n"
"base_sqltable={\n"
"	--	name		type			NULL	KEY,	default		extra\n"
"	{	\"id\",		\"bigint(20)\",	\"NO\",	\"PRI\",	nil,		\"auto_increment\"	}, -- unique object ID\n"
"	{	\"last\",		\"bigint(20)\",	\"NO\",	\"MUL\",	nil,		nil					}, -- last updated time\n"
"	{	\"latch\",	\"int(11)\",		\"NO\",	\"MUL\",	nil,		nil					}, -- a \"lock\" counter\n"
"	{	\"json\",		\"text\",			\"NO\",	nil,	nil,		nil					}, -- serialised data\n"
"}\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- create a data table\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function create_table(tabname)\n"
"\n"
"	sql.table_create(tabname,base_sqltable)\n"
"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- create a new item, you will need to call put, before it is actually created in the database\n"
"-- and of course the put may fail\n"
"-- set the id to 0 if you want to get an auto inc id\n"
"-- you may also create an item with a user id and perform a get rather than a put\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function create(tabname,id)\n"
"\n"
"local it={}\n"
"\n"
"	it.tabname=tabname\n"
"	it.id=id or 0\n"
"	it.last=os.time()\n"
"	it.latch=0\n"
"	it.data={}\n"
"	it.dirty=false\n"
"	it.json=json.Encode(it.data)\n"
"	\n"
"	return it\n"
"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- write data to database\n"
"-- this function may FAIL :)\n"
"-- need to take apropriate action if it does\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function put(it)\n"
"\n"
"	it.json=json.Encode(it.data) -- encode data, ready for send\n"
"	\n"
"	if it.id==0 or it.latch==0 then -- first write, so create a new ID\n"
"	\n"
"		local tab={}\n"
"		local t=os.time()\n"
"		local l=1\n"
"		\n"
"		tab.last=t\n"
"		tab.latch=l\n"
"		tab.json=it.json\n"
"		\n"
"		if it.id==0 then -- do not care about id\n"
"		\n"
"			local ret=sql.do_insert(it.tabname,tab)\n"
"			\n"
"			if ret==0 then return false end\n"
"			\n"
"			it.id=ret\n"
"		\n"
"		else -- we wish to create a fixed id\n"
"		\n"
"			tab.id=it.id\n"
"			local ret=sql.do_insert(it.tabname,tab)\n"
"			\n"
"			if ret~=1 then return false end\n"
"		end\n"
"	\n"
"		return true\n"
"			\n"
"	else -- update an existing item\n"
"	\n"
"		local tab={}\n"
"		local t=os.time()\n"
"		local l=it.latch+1\n"
"		\n"
"		tab.last=t\n"
"		tab.latch=l\n"
"		tab.json=it.json\n"
"		\n"
"		local ret=sql.do_update(it.tabname,tab,\" id=\"..it.id..\" AND latch=\"..it.latch)\n"
"		\n"
"		if ret==1 then -- updated OK\n"
"		\n"
"			it.latch=l\n"
"			it.last=t\n"
"		\n"
"			return true\n"
"		else\n"
"		\n"
"			it.dirty=true -- flag data as dirty\n"
"		\n"
"			return false\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	return false\n"
"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get data from database using id\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function get(it)\n"
"\n"
"	local res=sql.execute([[\n"
"			SELECT *\n"
"			FROM ]]..it.tabname..[[\n"
"			WHERE id=]]..it.id..[[ ]])\n"
"			\n"
"	local tab=sql.named(res,1)\n"
"	\n"
"	if not tab then return false end\n"
"	\n"
"	it.last=tonumber(tab.last)\n"
"	it.latch=tonumber(tab.latch)\n"
"	it.json=tab.json\n"
"	\n"
"	it.data=json.Decode(it.json) or {} -- decode data so we may edit it\n"
"	\n"
"	it.dirty=false\n"
"	\n"
"	return true\n"
"\n"
"end\n"
"\n"
"",

"wetgenes.tardis","\n"
"--\n"
"-- time and relative dimensions in space\n"
"--\n"
"-- a lua library for manipulating time and space\n"
"-- pure lua by default and opengl in flavour\n"
"--\n"
"-- recoil in terror as we use two glyph names to describe structures\n"
"-- whilst typing in random strings of numbers that may or may not contain tyops\n"
"--\n"
"-- v# vector [#]\n"
"-- m# matrix [#][#]\n"
"-- q4 quaternion (yeah its just a repackaged v4)\n"
"--\n"
"-- each class is a table of # values [1] to [#] , just access them directly\n"
"-- they are number streams formated the same way as opengl (row-major)\n"
"-- metatables are used to provide advanced functionality\n"
"--\n"
"-- currently this is not terribly optimised and may be broken in many places due to lack of testing\n"
"-- which means it is really not advisable to use this if you are not prepared to fix it :)\n"
"\n"
"local math=require(\"math\")\n"
"local table=require(\"table\")\n"
"local string=require(\"string\")\n"
"\n"
"local unpack=unpack\n"
"local getmetatable=getmetatable\n"
"local setmetatable=setmetatable\n"
"local type=type\n"
"local pairs=pairs\n"
"local ipairs=ipairs\n"
"local tostring=tostring\n"
"local tonumber=tonumber\n"
"local require=require\n"
"local error=error\n"
"\n"
"module(...)\n"
"local _M=require(...) -- do not rely on *any* questionable side effects of module\n"
"\n"
"-- a metatable typeof function\n"
"mtype_lookup=mtype_lookup or {}\n"
"function mtype(it)\n"
"	return mtype_lookup[getmetatable(it) or 0] or type(it)\n"
"end\n"
"\n"
"-- dumb class inheritance metatable creation\n"
"local function class(name,...)\n"
"\n"
"	local tab=_M[name] or {} -- use old or create new?\n"
"	local sub={...} -- possibly multiple sub classes\n"
"\n"
"	if #sub>0 then -- inherit?\n"
"		for idx=#sub,1,-1 do -- reverse sub class order, so the ones to the left overwrite the ones on the right\n"
"			for i,v in pairs(sub[idx]) do tab[i]=v end -- each subclass overwrites all values\n"
"		end\n"
"	end\n"
"\n"
"	tab.__index=tab -- this metatable is its own index\n"
"\n"
"	mtype_lookup[name]=tab -- classtype metatable lookup\n"
"	mtype_lookup[tab]=name -- tab->name or name->tab\n"
"\n"
"	_M[name]=tab\n"
"	return tab\n"
"end\n"
"\n"
"\n"
"\n"
"class(\"array\")\n"
"\n"
"function array.__tostring(it) -- these classes are all just 1d arrays of numbers\n"
"	local t={}\n"
"	t[#t+1]=mtype(it)\n"
"	t[#t+1]=\"={\"\n"
"	for i=1,#it do\n"
"		t[#t+1]=tostring(it[i])\n"
"		if i~=#it then t[#t+1]=\", \" end\n"
"	end\n"
"	t[#t+1]=\"}\"\n"
"	return table.concat(t)\n"
"end\n"
"\n"
"function array.set(it,...)\n"
"	local n=1\n"
"	for i,v in ipairs{...} do\n"
"		if not it[n] then return it end -- got all the data we need (#it)\n"
"		if type(v)==\"number\" then\n"
"			it[n]=v\n"
"			n=n+1\n"
"		else\n"
"			for ii,vv in ipairs(v) do -- allow one depth of tables\n"
"				it[n]=vv\n"
"				n=n+1\n"
"			end\n"
"		end\n"
"	end\n"
"	return it\n"
"end\n"
"\n"
"function array.product(a,b,r)\n"
"	local mta=mtype(a)\n"
"	local mtb=mtype(b)\n"
"	if mta==\"m4\" then\n"
"		if     mtb==\"v3\" then\n"
"			return m4_product_v3(a,b,r)\n"
"		elseif mtb==\"v4\" then\n"
"			return m4_product_v4(a,b,r)\n"
"		elseif mtb==\"m4\" then\n"
"			return m4_product_m4(a,b,r)\n"
"		end\n"
"	end\n"
"	error(\"tardis : \"..mta..\" product \"..mtb..\" not supported\",2)\n"
"end\n"
"\n"
"\n"
"class(\"m2\",array)\n"
"function m2.new(...) return setmetatable({0,0,0,0},m2):set(...) end\n"
"function m2.determinant(it)\n"
"	return	 ( it[ 1 ]*it[ 2+2 ] )\n"
"			+( it[ 2 ]*it[ 2+1 ] )\n"
"			-( it[ 1 ]*it[ 2+1 ] )\n"
"			-( it[ 2 ]*it[ 2+1 ] )\n"
"end\n"
"function m2.minor_xy(it,x,y)\n"
"	return it[1+(2-(x-1))+((2-(y-1))*2)]\n"
"end\n"
"function m2.transpose(it,r)\n"
"	r=r or it\n"
"	return	 r:set(it[1],it[2+1], it[2],it[2+2])\n"
"end\n"
"function m2.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set(it[1]*s,it[2]*s, it[2+1]*s,it[2+2]*s)\n"
"end\n"
"function m2.cofactor(it,r)\n"
"	r=r or it\n"
"	local t={}\n"
"	for iy=1,2 do\n"
"		for ix=1,2 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=m2.minor_xy(it,ix,iy)\n"
"				if ((ix+iy)%2)==1 then t[#t]=-t[#t] end\n"
"			end\n"
"		end\n"
"	end\n"
"	return r\n"
"end\n"
"function m2.adjugate(it,r)\n"
"	r=r or it\n"
"	return m2.cofactor(m2.transpose(it,m2.new()),r)\n"
"end\n"
"function m2.inverse(it,r)\n"
"	r=r or it\n"
"	local ood=1/m2.determinant(it)	\n"
"	return m2.scale(m2.cofactor(m2.transpose(it,m2.new())),ood,r)\n"
"end\n"
"\n"
"class(\"m3\",m2)\n"
"function m3.new(...) return setmetatable({0,0,0,0,0,0,0,0,0},m3):set(...) end\n"
"function m3.determinant(it)\n"
"	return	 ( it[ 1 ]*it[ 3+2 ]*it[ 6+3 ] )\n"
"			+( it[ 2 ]*it[ 3+3 ]*it[ 6+1 ] )\n"
"			+( it[ 3 ]*it[ 3+1 ]*it[ 6+2 ] )\n"
"			-( it[ 1 ]*it[ 3+3 ]*it[ 6+2 ] )\n"
"			-( it[ 2 ]*it[ 3+1 ]*it[ 6+3 ] )\n"
"			-( it[ 3 ]*it[ 3+2 ]*it[ 6+1 ] )\n"
"end\n"
"function m3.minor_xy(it,x,y)\n"
"	local t={}\n"
"	for ix=1,3 do\n"
"		for iy=1,3 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=it[ix+((iy-1)*3)]\n"
"			end\n"
"		end\n"
"	end\n"
"	return m2.determinant(t)\n"
"end\n"
"function m3.transpose(it,r)\n"
"	r=r or it\n"
"	return	 r:set(it[1],it[3+1],it[6+1], it[2],it[3+2],it[6+2], it[3],it[3+3],it[6+3])\n"
"end\n"
"function m3.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set(it[1]*s,it[2]*s,it[3]*s, it[3+1]*s,it[3+2]*s,it[3+3]*s, it[6+1]*s,it[6+2]*s,it[6+3]*s)\n"
"end\n"
"function m3.cofactor(it,r)\n"
"	r=r or it\n"
"	local t={}\n"
"	for iy=1,3 do\n"
"		for ix=1,3 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=m3.minor_xy(it,ix,iy)\n"
"				if ((ix+iy)%2)==1 then t[#t]=-t[#t] end\n"
"			end\n"
"		end\n"
"	end\n"
"	return r:set(t)\n"
"end\n"
"function m3.adjugate(it,r)\n"
"	r=r or it\n"
"	return m3.cofactor(m3.transpose(it,m3.new()),r)\n"
"end\n"
"function m3.inverse(it,r)\n"
"	r=r or it\n"
"	local ood=1/m3.determinant(it)	\n"
"	return m3.scale(m3.cofactor(m3.transpose(it,m3.new())),ood,r)\n"
"end\n"
"\n"
"class(\"m4\",m3)\n"
"function m4.new(...) return setmetatable({0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},m4):set(...) end\n"
"function m4.determinant(it)\n"
"return	(it[ 4 ] * it[ 4+3 ] * it[ 8+2 ] * it[ 12+1 ])-(it[ 3 ] * it[ 4+4 ] * it[ 8+2 ] * it[ 12+1 ])-\n"
"		(it[ 4 ] * it[ 4+2 ] * it[ 8+3 ] * it[ 12+1 ])+(it[ 2 ] * it[ 4+4 ] * it[ 8+3 ] * it[ 12+1 ])+\n"
"		(it[ 3 ] * it[ 4+2 ] * it[ 8+4 ] * it[ 12+1 ])-(it[ 2 ] * it[ 4+3 ] * it[ 8+4 ] * it[ 12+1 ])-\n"
"		(it[ 4 ] * it[ 4+3 ] * it[ 8+1 ] * it[ 12+2 ])+(it[ 3 ] * it[ 4+4 ] * it[ 8+1 ] * it[ 12+2 ])+\n"
"		(it[ 4 ] * it[ 4+1 ] * it[ 8+3 ] * it[ 12+2 ])-(it[ 1 ] * it[ 4+4 ] * it[ 8+3 ] * it[ 12+2 ])-\n"
"		(it[ 3 ] * it[ 4+1 ] * it[ 8+4 ] * it[ 12+2 ])+(it[ 1 ] * it[ 4+3 ] * it[ 8+4 ] * it[ 12+2 ])+\n"
"		(it[ 4 ] * it[ 4+2 ] * it[ 8+1 ] * it[ 12+3 ])-(it[ 2 ] * it[ 4+4 ] * it[ 8+1 ] * it[ 12+3 ])-\n"
"		(it[ 4 ] * it[ 4+1 ] * it[ 8+2 ] * it[ 12+3 ])+(it[ 1 ] * it[ 4+4 ] * it[ 8+2 ] * it[ 12+3 ])+\n"
"		(it[ 2 ] * it[ 4+1 ] * it[ 8+4 ] * it[ 12+3 ])-(it[ 1 ] * it[ 4+2 ] * it[ 8+4 ] * it[ 12+3 ])-\n"
"		(it[ 3 ] * it[ 4+2 ] * it[ 8+1 ] * it[ 12+4 ])+(it[ 2 ] * it[ 4+3 ] * it[ 8+1 ] * it[ 12+4 ])+\n"
"		(it[ 3 ] * it[ 4+1 ] * it[ 8+2 ] * it[ 12+4 ])-(it[ 1 ] * it[ 4+3 ] * it[ 8+2 ] * it[ 12+4 ])-\n"
"		(it[ 2 ] * it[ 4+1 ] * it[ 8+3 ] * it[ 12+4 ])+(it[ 1 ] * it[ 4+2 ] * it[ 8+3 ] * it[ 12+4 ])	\n"
"end\n"
"function m4.minor_xy(it,x,y)\n"
"	local t={}\n"
"	for ix=1,4 do\n"
"		for iy=1,4 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=it[ix+((iy-1)*4)]\n"
"			end\n"
"		end\n"
"	end\n"
"	return m3.determinant(t)\n"
"end\n"
"function m4.transpose(it,r)\n"
"	r=r or r\n"
"	return	 r:set(it[1],it[4+1],it[8+1],it[12+1], it[2],it[4+2],it[8+2],it[12+2], it[3],it[4+3],it[8+3],it[12+3], it[4],it[4+4],it[8+4],it[12+4])\n"
"end\n"
"function m4.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set(it[1]*s,it[2]*s,it[3]*s,it[4]*s, it[4+1]*s,it[4+2]*s,it[4+3]*s,it[4+4]*s, it[8+1]*s,it[8+2]*s,it[8+3]*s,it[8+4]*s, it[12+1]*s,it[12+2]*s,it[12+3]*s,it[12+4]*s)\n"
"end\n"
"function m4.cofactor(it,r)\n"
"	r=r or it\n"
"	local t={}\n"
"	for iy=1,4 do\n"
"		for ix=1,4 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=m4.minor_xy(it,ix,iy)\n"
"				if ((ix+iy)%2)==1 then t[#t]=-t[#t] end\n"
"			end\n"
"		end\n"
"	end\n"
"	return r:set(t)\n"
"end\n"
"function m4.adjugate(it,r)\n"
"	r=r or it\n"
"	return 	m4.cofactor(m4.transpose(it,m4.new()),r)\n"
"end\n"
"function m4.inverse(it,r)\n"
"	r=r or it\n"
"	local ood=1/m4.determinant(it)	\n"
"	return m4.scale(m4.cofactor(m4.transpose(it,m4.new())),ood,r)\n"
"end\n"
"\n"
"\n"
"\n"
"class(\"v2\",array)\n"
"function v2.new(...) return setmetatable({0,0},v2):set(...) end\n"
"function v2.lenlen(it)\n"
"	return (it[1]*it[1]) + (it[2]*it[2])\n"
"end\n"
"function v2.len(it)\n"
"	return math.sqrt( (it[1]*it[1]) + (it[2]*it[2]) )\n"
"end\n"
"function v2.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set( it[1]*s , it[2]*s )\n"
"end\n"
"function v2.normalize(it,r)\n"
"	return v2.scale(it,1/v2.len(it),r)\n"
"end\n"
"\n"
"class(\"v3\",v2)\n"
"function v3.new(...) return setmetatable({0,0,0},v3):set(...) end\n"
"function v3.lenlen(it)\n"
"	return (it[1]*it[1]) + (it[2]*it[2]) + (it[3]*it[3])\n"
"end\n"
"function v3.len(it)\n"
"	return math.sqrt( (it[1]*it[1]) + (it[2]*it[2]) + (it[3]*it[3]) )\n"
"end\n"
"function v3.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set( it[1]*s , it[2]*s , it[3]*s )\n"
"end\n"
"function v3.normalize(it,r)\n"
"	return v3.scale(it,1/v3.len(it),r)\n"
"end\n"
"function v3.add(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( va[1]+vb[1] , va[2]+vb[2] , va[3]+vb[3] )\n"
"end\n"
"function v3.sub(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( va[1]-vb[1] , va[2]-vb[2] , va[3]-vb[3] )\n"
"end\n"
"function v3.mul(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( (va[1]*vb[1]) , (va[2]*vb[2]) , (va[3]*vb[3]) )\n"
"end\n"
"function v3.dot(va,vb)\n"
"	return ( (va[1]*vb[1]) + (va[2]*vb[2]) + (va[3]*vb[3]) )\n"
"end\n"
"function v3.cross(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( (va[2]*vb[3])-(va[3]*vb[2]) , (va[3]*vb[1])-(va[1]*vb[3]) , (va[1]*vb[2])-(va[2]*vb[1]) )\n"
"end\n"
"\n"
"\n"
"class(\"v4\",v3)\n"
"function v4.new(...) return setmetatable({0,0,0,0},v4):set(...) end\n"
"function v4.to_v3(it,r) -- scale [4] to 1 then throw it away so we have a v3 xyz\n"
"	r=r or v3.new()\n"
"	local oow=1/it[4]\n"
"	return r:set( it[1]*oow , it[2]*oow , it[3]*oow )\n"
"end\n"
"function v4.lenlen(it)\n"
"	return (it[1]*it[1]) + (it[2]*it[2]) + (it[3]*it[3]) + (it[4]*it[4])\n"
"end\n"
"function v4.len(it)\n"
"	return math.sqrt( (it[1]*it[1]) + (it[2]*it[2]) + (it[3]*it[3]) + (it[4]*it[4]) )\n"
"end\n"
"function v4.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set( it[1]*s , it[2]*s , it[3]*s , it[4]*s )\n"
"end\n"
"function v4.normalize(it,r)\n"
"	return v4.scale(it,1/v4.len(it),r)\n"
"end\n"
"\n"
"class(\"q4\",v4)\n"
"function q4.new(...) return setmetatable({0,0,0,0},q4):set(...) end\n"
"\n"
"\n"
"class(\"line\",array)\n"
"line.set=nil -- disable\n"
"function line.new(...) return setmetatable({v3.new(),v3.new()},line) end -- [1]position , [2]normal\n"
"\n"
"class(\"plane\",line)\n"
"function plane.new(...) return setmetatable({v3.new(),v3.new()},plane) end -- [1]position , [2]normal\n"
"\n"
"\n"
"function line_intersect_plane(l,p,r)\n"
"	r=r or v3.new()\n"
"	local t=v3.new(p[1]):sub(l[1]) -- the line position relative to the plane\n"
"	local d=l[2]:dot(p[2]) -- the length of the line until it hits the plane\n"
"	if d~=0 then -- less errors please\n"
"		d=t:dot(p[2])/d\n"
"	end\n"
"	return r:set( l[1][1]+(l[2][1]*d) , l[1][2]+(l[2][2]*d) , l[1][3]+(l[2][3]*d) ) -- the point of intersection\n"
"end\n"
"\n"
"function m4_product_v4(m4a,v4b,r)\n"
"	r=r or v4b\n"
"	local r1= (m4a[   1]*v4b[1]) + (m4a[ 4+1]*v4b[2]) + (m4a[ 8+1]*v4b[3]) + (m4a[12+1]*v4b[4])\n"
"	local r2= (m4a[   2]*v4b[1]) + (m4a[ 4+2]*v4b[2]) + (m4a[ 8+2]*v4b[3]) + (m4a[12+2]*v4b[4])\n"
"	local r3= (m4a[   3]*v4b[1]) + (m4a[ 4+3]*v4b[2]) + (m4a[ 8+3]*v4b[3]) + (m4a[12+3]*v4b[4])\n"
"	local r4= (m4a[   4]*v4b[1]) + (m4a[ 4+4]*v4b[2]) + (m4a[ 8+4]*v4b[3]) + (m4a[12+4]*v4b[4])\n"
"	return r:set(r1,r2,r3,r4)\n"
"end\n"
"\n"
"function m4_product_v3(m4a,v3b,r)\n"
"	r=r or v3b\n"
"	local oow=1/( (m4a[   4]*v3b[1]) + (m4a[ 4+4]*v3b[2]) + (m4a[ 8+4]*v3b[3]) + (m4a[12+4] ) )\n"
"	local r1= oow * ( (m4a[   1]*v3b[1]) + (m4a[ 4+1]*v3b[2]) + (m4a[ 8+1]*v3b[3]) + (m4a[12+1] ) )\n"
"	local r2= oow * ( (m4a[   2]*v3b[1]) + (m4a[ 4+2]*v3b[2]) + (m4a[ 8+2]*v3b[3]) + (m4a[12+2] ) )\n"
"	local r3= oow * ( (m4a[   3]*v3b[1]) + (m4a[ 4+3]*v3b[2]) + (m4a[ 8+3]*v3b[3]) + (m4a[12+3] ) )\n"
"	return r:set(r1,r2,r3)\n"
"end\n"
"\n"
"function m4_product_m4(m4a,m4b,r)\n"
"	r=r or m4b\n"
"	local r1 = (m4a[   1]*m4b[   1]) + (m4a[   2]*m4b[ 4+1]) + (m4a[   3]*m4b[ 8+1]) + (m4a[   4]*m4b[12+1])\n"
"	local r2 = (m4a[   1]*m4b[   2]) + (m4a[   2]*m4b[ 4+2]) + (m4a[   3]*m4b[ 8+2]) + (m4a[   4]*m4b[12+2])\n"
"	local r3 = (m4a[   1]*m4b[   3]) + (m4a[   2]*m4b[ 4+3]) + (m4a[   3]*m4b[ 8+3]) + (m4a[   4]*m4b[12+3])\n"
"	local r4 = (m4a[   1]*m4b[   4]) + (m4a[   2]*m4b[ 4+4]) + (m4a[   3]*m4b[ 8+4]) + (m4a[   4]*m4b[12+4])\n"
"	local r5 = (m4a[ 4+1]*m4b[   1]) + (m4a[ 4+2]*m4b[ 4+1]) + (m4a[ 4+3]*m4b[ 8+1]) + (m4a[ 4+4]*m4b[12+1])\n"
"	local r6 = (m4a[ 4+1]*m4b[   2]) + (m4a[ 4+2]*m4b[ 4+2]) + (m4a[ 4+3]*m4b[ 8+2]) + (m4a[ 4+4]*m4b[12+2])\n"
"	local r7 = (m4a[ 4+1]*m4b[   3]) + (m4a[ 4+2]*m4b[ 4+3]) + (m4a[ 4+3]*m4b[ 8+3]) + (m4a[ 4+4]*m4b[12+3])\n"
"	local r8 = (m4a[ 4+1]*m4b[   4]) + (m4a[ 4+2]*m4b[ 4+4]) + (m4a[ 4+3]*m4b[ 8+4]) + (m4a[ 4+4]*m4b[12+4])\n"
"	local r9 = (m4a[ 8+1]*m4b[   1]) + (m4a[ 8+2]*m4b[ 4+1]) + (m4a[ 8+3]*m4b[ 8+1]) + (m4a[ 8+4]*m4b[12+1])\n"
"	local r10= (m4a[ 8+1]*m4b[   2]) + (m4a[ 8+2]*m4b[ 4+2]) + (m4a[ 8+3]*m4b[ 8+2]) + (m4a[ 8+4]*m4b[12+2])\n"
"	local r11= (m4a[ 8+1]*m4b[   3]) + (m4a[ 8+2]*m4b[ 4+3]) + (m4a[ 8+3]*m4b[ 8+3]) + (m4a[ 8+4]*m4b[12+3])\n"
"	local r12= (m4a[ 8+1]*m4b[   4]) + (m4a[ 8+2]*m4b[ 4+4]) + (m4a[ 8+3]*m4b[ 8+4]) + (m4a[ 8+4]*m4b[12+4])\n"
"	local r13= (m4a[12+1]*m4b[   1]) + (m4a[12+2]*m4b[ 4+1]) + (m4a[12+3]*m4b[ 8+1]) + (m4a[12+4]*m4b[12+1])\n"
"	local r14= (m4a[12+1]*m4b[   2]) + (m4a[12+2]*m4b[ 4+2]) + (m4a[12+3]*m4b[ 8+2]) + (m4a[12+4]*m4b[12+2])\n"
"	local r15= (m4a[12+1]*m4b[   3]) + (m4a[12+2]*m4b[ 4+3]) + (m4a[12+3]*m4b[ 8+3]) + (m4a[12+4]*m4b[12+3])\n"
"	local r16= (m4a[12+1]*m4b[   4]) + (m4a[12+2]*m4b[ 4+4]) + (m4a[12+3]*m4b[ 8+4]) + (m4a[12+4]*m4b[12+4])\n"
"	return r:set(r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15,r16)\n"
"end\n"
"\n"
"",

"spew.util","\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"local string=string\n"
"local math=math\n"
"local os=os\n"
"local print=print\n"
"local tonumber=tonumber\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"--\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"module(\"spew.util\")\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split a string into a table\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function str_split(div,str,enable_special_chars)\n"
"\n"
"  if (div=='') or not div then error(\"div expected\", 2) end\n"
"  if (str=='') or not str then error(\"str expected\", 2) end\n"
"  \n"
"  local pos,arr = 0,{}\n"
"  \n"
"  -- for each divider found\n"
"  for st,sp in function() return string.find(str,div,pos,not enable_special_chars) end do\n"
"	table.insert(arr,string.sub(str,pos,st-1)) -- Attach chars left of current divider\n"
"	pos = sp + 1 -- Jump past current divider\n"
"  end\n"
"  \n"
"  if pos~=0 then\n"
"	table.insert(arr,string.sub(str,pos)) -- Attach chars right of last divider\n"
"  else\n"
"	table.insert(arr,str) -- return entire string\n"
"  end\n"
"  \n"
"  \n"
"  return arr\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace any %xx with the intended char, eg \"%20\" becomes a \" \"\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_decode(str)\n"
"    return string.gsub(str, \"%%(%x%x)\", function(hex)\n"
"        return string.char(tonumber(hex, 16))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace % , & and = chars with %xx codes\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_encode(str)\n"
"    return string.gsub(str, \"([&=%%])\", function(c)\n"
"        return string.format(\"%%%02x\", string.byte(c))\n"
"    end)\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- decode a string into a msg\n"
"-- if last is passed in then this table is adjusted rather than a new table being created\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function str_to_msg(str,last)\n"
"local msg=last or {}\n"
"local arr\n"
"local set\n"
"\n"
"	arr=str_split(\"&\",str)\n"
"	\n"
"	for i,v in ipairs(arr) do\n"
"	\n"
"		if v~=\"\" then\n"
"		\n"
"			set=str_split(\"=\",v)\n"
"			\n"
"			if set[1] and set[2] then\n"
"			\n"
"				msg[ set[1] ]=url_decode(set[2])\n"
"			end\n"
"			\n"
"		end\n"
"	end\n"
"\n"
"	return msg\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- encode a msg into a string\n"
"-- if last is available then only *changes* from msg to last are encoded, last is also updated with these changes\n"
"-- this gives a very simple delta compression\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function msg_to_str(msg,last)\n"
"local str\n"
"local line=\"&\"\n"
"\n"
"	for i,v in pairs(msg) do\n"
"	\n"
"		if (not last) or (last[i]~=v) then -- only store changes in string\n"
"		\n"
"			line=line.. i ..\"=\".. url_encode(v) ..\"&\"\n"
"			\n"
"			if last then last[i]=v end\n"
"			\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	return line\n"
"end\n"
"\n"
"",

"fenestra.wrap","\n"
"\n"
"local print=print\n"
"\n"
"local core = require(\"fenestra.core\")\n"
"local console = require(\"fenestra.console\")\n"
"local data = require(\"fenestra.data\")\n"
"local avatar = require(\"fenestra.avatar\")\n"
"local font = require(\"fenestra.font\")\n"
"local widget = require(\"fenestra.widget\")\n"
"\n"
"local gl=require(\"gl\")\n"
"\n"
"module(\"fenestra.wrap\")\n"
"\n"
"--\n"
"-- Call win to get a unique table full of functions associated\n"
"-- with lots of tasty up values for easy use\n"
"--\n"
"-- local win=require(\"fenestra.wrap\").win()\n"
"--\n"
"function win(opts)\n"
"opts=opts or {}\n"
"\n"
"local win={}\n"
"\n"
"	function win.setup(g)\n"
"	\n"
"		win._g=g -- the global table\n"
"		win.into_hwnd=opts.into_hwnd\n"
"\n"
"-- open window of this height		\n"
"		win.width=opts.width\n"
"		win.height=opts.height\n"
"\n"
"		win.core = core.setup(win)\n"
"		\n"
"		win.core_data = core.data.setup(win.core)\n"
"		\n"
"		win.data = data.setup(win)\n"
"		\n"
"		win.core_ogl = core.ogl.setup(win.core)\n"
"		\n"
"		win.console = console.setup(win)		\n"
"		win.restore_print=win.console.replace_print(g)\n"
"		\n"
"		win.avatar = avatar.setup(win)\n"
"		\n"
"		win.font_base=font.setup(win,\"base\")\n"
"		win.font_sans=font.setup(win,\"sans\")\n"
"		win.font_debug=win.font_base -- old name, do not use...\n"
"		\n"
"		win.widget=widget.setup(win,{font=win.font_sans})\n"
"		\n"
"		return win\n"
"	end\n"
"\n"
"	function win.clean()\n"
"		\n"
"		win.widget.clean()\n"
"		\n"
"		win.font_sans.clean()\n"
"		win.font_base.clean()\n"
"\n"
"		win.avatar.clean()\n"
"		\n"
"		win.restore_print()\n"
"		win.console.clean()\n"
"		\n"
"		core.ogl.clean(win.core_ogl)\n"
"		\n"
"		win.data.clean()\n"
"		\n"
"		core.data.clean(win.core_data)\n"
"		\n"
"		core.clean(win.core)\n"
"\n"
"	end\n"
"\n"
"	function win.xox(xox_info)\n"
"\n"
"		local core=win.xox_setup(xox_info)\n"
"		local xox=win.xox_get(core)\n"
"		xox.info=xox_info\n"
"		xox.core=core\n"
"		\n"
"		function xox.clean()\n"
"			return win.xox_clean(core)\n"
"		end\n"
"		\n"
"		function xox.draw()\n"
"			return win.xox_draw(core)\n"
"		end\n"
"\n"
"		function xox.set()\n"
"			return win.xox_set(core,xox)\n"
"		end\n"
"		\n"
"		return xox\n"
"	end\n"
"	\n"
"	function win.xsx(xsx_info)\n"
"\n"
"		local core=win.xsx_setup(xsx_info)\n"
"		local xsx=win.xsx_get(core)\n"
"		xsx.info=xsx_info\n"
"		xsx.core=core\n"
"		\n"
"		function xsx.clean()\n"
"			return win.xsx_clean(core)\n"
"		end\n"
"		\n"
"		function xsx.draw(f)\n"
"			return win.xsx_draw(core,f)\n"
"		end\n"
"		\n"
"		function xsx.set()\n"
"			return win.xsx_set(core,xsx)\n"
"		end\n"
"		\n"
"		return xsx\n"
"\n"
"	end\n"
"\n"
"\n"
"	function win.fbo(width,height,depth)\n"
"	\n"
"		depth=depth or 0\n"
"		\n"
"		local core=win.fbo_setup(width,height,depth)\n"
"		local fbo={}\n"
"		fbo.core=core\n"
"		fbo.width=width\n"
"		fbo.height=height\n"
"		fbo.depth=depth\n"
"		\n"
"		function fbo.clean(fbo)\n"
"			return win.fbo_clean(core)\n"
"		end\n"
"		\n"
"		function fbo.bind(fbo)\n"
"			return win.fbo_bind(core)\n"
"		end\n"
"\n"
"		function fbo.texture(fbo)\n"
"			return win.fbo_texture(core)\n"
"		end\n"
"\n"
"		function fbo.draw(fbo)\n"
"			win.fbo_texture(core)\n"
"			gl.Disable(gl.CULL_FACE)\n"
"			gl.Enable(gl.TEXTURE_2D)\n"
"			gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR)\n"
"			gl.BlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA) --fbo has premultipliedalpha\n"
"			gl.Begin(gl.QUADS)\n"
"				gl.Color({1,1,1,1})\n"
"				gl.TexCoord(0, 0) gl.Vertex(fbo.width*-0.5, fbo.height*-0.5)\n"
"				gl.TexCoord(1, 0) gl.Vertex(fbo.width* 0.5, fbo.height*-0.5)\n"
"				gl.TexCoord(1, 1) gl.Vertex(fbo.width* 0.5, fbo.height* 0.5)\n"
"				gl.TexCoord(0, 1) gl.Vertex(fbo.width*-0.5, fbo.height* 0.5)\n"
"			gl.End()\n"
"		end\n"
"\n"
"		return fbo\n"
"\n"
"	end\n"
"\n"
"	function win.tex(grd) -- this takes a copy of the given grd\n"
"	\n"
"		local core=win.tex_setup(grd)\n"
"		local tex={}\n"
"		tex.core=core\n"
"		tex.width=grd.width\n"
"		tex.height=grd.height\n"
"		tex.depth=grd.depth\n"
"		\n"
"		grd=nil -- do not keep any references\n"
"		\n"
"		function tex.clean(tex)\n"
"			return win.tex_clean(core)\n"
"		end\n"
"		\n"
"		function tex.bind(tex)\n"
"			return win.tex_bind(core)\n"
"		end\n"
"\n"
"		function tex.draw(tex)\n"
"			win.tex_bind(core)\n"
"			gl.Disable(gl.CULL_FACE)\n"
"			gl.Enable(gl.TEXTURE_2D)\n"
"			gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR)\n"
"			gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)\n"
"			gl.Begin(gl.QUADS)\n"
"				gl.Color({1,1,1,1})\n"
"				gl.TexCoord(0, 0) gl.Vertex(tex.width*-0.5, tex.height* 0.5)\n"
"				gl.TexCoord(1, 0) gl.Vertex(tex.width* 0.5, tex.height* 0.5)\n"
"				gl.TexCoord(1, 1) gl.Vertex(tex.width* 0.5, tex.height*-0.5)\n"
"				gl.TexCoord(0, 1) gl.Vertex(tex.width*-0.5, tex.height*-0.5)\n"
"			gl.End()\n"
"		end\n"
"\n"
"		return tex\n"
"\n"
"	end\n"
"\n"
"	\n"
"-- return window x,y pos transformed into the viewspace of project23d if you provided h/w to that function\n"
"	function win.mouse23d(w,h,x,y)\n"
"	\n"
"		local hx=win.width/2\n"
"		local hy=win.height/2\n"
"\n"
"		local tx,ty\n"
"		\n"
"		if win.height/(win.width or 1) > (h/w) then -- deal with new \"smart\" viewport sizeing\n"
"		\n"
"			tx=(w/ 2)*(x-hx)/hx\n"
"			ty=(w/-2)*(hy-y)/hx\n"
"			\n"
"		else\n"
"		\n"
"			tx=(h/ 2)*(x-hx)/hy\n"
"			ty=(h/-2)*(hy-y)/hy\n"
"\n"
"		end\n"
"\n"
"		return tx,ty\n"
"	end\n"
"\n"
"function win.choose_file(...)			return core.choose_file(				win.core,		...) end\n"
"\n"
"-- default key and mouse functions just send data to the debug console	\n"
"function win.keypress(...)				return win.console.keypress(							...) end\n"
"function win.mouse(...)					return win.console.mouse(								...) end\n"
"\n"
"function win.msg(...)					return core.msg(						win.core,		...) end\n"
"function win.time(...)					return core.time(						win.core,		...) end\n"
"\n"
"function win.getwin(...)				return core.getwin(						win.core,		...) end\n"
"function win.setwin(...)				return core.setwin(						win.core,		...) end\n"
"\n"
"function win.get(...)					return core.ogl.get(					win.core_ogl,	...) end\n"
"function win.set(...)					return core.ogl.set(					win.core_ogl,	...) end\n"
"function win.begin(...)					return core.ogl.begin(					win.core_ogl,	...) end\n"
"function win.clip2d(...)				return core.ogl.clip2d(					win.core_ogl,	...) end\n"
"function win.project23d(...)			return core.ogl.project23d(				win.core_ogl,	...) end\n"
"function win.swap(...)					return core.ogl.swap(					win.core_ogl,	...) end\n"
"\n"
"function win.target(...)				return core.ogl.target(					win.core_ogl,	...) end\n"
"function win.readpixels(...)			return core.ogl.readpixels(				win.core_ogl,	...) end\n"
"\n"
"\n"
"function win.debug_begin(...)			return core.ogl.debug_begin(			win.core_ogl,	...) end\n"
"function win.debug_end(...)				return core.ogl.debug_end(				win.core_ogl,	...) end\n"
"function win.debug_print(...)			return core.ogl.debug_print(			win.core_ogl,	...) end\n"
"function win.debug_print_alt(...)		return core.ogl.debug_print_alt(		win.core_ogl,	...) end\n"
"function win.debug_rect(...)			return core.ogl.debug_rect(				win.core_ogl,	...) end\n"
"function win.debug_polygon_begin(...)	return core.ogl.debug_polygon_begin(	win.core_ogl,	...) end\n"
"function win.debug_polygon_vertex(...)	return core.ogl.debug_polygon_vertex(	win.core_ogl,	...) end\n"
"function win.debug_polygon_end(...)		return core.ogl.debug_polygon_end(		win.core_ogl,	...) end\n"
"\n"
"\n"
"function win.flat_begin(...)			return core.ogl.flat_begin(				win.core_ogl,	...) end\n"
"function win.flat_end(...)				return core.ogl.flat_end(				win.core_ogl,	...) end\n"
"function win.flat_font(...)				return core.ogl.flat_font(				win.core_ogl,	...) end\n"
"function win.flat_print(...)			return core.ogl.flat_print(				win.core_ogl,	...) end\n"
"function win.flat_measure(...)			return core.ogl.flat_measure(			win.core_ogl,	...) end\n"
"function win.flat_which(...)			return core.ogl.flat_which(				win.core_ogl,	...) end\n"
"function win.flat_fits(...)				return core.ogl.flat_fits(				win.core_ogl,	...) end\n"
"function win.flat_rect(...)				return core.ogl.debug_rect(				win.core_ogl,	...) end\n"
"function win.flat_polygon_begin(...)	return core.ogl.debug_polygon_begin(	win.core_ogl,	...) end\n"
"function win.flat_polygon_vertex(...)	return core.ogl.debug_polygon_vertex(	win.core_ogl,	...) end\n"
"function win.flat_polygon_end(...)		return core.ogl.debug_polygon_end(		win.core_ogl,	...) end\n"
"\n"
"\n"
"function win.draw_cube(...)				return core.ogl.draw_cube(				win.core_ogl,	...) end\n"
"\n"
"function win.xox_setup(...)				return core.ogl.xox_setup(				win.core_ogl,	...) end\n"
"function win.xox_clean(...)				return core.ogl.xox_clean(				win.core_ogl,	...) end\n"
"function win.xox_draw(...)				return core.ogl.xox_draw(				win.core_ogl,	...) end\n"
"function win.xox_get(...)				return core.ogl.xox_get(				win.core_ogl,	...) end\n"
"function win.xox_set(...)				return core.ogl.xox_set(				win.core_ogl,	...) end\n"
"\n"
"function win.xsx_setup(...)				return core.ogl.xsx_setup(				win.core_ogl,	...) end\n"
"function win.xsx_clean(...)				return core.ogl.xsx_clean(				win.core_ogl,	...) end\n"
"function win.xsx_draw(...)				return core.ogl.xsx_draw(				win.core_ogl,	...) end\n"
"function win.xsx_get(...)				return core.ogl.xsx_get(				win.core_ogl,	...) end\n"
"function win.xsx_set(...)				return core.ogl.xsx_set(				win.core_ogl,	...) end\n"
"\n"
"function win.fbo_setup(...)				return core.ogl.fbo_setup(				win.core_ogl,	...) end\n"
"function win.fbo_clean(...)				return core.ogl.fbo_clean(				win.core_ogl,	...) end\n"
"function win.fbo_bind(...)				return core.ogl.fbo_bind(				win.core_ogl,	...) end\n"
"function win.fbo_texture(...)			return core.ogl.fbo_texture(			win.core_ogl,	...) end\n"
"\n"
"function win.tex_setup(...)				return core.ogl.tex_setup(				win.core_ogl,	...) end\n"
"function win.tex_clean(...)				return core.ogl.tex_clean(				win.core_ogl,	...) end\n"
"function win.tex_bind(...)				return core.ogl.tex_bind(				win.core_ogl,	...) end\n"
"\n"
"function win.load(...)					return core.data.load(					win.core_data,	...) end\n"
"	\n"
"	return win\n"
"end\n"
"\n"
"",

"wetgenes.cgilua.session","--\n"
"-- Mysql helper functions\n"
"--\n"
"\n"
"require\"cgilua.cookies\"\n"
"\n"
"local sql=require(\"wetgenes.cgilua.mysql\")\n"
"\n"
"\n"
"local type,ipairs=type,ipairs\n"
"\n"
"local string=string\n"
"\n"
"local wet_html=require(\"wetgenes.html\")\n"
"\n"
"local cgi = wetgenes.cgilua or require(\"wetgenes.cgilua\")\n"
"local cfg = cfg\n"
"\n"
"\n"
"local cgilua=cgilua\n"
"\n"
"local dbg=dbg or function(s) cgilua.errorlog(s) end\n"
"\n"
"module(\"wetgenes.cgilua.session\")\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- log in using a session\n"
"-- if need is set to true then redirect to a login page as a login is needed\n"
"--\n"
"-- pass in url of current page if needed, (escaping is icky)\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function login(need)\n"
"\n"
"local sess=cgilua.cookies.get(cfg.cookie_session)\n"
"\n"
"local redirect=\"http://join.wetgenes.\"..cfg.tld..\"/?redirect=\"..wet_html.url_esc(wet_html.url_esc(cgi.url_query))\n"
"\n"
"user={}\n"
"\n"
"\n"
"	if sess then\n"
"\n"
"		sess=string.gsub(sess, \"[^0-9a-zA-Z]+\", \"\" )\n"
"\n"
"\n"
"		local info=sql.execute([[SELECT\n"
"				u.alias, u.posts_ppg, u.time_zone, u.sig, u.last_visit, u.last_read, u.cat_collapse_status, u.users_opt,\n"
"				u.ignore_list, u.buddy_list, u.id, u.group_leader_list, u.email, u.login, u.sq, u.ban_expiry\n"
"				, u.avatar_loc , u.referer_id , s.time_sec , s.sys_id\n"
"			FROM ]]..cfg.mysql_prefix_fud..[[ses s\n"
"				INNER JOIN ]]..cfg.mysql_prefix_fud..[[users u ON u.id=(CASE WHEN s.user_id>2000000000 THEN 1 ELSE s.user_id END)\n"
"			WHERE ses_id=']]..sess..[[']])\n"
"\n"
"		local tab=sql.named(info,1)\n"
"\n"
"		if tab then -- session exists\n"
"		\n"
"			if cgi.ip==tab.sys_id then -- mild security fix, session is locked to ip\n"
"			\n"
"			\n"
"				user.fud=tab\n"
"				\n"
"				if tab.login==\"XIX\" or tab.login==\"shi\" then -- flag admin logins\n"
"					tab.admin=true\n"
"				end\n"
"			\n"
"--	dbg(\"success\")\n"
"	\n"
"			else\n"
"\n"
"				if need then\n"
"					cgi.redirect(redirect)\n"
"				end\n"
"--	dbg(\"fail bad ip \"..cgi.ip..\":\"..tab.sys_id)\n"
"\n"
"			end\n"
"			\n"
"			\n"
"		else -- user does not exist\n"
"		\n"
"--	dbg(\"fail bad sesson\")\n"
"			\n"
"			if need then\n"
"				cgi.redirect(redirect)\n"
"			end\n"
"			\n"
"		end\n"
"\n"
"	else\n"
"	\n"
"		if need then\n"
"			cgi.redirect(redirect)\n"
"		end\n"
"			\n"
"--	dbg(\"fail no session\")\n"
"	\n"
"	end\n"
"	\n"
"	return user\n"
"\n"
"end\n"
"\n"
"\n"
"",

"fenestra.buffedit","\n"
"\n"
"\n"
"local require=require\n"
"\n"
"-- a 1 line buffer edit, how you display it is up to you\n"
"-- has a simple history, just pass in key presses\n"
"-- this is intended for commandline style editing\n"
"\n"
"module(\"fenestra.buffedit\")\n"
"\n"
"local string=require(\"string\")\n"
"local table=require(\"table\")\n"
"\n"
"\n"
"\n"
"function keypress(it,ascii,key,act)\n"
"	\n"
"	if act==\"down\" or act==\"repeat\" then\n"
"	\n"
"		if key==\"left\" then\n"
"\n"
"			it.line_idx=it.line_idx-1\n"
"			if it.line_idx<0 then it.line_idx=0 end\n"
"			\n"
"			it.throb=255\n"
"						\n"
"		elseif key==\"right\" then\n"
"	\n"
"			it.line_idx=it.line_idx+1\n"
"			if it.line_idx>#it.line then it.line_idx=#it.line end\n"
"			\n"
"			it.throb=255\n"
"			\n"
"		elseif key==\"home\" then\n"
"		\n"
"			it.line_idx=0\n"
"		\n"
"		elseif key==\"end\" then\n"
"		\n"
"			it.line_idx=#it.line\n"
"		\n"
"		elseif key==\"backspace\" then\n"
"	\n"
"			if it.line_idx >= #it.line then -- at end\n"
"			\n"
"				it.line=it.line:sub(1,-2)\n"
"				it.line_idx=#it.line\n"
"			\n"
"			elseif it.line_idx == 0 then -- at start\n"
"			\n"
"			elseif it.line_idx == 1 then -- near start\n"
"			\n"
"				it.line=it.line:sub(2)\n"
"				it.line_idx=it.line_idx-1\n"
"			\n"
"			else -- somewhere in the line\n"
"			\n"
"				it.line=it.line:sub(1,it.line_idx-1) .. it.line:sub(it.line_idx+1)\n"
"				it.line_idx=it.line_idx-1\n"
"				\n"
"			end\n"
"			\n"
"			it.throb=255\n"
"			\n"
"		elseif key==\"delete\" then\n"
"	\n"
"			if it.line_idx >= #it.line then -- at end\n"
"			\n"
"\n"
"			elseif it.line_idx == 0 then -- at start\n"
"			\n"
"				it.line=it.line:sub(2)\n"
"				it.line_idx=0\n"
"			\n"
"			else -- somewhere in the line\n"
"			\n"
"				it.line=it.line:sub(1,it.line_idx) .. it.line:sub(it.line_idx+2)\n"
"				it.line_idx=it.line_idx\n"
"				\n"
"			end\n"
"			\n"
"			it.throb=255\n"
"			\n"
"		elseif key==\"enter\" or key==\"return\" then\n"
"		\n"
"			if act==\"down\" then -- ignore repeats on enter key\n"
"			\n"
"				local f=it.line\n"
"--				fenestra._g.print(\">\"..f)\n"
"				\n"
"				table.insert(it.history,it.line)\n"
"				\n"
"				while #it.history > it.history_max do\n"
"					table.remove(it.history,1)\n"
"				end\n"
"		\n"
"				it.history_idx=#it.history+1\n"
"			\n"
"				it.line=\"\"\n"
"				it.line_idx=0\n"
"				\n"
"				if f and it.enter then -- callback?\n"
"				\n"
"					it:enter(f)\n"
"					\n"
"				end\n"
"				\n"
"			end\n"
"			\n"
"		elseif key==\"up\" then\n"
"		\n"
"			it.history_idx=it.history_idx-1\n"
"			if it.history_idx<0 then it.history_idx=#it.history end\n"
"			it.line=it.history[it.history_idx] or \"\"\n"
"			it.line_idx=#it.line\n"
"		\n"
"		elseif key==\"down\" then\n"
"		\n"
"			it.history_idx=it.history_idx+1\n"
"			if it.history_idx>#it.history then it.history_idx=0 end\n"
"			it.line=it.history[it.history_idx] or \"\"\n"
"			it.line_idx=#it.line\n"
"			\n"
"		elseif ascii~=\"\" then -- not a blank string\n"
"			local c=string.byte(ascii)\n"
"			\n"
"			if c>=32 and c<128 then\n"
"			\n"
"				if it.line_idx >= #it.line then -- put at end\n"
"				\n"
"					it.line=it.line..ascii\n"
"					it.line_idx=#it.line\n"
"					\n"
"				elseif it.line_idx == 0 then -- put at start\n"
"				\n"
"					it.line=ascii..it.line\n"
"					it.line_idx=it.line_idx+1\n"
"					\n"
"				else -- need to insert into line\n"
"				\n"
"					it.line=it.line:sub(1,it.line_idx) .. ascii .. it.line:sub(it.line_idx+1)\n"
"					it.line_idx=it.line_idx+1\n"
"					\n"
"				end\n"
"				\n"
"				it.throb=255\n"
"				\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	return true\n"
"\n"
"end\n"
"\n"
"\n"
"function update(it)\n"
"\n"
"	it.throb=it.throb-4\n"
"	if it.throb<0 then it.throb=255 end\n"
"\n"
"end\n"
"\n"
"\n"
"function create()\n"
"\n"
"local it={}\n"
"\n"
"	it.history={}\n"
"	it.history_idx=0\n"
"	it.history_max=64\n"
"	it.line=\"\"\n"
"	it.line_idx=0\n"
"\n"
"	it.throb=255\n"
"	\n"
"	it.keypress=keypress\n"
"	it.update=update\n"
"\n"
"	return it\n"
"end\n"
"",

"wetgenes.cgilua","--\n"
"-- Some cgilua helper functions\n"
"--\n"
"\n"
"local cgi\n"
"local cgilua=cgilua\n"
"\n"
"local string=string\n"
"local table=table\n"
"local math=math\n"
"\n"
"local type=type\n"
"local pairs=pairs\n"
"local setfenv=setfenv\n"
"\n"
"local socket=require(\"socket\")\n"
"local misc=require(\"wetgenes.cgilua.misc\")\n"
"\n"
"module(\"wetgenes.cgilua\")\n"
"cgi=_M -- cgi should point to this module\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- print a debug string somewhere useful\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"dbg=function(s)\n"
"	cgilua.errorlog(s)\n"
"	if not headers_sent then \n"
"		contentheader(\"text\", \"html\")\n"
"	end\n"
"	cgilua.put(s)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- just a copy of some cgilua put\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"put=function(s)\n"
"	cgilua.put(s)\n"
"end\n"
"header=function(a,b)\n"
"	cgilua.header(a,b)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- Set content type and remember headers have been sent\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function contentheader(type, subtype)\n"
"\n"
"	if headers_sent then return end -- so this is safe to call multiple times\n"
"	\n"
"	headers_sent=true -- flag\n"
"	\n"
"	cgilua.contentheader(type, subtype)\n"
"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- redirect\n"
"-- either with headers or throw out some javascript if that is too late\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function redirect(url)\n"
"\n"
"	if headers_sent then\n"
"\n"
"		cgilua.put([[<script type=\"text/javascript\"> window.location = ]]..string.format(\"%q\",url)..[[; </script>]])\n"
"\n"
"	else\n"
"\n"
"		cgilua.redirect(url)\n"
"\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- Build some always useful information about this request\n"
"-- into this module\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function setup() -- call setup once to set global values for this request?\n"
"\n"
"	start_time=socket.gettime()\n"
"	query_count=0\n"
"	\n"
"	math.randomseed( math.floor(start_time*1000) )\n"
"	math.random()\n"
"\n"
"	headers_sent=false\n"
"\n"
"	path=cgilua.servervariable(\"SCRIPT_NAME\")..cgilua.servervariable(\"PATH_INFO\")\n"
"\n"
"	server=cgilua.servervariable(\"SERVER_NAME\")\n"
"\n"
"	query=cgilua.servervariable(\"QUERY_STRING\")\n"
"\n"
"	ip=cgilua.servervariable(\"REMOTE_ADDR\")\n"
"	ipnum=misc.ipstr_to_number(ip)\n"
"\n"
"	url=\"http://\"..server..path\n"
"	url_query=url\n"
"\n"
"	if query and query~=\"\" then url_query=url..\"?\"..query end\n"
"	-- url_query is now probably full if we need to redirect to ourselves (which we often do)\n"
"	\n"
"	slash=misc.str_split(\"/\",url) --  a normally useful array\n"
"\n"
"	-- the lua query/post are dangerous as they may contain tables...\n"
"	-- this creates safe copies that are only strings\n"
"\n"
"	gets={}\n"
"	for i,v in pairs(cgilua.QUERY) do\n"
"		if type(i)==\"string\" and type(v)==\"string\" then -- do not allow tables to break simple code\n"
"			gets[i]=v\n"
"		end\n"
"	end\n"
"\n"
"	posts={}\n"
"	for i,v in pairs(cgilua.POST) do\n"
"		if type(i)==\"string\" and type(v)==\"string\" then -- do not allow tables to break simple code\n"
"			posts[i]=v\n"
"		end\n"
"	end\n"
"\n"
"	json=nil\n"
"	if gets.fmt==\"json\" or posts.fmt==\"json\" then -- a special json request, start building the return\n"
"		json={}\n"
"		json.doups={}\n"
"	end\n"
"	\n"
"	return _M\n"
"end\n"
"",

"wetgenes.bake.pathfix","-- make sure we have the package path setup and working to find everything, this should be made smrtr\n"
"-- i mean you still have to find this file in the first place...\n"
"\n"
"package.path =package.path.. \";../bin/lua/?.lua;../bin/lua/?/init.lua\"\n"
"\n"
"if os.getenv(\"SHELL\") and string.sub(os.getenv(\"SHELL\"),1,5)== \"/bin/\" then\n"
"	package.cpath=package.cpath..\";../bin/exe/?.so\"\n"
"else\n"
"	package.cpath=package.cpath..\";../bin/exe/?.dll\"\n"
"end\n"
"",

"wetgenes.bake.js","\n"
"local require=require\n"
"local loadfile=loadfile\n"
"local setfenv=setfenv\n"
"local pcall=pcall\n"
"local print=print\n"
"local pairs=pairs\n"
"local ipairs=ipairs\n"
"local type=type\n"
"\n"
"local string=string\n"
"local table=table\n"
"local io=io\n"
"local os=os\n"
"\n"
"module(...)\n"
"\n"
"function build(tab)\n"
"\n"
"local bake=require(\"wetgenes.bake\")\n"
"\n"
"local pp=require(\"wetgenes.pp\")\n"
"local lfs=require(\"lfs\")\n"
"\n"
"local no_art=false\n"
"\n"
"local opts=tab.opts or {} -- can pass in an opts of default options\n"
"\n"
"local opts_changed=false\n"
"local func\n"
"\n"
"	opts.VERSION_NUMBER=opts.VERSION_NUMBER or 0\n"
"\n"
"	func=loadfile(\"src/opts.lua\")\n"
"	if func then\n"
"		setfenv(func,opts)\n"
"		pcall(func)\n"
"	else\n"
"		opts_changed=true\n"
"	end\n"
"		\n"
"	for i=1,#tab.arg do\n"
"		\n"
"		if tab.arg[i]==\"bump\" then\n"
"		\n"
"			opts.VERSION_NUMBER=opts.VERSION_NUMBER+0.001\n"
"		\n"
"			opts_changed=true\n"
"		end\n"
"		\n"
"		if tab.arg[i]==\"debug\" then\n"
"		\n"
"			opts.VERSION_BUILD=\"debug\"\n"
"		\n"
"			opts_changed=true\n"
"		end\n"
"		\n"
"		if tab.arg[i]==\"release\" then\n"
"		\n"
"			opts.VERSION_BUILD=\"release\"\n"
"		\n"
"			opts_changed=true\n"
"		end\n"
"		\n"
"		if tab.arg[i]==\"noart\" then\n"
"			no_art=true\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	if opts_changed then -- write out changed file\n"
"		local fp=io.open(\"src/opts.lua\",\"w\")\n"
"		for i,v in pairs(opts) do\n"
"		\n"
"			if type(v)==\"number\" then\n"
"				fp:write(i..\"=\"..v..\"\\n"
"\")\n"
"			elseif type(v)==\"string\" then\n"
"				fp:write(i..\"=\"..string.format(\"%q\",v)..\"\\n"
"\")\n"
"			end\n"
"		end\n"
"		fp:close()\n"
"	end\n"
"	\n"
"	\n"
"	\n"
"	\n"
"-- where we are building from\n"
"bake.cd_base	=	bake.cd_base or bake.get_cd()\n"
"\n"
"-- where we are building to\n"
"bake.cd_out		=	bake.cd_out or 'out'\n"
"\n"
"lfs.mkdir(bake.cd_out)\n"
"lfs.mkdir(bake.cd_out..'/art')\n"
"lfs.mkdir(bake.cd_out..'/cache')\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"-- go up a dir from base cd and remember as main CD for building commands\n"
"\n"
"bake.set_cd(bake.get_cd()..'/..')\n"
"bake.cd=bake.get_cd()\n"
"\n"
"print('cd','=',bake.cd)\n"
"\n"
"\n"
"bake.cmd.java=\"java\" -- needed for minifier\n"
"bake.cmd.zip=\"zip\" -- needed to zip stuffs\n"
"\n"
"bake.cmd.lua		=	bake.path_clean_exe( bake.cd , '/exe/lua' )\n"
"\n"
"if bake.osflavour==\"nix\" then -- expected to be installed...\n"
"--	bake.cmd.mtasc=\"mtasc\"\n"
"--	bake.cmd.swfmill=\"swfmill\"\n"
"end\n"
"\n"
"\n"
"bake.set_cd(bake.cd_base)\n"
"\n"
"bake.files_min_js=bake.files_min_js or {}\n"
"bake.files_min_js[ #bake.files_min_js + 1 ]=tab.name\n"
"\n"
"bake.files_js={}\n"
"for v in lfs.dir(\"src\") do -- add all .js files in the src dir\n"
"	if string.find(v,\"%.js$\") then\n"
"		v=string.gsub( v , \"%.js$\" , \"\")\n"
"		table.insert(bake.files_js,v)\n"
"	end\n"
"end\n"
"\n"
"bake.files_css={}\n"
"for v in lfs.dir(\"src\") do -- add all .css files in the src dir\n"
"	if string.find(v,\"%.css$\") then\n"
"		v=string.gsub( v , \"%.css$\" , \"\")\n"
"		table.insert(bake.files_css,v)\n"
"	end\n"
"end\n"
"\n"
"bake.files_html={}\n"
"for v in lfs.dir(\"src\") do -- and all .html files in the src dir\n"
"	if string.find(v,\"%.html$\") then\n"
"		v=string.gsub( v , \"%.html$\" , \"\")\n"
"		table.insert(bake.files_html,v)\n"
"	end\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"for i,v in ipairs(bake.files_js) do\n"
"	pp.loadsave( 'src/'..v..'.js' , bake.cd_out..'/'..v..'.js' )\n"
"end\n"
"for i,v in ipairs(bake.files_css) do\n"
"	pp.loadsave( 'src/'..v..'.css' , bake.cd_out..'/'..v..'.css' )\n"
"end\n"
"\n"
"for i,v in ipairs(bake.files_html) do\n"
"	pp.loadsave( 'src/'..v..'.html' , bake.cd_out..'/'..v..'.html' )\n"
"end\n"
"\n"
"-- generic pp of files,full paths from -> to\n"
"bake.files_pp=bake.files_pp or {}\n"
"for i,v in ipairs(bake.files_pp) do\n"
"	pp.loadsave( v[1] , v[2] )\n"
"end\n"
"\n"
"\n"
"io.flush()\n"
"\n"
"if no_art then\n"
"print('****')\n"
"print('**SKIPPING**ART**BUILD**STEP**')\n"
"print('****')\n"
"else\n"
"\n"
"\n"
"for i,v in ipairs(bake.files_min_js) do\n"
"print('compressing '..v)\n"
"	bake.execute( bake.cd_base , bake.cmd.java ,\n"
"\"-jar ../../js/class/compiler.jar --js_output_file \"..bake.cd_out..\"/\"..v..\".min.js --js \"..bake.cd_out..\"/\"..v..\".js\")\n"
"\n"
"end\n"
"\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.png$\"}\n"
"	for i,v in ipairs(r.ret) do\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\n"
"	end\n"
"\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.jpg$\"}\n"
"	for i,v in ipairs(r.ret) do\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\n"
"	end\n"
"\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.swf$\"}\n"
"	for i,v in ipairs(r.ret) do\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\n"
"	end\n"
"\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.css$\"}\n"
"	for i,v in ipairs(r.ret) do\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\n"
"	end\n"
"\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.mp3$\"}\n"
"	for i,v in ipairs(r.ret) do\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\n"
"	end\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.ogg$\"}\n"
"	for i,v in ipairs(r.ret) do\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\n"
"	end\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.wav$\"}\n"
"	for i,v in ipairs(r.ret) do\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\n"
"	end\n"
"\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"jslib\",filter=\"%.js$\"}\n"
"	for i,v in ipairs(r.ret) do\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\n"
"	end\n"
"	\n"
"-- build an application cache\n"
"\n"
"	for i,v in ipairs(tab.cache_files or {}) do\n"
"		local v1,v2\n"
"		if type(v)==\"table\" then\n"
"			v1=v[1]\n"
"			v2=v[2]\n"
"		else\n"
"			v1=v\n"
"			v2=v\n"
"		end\n"
"print('caching out/'..v1..\" as \"..v2)\n"
"		bake.create_dir_for_file(bake.cd_out..\"/cache/\"..v2)\n"
"		bake.copyfile(\"out/\"..v1,bake.cd_out..\"/cache/\"..v2)\n"
"	end\n"
"\n"
"	local r=bake.findfiles{basedir=bake.cd_out..\"/cache\",dir=\".\",filter=\"\"}\n"
"	local mc=table.concat(r.ret,\"\\n"
"\")..\"\\n"
"\"\n"
"	local fp=io.open(bake.cd_out..\"/cache/cache.manifest\",\"w\")\n"
"	fp:write(\"CACHE MANIFEST\\n"
"\")\n"
"	fp:write(\"#Updated on \"..os.date()..\"\\n"
"\")\n"
"	fp:write(mc)\n"
"	fp:close()\n"
"	\n"
"-- zip everything in the cache, this is our distribution package\n"
"	bake.execute(bake.cd_out..\"/cache\",bake.cmd.zip,\"../\"..tab.name..\".zip * -r\")\n"
"\n"
"end\n"
"\n"
"\n"
"	\n"
"end\n"
"\n"
"\n"
"\n"
"",

"ltn12","-----------------------------------------------------------------------------\n"
"-- LTN12 - Filters, sources, sinks and pumps.\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: ltn12.lua,v 1.31 2006/04/03 04:45:42 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module\n"
"-----------------------------------------------------------------------------\n"
"local string = require(\"string\")\n"
"local table = require(\"table\")\n"
"local base = _G\n"
"module(\"ltn12\")\n"
"\n"
"filter = {}\n"
"source = {}\n"
"sink = {}\n"
"pump = {}\n"
"\n"
"-- 2048 seems to be better in windows...\n"
"BLOCKSIZE = 2048\n"
"_VERSION = \"LTN12 1.0.1\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Filter stuff\n"
"-----------------------------------------------------------------------------\n"
"-- returns a high level filter that cycles a low-level filter\n"
"function filter.cycle(low, ctx, extra)\n"
"    base.assert(low)\n"
"    return function(chunk)\n"
"        local ret\n"
"        ret, ctx = low(ctx, chunk, extra)\n"
"        return ret\n"
"    end\n"
"end\n"
"\n"
"-- chains a bunch of filters together\n"
"-- (thanks to Wim Couwenberg)\n"
"function filter.chain(...)\n"
"    local n = table.getn(arg)\n"
"    local top, index = 1, 1\n"
"    local retry = \"\"\n"
"    return function(chunk)\n"
"        retry = chunk and retry\n"
"        while true do\n"
"            if index == top then\n"
"                chunk = arg[index](chunk)\n"
"                if chunk == \"\" or top == n then return chunk\n"
"                elseif chunk then index = index + 1\n"
"                else\n"
"                    top = top+1\n"
"                    index = top\n"
"                end\n"
"            else\n"
"                chunk = arg[index](chunk or \"\")\n"
"                if chunk == \"\" then\n"
"                    index = index - 1\n"
"                    chunk = retry\n"
"                elseif chunk then\n"
"                    if index == n then return chunk\n"
"                    else index = index + 1 end\n"
"                else base.error(\"filter returned inappropriate nil\") end\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Source stuff\n"
"-----------------------------------------------------------------------------\n"
"-- create an empty source\n"
"local function empty()\n"
"    return nil\n"
"end\n"
"\n"
"function source.empty()\n"
"    return empty\n"
"end\n"
"\n"
"-- returns a source that just outputs an error\n"
"function source.error(err)\n"
"    return function()\n"
"        return nil, err\n"
"    end\n"
"end\n"
"\n"
"-- creates a file source\n"
"function source.file(handle, io_err)\n"
"    if handle then\n"
"        return function()\n"
"            local chunk = handle:read(BLOCKSIZE)\n"
"            if not chunk then handle:close() end\n"
"            return chunk\n"
"        end\n"
"    else return source.error(io_err or \"unable to open file\") end\n"
"end\n"
"\n"
"-- turns a fancy source into a simple source\n"
"function source.simplify(src)\n"
"    base.assert(src)\n"
"    return function()\n"
"        local chunk, err_or_new = src()\n"
"        src = err_or_new or src\n"
"        if not chunk then return nil, err_or_new\n"
"        else return chunk end\n"
"    end\n"
"end\n"
"\n"
"-- creates string source\n"
"function source.string(s)\n"
"    if s then\n"
"        local i = 1\n"
"        return function()\n"
"            local chunk = string.sub(s, i, i+BLOCKSIZE-1)\n"
"            i = i + BLOCKSIZE\n"
"            if chunk ~= \"\" then return chunk\n"
"            else return nil end\n"
"        end\n"
"    else return source.empty() end\n"
"end\n"
"\n"
"-- creates rewindable source\n"
"function source.rewind(src)\n"
"    base.assert(src)\n"
"    local t = {}\n"
"    return function(chunk)\n"
"        if not chunk then\n"
"            chunk = table.remove(t)\n"
"            if not chunk then return src()\n"
"            else return chunk end\n"
"        else\n"
"            table.insert(t, chunk)\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function source.chain(src, f)\n"
"    base.assert(src and f)\n"
"    local last_in, last_out = \"\", \"\"\n"
"    local state = \"feeding\"\n"
"    local err\n"
"    return function()\n"
"        if not last_out then\n"
"            base.error('source is empty!', 2)\n"
"        end\n"
"        while true do\n"
"            if state == \"feeding\" then\n"
"                last_in, err = src()\n"
"                if err then return nil, err end\n"
"                last_out = f(last_in)\n"
"                if not last_out then\n"
"                    if last_in then\n"
"                        base.error('filter returned inappropriate nil')\n"
"                    else\n"
"                        return nil\n"
"                    end\n"
"                elseif last_out ~= \"\" then\n"
"                    state = \"eating\"\n"
"                    if last_in then last_in = \"\" end\n"
"                    return last_out\n"
"                end\n"
"            else\n"
"                last_out = f(last_in)\n"
"                if last_out == \"\" then\n"
"                    if last_in == \"\" then\n"
"                        state = \"feeding\"\n"
"                    else\n"
"                        base.error('filter returned \"\"')\n"
"                    end\n"
"                elseif not last_out then\n"
"                    if last_in then\n"
"                        base.error('filter returned inappropriate nil')\n"
"                    else\n"
"                        return nil\n"
"                    end\n"
"                else\n"
"                    return last_out\n"
"                end\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-- creates a source that produces contents of several sources, one after the\n"
"-- other, as if they were concatenated\n"
"-- (thanks to Wim Couwenberg)\n"
"function source.cat(...)\n"
"    local src = table.remove(arg, 1)\n"
"    return function()\n"
"        while src do\n"
"            local chunk, err = src()\n"
"            if chunk then return chunk end\n"
"            if err then return nil, err end\n"
"            src = table.remove(arg, 1)\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Sink stuff\n"
"-----------------------------------------------------------------------------\n"
"-- creates a sink that stores into a table\n"
"function sink.table(t)\n"
"    t = t or {}\n"
"    local f = function(chunk, err)\n"
"        if chunk then table.insert(t, chunk) end\n"
"        return 1\n"
"    end\n"
"    return f, t\n"
"end\n"
"\n"
"-- turns a fancy sink into a simple sink\n"
"function sink.simplify(snk)\n"
"    base.assert(snk)\n"
"    return function(chunk, err)\n"
"        local ret, err_or_new = snk(chunk, err)\n"
"        if not ret then return nil, err_or_new end\n"
"        snk = err_or_new or snk\n"
"        return 1\n"
"    end\n"
"end\n"
"\n"
"-- creates a file sink\n"
"function sink.file(handle, io_err)\n"
"    if handle then\n"
"        return function(chunk, err)\n"
"            if not chunk then\n"
"                handle:close()\n"
"                return 1\n"
"            else return handle:write(chunk) end\n"
"        end\n"
"    else return sink.error(io_err or \"unable to open file\") end\n"
"end\n"
"\n"
"-- creates a sink that discards data\n"
"local function null()\n"
"    return 1\n"
"end\n"
"\n"
"function sink.null()\n"
"    return null\n"
"end\n"
"\n"
"-- creates a sink that just returns an error\n"
"function sink.error(err)\n"
"    return function()\n"
"        return nil, err\n"
"    end\n"
"end\n"
"\n"
"-- chains a sink with a filter\n"
"function sink.chain(f, snk)\n"
"    base.assert(f and snk)\n"
"    return function(chunk, err)\n"
"        if chunk ~= \"\" then\n"
"            local filtered = f(chunk)\n"
"            local done = chunk and \"\"\n"
"            while true do\n"
"                local ret, snkerr = snk(filtered, err)\n"
"                if not ret then return nil, snkerr end\n"
"                if filtered == done then return 1 end\n"
"                filtered = f(done)\n"
"            end\n"
"        else return 1 end\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Pump stuff\n"
"-----------------------------------------------------------------------------\n"
"-- pumps one chunk from the source to the sink\n"
"function pump.step(src, snk)\n"
"    local chunk, src_err = src()\n"
"    local ret, snk_err = snk(chunk, src_err)\n"
"    if chunk and ret then return 1\n"
"    else return nil, src_err or snk_err end\n"
"end\n"
"\n"
"-- pumps all data from a source to a sink, using a step function\n"
"function pump.all(src, snk, step)\n"
"    base.assert(src and snk)\n"
"    step = step or pump.step\n"
"    while true do\n"
"        local ret, err = step(src, snk)\n"
"        if not ret then\n"
"            if err then return nil, err\n"
"            else return 1 end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"",

"socket.tp","-----------------------------------------------------------------------------\n"
"-- Unified SMTP/FTP subsystem\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: tp.lua,v 1.22 2006/03/14 09:04:15 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local string = require(\"string\")\n"
"local socket = require(\"socket\")\n"
"local ltn12 = require(\"ltn12\")\n"
"module(\"socket.tp\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Program constants\n"
"-----------------------------------------------------------------------------\n"
"TIMEOUT = 60\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Implementation\n"
"-----------------------------------------------------------------------------\n"
"-- gets server reply (works for SMTP and FTP)\n"
"local function get_reply(c)\n"
"    local code, current, sep\n"
"    local line, err = c:receive()\n"
"    local reply = line\n"
"    if err then return nil, err end\n"
"    code, sep = socket.skip(2, string.find(line, \"^(%d%d%d)(.?)\"))\n"
"    if not code then return nil, \"invalid server reply\" end\n"
"    if sep == \"-\" then -- reply is multiline\n"
"        repeat\n"
"            line, err = c:receive()\n"
"            if err then return nil, err end\n"
"            current, sep = socket.skip(2, string.find(line, \"^(%d%d%d)(.?)\"))\n"
"            reply = reply .. \"\\n"
"\" .. line\n"
"        -- reply ends with same code\n"
"        until code == current and sep == \" \"\n"
"    end\n"
"    return code, reply\n"
"end\n"
"\n"
"-- metatable for sock object\n"
"local metat = { __index = {} }\n"
"\n"
"function metat.__index:check(ok)\n"
"    local code, reply = get_reply(self.c)\n"
"    if not code then return nil, reply end\n"
"    if base.type(ok) ~= \"function\" then\n"
"        if base.type(ok) == \"table\" then\n"
"            for i, v in base.ipairs(ok) do\n"
"                if string.find(code, v) then\n"
"                    return base.tonumber(code), reply\n"
"                end\n"
"            end\n"
"            return nil, reply\n"
"        else\n"
"            if string.find(code, ok) then return base.tonumber(code), reply\n"
"            else return nil, reply end\n"
"        end\n"
"    else return ok(base.tonumber(code), reply) end\n"
"end\n"
"\n"
"function metat.__index:command(cmd, arg)\n"
"    if arg then\n"
"        return self.c:send(cmd .. \" \" .. arg.. \"\\r\\n"
"\")\n"
"    else\n"
"        return self.c:send(cmd .. \"\\r\\n"
"\")\n"
"    end\n"
"end\n"
"\n"
"function metat.__index:sink(snk, pat)\n"
"    local chunk, err = c:receive(pat)\n"
"    return snk(chunk, err)\n"
"end\n"
"\n"
"function metat.__index:send(data)\n"
"    return self.c:send(data)\n"
"end\n"
"\n"
"function metat.__index:receive(pat)\n"
"    return self.c:receive(pat)\n"
"end\n"
"\n"
"function metat.__index:getfd()\n"
"    return self.c:getfd()\n"
"end\n"
"\n"
"function metat.__index:dirty()\n"
"    return self.c:dirty()\n"
"end\n"
"\n"
"function metat.__index:getcontrol()\n"
"    return self.c\n"
"end\n"
"\n"
"function metat.__index:source(source, step)\n"
"    local sink = socket.sink(\"keep-open\", self.c)\n"
"    local ret, err = ltn12.pump.all(source, sink, step or ltn12.pump.step)\n"
"    return ret, err\n"
"end\n"
"\n"
"-- closes the underlying c\n"
"function metat.__index:close()\n"
"    self.c:close()\n"
"	return 1\n"
"end\n"
"\n"
"-- connect with server and return c object\n"
"function connect(host, port, timeout, create)\n"
"    local c, e = (create or socket.tcp)()\n"
"    if not c then return nil, e end\n"
"    c:settimeout(timeout or TIMEOUT)\n"
"    local r, e = c:connect(host, port)\n"
"    if not r then\n"
"        c:close()\n"
"        return nil, e\n"
"    end\n"
"    return base.setmetatable({c = c}, metat)\n"
"end\n"
"\n"
"",

"fenestra.widget.file","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"-- a scrolling area, the widget is biger than display area but scroll bars allow you to see it all\n"
"\n"
"\n"
"\n"
"module(\"fenestra.widget.file\")\n"
"\n"
"\n"
"function mouse(widget,act,x,y,key)\n"
"	return widget.meta.mouse(widget,act,x,y,key)\n"
"end\n"
"\n"
"\n"
"function key(widget,ascii,key,act)\n"
"	return widget.meta.key(widget,ascii,key,act)\n"
"end\n"
"\n"
"\n"
"function update(widget)\n"
"	return widget.meta.update(widget)\n"
"end\n"
"\n"
"function draw(widget)\n"
"	return widget.meta.draw(widget)\n"
"end\n"
"\n"
"function setup(widget,def)\n"
"	widget.class=\"file\"\n"
"	\n"
"	widget.key=key\n"
"	widget.mouse=mouse\n"
"	widget.update=update\n"
"	widget.draw=draw\n"
"\n"
"-- auto add the draging button as a child\n"
"--[[\n"
"	local ss=16\n"
"	if widget.hx<ss*2 then ss=widget.hx/2 end\n"
"	if widget.hy<ss*2 then ss=widget.hy/2 end\n"
"	\n"
"	widget.pan=		widget:add({class=\"pan\",	hx=widget.hx-ss,	hy=widget.hy-ss,	})\n"
"	widget.slidey=	widget:add({class=\"slide\",	hx=ss,				hy=widget.hy-ss,	px=widget.hx-ss,	py=0,\n"
"		datx={max=0},daty={max=1},color=0xffffffff})\n"
"	widget.slidex=	widget:add({class=\"slide\",	hx=widget.hx-ss,	hy=ss,           	px=0,           	py=widget.hy-ss,\n"
"		datx={max=1},daty={max=0},color=0xffffffff})\n"
"]]\n"
"	return widget\n"
"end\n"
"",

"wetgenes.bake.gamecake","\n"
"local require=require\n"
"\n"
"local ipairs=ipairs\n"
"\n"
"module(...)\n"
"\n"
"function build(tab)\n"
"\n"
"	local bake=require(\"wetgenes.bake\")\n"
"	local bakejs=require(\"wetgenes.bake.js\")\n"
"\n"
"	-- where we are building from\n"
"	bake.cd_base	=	bake.cd_base or bake.get_cd()\n"
"	-- where we are building to\n"
"	bake.cd_out		=	bake.cd_out or 'out'\n"
"\n"
"	bake.files_min_js=bake.files_min_js or {}\n"
"	bake.files_min_js[ #bake.files_min_js + 1 ]=\"gamecake\"\n"
"\n"
"	local files_gamecake={}\n"
"	local r=bake.findfiles{basedir=\"../../js/gamecake/src\",dir=\"\",filter=\"%.js$\"}\n"
"	for i,v in ipairs(r.ret) do\n"
"		files_gamecake[#files_gamecake+1]=v\n"
"		bake.create_dir_for_file(bake.cd_out..\"/js/gamecake/\"..v)\n"
"	end\n"
"\n"
"	bake.files_pp=bake.files_pp or {}\n"
"	for i,v in ipairs(files_gamecake) do\n"
"		bake.files_pp[ #bake.files_pp +1]={ \"../../js/gamecake/src\"..v , bake.cd_out..'/js/gamecake'..v }\n"
"	end\n"
"\n"
"	local r=bake.findfiles{basedir=\"../../js/gamecake/jslib\",dir=\"\",filter=\"%.js$\"}\n"
"	for i,v in ipairs(r.ret) do\n"
"		bake.create_dir_for_file(bake.cd_out..\"/jslib\"..v)\n"
"		bake.copyfile(\"../../js/gamecake/jslib\"..v,bake.cd_out..\"/jslib\"..v)\n"
"	end\n"
"\n"
"	local r=bake.findfiles{basedir=\"../../js/gamecake/art\",dir=\"\",filter=\"%.swf$\"}\n"
"	for i,v in ipairs(r.ret) do\n"
"		bake.create_dir_for_file(bake.cd_out..\"/art\"..v)\n"
"		bake.copyfile(\"../../js/gamecake/art\"..v,bake.cd_out..\"/art\"..v)\n"
"	end\n"
"\n"
"-- the main action happens here\n"
"	bakejs.build(tab)\n"
"\n"
"end\n"
"",

"wetgenes.bake","--+-----------------------------------------------------------------------------------------------------------------+--\n"
"--\n"
"-- (C) Kriss Daniels 2005 http://www.XIXs.com\n"
"--\n"
"-- This file made available under the terms of The MIT License : http://www.opensource.org/licenses/mit-license.php\n"
"--\n"
"-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n"
"--\n"
"-- The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n"
"--\n"
"-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
"--\n"
"--+-----------------------------------------------------------------------------------------------------------------+--\n"
"\n"
"\n"
"--\n"
"-- A thrown together build toool, well some useful lua functions for making a build.\n"
"--\n"
"-- The intent is to optimise a fullbuild rather than a partial build,\n"
"--\n"
"-- it is the times you have to rebuild everything that causes you to go make a cup of tea, after all.\n"
"--\n"
"-- This is exceptionally true of windows where process creation has a huge overhead\n"
"--\n"
"-- Hopefully things are kept shrinkwrapped enough here to enable an easy unixy port when I need it (theywoz)\n"
"--\n"
"\n"
"local lfs=require(\"lfs\")\n"
"local table=table\n"
"local string=string\n"
"local os=os\n"
"local io=io\n"
"local print=print\n"
"\n"
"local ipairs=ipairs\n"
"\n"
"\n"
"module(\"wetgenes.bake\")\n"
"\n"
"osflavour=\"win\"\n"
"	\n"
"local os_shell=os.getenv(\"SHELL\")\n"
"if os_shell and string.sub(os_shell,1,5)== \"/bin/\" then\n"
"	osflavour=\"nix\"\n"
"end\n"
"\n"
"-- fullpaths to usefull commands\n"
"\n"
"cmd={}\n"
"\n"
"\n"
"-- place to store options\n"
"\n"
"opt={}\n"
"\n"
"\n"
"\n"
"\n"
"--\n"
"-- get/set current dir\n"
"--\n"
"get_cd=function()\n"
"\n"
"	return string.gsub(lfs.currentdir(),'\\\\','/')\n"
"\n"
"end\n"
"set_cd=function(str)\n"
"\n"
"	lfs.chdir(str)\n"
"\n"
"end\n"
"\n"
"\n"
"--\n"
"-- combine strings and resolve . or .. and cancel out multiple // and switch \\ to /\n"
"-- so we should end up with a valid clean path\n"
"--\n"
"path_clean=function(...)\n"
"\n"
"local str\n"
"\n"
"	str=table.concat({...})\n"
"	str=string.gsub(str,'\\\\','/')\n"
"\n"
"	return(str)\n"
"\n"
"end\n"
"\n"
"--\n"
"-- as path_clean but add .exe (so we can easily not do this later if under unix)\n"
"--\n"
"path_clean_exe=function(...)\n"
"\n"
"if osflavour==\"nix\" then\n"
"	return(path_clean(...))\n"
"else\n"
"	return(path_clean(...)..'.exe')\n"
"end\n"
"\n"
"end\n"
"\n"
"\n"
"--\n"
"-- return the substring after the last .\n"
"--\n"
"path_ext=function(str)\n"
"\n"
"	return(str)\n"
"\n"
"end\n"
"\n"
"--\n"
"-- perform some substitutions and then execute the command from the given cwd\n"
"--\n"
"execute=function(cwd,cmd,arg)\n"
"\n"
"	if cwd then\n"
"	\n"
"		lfs.chdir(cwd)\n"
"	\n"
"	end\n"
"	\n"
"	if arg then\n"
"	\n"
"		os.execute(cmd..' '..arg)\n"
"		\n"
"	else\n"
"	\n"
"		os.execute(cmd)\n"
"\n"
"	end\n"
"\n"
"end\n"
"\n"
"--\n"
"-- Copy a file from one location to another\n"
"--\n"
"copyfile=function(f,t)\n"
"\n"
"local fpr=io.open(f,\"rb\")\n"
"local d=fpr:read(\"*a\")\n"
"local fpw=io.open(t,\"wb\")\n"
"\n"
"	fpw:write(d)\n"
"	fpr:close()\n"
"	fpw:close()\n"
"end\n"
"\n"
"\n"
"--\n"
"-- given a filename make sure that its containing directory exists\n"
"--\n"
"create_dir_for_file=function(n)\n"
"	local t={}\n"
"	for w in string.gmatch(n, \"[^/]+\") do t[#t+1]=w end\n"
"	local s=\"\"\n"
"	t[#t]=nil -- remove the filename\n"
"	for i,v in ipairs(t) do\n"
"		s=s..v\n"
"		lfs.mkdir(s)\n"
"		s=s..\"/\"\n"
"	end\n"
"end\n"
"\n"
"--\n"
"-- get the filenames (relative to the basedir) of all files matching the filter\n"
"--\n"
"findfiles=function(opts)\n"
"if not opts then return end\n"
"if not opts.basedir then return end\n"
"if not opts.dir then return end\n"
"if not opts.filter then return end\n"
"opts.ret=opts.ret or {}\n"
"\n"
"	local subdirs={}\n"
"	local d=opts.basedir..\"/\"..opts.dir\n"
"	for v in lfs.dir(d) do\n"
"		local a=lfs.attributes(d..\"/\"..v)\n"
"--print(\"test\",v,a.mode)\n"
"		if a.mode==\"file\" then\n"
"			if string.find(v,opts.filter) then\n"
"--print(\"found\",v)\n"
"				opts.ret[#opts.ret+1]=opts.dir..\"/\"..v\n"
"			end\n"
"		end\n"
"		if a.mode==\"directory\" then\n"
"			if v:sub(1,1)~=\".\" then\n"
"				subdirs[#subdirs+1]=v\n"
"			end\n"
"		end\n"
"	end\n"
"\n"
"-- recurse\n"
"	local dir=opts.dir\n"
"	for i,v in ipairs(subdirs) do\n"
"		opts.dir=dir..\"/\"..v\n"
"		findfiles(opts)\n"
"	end\n"
"\n"
"	return opts\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"",

"socket","-----------------------------------------------------------------------------\n"
"-- LuaSocket helper module\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: socket.lua,v 1.22 2005/11/22 08:33:29 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local string = require(\"string\")\n"
"local math = require(\"math\")\n"
"local socket = require(\"socket.core\")\n"
"module(\"socket\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Exported auxiliar functions\n"
"-----------------------------------------------------------------------------\n"
"function connect(address, port, laddress, lport)\n"
"    local sock, err = socket.tcp()\n"
"    if not sock then return nil, err end\n"
"    if laddress then\n"
"        local res, err = sock:bind(laddress, lport, -1)\n"
"        if not res then return nil, err end\n"
"    end\n"
"    local res, err = sock:connect(address, port)\n"
"    if not res then return nil, err end\n"
"    return sock\n"
"end\n"
"\n"
"function bind(host, port, backlog)\n"
"    local sock, err = socket.tcp()\n"
"    if not sock then return nil, err end\n"
"    sock:setoption(\"reuseaddr\", true)\n"
"    local res, err = sock:bind(host, port)\n"
"    if not res then return nil, err end\n"
"    res, err = sock:listen(backlog)\n"
"    if not res then return nil, err end\n"
"    return sock\n"
"end\n"
"\n"
"try = newtry()\n"
"\n"
"function choose(table)\n"
"    return function(name, opt1, opt2)\n"
"        if base.type(name) ~= \"string\" then\n"
"            name, opt1, opt2 = \"default\", name, opt1\n"
"        end\n"
"        local f = table[name or \"nil\"]\n"
"        if not f then base.error(\"unknown key (\".. base.tostring(name) ..\")\", 3)\n"
"        else return f(opt1, opt2) end\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Socket sources and sinks, conforming to LTN12\n"
"-----------------------------------------------------------------------------\n"
"-- create namespaces inside LuaSocket namespace\n"
"sourcet = {}\n"
"sinkt = {}\n"
"\n"
"BLOCKSIZE = 2048\n"
"\n"
"sinkt[\"close-when-done\"] = function(sock)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function(self, chunk, err)\n"
"            if not chunk then\n"
"                sock:close()\n"
"                return 1\n"
"            else return sock:send(chunk) end\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"sinkt[\"keep-open\"] = function(sock)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function(self, chunk, err)\n"
"            if chunk then return sock:send(chunk)\n"
"            else return 1 end\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"sinkt[\"default\"] = sinkt[\"keep-open\"]\n"
"\n"
"sink = choose(sinkt)\n"
"\n"
"sourcet[\"by-length\"] = function(sock, length)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function()\n"
"            if length <= 0 then return nil end\n"
"            local size = math.min(socket.BLOCKSIZE, length)\n"
"            local chunk, err = sock:receive(size)\n"
"            if err then return nil, err end\n"
"            length = length - string.len(chunk)\n"
"            return chunk\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"sourcet[\"until-closed\"] = function(sock)\n"
"    local done\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function()\n"
"            if done then return nil end\n"
"            local chunk, err, partial = sock:receive(socket.BLOCKSIZE)\n"
"            if not err then return chunk\n"
"            elseif err == \"closed\" then\n"
"                sock:close()\n"
"                done = 1\n"
"                return partial\n"
"            else return nil, err end\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"\n"
"sourcet[\"default\"] = sourcet[\"until-closed\"]\n"
"\n"
"source = choose(sourcet)\n"
"\n"
"",

"wetgenes.waka","\n"
"--\n"
"-- a waka is made of chunks\n"
"-- chunks are made of text that contains links\n"
"-- a word that begins with / or http: is a link\n"
"-- there is no waka markup, if you want markup then use xhtml\n"
"--\n"
"\n"
"local table=table\n"
"local string=string\n"
"\n"
"\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"\n"
"local string=string\n"
"local type=type\n"
"local tostring=tostring\n"
"\n"
"local require=require\n"
"local loadstring=loadstring\n"
"local setfenv=setfenv\n"
"local pcall=pcall\n"
"\n"
"-- my string functions\n"
"local str=require(\"wetgenes.string\")\n"
"local sbox=require(\"wetgenes.sandbox\")\n"
"\n"
"\n"
"module(\"wetgenes.waka\")\n"
"\n"
"local split_lines		=str.split_lines\n"
"local split_words		=str.split_words\n"
"local split_whitespace	=str.split_whitespace\n"
"local split_equal		=str.split_equal\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- turn a string into a tag array\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function text_to_tags(text)\n"
"	local r={}\n"
"	\n"
"	if text then\n"
"		if string.find(text,\",\") then -- coma seperated\n"
"			local a=split_words(text,\",\")\n"
"			for i,v in ipairs(a) do\n"
"				local s=str.trim(v)\n"
"				if #s>0 then r[s]=true end\n"
"			end\n"
"		else -- white space seperated\n"
"			local a=split_words(text)\n"
"			for i,v in ipairs(a) do\n"
"				local s=str.trim(v)\n"
"				if #s>0 then r[s]=true end\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	return r\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- take some text and break it into named chunks\n"
"-- returns a lookup table of chunks and numerical list of these chunks in the order they where first defined\n"
"-- body is the default chunk name\n"
"--\n"
"-- a chunk is a line that begins with #\n"
"-- the part after the # and ending with whitespace is the chunk name\n"
"-- all text following this line is part of that chunk\n"
"-- the default section if none is give is \"body\", so any whitespace at the start of the file\n"
"-- before the first # line will be assigned to this chunk\n"
"-- data may follow this chunk name, if multiple chunks of the same name\n"
"-- are defined they are simple merged into one\n"
"-- and each #chunk line is combined into one chunk data\n"
"--\n"
"-- use option=value after the section name to provide options, so somthing like this\n"
"--\n"
"-- #name opt=val opt=val opt=val\n"
"-- # opt=val\n"
"-- here is some text\n"
"-- # opt=val\n"
"-- here is some more text\n"
"-- ## special comment, this line is ignored\n"
"-- ## comments are just a line that begins with two hashes\n"
"--\n"
"-- is a valid chunk, all of the opt=val will be assigned to the same chunk\n"
"-- and all the other text will be joined as that chunks body\n"
"--\n"
"-- pass in chunks and you can merge multiple texts into one chunk\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function text_to_chunks(text,chunks)\n"
"\n"
"local chunkend -- special end of chunk test\n"
"\n"
"	chunks=chunks or {}\n"
"\n"
"	local function manifest_chunk(line,oldchunk)\n"
"		local opts=split_words( line:sub(2) ) -- skip # at start of line\n"
"		local name=string.lower( opts[1] or \"body\" )\n"
"		local chunk\n"
"		local c2=line:sub(2,2)\n"
"				\n"
"		if c2:find(\"%s\") then -- if first char after # is whitespace, then use the old chunk \n"
"			chunk=oldchunk\n"
"		end\n"
"		\n"
"		if not chunk then\n"
"			chunk=chunks[name] -- do we already have this chunk?\n"
"		end\n"
"		\n"
"		if chunk then -- update an old chunk\n"
"		\n"
"			for i=1,#opts do local v=opts[i]\n"
"				table.insert( chunk.opts , v ) -- add extra opts\n"
"				local a,b=split_equal(v)\n"
"				if a then chunk.opts[a]=b end\n"
"			end\n"
"			\n"
"		else -- create a new chunk\n"
"		\n"
"			chunk={} -- make default chunk\n"
"\n"
"-- set some default options depending on the chunk name\n"
"\n"
"			if name:sub(1,4)==\"body\" then -- all chunks begining with \"body\" are waka format by default\n"
"				opts.form=\"waka\"\n"
"			end\n"
"\n"
"			if name:sub(1,5)==\"title\" then -- all chunks begining with \"title\" are trimed by default\n"
"				opts.trim=\"ends\"\n"
"			end\n"
"\n"
"			if name:sub(1,3)==\"css\" then -- all chunks begining with \"css\" append children by default\n"
"				opts.append=\"on\"\n"
"			end\n"
"		\n"
"			if name:sub(1,3)==\"lua\" then -- all chunks begining with \"lua\" are lua code by default\n"
"				opts.form=\"lua\"\n"
"			end\n"
"			\n"
"-- the actual options will overide the defaults\n"
"\n"
"			for i=1,#opts do local v=opts[i]\n"
"				local a,b=split_equal(v)\n"
"				if a then opts[a]=b end\n"
"			end\n"
"			\n"
"			chunk.id=#chunks+1\n"
"			chunk.name=name\n"
"			chunk.opts=opts\n"
"			chunk.lines={}\n"
"			\n"
"			chunks[chunk.id]=chunk		-- save chunk in chunks as numbered id\n"
"			chunks[chunk.name]=chunk	-- and as name\n"
"		end\n"
"		\n"
"		return chunk\n"
"	end\n"
"		\n"
"	local lines=split_lines(text)\n"
"	\n"
"	local chunk\n"
"	\n"
"	for i=1,#lines do local v=lines[i] -- ipairs\n"
"		\n"
"		local c=v:sub(1,1) -- the first char is special\n"
"		\n"
"		if c==\"#\" then -- start of chunk\n"
"		\n"
"			if chunkend then -- waiting for special end everything is inserted\n"
"			\n"
"				if chunkend==v:sub(1,#chunkend) then -- got it\n"
"					chunkend=nil\n"
"				else\n"
"					if not chunk then chunk=manifest_chunk(\"#body\") end --sanity				\n"
"					table.insert(chunk.lines , v)\n"
"				end\n"
"				\n"
"			else\n"
"\n"
"				if \"#[[\"==v:sub(1,3) then -- special open\n"
"				\n"
"					chunkend=\"#]]\"..v:sub(4) -- any special hash we need to close\n"
"				\n"
"				elseif v:sub(2,2)~=\"#\" then -- skip all comments\n"
"\n"
"					chunk=manifest_chunk(v,chunk)\n"
"\n"
"				end\n"
"				\n"
"			end\n"
"			\n"
"		else -- normal lime add to the current chunk\n"
"		\n"
"			if not chunk then chunk=manifest_chunk(\"#body\") end --sanity\n"
"			\n"
"			table.insert(chunk.lines , v)\n"
"		end\n"
"	\n"
"	end\n"
"	\n"
"	for i=1,#chunks do local v=chunks[i] -- perform some final actions on all chunks\n"
"	\n"
"		v.text=table.concat(v.lines) -- merge the split lines back together into one string\n"
"		\n"
"	end\n"
"	\n"
"	return chunks\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- merge source data into dest data, dest data may be nil in which case this \n"
"-- works like a copy. Return the dest chunk. It is intended that you have a\n"
"-- a number of chunks and then merge them together into a final data chunk\n"
"-- using this function, the first merge creates a new dest chunk. the final result\n"
"-- will have a new ordering depending on the merged chunks but the numerical array\n"
"-- can still be used to loop through chunks\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function chunks_merge(dest,source)\n"
"\n"
"	local dest=dest or {}\n"
"	\n"
"	local locked=dest.opts and dest.opts.opts.lock==\"on\" -- parent chunk locked\n"
"			\n"
"	for i,v in ipairs(source) do\n"
"	\n"
"		local c=dest[v.name] -- merge or\n"
"		\n"
"		local function set_data()\n"
"			if c.opts.append==\"on\" then -- add new lines to the end of the chunk rather than replace\n"
"				c.text=(c.text or \"\") .. ( v.text or \"\" )\n"
"				c.lines=split_lines(c.text) -- also need to build lines?\n"
"			else -- just replace\n"
"				c.lines=v.lines -- set or override\n"
"				c.text=v.text -- set or override\n"
"			end\n"
"			for ii,vv in pairs(v.opts) do\n"
"				c.opts[ii]=vv\n"
"			end\n"
"		end\n"
"		\n"
"		if not c then -- make a new chunk\n"
"			c={}\n"
"			c.id=#dest+1\n"
"			c.name=v.name\n"
"			c.opts={}\n"
"			dest[c.id]=c -- link it into dest by array\n"
"			dest[c.name]=c -- and by name\n"
"			\n"
"			set_data()\n"
"		else\n"
"			if not locked then -- skip lock\n"
"				set_data()\n"
"			end\n"
"		end\n"
"\n"
"	end\n"
"\n"
"	return dest\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get a html given some simple waka text\n"
"--\n"
"-- \\n"
" are turned into <br/> tags\n"
"-- and words that look like links are turned into links\n"
"-- any included html should get escaped so this is \"safe\" to use on user input\n"
"--\n"
"-- aditional opts\n"
"--\n"
"-- we need to know the base_url of this page when building links, if this is not given\n"
"-- then relative links may bork?\n"
"--\n"
"-- setting escape_html to true prevents any html from getting through\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function waka_to_html(input,opts)\n"
"	opts=opts or {}\n"
"\n"
"local base_url=opts.base_url or \"\"\n"
"local escape_html=opts.escape_html or false\n"
"\n"
"	local r={}\n"
"	local esc\n"
"	if escape_html then -- simple html escape\n"
"		esc=function(s) \n"
"			local escaped = { ['<']='&lt;', ['>']='&gt;', [\"&\"]='&amp;' , [\"\\n"
"\"]='<br/>\\n"
"' }\n"
"			return (s:gsub(\"[<>&\\n"
"]\", function(c) return escaped[c] or c end))\n"
"		end\n"
"	else -- no escape just convert \\n"
" to <br/>\n"
"		esc=function(s) \n"
"			local escaped = { [\"\\n"
"\"]='<br/>\\n"
"' }\n"
"			return (s:gsub(\"[\\n"
"]\", function(c) return escaped[c] or c end))\n"
"		end\n"
"	end\n"
"	\n"
"	local function link( url , str )\n"
"		table.insert(r,\"<a href=\\\"\"..url..\"\\\">\"..esc(str)..\"</a>\")\n"
"	end\n"
"	local function text( str )\n"
"		table.insert(r,esc(str))\n"
"	end\n"
"\n"
"	local tokens=split_whitespace(input)\n"
"	\n"
"	for i2=1,#tokens do local token=tokens[i2]\n"
"	\n"
"		local done=false\n"
"		\n"
"		local len=token:len()\n"
"		\n"
"		if len>=2 then -- too short to be a link\n"
"		\n"
"			local c1=token:sub(1,1) -- some chars to check\n"
"			\n"
"			if c1 == \"/\" then -- a very simple link relative to where we are\n"
"			\n"
"				local chars=\"[%w/%-%+_#%.:]+\"\n"
"				\n"
"--				if token:sub(1,3)==\"///\" then chars=\"[%w/%-%+_#%.:]+\" end -- allow common domain chars\n"
"			\n"
"				local s=token:sub(2) -- skip this first char\n"
"				\n"
"				local f1,f2=s:find(chars)\n"
"				if f1 then -- must find a word\n"
"					local s1=s:sub(f1,f2)\n"
"					if s1:sub(-1)==\".\" then -- trim trailing dot\n"
"						f2=f2-1\n"
"						s1=s:sub(f1,f2)\n"
"					end\n"
"					local ss=split_words(s1,\"/\")\n"
"					local tail=ss[#ss] \n"
"					link(s1,tail or s1)\n"
"					if f2<s:len() then -- some left over string\n"
"						text(s:sub(f2+1))\n"
"					end\n"
"					done=true\n"
"				end\n"
"				\n"
"			elseif token:sub(1,7)==\"http://\" then\n"
"					link(token,token)\n"
"					done=true\n"
"\n"
"			elseif token:sub(1,8)==\"https://\" then\n"
"					link(token,token)\n"
"					done=true\n"
"			end\n"
"			\n"
"		end\n"
"		\n"
"		\n"
"		if not done then -- unhandled token, just add it\n"
"			text(token)				\n"
"		end\n"
"	\n"
"	end\n"
"	\n"
"	return table.concat(r)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- turn some chunks into their prefered form, escape, trim and expand\n"
"--\n"
"-- i need a naming convention that make sense so this is now calledm\n"
"-- refine_chunks with coarse meaning unrefined\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function form_chunks(srv,chunks,opts) return refine_chunks(srv,chunks,opts) end\n"
"function refine_chunks(srv,chunks,opts)\n"
"\n"
"	opts=opts or {}\n"
"\n"
"	local refined={}\n"
"	\n"
"	for i,v in pairs(opts) do -- copy opts into refined\n"
"		refined[i]=v\n"
"	end\n"
"\n"
"-- start by compiling the lua chunks and running its pageopts hook\n"
"	for i,v in ipairs(chunks) do\n"
"	\n"
"		if v.opts.form==\"lua\" then -- we have some lua code for this page\n"
"			local e=sbox.make_env()\n"
"			v.env=e -- store it for later\n"
"			e.text=v.text -- let code know its sourcecode\n"
"			local f,err=loadstring(v.text)\n"
"			e.text=err or v.text -- replace with error for simple parse display\n"
"			if f then\n"
"				setfenv(f, e)\n"
"				pcall(f)\n"
"			end\n"
"			\n"
"			if v.env.hook_pageopts then\n"
"				pcall(function() v.env.hook_pageopts(srv.pageopts) end) -- update pageopts?\n"
"			end\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"	\n"
"	for i,v in ipairs(chunks) do -- do basic process of all of the page chunks into their prefered form \n"
"		local s=v.text\n"
"		\n"
"		local format=v.opts.form\n"
"		local trim=v.opts.trim\n"
"		\n"
"		if trim==\"ends\" then s=str.trim(s) end -- trim whitespace, useful for one word chunks?\n"
"\n"
"		if format==\"nohtml\" then -- like normal but all html is escaped\n"
"\n"
"			s=waka_to_html(s,{base_url=opts.baseurl,escape_html=true}) \n"
"\n"
"		elseif format==\"import\" then -- very special import, treat as chunk of lua import opts/code\n"
"		\n"
"			local e=sbox.make_env()\n"
"			local f,err=loadstring(s)\n"
"			if f then\n"
"				setfenv(f, e)\n"
"				pcall(f)\n"
"			else\n"
"				s=err\n"
"			end\n"
"			\n"
"			if e.import==\"blog\" then\n"
"			\n"
"				e.hook   = e.hook   or opts.hook\n"
"				e.limit=e.limit or 5\n"
"				e.layer=e.layer or 0\n"
"				e.sort=e.sort or \"pubdate\"\n"
"				\n"
"				if not opts.noblog then -- prevent recursions\n"
"					local blog=require(\"blog\")\n"
"					s=blog.chunk_import(srv,e)\n"
"				end\n"
"				\n"
"			elseif e.import==\"note\" then\n"
"			\n"
"				e.hook   = e.hook   or opts.hook\n"
"				e.limit=e.limit or 5\n"
"				e.sort=e.sort or \"pubdate\"\n"
"				\n"
"				if not opts.nonote then -- prevent recursions\n"
"					local note=require(\"note\")\n"
"					s=note.chunk_import(srv,e)\n"
"				end\n"
"				\n"
"			elseif e.import==\"comic\" then\n"
"			\n"
"				e.hook   = e.hook   or opts.hook\n"
"				e.limit=e.limit or 5\n"
"				e.sort=e.sort or \"pubdate\"\n"
"				\n"
"				if not opts.nocomic then -- prevent recursions\n"
"					local comic=require(\"comic\")\n"
"					s=comic.chunk_import(srv,e)\n"
"				end\n"
"				\n"
"			elseif e.import==\"gsheet\" then -- we need to grab some json from google\n"
"			\n"
"				local gsheet=require(\"waka.gsheet\")\n"
"				e.offset = e.offset or opts.offset -- can choose new pages\n"
"				e.limit  = e.limit  or opts.limit -- can choose new pages\n"
"				e.query  = e.query  or opts.query\n"
"				e.plate  = e.plate  or opts.plate\n"
"				e.key    = e.key    or opts.key\n"
"				e.hook   = e.hook   or opts.hook -- callback function to fixup data\n"
"				s=gsheet.getwaka(srv,e) -- get a string\n"
"				\n"
"			elseif e.import==\"wikipedia\" then -- we need to import some xml from wikipedia\n"
"			\n"
"				local wikipedia=require(\"waka.wikipedia\")\n"
"				e.offset = e.offset or opts.offset -- can choose new pages\n"
"				e.limit  = e.limit  or opts.limit -- can choose new pages\n"
"				e.name  = e.name  or opts.name -- get this page\n"
"				e.search  = e.search  or opts.search -- search for\n"
"				e.hook   = e.hook   or opts.hook -- callback function to fixup data\n"
"				\n"
"				s=wikipedia.getwaka(srv,e) -- get a string\n"
"				\n"
"			end\n"
"		\n"
"		elseif format==\"waka\" then -- basic waka format, html allowed but links are upgraded and line ends are <br/>\n"
"\n"
"			s=waka_to_html(s,{base_url=opts.baseurl,escape_html=false})\n"
"\n"
"		else -- raw\n"
"			\n"
"			s=s\n"
"\n"
"		end\n"
"\n"
"		refined[v.name]=s\n"
"	end\n"
"	\n"
"-- end by running any refined lua hooks\n"
"	for i,v in ipairs(chunks) do\n"
"		if v.opts.form==\"lua\" then -- we have some lua code for this page\n"
"			\n"
"			if v.env then -- stick the env table in the refined table\n"
"				refined[v.name]=v.env\n"
"				if v.env.hook_refined then\n"
"					pcall(function() v.env.hook_refined(refined) end) -- update refined data\n"
"				end\n"
"			end\n"
"		end\n"
"	end\n"
"\n"
"	\n"
"	return refined\n"
"end\n"
"",

"spew.client.comm","\n"
"\n"
"local comm=require(\"spew.comm\")\n"
"local util=require(\"spew.util\")\n"
"\n"
"local socket = require(\"socket\")\n"
"\n"
"local _G=_G\n"
"\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"local string=string\n"
"local math=math\n"
"local os=os\n"
"local print=print\n"
"\n"
"local unpack=unpack\n"
"local tostring=tostring\n"
"\n"
"\n"
"local spew_host=\"swf.wetgenes.com\"\n"
"--local spew_host=\"swf.wetgenes.local\"\n"
"local spew_port=5223\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- basic client communication with a spew server\n"
"-- uses lua sockets to connect\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module(\"spew.client.comm\")\n"
"\n"
"-- callback hooks\n"
"hooks={}\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- setup and connect to the spew server\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function setup()\n"
"\n"
"	con=comm.setup( socket.connect(spew_host,spew_port) , {format=\"spew\"} ) -- connect\n"
"	if not con then\n"
"		print( \"failed to connect to \"..spew_host )\n"
"	else\n"
"		if con.error then print(con.error) end\n"
"	end\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- clean and disconnect from the spew server\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function clean()\n"
"\n"
"	if con then\n"
"		comm.clean(con.client)\n"
"	end\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- This handles any incoming data waiting but does not block\n"
"-- so call it a few times a second, every frame should be good\n"
"-- the data will be processed and you will receive callbacks for events\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"function update()\n"
"\n"
"	local tab,_,err=socket.select(comm.recvt,nil,0.00001)\n"
"-- read from sockets\n"
"	for i,v in ipairs(tab or {}) do\n"
"	\n"
"			local p1, error ,p2 = v:receive(\"*a\")\n"
"			local line=p1 or p2\n"
"			\n"
"			if error==\"timeout\" then -- a timeout is not an error, it is actually success\n"
"				error=nil\n"
"			end\n"
"\n"
"			if error then -- error causes disconenct\n"
"			\n"
"				comm.disconnect(v)\n"
"				\n"
"			elseif line then -- got data\n"
"			\n"
"				comm.received(v , line)\n"
"				\n"
"			end\n"
"	end\n"
"	\n"
"-- handle any input\n"
"\n"
"	for client,con in pairs(comm.active) do\n"
"		for i,line in ipairs(con.linein) do\n"
"\n"
"-- as a client we only have one connection\n"
"			util.str_to_msg(line,con.msg)\n"
"			\n"
"			got_amsg(con.msg)\n"
"--			print(con.msg)\n"
"		end\n"
"		con.linein={} -- readit\n"
"	end\n"
"	comm.active={} -- clear active table\n"
"\n"
"end\n"
"\n"
"-- send a msg\n"
"function send(msg)\n"
"\n"
"	comm.send( con.client , util.msg_to_str(msg)..\"\\0\" )\n"
"\n"
"	if hooks.sent then hooks.sent(msg) end\n"
"end\n"
"\n"
"-- all msgs\n"
"function got_amsg(msg)\n"
"	if hooks.amsg then hooks.amsg(msg) end\n"
"	if msg.cmd==\"ville\" then\n"
"		got_vmsg(msg) \n"
"	else\n"
"		got_cmsg(msg)\n"
"	end\n"
"end\n"
"\n"
"-- chat msgs\n"
"function got_cmsg(msg)\n"
"--	print(msg.cmd)\n"
"	if hooks.cmsg then hooks.cmsg(msg) end\n"
"end\n"
"\n"
"-- game msgs\n"
"function got_gmsg(msg)\n"
"--	print(msg.gcmd)\n"
"	if hooks.gmsg then hooks.gmsg(msg) end\n"
"end\n"
"\n"
"-- ville msgs\n"
"function got_vmsg(msg)\n"
"--	print(msg.vcmd)\n"
"	if hooks.vmsg then hooks.vmsg(msg) end\n"
"end\n"
"\n"
"\n"
"\n"
"",

"wetgenes.diff","-----------------------------------------------------------------------------\n"
"-- Provides functions for diffing text.\n"
"--\n"
"-- (c) 2007, 2008  Yuri Takhteyev (yuri@freewisdom.org)\n"
"-- (c) 2007 Hisham Muhammad\n"
"--\n"
"-- License: MIT/X, see http://sputnik.freewisdom.org/en/License\n"
"--\n"
"-- the above was used as a base, it is no longer the same code...\n"
"--\n"
"-- this diff now returns a different slightly more compressed format\n"
"-- which is a table of numbers and strings of only the differences\n"
"-- and that format can be used to convert either string into the other string\n"
"--\n"
"-- most of the changes are actually commented and are just mild changes really\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"\n"
"local string=string\n"
"local table=table\n"
"local math=math\n"
"\n"
"local assert=assert\n"
"local setmetatable=setmetatable\n"
"local ipairs=ipairs\n"
"local type=type\n"
"\n"
"module(\"wetgenes.diff\")\n"
"\n"
"-- java version of lua, not so good at strings, so might as well use numbers for these as they are now internal only\n"
"local SAME = 0  -- token statuses\n"
"local IN   = 1\n"
"local OUT  = 2\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Split a string into tokens.  (Adapted from Gavin Kistner's split on\n"
"-- http://lua-users.org/wiki/SplitJoin.\n"
"--\n"
"-- @param text           A string to be split.\n"
"-- @param separator      [optional] the separator pattern (defaults to any\n"
"--                       white space - %s+).\n"
"-- @param skip_separator [optional] don't include the sepator in the results.     \n"
"-- @return               A list of tokens.\n"
"-----------------------------------------------------------------------------\n"
"local function split(text, separator, skip_separator)\n"
"	separator = separator or \"%s+\"\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	while split_start do\n"
"		if skip_separator then\n"
"			table.insert(parts, text:sub(start, split_start-1))\n"
"		else\n"
"			table.insert(parts, text:sub(start, split_end)) -- now includes the seperator *inside* each token\n"
"		end\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	return parts\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Derives the longest common subsequence of two strings.  This is a faster\n"
"-- implementation than one provided by stdlib.  Submitted by Hisham Muhammad. \n"
"-- The algorithm was taken from:\n"
"-- http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_subsequence\n"
"--\n"
"-- @param t1             the first string.\n"
"-- @param t2             the second string.\n"
"-- @return               the least common subsequence as a matrix.\n"
"-----------------------------------------------------------------------------\n"
"local function quick_LCS(t1, t2)\n"
"   local m = #t1\n"
"   local n = #t2\n"
"\n"
"   -- Build matrix on demand\n"
"   local C = {}\n"
"   local setmetatable = setmetatable\n"
"   local mt_tbl = {\n"
"      __index = function(t, k)\n"
"         t[k] = 0\n"
"         return 0\n"
"      end\n"
"   }\n"
"   local mt_C = {\n"
"      __index = function(t, k)\n"
"         local tbl = {}\n"
"         setmetatable(tbl, mt_tbl)\n"
"         t[k] = tbl\n"
"         return tbl\n"
"      end\n"
"   }\n"
"   setmetatable(C, mt_C)\n"
"   local max = math.max\n"
"   for i = 1, m+1 do\n"
"      local ci1 = C[i+1]\n"
"      local ci = C[i]\n"
"      for j = 1, n+1 do\n"
"         if t1[i-1] == t2[j-1] then\n"
"            ci1[j+1] = ci[j] + 1\n"
"         else\n"
"            ci1[j+1] = max(ci1[j], ci[j+1])\n"
"         end\n"
"      end\n"
"   end\n"
"   return C\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Returns a diff of two strings as a list of pairs, where the first value\n"
"-- represents a token and the second the token's status (\"same\", \"in\", \"out\").\n"
"--\n"
"-- @param old             The \"old\" text string\n"
"-- @param new             The \"new\" text string\n"
"-- @param separator      [optional] the separator pattern (defaults ot any\n"
"--                       white space).\n"
"-- @return               A list of annotated tokens.\n"
"-----------------------------------------------------------------------------\n"
"local function rev_diff(old, new, separator)\n"
"   assert(old); assert(new)\n"
"   new = split(new, separator); old = split(old, separator)\n"
"\n"
"   -- First, compare the beginnings and ends of strings to remove the common\n"
"   -- prefix and suffix.  Chances are, there is only a small number of tokens\n"
"   -- in the middle that differ, in which case  we can save ourselves a lot\n"
"   -- in terms of LCS computation.\n"
"   local prefix = \"\" -- common text in the beginning\n"
"   local suffix = \"\" -- common text in the end\n"
"   while old[1] and old[1] == new[1] do\n"
"      local token = table.remove(old, 1)\n"
"      table.remove(new, 1)\n"
"      prefix = prefix..token\n"
"   end\n"
"   while old[#old] and old[#old] == new[#new] do\n"
"      local token = table.remove(old)\n"
"      table.remove(new)\n"
"      suffix = token..suffix\n"
"   end\n"
"\n"
"   -- Setup a table that will store the diff (an upvalue for get_diff). We'll\n"
"   -- store it in the reverse order to allow for tail calls.  We'll also keep\n"
"   -- in this table functions to handle different events.\n"
"   local rev_diff = {\n"
"      put  = function(self, token, type) table.insert(self, token ) table.insert(self, type ) end, -- no sub tables, so less resources, probably\n"
"      ins  = function(self, token) self:put(token, IN) end,\n"
"      del  = function(self, token) self:put(token, OUT) end,\n"
"      same = function(self, token) if token then self:put(token, SAME) end end,\n"
"   }\n"
"\n"
"   -- Put the suffix as the first token (we are storing the diff in the\n"
"   -- reverse order)\n"
"\n"
"   rev_diff:same(suffix)\n"
"\n"
"   -- Define a function that will scan the LCS matrix backwards and build the\n"
"   -- diff output recursively.\n"
"   local function get_diff(C, old, new, i, j)\n"
"      local old_i = old[i]\n"
"      local new_j = new[j]\n"
"      if i >= 1 and j >= 1 and old_i == new_j then\n"
"         rev_diff:same(old_i)\n"
"         return get_diff(C, old, new, i-1, j-1)\n"
"      else\n"
"         local Cij1 = C[i][j-1]\n"
"         local Ci1j = C[i-1][j]\n"
"         if j >= 1 and (i == 0 or Cij1 >= Ci1j) then\n"
"            rev_diff:ins(new_j)\n"
"            return get_diff(C, old, new, i, j-1)\n"
"         elseif i >= 1 and (j == 0 or Cij1 < Ci1j) then\n"
"            rev_diff:del(old_i)\n"
"            return get_diff(C, old, new, i-1, j)\n"
"         end\n"
"      end\n"
"   end\n"
"   -- Then call it.\n"
"   get_diff(quick_LCS(old, new), old, new, #old + 1, #new + 1)\n"
"\n"
"   -- Put the prefix in at the end\n"
"   rev_diff:same(prefix)\n"
"\n"
"   return rev_diff\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Returns a diff of two strings as a list of pairs, where the first value\n"
"-- represents a token and the second the token's status (\"same\", \"in\", \"out\").\n"
"--\n"
"-- @param old             The \"old\" text string\n"
"-- @param new             The \"new\" text string\n"
"-- @param separator      [optional] the separator pattern (defaults ot any\n"
"--                       white space).\n"
"-- @return\n"
"--\n"
"-- a table containg a list of the following commands\n"
"-- if a number then the length of string that is the same and should be skipped\n"
"-- if a string then it is part of a pair of strings\n"
"-- [1] contains the old string and [2] contains the new string\n"
"-- strings are always in pairs and numbers are always seperated by two strings\n"
"-- this should be reasonably compact data\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function diff(old, new, separator)\n"
"\n"
"	local d=rev_diff(old, new, separator)\n"
"\n"
"	local t={}\n"
"	\n"
"	local same,new,old\n"
"	\n"
"	local function reset() same=0 new=\"\" old=\"\" end\n"
"	\n"
"	reset()\n"
"	\n"
"\n"
"-- scan the data from diff_base\n"
"	for i = #d , 2 , -2 do -- data comes in reversed and in pairs\n"
"	\n"
"	\n"
"	local v1=d[i] 		-- command\n"
"	local v2=d[i-1] 	-- data\n"
"	\n"
"\n"
"		if v1==SAME then\n"
"		\n"
"			if ( new~=\"\" or old~=\"\" ) then -- change state\n"
"			\n"
"				table.insert(t,old)\n"
"				table.insert(t,new)\n"
"				reset()\n"
"			end\n"
"			\n"
"			same=same+v2:len()\n"
"		\n"
"		elseif v1==OUT then \n"
"		\n"
"			if same>0 then -- change state\n"
"			\n"
"				table.insert(t,same)\n"
"				reset()\n"
"			end\n"
"			\n"
"			old=old..v2\n"
"			\n"
"		elseif v1==IN then\n"
"		\n"
"			if same>0 then -- change state\n"
"			\n"
"				table.insert(t,same)\n"
"				reset()\n"
"			end\n"
"			\n"
"			new=new..v2			\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"-- add the final chunk\n"
"	\n"
"	if same>0 then\n"
"	\n"
"		table.insert(t,same)\n"
"		\n"
"	elseif ( new~=\"\" or old~=\"\" ) then\n"
"\n"
"		table.insert(t,old)\n"
"		table.insert(t,new)\n"
"	end\n"
"\n"
"	return t\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- patch a diff against a string and return the new string\n"
"--\n"
"-- set undo to true and the patch will be applied in reverse\n"
"--\n"
"-- s1,s2\n"
"-- d=diff(s1,s2)\n"
"-- s2==patch(s1,d)\n"
"-- s1==patch(s2,d,true)\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function patch(s,t,undo)\n"
"\n"
"	local o={}\n"
"	local idx=1\n"
"\n"
"	local i=1\n"
"	local len=#t\n"
"	while i<=len do\n"
"	\n"
"		local v1,v2\n"
"		v1=t[i]\n"
"		i=i+1\n"
"		\n"
"		if type(v1)==\"string\" then\n"
"		\n"
"			v2=t[i]\n"
"			i=i+1	-- strings come in pairs so get second string\n"
"			\n"
"			if undo then\n"
"			\n"
"				table.insert(o, v1 )\n"
"				idx=idx+v2:len()\n"
"				\n"
"			else\n"
"			\n"
"				table.insert(o, v2 )\n"
"				idx=idx+v1:len()\n"
"				\n"
"			end\n"
"		else\n"
"		\n"
"			table.insert(o, s:sub(idx,idx+v1-1) )\n"
"			idx=idx+v1\n"
"			\n"
"		end\n"
"	end\n"
"	\n"
"	return table.concat(o) -- build a return string\n"
"\n"
"end\n"
"\n"
"-- a more readable way to unpatch\n"
"function unpatch(s,t) return patch(s,t,true) end\n"
"\n"
"",

"wetgenes.cgilua.mysql","\n"
"--\n"
"-- Mysql helper functions\n"
"--\n"
"\n"
"\n"
"local type,ipairs,pairs,tonumber=type,ipairs,pairs,tonumber\n"
"\n"
"local string=string\n"
"\n"
"local cgilua=cgilua\n"
"\n"
"local cfg = cfg\n"
"\n"
"\n"
"local luasql = require(\"luasql.mysql\")\n"
"local sql = luasql.mysql()\n"
"\n"
"local dbg=dbg or function(s) cgilua.errorlog(s) end\n"
"\n"
"module(\"wetgenes.cgilua.mysql\")\n"
"\n"
"query_count=0\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function setup()\n"
"	clean()\n"
"	\n"
"local err\n"
"\n"
"	con,err=sql:connect(cfg.mysql_database,cfg.mysql_username,cfg.mysql_password,cfg.mysql_hostname)\n"
"	\n"
"	if not con then\n"
"	\n"
"		dbg(\"\\n"
"\"..\"Failed to connect to mysql\"..(err or \"unknown\")..\"\\n"
"\") -- print error\n"
"		\n"
"		return nil\n"
"	end\n"
"	\n"
"	cgilua.addclosefunction( clean )\n"
"\n"
"	return _M\n"
"end\n"
"function clean()\n"
"	if con then con:close() end\n"
"	con=nil\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert a string into a hex string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function str_to_hex(s)\n"
"	return string.gsub(s, \".\", function (c)\n"
"		return string.format(\"%02x\", string.byte(c))\n"
"	end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- escape a string for mysql, convert to a (possibly large) number in hex\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function mysql_escape(s)\n"
"	return \"0x\"..str_to_hex(s)\n"
"end\n"
"\n"
"\n"
"\n"
"--[[\n"
"+------------+----------+------+-----+---------+----------------+\n"
"| Field      | Type     | Null | Key | Default | Extra          |\n"
"+------------+----------+------+-----+---------+----------------+\n"
"| Id         | int(11)  | NO   | PRI | NULL    | auto_increment |\n"
"| Name       | char(35) | NO   |     |         |                |\n"
"| Country    | char(3)  | NO   | UNI |         |                |\n"
"| District   | char(20) | YES  | MUL |         |                |\n"
"| Population | int(11)  | NO   |     | 0       |                |\n"
"+------------+----------+------+-----+---------+----------------+\n"
"]]\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- mysql table creation system\n"
"--\n"
"-- check if a table exists, if it doesnt then just create it\n"
"--\n"
"-- then check each column, any column that doesnt exist but should is then added\n"
"--\n"
"-- name is the name of the table\n"
"-- cols, consists of the result you would expect from a SHOW COLUMNS FROM query\n"
"-- any descrepencies will be reported,\n"
"-- see above for example showing columns output\n"
"--\n"
"-- extra is other mysql key creation to put onto the end of the initial table creation\n"
"-- any post creation optimisation will have to happen by hand, maintaining the table columns consistency is the important bit\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function table_create(name,cols,extra)\n"
"\n"
"local cur,err\n"
"local q\n"
"\n"
"-- build table creation string\n"
"\n"
"	q=\"\"\n"
"	q=q..[[ CREATE TABLE IF NOT EXISTS `]]..name..[[` ( ]]..\"\\n"
"\"\n"
"	\n"
"	for i,v in ipairs(cols) do\n"
"	\n"
"		local l\n"
"		\n"
"		if i==1 then l=\"\" else l=\",\\n"
"\" end\n"
"		\n"
"		l=l..[[ `]]..v[1]..[[` ]]..v[2]\n"
"		\n"
"		if v[3]==\"NO\" then l=l..\" NOT NULL\" end\n"
"		if v[5] then l=l..\" DEFAULT \"..v[5] end\n"
"		if v[6] then l=l..\" \"..v[6] end\n"
"		\n"
"		q=q..l\n"
"	\n"
"	end\n"
"		\n"
"	for i,v in ipairs(cols) do -- add extra key optimizations to the table\n"
"	\n"
"		if v[4] then\n"
"		\n"
"			local l=\",\\n"
"\"\n"
"			\n"
"			if v[4]==\"PRI\" then\n"
"			\n"
"				l=l..[[ PRIMARY KEY (`]]..v[1]..[[`) ]]\n"
"			\n"
"			elseif v[4]==\"MUL\" then\n"
"			\n"
"				l=l..[[ KEY `]]..v[1]..[[` (`]]..v[1]..[[`) ]]\n"
"				\n"
"			elseif v[4]==\"UNI\" then\n"
"			\n"
"				l=l..[[ UNIQUE KEY `]]..v[1]..[[` (`]]..v[1]..[[`) ]]\n"
"			\n"
"			end\n"
"			\n"
"			q=q..l\n"
"			\n"
"		end\n"
"	\n"
"	end\n"
"	\n"
"	if extra then -- include extra table creation lines for keys etc\n"
"	\n"
"		q=q..\",\\n"
" \"..extra\n"
"	\n"
"	end\n"
"		\n"
"	q=q..[[ ) ]]..\"\\n"
"\"\n"
"\n"
"--dbg(\"**Preparing table \" ..name..\"\\n"
"\")\n"
"--dbg(q)\n"
"\n"
"	cur,err=con:execute(q)\n"
"	if not cur and err then dbg(\"\\n"
"\"..err..\"\\n"
"\") end\n"
"	\n"
"	cur,err=con:execute(\"SHOW COLUMNS FROM \"..name)\n"
"	if not cur and err then dbg(\"\\n"
"\"..err..\"\\n"
"\") end\n"
"	\n"
"	local i=1\n"
"	local r\n"
"	local tab={}\n"
"\n"
"	repeat\n"
"	\n"
"		r=cur:fetch({})\n"
"		tab[i]=r\n"
"		i=i+1\n"
"	\n"
"	until not r\n"
"	\n"
"--dbg(\"**Checking table \" ..name..\"\\n"
"\")\n"
"	for i,v in ipairs(tab) do\n"
"	\n"
"		local s\n"
"		for ii,vv in ipairs(v) do\n"
"			if s then s=s..\"\\t\"..vv else s=vv end\n"
"		end\n"
"	\n"
"--		dbg( s..\"\\n"
"\" )\n"
"	\n"
"	end\n"
"	\n"
"--dbg(\"**Created table \" ..name..\"\\n"
"\")\n"
"\n"
"	if cur then cur:close() end\n"
"	\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- perform the sql queery\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function execute(q,flags)\n"
"\n"
"local cur,ret,err\n"
"local lastid,lastcur\n"
"\n"
"	\n"
"query_count=query_count+1\n"
"	cur,err=con:execute(q)\n"
"	\n"
"	if not cur and err then -- indicate failure\n"
"	\n"
"		dbg(\"\\n"
"\"..err..\"\\n"
"\") -- print error\n"
"		\n"
"		return nil\n"
"	end\n"
"	\n"
"	if type(cur)==\"number\" then -- a single number return value\n"
"	\n"
"		if flags==\"lastid\" and (cur~=0) then -- get last id\n"
"		\n"
"			lastcur,err=con:execute(\"SELECT LAST_INSERT_ID()\")\n"
"			\n"
"			if not lastcur and err then -- indicate failure\n"
"			\n"
"				dbg(\"\\n"
"\"..err..\"\\n"
"\") -- print error\n"
"				\n"
"				lastid=0\n"
"				\n"
"			else\n"
"			\n"
"				lastid=lastcur:fetch({})[1]\n"
"				\n"
"				lastid=tonumber(lastid)\n"
"				\n"
"				if lastcur then lastcur:close() end\n"
"				\n"
"--				dbg(\"\\n"
" LASTID = \"..lastid..\"\\n"
"\") -- print error\n"
"			end\n"
"			\n"
"			return lastid\n"
"		end\n"
"	\n"
"		return cur\n"
"	end\n"
"	\n"
"	ret={}\n"
"	\n"
"	ret.names=cur:getcolnames()\n"
"	ret.types=cur:getcoltypes()\n"
"	\n"
"	local i=1\n"
"	local r\n"
"	\n"
"	repeat\n"
"	\n"
"		r=cur:fetch({})\n"
"		ret[i]=r\n"
"		i=i+1\n"
"	\n"
"	until not r\n"
"		\n"
"	if cur then cur:close() end\n"
"	return ret\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- fill up a table with named results\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function named(tab,idx)\n"
"\n"
"	if (not tab) or (not tab[idx]) then return nil end\n"
"\n"
"local ret={}\n"
"\n"
"	for i,v in ipairs(tab.names) do\n"
"		ret[v]=tab[idx][i]\n"
"	end\n"
"\n"
"	return ret\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- insert or update data on clash, similar format to the lanes returned info\n"
"-- this function doesnt do anything it just builds a queery string that will\n"
"--\n"
"-- name == table name\n"
"-- row == data to insert\n"
"--\n"
"-- row.names == table of named columns\n"
"-- row[1] == table of data (strings need to have already been fixed/escaped)\n"
"--\n"
"-- this is a single insert or update, so there is only one row\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_set(name,row)\n"
"\n"
"local q=\"INSERT INTO \"..name..\" SET \"\n"
"\n"
"	for i,v in ipairs(row.names) do\n"
"	\n"
"		local sep=\", \\n"
"\" if i==1 then sep=\" \\n"
"\" end\n"
"		\n"
"		q=q..sep..v..\"=\"..row[1][i]..\" \"\n"
"	\n"
"	end\n"
"	\n"
"	q=q..\"\\n"
" ON DUPLICATE KEY UPDATE \"\n"
"\n"
"	for i,v in ipairs(row.names) do\n"
"	\n"
"		local sep=\", \\n"
"\" if i==1 then sep=\" \\n"
"\" end\n"
"		\n"
"		q=q..sep..v..\"=\"..row[1][i]..\" \"\n"
"	\n"
"	end\n"
"		\n"
"	return q\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- insert only, similar format to the lanes returned info\n"
"-- this function doesnt do anything it just builds a queery string that will\n"
"--\n"
"-- name == table name\n"
"-- row == data to insert\n"
"--\n"
"-- row.names == table of named columns\n"
"-- row[1] == table of data (strings need to have already been fixed/escaped)\n"
"--\n"
"-- this is a single insert or update, so there is only one row\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_insert(name,row)\n"
"\n"
"local q=\"INSERT INTO \"..name..\" SET \"\n"
"\n"
"	for i,v in ipairs(row.names) do\n"
"	\n"
"		local sep=\", \\n"
"\" if i==1 then sep=\" \\n"
"\" end\n"
"		\n"
"		q=q..sep..v..\"=\"..row[1][i]..\" \"\n"
"	\n"
"	end\n"
"	\n"
"	q=q..\"\\n"
"\"\n"
"		\n"
"	return q\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- update only, similar format to the lanes returned info\n"
"-- this function doesnt do anything it just builds a queery string that will\n"
"--\n"
"-- name == table name\n"
"-- row == data to insert\n"
"-- where == where to update\n"
"--\n"
"-- row.names == table of named columns\n"
"-- row[1] == table of data (strings need to have already been fixed/escaped)\n"
"--\n"
"-- this is a single insert or update, so there is only one row\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_update(name,row,where)\n"
"\n"
"local q=\"UPDATE \"..name..\" SET \"\n"
"\n"
"	for i,v in ipairs(row.names) do\n"
"	\n"
"		local sep=\", \\n"
"\" if i==1 then sep=\" \\n"
"\" end\n"
"		\n"
"		q=q..sep..v..\"=\"..row[1][i]..\" \"\n"
"	\n"
"	end\n"
"	\n"
"	q=q..\"\\n"
" WHERE \"..where\n"
"		\n"
"	return q\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert a table into a row set\n"
"--\n"
"-- returns row where\n"
"--\n"
"-- row.names == table of named columns\n"
"-- row[1] == table of data with strings fixed/escaped\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function tab_to_row(dat)\n"
"\n"
"	local idx=1\n"
"	local row={}\n"
"	row.names={}\n"
"	row[1]={}\n"
"	\n"
"	for n,v in pairs(dat) do -- build and fixup mysql data\n"
"	\n"
"		row.names[idx]=n\n"
"		\n"
"		if type(v)==\"string\" then\n"
"		\n"
"			if v==\"\" then\n"
"			\n"
"				row[1][idx]=\"DEFAULT\"\n"
"				\n"
"			else\n"
"		\n"
"				row[1][idx]=mysql_escape(v)\n"
"			\n"
"			end\n"
"			\n"
"		else\n"
"		\n"
"			row[1][idx]=v\n"
"		\n"
"		end\n"
"		\n"
"		idx=idx+1\n"
"	\n"
"	end\n"
"		\n"
"	return row\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- create and perform a blocking data insert or update\n"
"--\n"
"-- just pass in a tab and it will build and execute a sql query to add or change that data\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function do_set(name,tab)\n"
"\n"
"	return execute( make_set(name,tab_to_row(tab)) , \"lastid\" )\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- create and perform a blocking data insert\n"
"--\n"
"-- just pass in a tab and it will build and execute a sql query to add or change that data\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function do_insert(name,tab)\n"
"\n"
"	return execute( make_insert(name,tab_to_row(tab)) , \"lastid\" )\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- create and perform a blocking data update\n"
"--\n"
"-- just pass in a tab and it will build and execute a sql query to add or change that data\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function do_update(name,tab,where)\n"
"\n"
"	return execute( make_update(name,tab_to_row(tab),where) )\n"
"	\n"
"end\n"
"",

"fenestra.widget.textedit","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- widget class string\n"
"-- a one line string buffer that can be edited\n"
"\n"
"\n"
"\n"
"\n"
"module(\"fenestra.widget.textedit\")\n"
"\n"
"local widget_data=require(\"fenestra.widget.data\")\n"
"\n"
"\n"
"function mouse(widget,act,x,y,key)\n"
"\n"
"--	local it=widget.string\n"
"\n"
"-- call here so we can use any state changes immediatly	\n"
"	local ret=widget.meta.mouse(widget,act,x,y,key)\n"
"	\n"
"	if widget.master.active==widget then\n"
"	\n"
"		widget.master.focus=widget\n"
"		\n"
"		if act==\"down\" then\n"
"			local dx=x-((widget.pxd or 0)+(widget.text_x or 0))\n"
"--print(dx)\n"
"			if dx<0 then -- catch lessthan\n"
"				widget.data.str_idx=0\n"
"			else\n"
"				widget.data.str_idx=widget.master.font.which(dx,widget.data.str)\n"
"				if widget.data.str_idx<0 then widget.data.str_idx=#widget.data.str end -- catch morethan\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	return ret\n"
"end\n"
"\n"
"\n"
"function key(widget,ascii,key,act)\n"
"--	local it=widget.string\n"
"	local master=widget.master\n"
"	\n"
"	local changed=false\n"
"\n"
"--print(\"gotkey\",ascii)\n"
"	\n"
"	if act==\"down\" or act==\"repeat\" then\n"
"	\n"
"		if key==\"left\" then\n"
"\n"
"			widget.data.str_idx=widget.data.str_idx-1\n"
"			if widget.data.str_idx<0 then widget.data.str_idx=0 end\n"
"			\n"
"			master.throb=255\n"
"						\n"
"		elseif key==\"right\" then\n"
"	\n"
"			widget.data.str_idx=widget.data.str_idx+1\n"
"			if widget.data.str_idx>#widget.data.str then widget.data.str_idx=#widget.data.str end\n"
"			\n"
"			master.throb=255\n"
"			\n"
"		elseif key==\"home\" then\n"
"		\n"
"			widget.data.str_idx=0\n"
"		\n"
"		elseif key==\"end\" then\n"
"		\n"
"			widget.data.str_idx=#widget.data.str\n"
"		\n"
"		elseif key==\"backspace\" then\n"
"	\n"
"			if widget.data.str_idx >= #widget.data.str then -- at end\n"
"			\n"
"				widget.data.str=widget.data.str:sub(1,-2)\n"
"				widget.data.str_idx=#widget.data.str\n"
"				\n"
"				changed=true\n"
"			\n"
"			elseif widget.data.str_idx < 1 then -- at start\n"
"			\n"
"			elseif widget.data.str_idx == 1 then -- near start\n"
"			\n"
"				widget.data.str=widget.data.str:sub(2)\n"
"				widget.data.str_idx=widget.data.str_idx-1\n"
"			\n"
"				changed=true\n"
"\n"
"			else -- somewhere in the line\n"
"			\n"
"				widget.data.str=widget.data.str:sub(1,widget.data.str_idx-1) .. widget.data.str:sub(widget.data.str_idx+1)\n"
"				widget.data.str_idx=widget.data.str_idx-1\n"
"				\n"
"				changed=true\n"
"\n"
"			end\n"
"			\n"
"			master.throb=255\n"
"			\n"
"		elseif key==\"delete\" then\n"
"	\n"
"			if widget.data.str_idx >= #widget.data.str then -- at end\n"
"			\n"
"			elseif widget.data.str_idx < 1 then -- at start\n"
"			\n"
"				widget.data.str=widget.data.str:sub(2)\n"
"				widget.data.str_idx=0\n"
"			\n"
"				changed=true\n"
"\n"
"			else -- somewhere in the line\n"
"			\n"
"				widget.data.str=widget.data.str:sub(1,widget.data.str_idx) .. widget.data.str:sub(widget.data.str_idx+2)\n"
"				widget.data.str_idx=widget.data.str_idx\n"
"				\n"
"				changed=true\n"
"\n"
"			end\n"
"			\n"
"			master.throb=255\n"
"			\n"
"		elseif key==\"enter\" or key==\"return\" then\n"
"		\n"
"			if act==\"down\" then -- ignore repeats on enter key\n"
"			\n"
"				if widget.data.str and widget.onenter then -- callback?\n"
"				\n"
"					widget:call_hook(\"click\")\n"
"					\n"
"				end\n"
"				\n"
"			end\n"
"			\n"
"--		elseif key==\"up\" then\n"
"--		elseif key==\"down\" then\n"
"		\n"
"		elseif ascii~=\"\" then -- not a blank string\n"
"			local c=string.byte(ascii)\n"
"			\n"
"			if c>=32 and c<128 then\n"
"			\n"
"				if widget.data.str_idx >= #widget.data.str then -- put at end\n"
"				\n"
"					widget.data.str=widget.data.str..ascii\n"
"					widget.data.str_idx=#widget.data.str\n"
"					\n"
"				elseif widget.data.str_idx < 1 then -- put at start\n"
"				\n"
"					widget.data.str=ascii..widget.data.str\n"
"					widget.data.str_idx=1\n"
"					\n"
"				else -- need to insert into line\n"
"				\n"
"					widget.data.str=widget.data.str:sub(1,widget.data.str_idx) .. ascii .. widget.data.str:sub(widget.data.str_idx+1)\n"
"					widget.data.str_idx=widget.data.str_idx+1\n"
"					\n"
"				end\n"
"				\n"
"				master.throb=255\n"
"				\n"
"				changed=true\n"
"\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	if changed then\n"
"		widget.text=widget.data.str\n"
"		\n"
"		widget:call_hook(\"update\")\n"
"	end\n"
"	\n"
"	return true\n"
"\n"
"end\n"
"\n"
"\n"
"function update(widget)\n"
"end\n"
"\n"
"\n"
"function setup(widget,def)\n"
"--	local it={}\n"
"--	widget.string=it\n"
"	widget.class=\"textedit\"\n"
"	\n"
"	widget.data=widget.data or widget_data.new_data({})\n"
"	\n"
"--	widget.data.str=\"\"\n"
"--	widget.data.str_idx=0\n"
"	\n"
"--	widget.key=key\n"
"	widget.update=update\n"
"\n"
"	widget.key=key\n"
"	widget.mouse=mouse\n"
"\n"
"	return widget\n"
"end\n"
"",

"wetgenes.snipets","-- just snippets of code for copypasta do not run as it should do nothing\n"
"-- this files is intended as a central place to keep upto date incase things need to be changed\n"
"\n"
"-- copy functions into locals\n"
"local assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- copy libs into locals\n"
"local coroutine,package,string,table,math,io,os,debug=coroutine,package,string,table,math,io,os,debug\n"
"\n"
"-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"",

"wetgenes.simpxml","\n"
"local table=table\n"
"local string=string\n"
"\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"\n"
"local type=type\n"
"\n"
"local print=log or print\n"
"local assert=assert\n"
"\n"
"module(...)\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- some old simple xml parsing code, found here and fixed up a little :)\n"
"--\n"
"-- http://lua-users.org/lists/lua-l/2002-06/msg00040.html\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- auxiliar function to parse tag attributes\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function parse_args(s,label)\n"
"  local arg = {}\n"
"  arg[0]=label or \"?\"\n"
"  string.gsub(s, \"([%w_]+)%s*=%s*([\\\"'])(.-)%2\", function (w, _, a)\n"
"    arg[string.lower(w)] = a\n"
"  end)\n"
"  return arg\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- string \"s\" is a string with XML marks. This function parses the string\n"
"-- and returns the resulting tree.\n"
"--\n"
"-- simple but will parse small basic data xml files just fine and thats what im using it for\n"
"--\n"
"-- it is however very easy to produce a valid xml file that will break this...\n"
"-- but, as long as you are just using tags/data then this is fine\n"
"--\n"
"-- by putting the tag name in [0] we can use the string namespace for all attributes\n"
"-- and can iterate over the table entries 1+ in a normal way\n"
"--\n"
"-- [0] == tag name\n"
"-- [1++] == contained strings or tables (sub tags)\n"
"-- [stringnames] == attributes IE all string keys\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function parse(s)\n"
"  local stack = {}\n"
"  local top = {}\n"
"  table.insert(stack, top)\n"
"  local i = 1\n"
"\n"
"local ret_stack=2 -- we start by assuming we will be skipping a header\n"
"\n"
"  local warnings\n"
"  local warn=function(s)\n"
"	if not warnings then warnings={} end\n"
"	warnings[#warnings+1]=s\n"
"  end\n"
"\n"
"\n"
"\n"
"	local j2\n"
"-- find header\n"
"  local ni,j,c,label,args, empty = string.find(s, \"<%?(%/?)([%w_]+)(.-)(%/?)%?>\")\n"
"  \n"
"  if not ni then -- ignore missing <? tag header at start\n"
"	ret_stack=1\n"
"	ni,j,c,label,args, empty = string.find(s, \"<(%/?)([%w_]+)(.-)(%/?)>\")\n"
"  end\n"
"  \n"
"  \n"
"  while ni do\n"
"--print(ni,j,c,label,args,empty)\n"
"    local text = string.sub(s, i, ni-1)\n"
"\n"
"--print(text)\n"
"    \n"
"    if not string.find(text, \"^%s*$\") then -- if not just white space\n"
"      table.insert(top, text)\n"
"    end\n"
"    if empty == \"/\" then  -- empty element tag\n"
"      table.insert(top, parse_args(args,label) )\n"
"    elseif c == \"xml\" then   -- top tag\n"
"      top = parse_args(args,label)\n"
"      table.insert(stack, top)   -- new level\n"
"    elseif c == \"\" then   -- start tag\n"
"      top = parse_args(args,label)\n"
"      table.insert(stack, top)   -- new level\n"
"    else  -- end tag\n"
"		local autoclose=true -- autoclose\n"
"		while autoclose do\n"
"		  local toclose = table.remove(stack)  -- remove top\n"
"		  top = stack[#stack]\n"
"		  if #stack < 1 then\n"
"			warn(\"Tag <\"..label..\"> not matched \")\n"
"		  else\n"
"			  if toclose[0] ~= label then\n"
"				warn(\"Tag <\"..(toclose[0] or \"?\")..\"> doesnt match <\"..(label or \"?\")..\">.\")\n"
"				else\n"
"				autoclose=false\n"
"			  end\n"
"		  end\n"
"		  table.insert(top, toclose)\n"
"		end\n"
"    end \n"
"    i = j+1\n"
"\n"
"-- catch cdata in tag\n"
"    ni,j2,text = string.find(s, \"^%<%!%[CDATA%[(.-)%]%]%>\", i)\n"
"    if ni then\n"
"--print(text)\n"
"		table.insert(top, text) -- just insert the content\n"
"		j=j2\n"
"		i = j+1\n"
"	end\n"
"    \n"
"    \n"
"    ni,j,c,label,args, empty = string.find(s, \"<(%/?)([%w_]+)(.-)(%/?)>\", i)\n"
"  end\n"
"  local text = string.sub(s, i)\n"
"  if not string.find(text, \"^%s*$\") then\n"
"    table.insert(stack[#stack], text)\n"
"  end\n"
"  return stack[ret_stack],warnings\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert everything within this chunk, back to a html string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function unparse(parent,opts)\n"
"	opts=opts or {tabjoin=true}\n"
"\n"
"	local tabjoin=opts.tabjoin -- only one of these recursive calls should have this flag\n"
"	if tabjoin then opts.tabjoin=false end -- so disable it\n"
"	\n"
"	local out=function(s) opts.out[#opts.out+1]=s end\n"
"	local att=function(t)\n"
"		local at={}\n"
"		for i,v in pairs(t) do\n"
"			local t=type(i)\n"
"			if t==\"string\" then\n"
"				at[#at+1]=i..\"=\"..\"\\\"\"..v..\"\\\"\"\n"
"			end\n"
"		end\n"
"		if at[1] then\n"
"			return \" \"..table.concat(at,\" \")..\" \"\n"
"		else\n"
"			return \"\"\n"
"		end\n"
"	end\n"
"	\n"
"	if not opts.out then opts.out={} end\n"
"\n"
"	for i,v in ipairs(parent) do\n"
"		local t=type(v)\n"
"		if t==\"string\" then\n"
"			out(v)\n"
"		elseif t==\"table\" then\n"
"			if v[0] then\n"
"				if v[1] then -- stuff within this tag\n"
"					out(\"<\"..v[0]..att(v)..\">\")\n"
"						unparse(v,opts)\n"
"					out(\"</\"..v[0]..\">\")\n"
"				else -- an empty tag\n"
"					out(\"<\"..v[0]..att(v)..\"/>\")\n"
"				end\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	if tabjoin then -- reenable flag before returning\n"
"		opts.tabjoin=true\n"
"		return table.concat(opts.out)\n"
"	else\n"
"		return opts\n"
"	end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get/set the attr tag of the given type (deals with silly case problems)\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function attr(parent,name,set)\n"
"\n"
"	name=string.lower(name)\n"
"\n"
"	if set then parent[name]=set end\n"
"\n"
"	return parent[name]\n"
"--[[\n"
"\n"
"	for n,v in pairs(parent) do\n"
"		if type(n)==\"string\" and string.lower(n)==name then\n"
"			if set then parent[n]=set end\n"
"			return v\n"
"		end\n"
"	end\n"
"	\n"
"	return nil\n"
"]]\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- find the first child tag of the given type, this does not recurse\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function child(parent,name)\n"
"\n"
"	name=string.lower(name)\n"
"\n"
"	for i,v in ipairs(parent) do\n"
"		if type(v)==\"table\" and v[0] and string.lower(v[0])==name then return v end\n"
"	end\n"
"	\n"
"	return nil\n"
"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- find all the children tag of the given type, this does not recurse\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function childs(parent,name)\n"
"\n"
"	name=string.lower(name)\n"
"	\n"
"	local t={}\n"
"	\n"
"	for i,v in ipairs(parent) do\n"
"		if type(v)==\"table\" and v[0] and string.lower(v[0])==name then t[#t+1]=v end\n"
"	end\n"
"	\n"
"	return t\n"
"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- find the first descendent tag of the given type, this does recurse\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function descendent(parent,name)\n"
"\n"
"	name=string.lower(name)\n"
"\n"
"	for i,v in ipairs(parent) do\n"
"		if type(v)==\"table\" and v[0] and string.lower(v[0])==name then return v end\n"
"	end\n"
"	\n"
"	for i,v in ipairs(parent) do -- recurse\n"
"		local ret\n"
"		if type(v)==\"table\" then ret=descendent(v,name) end\n"
"		if ret then return ret end\n"
"	end\n"
"	\n"
"	return nil\n"
"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- find **all** the descendent tags of the given type, this does recurse\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function descendents(parent,name,opts)\n"
"	opts=opts or {}\n"
"	opts.out=opts.out or {}\n"
"	\n"
"	local out=function(s) opts.out[#opts.out+1]=s end\n"
"	\n"
"	name=string.lower(name)\n"
"\n"
"	for i,v in ipairs(parent) do -- this level\n"
"		if type(v)==\"table\" and v[0] and string.lower(v[0])==name then out(v) end\n"
"	end\n"
"	\n"
"	for i,v in ipairs(parent) do -- recurse\n"
"		if type(v)==\"table\" then descendents(v,name,opts) end\n"
"	end\n"
"	\n"
"	return opts.out -- maybe an empty output\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- find the first descendent tag of the given class, this does recurse\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function class(parent,name)\n"
"\n"
"	name=string.lower(name)\n"
"\n"
"	for i,v in ipairs(parent) do\n"
"		if type(v)==\"table\" then\n"
"			if attr(v,\"class\") then\n"
"--print( attr(v,\"class\") ..\"\\n"
"\" )\n"
"				if string.lower(attr(v,\"class\"))==name then return v end\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	for i,v in ipairs(parent) do -- recurse\n"
"		local ret\n"
"		if type(v)==\"table\" then ret=class(v,name) end\n"
"		if ret then return ret end\n"
"	end\n"
"	\n"
"	return nil\n"
"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- find **all** the descendent tags of the given class, this does recurse\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function classes(parent,name,opts)\n"
"	opts=opts or {}\n"
"	opts.out=opts.out or {}\n"
"	\n"
"	local out=function(s) opts.out[#opts.out+1]=s end\n"
"	\n"
"	name=string.lower(name)\n"
"\n"
"	for i,v in ipairs(parent) do -- this level\n"
"		if type(v)==\"table\" then\n"
"			if attr(v,\"class\") then\n"
"				if string.lower(attr(v,\"class\"))==name then out(v) end\n"
"			end\n"
"		end\n"
"		if type(v)==\"table\" and attr(v,\"class\") and string.lower(attr(v,\"class\"))==name then out(v) end\n"
"	end\n"
"	\n"
"	for i,v in ipairs(parent) do -- recurse\n"
"		if type(v)==\"table\" then classes(v,name,opts) end\n"
"	end\n"
"	\n"
"	return opts.out -- maybe an empty output\n"
"\n"
"end\n"
"\n"
"",

"fenestra.widget","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"--\n"
"-- handle widgets\n"
"--\n"
"\n"
"\n"
"local widget_meta=require(\"fenestra.widget.meta\")\n"
"local widget_skin=require(\"fenestra.widget.skin\")\n"
"\n"
"\n"
"\n"
"module(\"fenestra.widget\")\n"
"\n"
"\n"
"--\n"
"-- create a master widget\n"
"--\n"
"function setup(win,def)\n"
"\n"
"	local meta={}\n"
"	meta.__index=meta\n"
"	local master={} -- the master widget, all numerical keys of a widget are the widgets children\n"
"	setmetatable(master,meta)\n"
"	master.parent=master -- we are our own parent, probably safer than setting as null\n"
"	master.master=master -- and our own master\n"
"	\n"
"	master.font=def.font\n"
"	\n"
"	def.master=master\n"
"	def.meta=meta\n"
"	def.win=win\n"
"\n"
"	widget_meta.setup(def)\n"
"	widget_skin.setup(def)\n"
"	\n"
"-- default GUI size if no other is specified\n"
"	def.hx=def.hx or 640\n"
"	def.hy=def.hy or 480\n"
"	def.px=def.px or 0\n"
"	def.py=def.py or 0\n"
"	def.pxd=def.pxd or 0\n"
"	def.pyd=def.pyd or def.hy\n"
"\n"
"	def.class=def.class or \"master\"\n"
"	\n"
"	master:setup(def)\n"
"	\n"
"	return master -- our new widget is ready\n"
"\n"
"end\n"
"\n"
"",

"coxpcall","-------------------------------------------------------------------------------\n"
"-- Coroutine safe xpcall and pcall versions\n"
"--\n"
"-- Encapsulates the protected calls with a coroutine based loop, so errors can\n"
"-- be dealed without the usual Lua 5.x pcall/xpcall issues with coroutines\n"
"-- yielding inside the call to pcall or xpcall.\n"
"--\n"
"-- Authors: Roberto Ierusalimschy and Andre Carregal \n"
"-- Contributors: Thomas Harning Jr., Ignacio Burgueo, Fbio Mascarenhas\n"
"--\n"
"-- Copyright 2005 - Kepler Project (www.keplerproject.org)\n"
"--\n"
"-- $Id: coxpcall.lua,v 1.13 2008/05/19 19:20:02 mascarenhas Exp $\n"
"-------------------------------------------------------------------------------\n"
"\n"
"-------------------------------------------------------------------------------\n"
"-- Implements xpcall with coroutines\n"
"-------------------------------------------------------------------------------\n"
"local performResume, handleReturnValue\n"
"local oldpcall, oldxpcall = pcall, xpcall\n"
"\n"
"function handleReturnValue(err, co, status, ...)\n"
"    if not status then\n"
"        return false, err(debug.traceback(co, (...)), ...)\n"
"    end\n"
"    if coroutine.status(co) == 'suspended' then\n"
"        return performResume(err, co, coroutine.yield(...))\n"
"    else\n"
"        return true, ...\n"
"    end\n"
"end\n"
"\n"
"function performResume(err, co, ...)\n"
"    return handleReturnValue(err, co, coroutine.resume(co, ...))\n"
"end    \n"
"\n"
"function coxpcall(f, err, ...)\n"
"    local res, co = oldpcall(coroutine.create, f)\n"
"    if not res then\n"
"        local params = {...}\n"
"        local newf = function() return f(unpack(params)) end\n"
"        co = coroutine.create(newf)\n"
"    end\n"
"    return performResume(err, co, ...)\n"
"end\n"
"\n"
"-------------------------------------------------------------------------------\n"
"-- Implements pcall with coroutines\n"
"-------------------------------------------------------------------------------\n"
"\n"
"local function id(trace, ...)\n"
"  return ...\n"
"end\n"
"\n"
"function copcall(f, ...)\n"
"    return coxpcall(f, id, ...)\n"
"end\n"
"",

"lanes","--\n"
"-- LANES.LUA\n"
"--\n"
"-- Multithreading and -core support for Lua\n"
"--\n"
"-- Author: Asko Kauppi <akauppi@gmail.com>\n"
"--\n"
"-- History:\n"
"--    Jun-08 AKa: major revise\n"
"--    15-May-07 AKa: pthread_join():less version, some speedup & ability to\n"
"--                   handle more threads (~ 8000-9000, up from ~ 5000)\n"
"--    26-Feb-07 AKa: serialization working (C side)\n"
"--    17-Sep-06 AKa: started the module (serialization)\n"
"--\n"
"--[[\n"
"===============================================================================\n"
"\n"
"Copyright (C) 2007-08 Asko Kauppi <akauppi@gmail.com>\n"
"\n"
"Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"of this software and associated documentation files (the \"Software\"), to deal\n"
"in the Software without restriction, including without limitation the rights\n"
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"copies of the Software, and to permit persons to whom the Software is\n"
"furnished to do so, subject to the following conditions:\n"
"\n"
"The above copyright notice and this permission notice shall be included in\n"
"all copies or substantial portions of the Software.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n"
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
"THE SOFTWARE.\n"
"\n"
"===============================================================================\n"
"]]--\n"
"\n"
"module( \"lanes\", package.seeall )\n"
"\n"
"require \"lua51-lanes\"\n"
"assert( type(lanes)==\"table\" )\n"
"\n"
"local mm= lanes\n"
"\n"
"local linda_id=    assert( mm.linda_id )\n"
"\n"
"local thread_new=   assert(mm.thread_new)\n"
"local thread_status= assert(mm.thread_status)\n"
"local thread_wait=  assert(mm.thread_wait)\n"
"local thread_cancel= assert(mm.thread_cancel)\n"
"\n"
"local _single= assert(mm._single)\n"
"local _version= assert(mm._version)\n"
"\n"
"local _deep_userdata= assert(mm._deep_userdata)\n"
"\n"
"local now_secs= assert( mm.now_secs )\n"
"local wakeup_conv= assert( mm.wakeup_conv )\n"
"local timer_gateway= assert( mm.timer_gateway )\n"
"\n"
"local max_prio= assert( mm.max_prio )\n"
"\n"
"\n"
"ABOUT= \n"
"{\n"
"    author= \"Asko Kauppi <akauppi@gmail.com>\",\n"
"    description= \"Running multiple Lua states in parallel\",\n"
"    license= \"MIT/X11\",\n"
"    copyright= \"Copyright (c) 2007-08, Asko Kauppi\",\n"
"    version= _version,\n"
"}\n"
"\n"
"\n"
"-- Making copies of necessary system libs will pass them on as upvalues;\n"
"-- only the first state doing \"require 'lanes'\" will need to have 'string'\n"
"-- and 'table' visible.\n"
"--\n"
"local string_gmatch= assert( string.gmatch )\n"
"\n"
"local function WR(str)\n"
"    io.stderr:write( str..\"\\n"
"\" )\n"
"end\n"
"\n"
"local function DUMP( tbl )\n"
"    if not tbl then return end\n"
"    local str=\"\"\n"
"    for k,v in pairs(tbl) do\n"
"        str= str..k..\"=\"..tostring(v)..\"\\n"
"\"\n"
"    end\n"
"    WR(str)\n"
"end\n"
"\n"
"\n"
"---=== Laning ===---\n"
"\n"
"-- lane_h[1..n]: lane results, same as via 'lanes_h:join()'\n"
"-- lane_h[0]:    can be read to make sure a thread has finished (always gives 'true')\n"
"-- lane_h[-1]:   error message, without propagating the error\n"
"--\n"
"--      Reading a Lane result (or [0]) propagates a possible error in the lane\n"
"--      (and execution does not return). Cancelled lanes give 'nil' values.\n"
"--\n"
"-- lane_h.state: \"pending\"/\"running\"/\"waiting\"/\"done\"/\"error\"/\"cancelled\"\n"
"--\n"
"local lane_mt= {\n"
"    __index= function( me, k )\n"
"                if type(k) == \"number\" then\n"
"                    -- 'me[0]=true' marks we've already taken in the results\n"
"                    --\n"
"                    if not rawget( me, 0 ) then\n"
"                        -- Wait indefinately; either propagates an error or\n"
"                        -- returns the return values\n"
"                        --\n"
"                        me[0]= true  -- marker, even on errors\n"
"\n"
"                        local t= { thread_wait(me._ud,-1) }   -- wait indefinate\n"
"\n"
"                        -- Use 'pairs' and not 'ipairs' so that nil holes in\n"
"                        -- the returned values are tolerated.\n"
"                        --\n"
"                        for i,v in pairs(t) do\n"
"                            me[i]= v\n"
"                        end\n"
"                    end\n"
"                    \n"
"                    -- Check errors even if we'd first peeked them via [-1]\n"
"                    -- (or '.error') and then came for the actual results.\n"
"                    --\n"
"                    if rawget(me, -1) and k~=-1 then\n"
"                        error( t[2], 3 )    -- level that takes to customer's code\n"
"                                            -- TBD: level does not seem to have effect!\n"
"                    end\n"
"                    return rawget( me, k )\n"
"                    --\n"
"                elseif k==\"status\" then     -- me.status\n"
"                    return thread_status(me._ud)\n"
"                    --\n"
"                else\n"
"                    error( \"Unknown key: \"..k )\n"
"                end\n"
"             end\n"
"    }\n"
"\n"
"-----\n"
"-- h= lanes.gen( [libs_str|opt_tbl [, ...],] lane_func ) ( [...] )\n"
"--\n"
"-- 'libs': nil:     no libraries available (default)\n"
"--         \"\":      only base library ('assert', 'print', 'unpack' etc.)\n"
"--         \"math,os\": math + os + base libraries (named ones + base)\n"
"--         \"*\":     all standard libraries available\n"
"--\n"
"-- 'opt': .priority:  int (-2..+2) smaller is lower priority (0 = default)\n"
"--\n"
"--	      .cancelstep: bool | uint\n"
"--            false: cancellation check only at pending Linda operations\n"
"--                   (send/receive) so no runtime performance penalty (default)\n"
"--            true:  adequate cancellation check (same as 100)\n"
"--            >0:    cancellation check every x Lua lines (small number= faster\n"
"--                   reaction but more performance overhead)\n"
"--\n"
"--        .globals:  table of globals to set for a new thread (passed by value)\n"
"--\n"
"--        ... (more options may be introduced later) ...\n"
"--\n"
"-- Calling with a function parameter ('lane_func') ends the string/table\n"
"-- modifiers, and prepares a lane generator. One can either finish here,\n"
"-- and call the generator later (maybe multiple times, with different parameters) \n"
"-- or add on actual thread arguments to also ignite the thread on the same call.\n"
"--\n"
"local lane_proxy\n"
"\n"
"local valid_libs= {\n"
"    [\"package\"]= true,\n"
"    [\"table\"]= true,\n"
"    [\"io\"]= true,\n"
"    [\"os\"]= true,\n"
"    [\"string\"]= true,\n"
"    [\"math\"]= true,\n"
"    [\"debug\"]= true,\n"
"    --\n"
"    [\"base\"]= true,\n"
"    [\"coroutine\"]= true,\n"
"    [\"*\"]= true\n"
"}\n"
"\n"
"function gen( ... )\n"
"    local opt= {}\n"
"    local libs= nil\n"
"    local lev= 2  -- level for errors\n"
"\n"
"    local n= select('#',...)\n"
"    \n"
"    if n==0 then\n"
"        error( \"No parameters!\" )\n"
"    end\n"
"\n"
"    for i=1,n-1 do\n"
"        local v= select(i,...)\n"
"        if type(v)==\"string\" then\n"
"            libs= libs and libs..\",\"..v or v\n"
"        elseif type(v)==\"table\" then\n"
"            for k,vv in pairs(v) do\n"
"                opt[k]= vv\n"
"            end\n"
"        elseif v==nil then\n"
"            -- skip\n"
"        else\n"
"            error( \"Bad parameter: \"..tostring(v) )\n"
"        end\n"
"    end\n"
"\n"
"    local func= select(n,...)\n"
"    if type(func)~=\"function\" then\n"
"        error( \"Last parameter not function: \"..tostring(func) )\n"
"    end\n"
"\n"
"    -- Check 'libs' already here, so the error goes in the right place\n"
"    -- (otherwise will be noticed only once the generator is called)\n"
"    --\n"
"    if libs then\n"
"        for s in string_gmatch(libs, \"[%a*]+\") do\n"
"            if not valid_libs[s] then\n"
"                error( \"Bad library name: \"..s )\n"
"            end\n"
"        end\n"
"    end\n"
"    \n"
"    local prio, cs, g_tbl\n"
"\n"
"    for k,v in pairs(opt) do\n"
"            if k==\"priority\" then prio= v\n"
"        elseif k==\"cancelstep\" then cs= (v==true) and 100 or\n"
"                                        (v==false) and 0 or \n"
"                                        type(v)==\"number\" and v or\n"
"                                        error( \"Bad cancelstep: \"..tostring(v), lev )\n"
"        elseif k==\"globals\" then g_tbl= v\n"
"        --..\n"
"        elseif k==1 then error( \"unkeyed option: \".. tostring(v), lev )\n"
"        else error( \"Bad option: \".. tostring(k), lev )\n"
"        end\n"
"    end\n"
"\n"
"    -- Lane generator\n"
"    --\n"
"    return function(...)\n"
"              return lane_proxy( thread_new( func, libs, cs, prio, g_tbl,\n"
"                                             ... ) )     -- args\n"
"           end\n"
"end\n"
"\n"
"lane_proxy= function( ud )\n"
"    local proxy= {\n"
"        _ud= ud,\n"
"        \n"
"        -- void= me:cancel()\n"
"        --\n"
"        cancel= function(me) thread_cancel(ud) end,\n"
"        \n"
"        -- [...]|[nil,err]= me:join( [wait_secs=-1] [,propagate=true] )\n"
"        --\n"
"        join= function( me, wait, propagate ) \n"
"                return thread_wait(ud,wait,propagate)\n"
"            end,\n"
"        }\n"
"    assert( proxy._ud )\n"
"    setmetatable( proxy, lane_mt )\n"
"\n"
"    return proxy\n"
"end\n"
"\n"
"\n"
"---=== Lindas ===---\n"
"\n"
"-- We let the C code attach methods to userdata directly\n"
"\n"
"-----\n"
"-- linda_ud= lanes.linda()\n"
"--\n"
"function linda()\n"
"    local proxy= _deep_userdata( linda_id )\n"
"    assert( (type(proxy) == \"userdata\") and getmetatable(proxy) )\n"
"    return proxy\n"
"end\n"
"\n"
"\n"
"---=== Timers ===---\n"
"\n"
"-- \n"
"-- Linda protocol to timer lane:\n"
"--\n"
"--  \"set\": linda_h, key, wakeup_at_secs|0, repeat_secs|0\n"
"--\n"
"local timer_gateway_key= \"set\"\n"
"local first_time_key= \"first time\"\n"
"\n"
"local first_time= timer_gateway:get(first_time_key) == nil\n"
"timer_gateway:set(first_time_key,true)\n"
"\n"
"-----\n"
"-- = timer( linda_h, key_val, date_tbl|first_secs [,period_secs] )\n"
"--\n"
"function timer( linda, key, a, period )\n"
"\n"
"    if a==0.0 then\n"
"        -- Stop the timer (no 'period') or anyways return right away\n"
"        --\n"
"        if period and period>0 then\n"
"            timer( linda, key, period, period )\n"
"        else\n"
"            timer_gateway:send( \"set\", linda, key, 0, 0 )   -- clear the timer\n"
"        end\n"
"        \n"
"        -- Caller expects to get current time stamp in Linda, on return\n"
"        -- (like the timer had expired instantly); do this as late as possible\n"
"        -- to get most accurate current time\n"
"        --\n"
"        linda:set( key, now_secs() )\n"
"\n"
"    else\n"
"        local wakeup_at= type(a)==\"table\" and wakeup_conv(a)    -- given point of time\n"
"                                           or now_secs()+a\n"
"        -- queue to timer\n"
"        --\n"
"        timer_gateway:send( \"set\", linda, key, wakeup_at, period or 0 )\n"
"    end\n"
"end\n"
"\n"
"--\n"
"-- Timer lane; initialize only on the first 'require \"lanes\"' instance\n"
"--\n"
"if first_time then\n"
"    local table_remove= assert( table.remove )\n"
"    local table_insert= assert( table.insert )\n"
"\n"
"    --\n"
"    -- { [deep_linda_lightuserdata]= { [deep_linda_lightuserdata]=linda_h, \n"
"    --                                 [key]= { wakeup_secs [,period_secs] } [, ...] },\n"
"    -- }\n"
"    --\n"
"    -- Collection of all running timers, indexed with linda's & key.\n"
"    --\n"
"    -- Note that we need to use the deep lightuserdata identifiers, instead\n"
"    -- of 'linda_h' themselves as table indices. Otherwise, we'd get multiple\n"
"    -- entries for the same timer.\n"
"    --\n"
"    -- The 'hidden' reference to Linda proxy is used in 'check_timers()' but\n"
"    -- also important to keep the Linda alive, even if all outside world threw\n"
"    -- away pointers to it (which would ruin uniqueness of the deep pointer).\n"
"    -- Now we're safe.\n"
"    --\n"
"    local collection= {}\n"
"\n"
"    --\n"
"    -- set_timer( linda_h, key, wakeup_at_secs|0 [, period_secs] )\n"
"    --\n"
"    local function set_timer( linda, key, wakeup_at, period )\n"
"    \n"
"        assert( type(wakeup_at)==\"number\" )\n"
"        assert( period==nil or type(period)==\"number\" )\n"
"\n"
"        local linda_deep= linda:deep()\n"
"        assert( linda_deep )\n"
"\n"
"        -- Find or make a lookup for this timer\n"
"        --\n"
"        local t1= collection[linda_deep]\n"
"        if not t1 then\n"
"            t1= { [linda_deep]= linda }     -- proxy to use the Linda\n"
"            collection[linda_deep]= t1\n"
"        end\n"
"    \n"
"        if wakeup_at==0 then\n"
"            -- Clear the timer\n"
"            --\n"
"            t1[key]= nil\n"
"\n"
"            -- Remove empty tables from collection; speeds timer checks and\n"
"            -- lets our 'safety reference' proxy be gc:ed as well.\n"
"            --\n"
"            local empty= true\n"
"            for k,_ in pairs(t1) do\n"
"                if k~= linda_deep then\n"
"                    empty= false; break\n"
"                end\n"
"            end\n"
"            if empty then\n"
"                collection[linda_deep]= nil\n"
"            end\n"
"            \n"
"            -- Note: any unread timer value is left at 'linda[key]' intensionally;\n"
"            --       clearing a timer just stops it.\n"
"        else\n"
"            -- New timer or changing the timings\n"
"            --\n"
"            local t2= t1[key]\n"
"            if not t2 then\n"
"                t2= {}; t1[key]= t2\n"
"            end\n"
"    \n"
"            t2[1]= wakeup_at\n"
"            t2[2]= period   -- can be 'nil'\n"
"        end\n"
"    end\n"
"\n"
"    -----\n"
"    -- [next_wakeup_at]= check_timers()\n"
"    --\n"
"    -- Check timers, and wake up the ones expired (if any)\n"
"    --\n"
"    -- Returns the closest upcoming (remaining) wakeup time (or 'nil' if none).\n"
"    --\n"
"    local function check_timers()\n"
"\n"
"        local now= now_secs()\n"
"        local next_wakeup\n"
"\n"
"        for linda_deep,t1 in pairs(collection) do\n"
"            for key,t2 in pairs(t1) do\n"
"                --\n"
"                if key==linda_deep then\n"
"                    -- no 'continue' in Lua :/\n"
"                else\n"
"                    -- 't2': { wakeup_at_secs [,period_secs] }\n"
"                    --\n"
"                    local wakeup_at= t2[1]\n"
"                    local period= t2[2]     -- may be 'nil'\n"
"                    \n"
"                    if wakeup_at <= now then    \n"
"                        local linda= t1[linda_deep]\n"
"                        assert(linda)\n"
"    \n"
"                        linda:set( key, now )\n"
"        \n"
"                        -- 'pairs()' allows the values to be modified (and even\n"
"                        -- removed) as far as keys are not touched\n"
"                                                \n"
"                        if not period then\n"
"                            -- one-time timer; gone\n"
"                            --\n"
"                            t1[key]= nil\n"
"                            wakeup_at= nil   -- no 'continue' in Lua :/\n"
"                        else\n"
"                            -- repeating timer; find next wakeup (may jump multiple repeats)\n"
"                            --\n"
"                            repeat\n"
"                                wakeup_at= wakeup_at+period\n"
"                            until wakeup_at > now\n"
"    \n"
"                            t2[1]= wakeup_at\n"
"                        end\n"
"                    end\n"
"                    \n"
"                    if wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\n"
"                        next_wakeup= wakeup_at\n"
"                    end \n"
"                end\n"
"            end -- t2 loop\n"
"        end -- t1 loop\n"
"        \n"
"        return next_wakeup  -- may be 'nil'\n"
"    end    \n"
"\n"
"    -----\n"
"    -- Snore loop (run as a lane on the background)\n"
"    --\n"
"    local function loop()\n"
"        while true do\n"
"\n"
"            local next_wakeup= check_timers()\n"
"\n"
"            -- Sleep until next timer to wake up, or a set/clear command\n"
"            --\n"
"            local secs= next_wakeup and (next_wakeup - now_secs()) or nil\n"
"            local linda= timer_gateway:receive( secs, timer_gateway_key )\n"
"\n"
"            if linda then\n"
"                local key= timer_gateway:receive( 0.0, timer_gateway_key )\n"
"                local wakeup_at= timer_gateway:receive( 0.0, timer_gateway_key )\n"
"                local period= timer_gateway:receive( 0.0, timer_gateway_key )\n"
"                assert( key and wakeup_at and period )\n"
"\n"
"                set_timer( linda, key, wakeup_at, period>0 and period or nil )\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"    --\n"
"    -- Run timer lane with high priority, to get trustworthy timings.\n"
"    --\n"
"    gen( \"io\", { priority=max_prio }, loop )()\n"
"end\n"
"\n"
"\n"
"\n"
"---=== Lock & atomic generators ===---\n"
"\n"
"-- These functions are just surface sugar, but make solutions easier to read.\n"
"-- Not many applications should even need explicit locks or atomic counters.\n"
"\n"
"--\n"
"-- lock_f= lanes.genlock( linda_h, key [,N_uint=1] )\n"
"--\n"
"-- = lock_f( +M )   -- acquire M\n"
"--      ...locked...\n"
"-- = lock_f( -M )   -- release M\n"
"--\n"
"-- Returns an access function that allows 'N' simultaneous entries between\n"
"-- acquire (+M) and release (-M). For binary locks, use M==1.\n"
"--\n"
"function genlock( linda, key, N )\n"
"    linda:limit(key,N)\n"
"    linda:set(key,nil)  -- clears existing data\n"
"\n"
"    --\n"
"    -- [true [, ...]= trues(uint)\n"
"    --\n"
"    local function trues(n)\n"
"        if n>0 then return true,trues(n-1) end\n"
"    end\n"
"\n"
"    return\n"
"    function(M)\n"
"        if M>0 then\n"
"            -- 'nil' timeout allows 'key' to be numeric\n"
"            linda:send( nil, key, trues(M) )    -- suspends until been able to push them\n"
"        else\n"
"            for i=1,-M do\n"
"                linda:receive( key )\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"\n"
"--\n"
"-- atomic_f= lanes.genatomic( linda_h, key [,initial_num=0.0] )\n"
"--\n"
"-- int= atomic_f( [diff_num=1.0] )\n"
"--\n"
"-- Returns an access function that allows atomic increment/decrement of the\n"
"-- number in 'key'.\n"
"--\n"
"function genatomic( linda, key, initial_val )\n"
"    linda:limit(key,2)          -- value [,true]\n"
"    linda:set(key,initial_val or 0.0)   -- clears existing data (also queue)\n"
"\n"
"    return\n"
"    function(diff)\n"
"        -- 'nil' allows 'key' to be numeric\n"
"        linda:send( nil, key, true )    -- suspends until our 'true' is in\n"
"        local val= linda:get(key) + (diff or 1.0)\n"
"        linda:set( key, val )   -- releases the lock, by emptying queue\n"
"        return val\n"
"    end\n"
"end\n"
"\n"
"\n"
"--the end\n"
"",

"fenestra.avatar","\n"
"local bit=require('bit')\n"
"\n"
"\n"
"-- very simple xml parsing into a table\n"
"local sxml=require(\"simpxml\")\n"
"\n"
"local string=string\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local math=math\n"
"local loadstring=loadstring\n"
"local pcall=pcall\n"
"local error=error\n"
"local io=io\n"
"local type=type\n"
"local tonumber=tonumber\n"
"\n"
"-- imported global functions\n"
"local sub = string.sub\n"
"local match = string.match\n"
"local find = string.find\n"
"local push = table.insert\n"
"local pop = table.remove\n"
"local append = table.insert\n"
"local concat = table.concat\n"
"local floor = math.floor\n"
"local write = io.write\n"
"local read = io.read\n"
"local type = type\n"
"local setfenv = setfenv\n"
"local tostring=tostring\n"
"local pairs=pairs\n"
"local ipairs=ipairs\n"
"local unpack=unpack\n"
"\n"
"local _G = _G\n"
"\n"
"local apps=apps\n"
"local wldir=apps.dir or \"\"\n"
"\n"
"module(\"fenestra.avatar\")\n"
"\n"
"--\n"
"-- avatar part group information\n"
"--\n"
"-- group is where the object is located, IE head\n"
"-- then look up the actual xox filename using the easy name used on a soul \n"
"-- finally you now have a chunk of data that describes this xox\n"
"--\n"
"xox_groups={\n"
"\n"
"inmouth =\n"
"{ \n"
"	joint					= { xox=	\"inmouth_joint\"			; boi=1; grl=1; active=1; };\n"
"	fag						= { xox=	\"inmouth_fag\"			; boi=1; grl=1; active=1; };\n"
"	pipe					= { xox=	\"inmouth_pipe\"			; boi=1; grl=1; active=1; };\n"
"	cigar					= { xox=	\"inmouth_cigar\"			; boi=1; grl=1; active=1; };\n"
"	sushi_nigiri			= { xox=	\"inmouth_sushi_nigiri\"	; boi=1; grl=1; active=1; };\n"
"},\n"
"\n"
"inhand =\n"
"{ \n"
"	dagger					= { xox=	\"item_dagger_fist\"			; boi=1; grl=1; active=1; };\n"
"	hammer					= { xox=	\"item_hammer_fist\"			; boi=1; grl=1; active=1; };\n"
"	pistol					= { xox=	\"item_pistol_fist\"			; boi=1; grl=1; active=1; };\n"
"	joint					= { xox=	\"item_joint_fist\"			; boi=1; grl=1; active=1; };\n"
"	fag						= { xox=	\"item_fag_fist\"				; boi=1; grl=1; active=1; };\n"
"	joint					= { xox=	\"item_joint_fist\"			; boi=1; grl=1; active=1; };\n"
"	pipe					= { xox=	\"item_pipe_fist\"			; boi=1; grl=1; active=1; };\n"
"	cigar					= { xox=	\"item_cigar_fist\"			; boi=1; grl=1; active=1; };\n"
"	bottle					= { xox=	\"item_bottle_fist\"			; boi=1; grl=1; active=1; };\n"
"	bottle_smashed			= { xox=	\"item_bottle_smashed_fist\"	; boi=1; grl=1; active=1; };\n"
"},\n"
"\n"
"beard =\n"
"{ \n"
"	default					= { xox=	\"beard_circle\"			; boi=1; grl=0; active=1; };\n"
"	circle					= { xox=	\"beard_circle\"			; boi=1; grl=0; active=1; };\n"
"	circle_point			= { xox=	\"beard_circle_point\"	; boi=1; grl=0; active=1; };\n"
"	tash					= { xox=	\"beard_tash\"			; boi=1; grl=0; active=1; };\n"
"	whiskers				= { xox=	\"beard_whiskers\"		; boi=0; grl=0; active=1; };\n"
"},\n"
"\n"
"body =\n"
"{ \n"
"	\n"
"	bare					= { xox=	\"body_bare\"				; boi=1; grl=0; active=1; };\n"
"	bare_boobs				= { xox=	\"body_bare_boobs\"		; boi=0; grl=1; active=1; };\n"
"	\n"
"	robox					= { xox=	\"body_robox\"			; boi=0; grl=0; active=1; };\n"
"	\n"
"	bodess					= { xox=	\"body_bodess\"			; boi=0; grl=1; active=1; };\n"
"	\n"
"	tshirt					= { xox=	\"body_tshirt\"			; boi=1; grl=0; active=1; };\n"
"	tshirt_boobs			= { xox=	\"body_tshirt_boobs\"		; boi=0; grl=1; active=1; };\n"
"	tshirt_boobs_low		= { xox=	\"body_tshirt_boobs_low\"	; boi=0; grl=1; active=1; };\n"
"	\n"
"	coat					= { xox=	\"body_coat\"				; boi=1; grl=0; active=1; };\n"
"	overalls				= { xox=	\"body_overalls\"			; boi=1; grl=0; active=1; };\n"
"	vest					= { xox=	\"body_vest\"				; boi=1; grl=0; active=1; };\n"
"	vest_boobs				= { xox=	\"body_vest_boobs\"		; boi=0; grl=1; active=1; };\n"
"	\n"
"	tie						= { xox=	\"body_tie\"				; boi=1; grl=0; active=1; };\n"
"	tie_boobs				= { xox=	\"body_tie_boobs\"		; boi=0; grl=1; active=1; };\n"
"\n"
"	default					= { xox=	\"body\"					; boi=1; grl=0; active=1; };\n"
"	bare_boobs_small		= { xox=	\"body_bare_boobsa\"		; boi=0; grl=1; active=0; };\n"
"	bare_boobs_medium		= { xox=	\"body_bare_boobsc\"		; boi=0; grl=1; active=0; };\n"
"	bare_boobs_large		= { xox=	\"body_bare_boobse\"		; boi=0; grl=1; active=0; };\n"
"	bare_chest				= { xox=	\"body_bare_chest\"		; boi=1; grl=0; active=0; };\n"
"	bare_gut				= { xox=	\"body_bare_gut\"			; boi=1; grl=0; active=0; };\n"
"	bodess_medium			= { xox=	\"body_bodessc\"			; boi=0; grl=1; active=0; };\n"
"	bodess_large			= { xox=	\"body_bodesse\"			; boi=0; grl=1; active=0; };\n"
"	tshirt_boobs_small		= { xox=	\"body_tshirt_boobsa\"	; boi=0; grl=1; active=0; };\n"
"	tshirt_boobs_medium		= { xox=	\"body_tshirt_boobsc\"	; boi=0; grl=1; active=0; };\n"
"	tshirt_boobs_large		= { xox=	\"body_tshirt_boobse\"	; boi=0; grl=1; active=0; };\n"
"	tshirt_chest			= { xox=	\"body_tshirt_chest\"		; boi=1; grl=0; active=0; };\n"
"	tshirt_gut				= { xox=	\"body_tshirt_gut\"		; boi=1; grl=0; active=0; };\n"
"	tshirt_lowcut_large		= { xox=	\"body_tshirt_lowcute\"	; boi=0; grl=3; active=0; };\n"
"	tshirt_skinny			= { xox=	\"body_tshirt_skinny\"	; boi=1; grl=0; active=0; };\n"
"	\n"
"},\n"
"\n"
"tail =\n"
"{ \n"
"	default					= { xox=	\"tail\"					; boi=1; grl=1; active=1; };\n"
"	bunny					= { xox=	\"tail_bunny\"			; boi=0; grl=1; active=1; };\n"
"	devil					= { xox=	\"tail_devil\"			; boi=0; grl=1; active=1; };\n"
"},\n"
"\n"
"\n"
"ear =\n"
"{ \n"
"	default					= { xox=	\"ear\"					; boi=1; grl=1; active=1; };\n"
"	big						= { xox=	\"ear_big\"				; boi=1; grl=1; active=1; };\n"
"	big_sticky				= { xox=	\"ear_big_sticky\"		; boi=1; grl=1; active=1; };\n"
"	robox					= { xox=	\"ear_robox\"				; boi=0; grl=0; active=1; };\n"
"},\n"
"\n"
"\n"
"eye =\n"
"{ \n"
"	default					= { xox=	\"eye\"					; boi=1; grl=1; active=1; };\n"
"	bigbrow					= { xox=	\"eye_bigbrow\"			; boi=1; grl=1; active=1; };\n"
"	brow					= { xox=	\"eye_brow\"				; boi=0; grl=0; active=1; };\n"
"	tribrow					= { xox=	\"eye_tribrow\"			; boi=1; grl=1; active=1; };\n"
"	robox					= { xox=	\"eye_robox\"				; boi=0; grl=0; active=1; };\n"
"},\n"
"\n"
"\n"
"eyeball =\n"
"{ \n"
"	default					= { xox=	\"eyeball\"				; boi=5; grl=5; active=1; };\n"
"	diamond					= { xox=	\"eyeball_cat\"			; boi=1; grl=1; active=1; };\n"
"},\n"
"\n"
"\n"
"foot =\n"
"{ \n"
"	default					= { xox=	\"foot\"					; boi=1; grl=1; active=1; };\n"
"	bare					= { xox=	\"foot_bare\"				; boi=1; grl=1; active=1; };\n"
"	boot					= { xox=	\"foot_boot\"				; boi=1; grl=1; active=1; };\n"
"	flipflop				= { xox=	\"foot_flipflop\"			; boi=1; grl=1; active=1; };\n"
"	slipper					= { xox=	\"foot_slipper\"			; boi=1; grl=1; active=1; };\n"
"	heel					= { xox=	\"foot_heel\"				; boi=0; grl=1; active=1; };\n"
"	shoe					= { xox=	\"foot_shoe\"				; boi=1; grl=1; active=1; };\n"
"	hoof					= { xox=	\"foot_hoof\"				; boi=0; grl=0; active=1; };\n"
"	robox					= { xox=	\"foot_robox\"			; boi=0; grl=0; active=1; };\n"
"},\n"
"\n"
"\n"
"hair =\n"
"{ \n"
"	topspiked_short			= { xox=	\"hair_topspiked_short\"		; boi=1; grl=1; active=1; };\n"
"	peak					= { xox=	\"hair_peak\"					; boi=1; grl=1; active=1; };\n"
"	\n"
"	bob						= { xox=	\"hair_bob\"					; boi=1; grl=1; active=1; };\n"
"	goth_long				= { xox=	\"hair_goth_long\"			; boi=1; grl=1; active=1; };\n"
"	spikey_short			= { xox=	\"hair_spikey_short\"			; boi=1; grl=1; active=1; };\n"
"	trihawk_short			= { xox=	\"hair_trihawk_short\"		; boi=1; grl=1; active=1; };\n"
"	trihawk_hi				= { xox=	\"hair_trihawk_hi\"			; boi=1; grl=1; active=1; };\n"
"	hedgehog				= { xox=	\"hair_hedgehog\"				; boi=1; grl=1; active=1; };\n"
"	afro					= { xox=	\"hair_afro\"					; boi=1; grl=1; active=1; };\n"
"	afro_tall				= { xox=	\"hair_afro_tall\"			; boi=1; grl=1; active=1; };\n"
"		\n"
"	quiff					= { xox=	\"hair_quiff\"				; boi=1; grl=1; active=1; };\n"
"	curl_left				= { xox=	\"hair_curl_left\"			; boi=1; grl=1; active=1; };\n"
"	curl_right				= { xox=	\"hair_curl_right\"			; boi=1; grl=1; active=1; };\n"
"},\n"
"\n"
"hair_base =\n"
"{ \n"
"	default					= { xox=	\"hair\"						; boi=1; grl=1; active=1; };\n"
"	bowl					= { xox=	\"hair_bowl\"					; boi=1; grl=1; active=1; };\n"
"},\n"
"\n"
"hair_xtra =\n"
"{ \n"
"	ponytail				= { xox=	\"hair_ponytail\"				; boi=1; grl=1; active=1; };\n"
"	pigtails				= { xox=	\"hair_pigtails\"				; boi=1; grl=1; active=1; };\n"
"	long					= { xox=	\"hair_long\"					; boi=1; grl=1; active=1; };\n"
"	bunches					= { xox=	\"hair_bunches\"				; boi=1; grl=1; active=1; };\n"
"	bang					= { xox=	\"hair_bang_base\"			; boi=1; grl=1; active=1; };\n"
"	bang_zigs				= { xox=	\"hair_bang_zigs\"			; boi=1; grl=1; active=1; };\n"
"	bang_goff				= { xox=	\"hair_bang_goff\"			; boi=1; grl=1; active=1; };\n"
"	bang_sidel				= { xox=	\"hair_bang_sidel\"			; boi=1; grl=1; active=1; };\n"
"	bang_sider				= { xox=	\"hair_bang_sider\"			; boi=1; grl=1; active=1; };\n"
"	bang_emol				= { xox=	\"hair_bang_emol\"			; boi=1; grl=1; active=1; };\n"
"	bang_emor				= { xox=	\"hair_bang_emor\"			; boi=1; grl=1; active=1; };\n"
"	bang_nerd				= { xox=	\"hair_bang_nerd\"			; boi=1; grl=1; active=1; };\n"
"	bang_hugh				= { xox=	\"hair_bang_hugh\"			; boi=1; grl=1; active=1; };\n"
"},\n"
"\n"
"hat =\n"
"{ \n"
"	baseball				= { xox=	\"hat_baseball\"				; boi=1; grl=1; active=1; };\n"
"	pirate					= { xox=	\"hat_pirate\"				; boi=1; grl=1; active=1; };\n"
"	kerchief				= { xox=	\"hat_kerchief\"				; boi=1; grl=1; active=1; };\n"
"	bunny_ears				= { xox=	\"hat_bunny_ears\"			; boi=1; grl=1; active=1; };\n"
"},\n"
"\n"
"\n"
"hand =\n"
"{ \n"
"	default					= { xox=	\"hand\"					; boi=1; grl=1; active=1; };\n"
"	foot					= { xox=	\"hand_foot\"				; boi=0; grl=0; active=1; };\n"
"	hoof					= { xox=	\"hand_hoof\"				; boi=0; grl=0; active=1; };\n"
"	robox					= { xox=	\"hand_robox\"			; boi=0; grl=0; active=1; };\n"
"},\n"
"\n"
"\n"
"head =\n"
"{ \n"
"	default					= { xox=	\"head\"					; boi=1; grl=1; active=1; };\n"
"	cheekbones				= { xox=	\"head_cheakbones\"		; boi=1; grl=1; active=0; };\n"
"	chub					= { xox=	\"head_chub\"				; boi=1; grl=1; active=0; };\n"
"	thin					= { xox=	\"head_thin\"				; boi=1; grl=1; active=0; };\n"
"	skull					= { xox=	\"head_skull\"			; boi=0; grl=0; active=1; };\n"
"	robox					= { xox=	\"head_robox\"			; boi=0; grl=0; active=1; };\n"
"	chinless				= { xox=	\"head_chinless\"			; boi=0; grl=1; active=1; };\n"
"},\n"
"\n"
"\n"
"mouth =\n"
"{ \n"
"	default					= { xox=	\"mouth\"					; boi=1; grl=1; active=1; };\n"
"	bow						= { xox=	\"mouth_bow\"				; boi=1; grl=1; active=1; };\n"
"	bow_fat					= { xox=	\"mouth_bow_fat\"			; boi=1; grl=1; active=1; };\n"
"	bow_thin				= { xox=	\"mouth_bow_thin\"		; boi=1; grl=1; active=1; };\n"
"	fat						= { xox=	\"mouth_fat\"				; boi=1; grl=1; active=1; };\n"
"	thin					= { xox=	\"mouth_thin\"			; boi=1; grl=1; active=1; };\n"
"	beak					= { xox=	\"mouth_beak\"			; boi=0; grl=0; active=1; };\n"
"	squid					= { xox=	\"mouth_squid\"			; boi=0; grl=0; active=1; };\n"
"	jaw						= { xox=	\"mouth_jaw\"				; boi=0; grl=0; active=1; };\n"
"	robox					= { xox=	\"mouth_robox\"			; boi=0; grl=0; active=1; };\n"
"},\n"
"\n"
"\n"
"nose =\n"
"{ \n"
"	default					= { xox=	\"nose\"					; boi=1; grl=1; active=1; };\n"
"	small					= { xox=	\"nose_small\"			; boi=1; grl=1; active=1; };\n"
"	small_up				= { xox=	\"nose_small_up\"			; boi=1; grl=1; active=1; };\n"
"	snub					= { xox=	\"nose_snub\"				; boi=1; grl=1; active=1; };\n"
"	wide					= { xox=	\"nose_wide\"				; boi=1; grl=1; active=1; };\n"
"	wide_up					= { xox=	\"nose_wide_up\"			; boi=1; grl=1; active=1; };\n"
"	clown					= { xox=	\"nose_clown\"			; boi=0; grl=0; active=1; };\n"
"	snout					= { xox=	\"nose_snout\"			; boi=0; grl=0; active=1; };\n"
"	robox					= { xox=	\"nose_robox\"			; boi=0; grl=0; active=1; };\n"
"},\n"
"\n"
"\n"
"specs =\n"
"{ \n"
"	default					= { xox=	\"specs\"					; boi=1; grl=1; active=1; };\n"
"	round					= { xox=	\"specs_round\"			; boi=1; grl=1; active=1; };\n"
"	eyepatch_left			= { xox=	\"specs_eyepatch_left\"	; boi=1; grl=1; active=1; };\n"
"	eyepatch_right			= { xox=	\"specs_eyepatch_right\"	; boi=1; grl=1; active=1; };\n"
"},\n"
"\n"
"}\n"
"for g,t in pairs(xox_groups) do\n"
"	for n,v in pairs(t) do\n"
"		v.group=g\n"
"		v.name=n\n"
"	end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split a string into a table\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function split(div,str)\n"
"\n"
"  if (div=='') or not div then error(\"div expected\", 2) end\n"
"  if (str=='') or not str then error(\"str expected\", 2) end\n"
"  \n"
"  local pos,arr = 0,{}\n"
"  \n"
"  -- for each divider found\n"
"  for st,sp in function() return string.find(str,div,pos,false) end do\n"
"	table.insert(arr,sub(str,pos,st-1)) -- Attach chars left of current divider\n"
"	pos = sp + 1 -- Jump past current divider\n"
"  end\n"
"  \n"
"  if pos~=0 then\n"
"	table.insert(arr,sub(str,pos)) -- Attach chars right of last divider\n"
"  else\n"
"	table.insert(arr,str) -- return entire string\n"
"  end\n"
"  \n"
"  \n"
"  return arr\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- find the basename from a filename\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function get_basename(name)\n"
"\n"
"	local a1=split(\"%/\",name)\n"
"	local a2=split(\"%.\",a1[#a1])\n"
"	local a3=split(\"%_\",a2[1])\n"
"	local s=a3[1]\n"
"	\n"
"	if s==\"left\" or s==\"right\" then s=a3[2] end\n"
"	\n"
"	return s\n"
"end\n"
"\n"
"function setup(win)\n"
"\n"
"	local function print(...)\n"
"		win._g.print(...)\n"
"	end\n"
"\n"
"	local ogl=win.ogl\n"
"\n"
"	local it={}\n"
"	\n"
"	it.basename_map={\n"
"		[	\"body\"			]	=	\"body\"				,\n"
"		[	\"head\"			]	=	\"head\"				,\n"
"		[	\"foot\"			]	=	\"left_foot\"			,\n"
"		[	\"foot_flip\"		]	=	\"right_foot\"		,\n"
"		[	\"hair\"			]	=	\"hair\"				,\n"
"		[	\"ear\"			]	=	\"left_ear\"			,\n"
"		[	\"ear_flip\"		]	=	\"right_ear\"			,\n"
"		[	\"nose\"			]	=	\"nose\"				,\n"
"		[	\"mouth\"			]	=	\"mouth\"				,\n"
"		[	\"eye\"			]	=	\"left_eye\"			,\n"
"		[	\"eye_flip\"		]	=	\"right_eye\"			,\n"
"		[	\"tail\"			]	=	\"tail\"				,\n"
"		[	\"hand\"			]	=	\"left_hand\"			,\n"
"		[	\"hand_flip\" 	]	=	\"right_hand\"		,\n"
"		[	\"eyeball\"		]	=	\"left_eyeball\"		,\n"
"		[	\"eyeball_flip\"	]	=	\"right_eyeball\"		,\n"
"	}\n"
"	\n"
"	it.bodyparts={\n"
"		body				={\"body\"},\n"
"		head				={\"head\"},\n"
"		left_foot			={\"foot\"},\n"
"		right_foot			={\"foot\"},\n"
"		hair				={\"hair\"},\n"
"		left_ear			={\"ear\"},\n"
"		right_ear			={\"ear\"},\n"
"		nose				={\"nose\"},\n"
"		mouth				={\"mouth\"},\n"
"		left_eye			={\"eye\"},\n"
"		right_eye			={\"eye\"},\n"
"		tail				={\"tail\"},\n"
"		left_hand			={\"hand\"},\n"
"		right_hand			={\"hand\"},\n"
"		left_eyeball		={\"eyeball\"},\n"
"		right_eyeball		={\"eyeball\"},\n"
"	}\n"
"	\n"
"	function it.clean()\n"
"\n"
"	end\n"
"\n"
"\n"
"--\n"
"-- Load avatar parts into an xsx for display\n"
"--	\n"
"	function it.map_xsx(xsx,soul)\n"
"	\n"
"\n"
"		for i,v in ipairs(xsx.items) do\n"
"		\n"
"			local name=get_basename(v.name)\n"
"			local flip=((v.flags%2)==1)\n"
"			if flip then name=name..\"_flip\" end\n"
"			\n"
"			local name=it.basename_map[name]\n"
"			\n"
"--			print(name or i)\n"
"			\n"
"			if name then\n"
"				local part=soul.vanilla.parts[name]\n"
"				if part then\n"
"					v.fname=v.fname or {}\n"
"					v.data=v.data or {}\n"
"					v.soulinfo=v.soulinfo or {}\n"
"					\n"
"					v.size[1]=part.xsize or 1 -- v.size[1]\n"
"					v.size[2]=part.ysize or 1 -- v.size[2]\n"
"					v.size[3]=part.zsize or 1 -- v.size[3]\n"
"					\n"
"					v.morphs[1]=part.morph0 or 0\n"
"					v.morphs[2]=part.morph1 or 0\n"
"					v.morphs[3]=part.morph2 or 0\n"
"					v.morphs[4]=part.morph3 or 0\n"
"					\n"
"					v.pos[1]=part.xpos or 0 -- v.size[1]\n"
"					v.pos[2]=part.ypos or 0 -- v.size[2]\n"
"					v.pos[3]=part.zpos or 0 -- v.size[3]\n"
"					\n"
"					for i=1,4 do\n"
"					\n"
"						v.soulinfo[i]=part[i]\n"
"							\n"
"						if part[i] and part[i].xox_info and part[i].xox_info.xox then\n"
"					\n"
"							local fname=\"data/avatar/xox/\"..part[i].xox_info.xox..\".xox\"\n"
"							\n"
"							if v.fname[i]~=fname then\n"
"							\n"
"								if v[i] then v[i].clean() end\n"
"								\n"
"								v.data[i]=win.data.load(fname)\n"
"								v[i]=win.xox(v.data[i])\n"
"								v.fname[i]=fname\n"
"								\n"
"							end\n"
"							\n"
"							if v[i] then\n"
"								for i,v in ipairs(v[i].surfaces or {}) do\n"
"								\n"
"									local surf=soul.vanilla.surfaces[v.name]\n"
"									if surf then\n"
"										v.argb =surf.argb  or v.argb\n"
"										v.spec =surf.spec  or v.spec\n"
"										v.gloss=surf.gloss or v.gloss\n"
"									end\n"
"--print(\"surf:\"..v.name..\" \"..v.spec..\" \"..v.gloss)\n"
"								\n"
"								end\n"
"								\n"
"								v[i].set()\n"
"							end\n"
"							\n"
"							\n"
"						else\n"
"							if v[i] then v[i].clean() end\n"
"							v[i]=nil\n"
"							v.fname[i]=nil\n"
"							v.data[i]=nil\n"
"						end\n"
"					end\n"
"					\n"
"				end\n"
"			end\n"
"		end\n"
"		\n"
"		xsx.set()\n"
"\n"
"	end\n"
"	\n"
"--\n"
"-- Load an avatars soul (xml file)\n"
"--	\n"
"	function it.load_soul(filename,d)\n"
"	\n"
"		local soul={}\n"
"		if not d then -- did not pass in data, read it from a file\n"
"--print(\"soul : \"..filename)\n"
"			local fp=io.open(filename,\"r\")\n"
"			d=fp:read(\"*a\")\n"
"			fp:close()\n"
"		end\n"
"		\n"
"		local tab=sxml.parse(d)\n"
"--print(sxml.tree_to_string(tab))\n"
"		local t=tab\n"
"		\n"
"		local function isa(t,s)\n"
"			if type(t)~=\"table\" then return false end\n"
"			if t[0]==s then return true end\n"
"			return false\n"
"		end\n"
"		\n"
"		local function fromhex(s)\n"
"			if s then\n"
"				if s:sub(1,2)==\"0x\" then\n"
"					return tonumber(s:sub(3),16)\n"
"				else\n"
"					return tonumber(s,16)\n"
"				end\n"
"			end\n"
"			return nil\n"
"		end\n"
"		local function fromnum(s)\n"
"			if s then return tonumber(s) end\n"
"			return nil\n"
"		end\n"
"		\n"
"		t=sxml.child(t,\"soul\")\n"
"		for i,v in ipairs(t) do\n"
"		\n"
"			if isa(v,\"flavour\") then -- for each flavour\n"
"			\n"
"				local dat={}\n"
"				soul[v.name]=dat\n"
"				dat.parts={}\n"
"				dat.surfaces={}\n"
"			\n"
"				for i,v in ipairs(v) do\n"
"				\n"
"					if isa(v,\"part\") then -- for each part\n"
"					\n"
"						local p={}\n"
"						dat.parts[v.name]=p\n"
"						\n"
"						for i,v in pairs(v) do\n"
"							if type(i)==\"string\" then -- set all attribs\n"
"								if i~=\"name\" then\n"
"									p[i]=v\n"
"								end\n"
"							end\n"
"						end\n"
"						\n"
"						local idx=1\n"
"						for i,v in ipairs(v) do\n"
"							if type(v)==\"table\" and v[0]==\"object\" then -- an object\n"
"								local o={}\n"
"								p[idx]=o\n"
"								\n"
"								for i,v in pairs(v) do\n"
"									if type(i)==\"string\" then -- set all attribs\n"
"										o[i]=v\n"
"									end\n"
"								end\n"
"								\n"
"								o.xox_info=xox_groups[ o.group ]\n"
"								if o.xox_info then\n"
"									o.xox_info=o.xox_info[ o.name ]\n"
"								end\n"
"								\n"
"								\n"
"								idx=idx+1\n"
"								if idx>4 then break end\n"
"							end\n"
"						end\n"
"						\n"
"						p.xpos=fromnum(p.xpos)\n"
"						p.ypos=fromnum(p.ypos)\n"
"						p.zpos=fromnum(p.zpos)\n"
"						\n"
"						p.xsize=fromnum(p.xsize)\n"
"						p.ysize=fromnum(p.ysize)\n"
"						p.zsize=fromnum(p.zsize)\n"
"						\n"
"						p.morph0=fromnum(p.morph0)\n"
"						p.morph1=fromnum(p.morph1)\n"
"						p.morph2=fromnum(p.morph2)\n"
"						p.morph3=fromnum(p.morph3)\n"
"\n"
"					\n"
"					elseif isa(v,\"surface\") then -- for each surface\n"
"					\n"
"						local p={}\n"
"						dat.surfaces[v.name]=p\n"
"						\n"
"						for i,v in pairs(v) do\n"
"							if type(i)==\"string\" then -- set all attribs\n"
"								if i~=\"name\" then\n"
"									p[i]=v\n"
"								end\n"
"							end\n"
"						end\n"
"						\n"
"						p.argb=bit.bor(fromhex(p.argb),0xff000000)\n"
"						p.spec=bit.bor(fromhex(p.spec),0xff000000)\n"
"						p.gloss=2+(tonumber(p.gloss)*126) -- make 0 a \"good gloss number\"\n"
"						\n"
"					end\n"
"					\n"
"				end\n"
"				\n"
"			end\n"
"		end\n"
"		\n"
"--		print(soul)\n"
"\n"
"\n"
"-- whoops spilling\n"
"		soul.vanilla=soul.vanilla or soul.vanila\n"
"		soul.vanila=nil\n"
"-- whoops spilling\n"
"\n"
"		return soul\n"
"	end\n"
"	\n"
"--\n"
"-- Save an avatars soul (xml file)\n"
"--	\n"
"	function it.save_soul(soul,filename)\n"
"	\n"
"		local tree={}\n"
"		tree[1]={[0]=\"soul\",version=\"1.0\"}\n"
"		for i,v in pairs(soul) do\n"
"			local t=tree[1]\n"
"			t[#t+1]={[0]=\"flavour\",name=i}\n"
"			t=t[#t]\n"
"			for i,v in pairs(v.parts) do\n"
"				t[#t+1]={[0]=\"part\",name=i}\n"
"				local p=t[#t]\n"
"				for ii,vv in pairs(v) do\n"
"					if type(ii)==\"string\" then\n"
"						p[ii]=tostring(vv)\n"
"					end\n"
"				end\n"
"				for i=1,4 do\n"
"					p[#p+1]={[0]=\"object\"}\n"
"					local o=p[#p]\n"
"					for ii,vv in pairs(v[i] or {}) do\n"
"						if type(ii)==\"string\" and type(vv)~=\"table\" then\n"
"							o[ii]=tostring(vv)\n"
"						end\n"
"					end\n"
"				end\n"
"			end\n"
"			for i,v in pairs(v.surfaces) do\n"
"				t[#t+1]={[0]=\"surface\",name=i}\n"
"				local s=t[#t]\n"
"				for ii,vv in pairs(v) do\n"
"					if type(ii)==\"string\" then\n"
"						s[ii]=tostring(vv)\n"
"					end\n"
"				end\n"
"				if s.argb then s.argb=string.format(\"0x%08x\",s.argb) end -- use hex\n"
"				if s.spec then s.spec=string.format(\"0x%08x\",s.spec) end -- use hex\n"
"				if s.gloss then s.gloss=(s.gloss-2)/126 end -- slight number fiddle, sorry\n"
"			end\n"
"		end\n"
"	\n"
"		local fp=io.open(filename,\"w\")\n"
"		if not fp then return false,\"open failed\" end\n"
"		fp:write(\n"
"		sxml.tree_to_string(tree))\n"
"		fp:close()\n"
"		\n"
"		return true\n"
"	end\n"
"	\n"
"	return it\n"
"end\n"
"",

"fenestra.font","\n"
"\n"
"--\n"
"-- draw a font\n"
"--\n"
"\n"
"\n"
"\n"
"\n"
"module(\"fenestra.font\")\n"
"\n"
"\n"
"--\n"
"-- Return a font object we can use to draw text with\n"
"--\n"
"-- \"base\" is the built in 8x8 font\n"
"-- \"sans\" is the default proportional font\n"
"--\n"
"function setup(win,name)\n"
"\n"
"\n"
"	local font={}\n"
"	\n"
"	font.name=nil -- base by default\n"
"	if name==\"sans\" then font.name=\"sans\" end\n"
"	\n"
"	font.sx=8 -- base size of each char in this font\n"
"	font.sy=8\n"
"	\n"
"	font.px=0 -- current drawing position for this font\n"
"	font.py=0\n"
"	\n"
"	font.color=0xffffffff -- the current color to draw in\n"
"	\n"
"--\n"
"-- To simplify drawing the fonts are drawn not at the baseline but as their top/left corners\n"
"-- this way we can return a width and height of the total area neeeded to draw, you will need to handle\n"
"-- baseline offsets when positioning text. The whole baseline thing is a bit oldskool anyhow.\n"
"-- If you wish to have multiple sized fonts on a single line it is better if we make that\n"
"-- as hard as possible :)\n"
"--\n"
"-- also fonts are drawn in the directions of x++ and y--,\n"
"-- use open gl transforms to position the 0,0 wherever you want before drawing here\n"
"--	\n"
"	\n"
"--\n"
"-- cleanup this font\n"
"--\n"
"	function font.clean()\n"
"	end\n"
"	\n"
"--\n"
"-- make this font active\n"
"--\n"
"	function font.active(force)\n"
"		if force or win.font ~= font then\n"
"			win.font=font\n"
"			win.flat_font(font.name)\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- set the position and color and size, any input may be nil for no change\n"
"--\n"
"	function font.set(px,py,color,sx,sy)\n"
"		font.active()\n"
"		font.px=px or font.px\n"
"		font.py=py or font.py\n"
"		font.color=color or font.color		\n"
"		font.sx=sx or font.sx\n"
"		font.sy=sy or sx or font.sy\n"
"		\n"
"	end\n"
"--\n"
"-- how big an area does this string require, return width,height\n"
"--\n"
"	function font.size(text,size)\n"
"		font.active()\n"
"		if size then font.sx=size font.sy=size end\n"
"		if text then return win.flat_measure({size=font.sx,s=text}) , font.sy end\n"
"	end\n"
"--\n"
"-- draw this string, optionally apply a different color to each char using the colors array\n"
"--\n"
"	function font.draw(text,colors)\n"
"		font.active()\n"
"		win.flat_print({x=font.px,y=font.py,size=font.sx,color=font.color,s=text,c=colors})\n"
"	end\n"
"--\n"
"-- number of characters that fit in this width\n"
"--\n"
"	function font.fits(width,text,size)\n"
"		font.active()\n"
"		if size then font.sx=size font.sy=size end\n"
"		if text then return win.flat_fits({size=font.sx,s=text,width=width}) end\n"
"	end\n"
"	\n"
"--\n"
"-- which char is under this xpos, ( 0 is first and -1 is unknown )\n"
"--\n"
"	function font.which(x,text,size)\n"
"		font.active()\n"
"		if size then font.sx=size font.sy=size end\n"
"		if text then return win.flat_which({size=font.sx,s=text,x=x}) end\n"
"	end\n"
"\n"
"--\n"
"-- break this string into an array of strings with proper word wrapping to the given width\n"
"-- whitespace will be removed from the begining of the strings\n"
"--\n"
"	function font.wrap(width,text,size)\n"
"		font.active()\n"
"		if size then font.sx=size font.sy=size end\n"
"		if text then\n"
"		\n"
"			local s=text\n"
"			local s1=0\n"
"			local ss={}\n"
"			while #s>0 do\n"
"				s1=font.fits(width,s)\n"
"				if s1>=0 then\n"
"					local bp=s1\n"
"					\n"
"					local sa,sb=s:find(\"\\n"
"\")		-- new lines force breaks\n"
"					if sa and sa<bp then bp=sa end\n"
"					\n"
"					local wa,wb=s:sub(bp+1):find(\"^%s+\") -- white space at end?\n"
"					\n"
"					if #s == bp then -- the end of string\n"
"					\n"
"					elseif wa then -- perfect split, followed by space\n"
"					\n"
"						bp=bp+wb -- include the space at the end\n"
"						\n"
"					else -- find the space before\n"
"					\n"
"						local a,b = s:find(\"%s+\")\n"
"						\n"
"						while a do\n"
"							if a<s1 then bp=b else break end\n"
"							a,b = s:find(\"%s+\",b+1)\n"
"						end\n"
"						\n"
"					end\n"
"					ss[#ss+1]=s:sub(1,bp)\n"
"					s=s:sub(bp+1)\n"
"				else\n"
"					break\n"
"				end\n"
"			end\n"
"\n"
"			return ss\n"
"		end\n"
"	end\n"
"\n"
"	return font\n"
"end\n"
"\n"
"",

"fenestra.widget.slide","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"-- two basic widgets merged together to give a simple slide or scrollbar \n"
"\n"
"\n"
"module(\"fenestra.widget.slide\")\n"
"\n"
"local widget_data=require(\"fenestra.widget.data\")\n"
"\n"
"\n"
"function mouse(widget,act,x,y,key)\n"
"--	widget.master.focus=widget\n"
"	return widget.meta.mouse(widget,act,x,y,key)\n"
"end\n"
"\n"
"\n"
"function key(widget,ascii,key,act)\n"
"	return widget.meta.key(widget,ascii,key,act)\n"
"end\n"
"\n"
"\n"
"function update(widget)\n"
"--	local it=widget.slide\n"
"\n"
"\n"
"	widget:snap()\n"
"\n"
"--	it.drag.text=it.datx:get_string()\n"
"	\n"
"	return widget.meta.update(widget)\n"
"end\n"
"\n"
"\n"
"function slide_snap(it)\n"
"\n"
"-- auto snap positions when draged\n"
"	it.drag.px=it.datx:snap( it.hx , it.drag.hx , it.drag.px )\n"
"	it.drag.pxd=it.pxd+it.drag.px\n"
"	\n"
"-- upside down y so need to twiddle it, pyr is \"the right way up\"\n"
"	it.drag.py=it.daty:snap( it.hy , it.drag.hy , it.drag.py )\n"
"	it.drag.pyd=it.pyd-it.drag.py\n"
"	\n"
"end\n"
"	\n"
"function setup(widget,def)\n"
"--	local it={} -- our main data so as not to clobber widget values\n"
"--	it.widget=widget\n"
"--	widget.slide=it\n"
"	widget.class=\"slide\"\n"
"	\n"
"	widget.snap=slide_snap\n"
"	\n"
"	widget.key=key\n"
"	widget.mouse=mouse\n"
"	widget.update=update\n"
"	\n"
"--setup constraints in x and y \n"
"	widget.datx=widget_data.new_data(def.datx)\n"
"	widget.daty=widget_data.new_data(def.daty)\n"
"\n"
"-- auto add the draging button as a child\n"
"	widget.drag=widget:add({class=\"drag\",color=0xffffffff,hy=widget.daty:get_size(widget.hy),hx=widget.datx:get_size(widget.hx),pxf=widget.datx:get_pos(),pyf=widget.daty:get_pos(),data=widget.data})\n"
"	\n"
"	return widget\n"
"end\n"
"",

"fenestra.widget.drag","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"module(\"fenestra.widget.drag\")\n"
"\n"
"\n"
"function mouse(widget,act,x,y,key)\n"
"--	widget.master.focus=widget\n"
"	return widget.meta.mouse(widget,act,x,y,key)\n"
"end\n"
"\n"
"\n"
"function key(widget,ascii,key,act)\n"
"	return widget.meta.key(widget,ascii,key,act)\n"
"end\n"
"\n"
"\n"
"function update(widget)\n"
"\n"
"	if widget.data then\n"
"		widget.text=widget.data:get_string()\n"
"	end\n"
"\n"
"	return widget.meta.update(widget)\n"
"end\n"
"\n"
"function draw(widget)\n"
"	return widget.meta.draw(widget)\n"
"end\n"
"\n"
"\n"
"function setup(widget,def)\n"
"--	local it={}\n"
"--	widget.drag=it\n"
"	widget.class=\"drag\"\n"
"	\n"
"	widget.key=key\n"
"	widget.mouse=mouse\n"
"	widget.update=update\n"
"	widget.draw=draw\n"
"\n"
"	return widget\n"
"end\n"
"",

"wetgenes.string","\r--local log=require(\"wetgenes.aelua.log\").log\r\rlocal string=string\rlocal table=table\rlocal math=math\r\rlocal type=type\rlocal pairs=pairs\rlocal ipairs=ipairs\rlocal tostring=tostring\rlocal setmetatable=setmetatable\rlocal error=error\rlocal tonumber=tonumber\r\r--\r-- Some ueful string functions.\r--\r\rmodule(\"wetgenes.string\")\r\r\r\r\r-----------------------------------------------------------------------------\r--\r-- split a string into a table, flag enables pattern match on true\r--\r-----------------------------------------------------------------------------\rfunction str_split(div,str,flag)\r\r	if (str=='') then return {\"\"} end\r	\r	if (div=='') or not div then error(\"div expected\", 2) end\r	if (str=='') or not str then error(\"str expected\", 2) end\r\r	local pos,arr = 0,{}\r\r	-- for each divider found\r	for st,sp in function() return string.find(str,div,pos,not flag) end do\r		table.insert(arr,string.sub(str,pos,st-1)) -- Attach chars left of current divider\r		pos = sp + 1 -- Jump past current divider\r	end\r\r	if pos~=0 then\r		table.insert(arr,string.sub(str,pos)) -- Attach chars right of last divider\r	else\r		table.insert(arr,str) -- return entire string\r	end\r\r\r	return arr\rend\r\r\r\r\r-----------------------------------------------------------------------------\r--\r-- serialize a simple table to a lua string that would hopefully recreate said table if executed\r--\r-- returns a string\r--\r-----------------------------------------------------------------------------\rfunction serialize(o,opts)\ropts=opts or {}\ropts.done=opts.done or {} -- only do tables once\r\ropts.indent=opts.indent or \"\"\ropts.newline=opts.newline or ( opts.compact and \"\" or \"\\n"
"\" )\r\rlocal fout=opts.fout\r\r	if not fout then -- call with a new function to build and return a string\r		local ret={}\r		opts.fout=function(...)\r			for i,v in ipairs({...}) do ret[#ret+1]=v end\r		end\r		serialize(o,opts)		\r		return table.concat(ret)\r	end\r\r	if type(o) == \"number\" then\r	\r		return fout(o)\r		\r	elseif type(o) == \"boolean\" then\r	\r		if o then return fout(\"true\") else return fout(\"false\") end\r		\r	elseif type(o) == \"string\" then\r	\r		return fout(string.format(\"%q\", o))\r		\r	elseif type(o) == \"table\" then\r	\r		\r		if opts.done[o] and opts.no_duplicates then\r			fout(opts.indent,\"\\n"
"\",opts.indent,\"{--[[DUPLICATE]]}\",opts.newline)\r			return\r		else\r		\r			fout(opts.newline,opts.indent,\"{\",opts.newline)\r\r			if opts.pretty then\r				opts.indent=opts.indent..\" \"\r			end\r			\r			opts.done[o]=true\r			\r			local maxi=0\r			\r			for k,v in ipairs(o) do -- dump number keys in order\r				fout(opts.indent)\r				serialize(v,opts)\r				fout(\",\",opts.newline)\r				maxi=k -- remember top\r			end\r			\r			for k,v in pairs(o) do\r				if (type(k)~=\"number\") or (k<1) or (k>maxi) or (math.floor(k)~=k) then -- skip what we already dumped\r					fout(opts.indent,\"[\")\r					serialize(k,opts)\r					fout(\"]=\")\r					serialize(v,opts)\r					fout(\",\",opts.newline)\r				end\r			end\r			\r			if opts.pretty then\r				opts.indent=opts.indent:sub(1,-2)\r			end\r			fout(opts.indent,\"}\",opts.newline)\r			return\r		end\r	else\r		error(\"cannot serialize a \" .. type(o))\r	end\r	\rend\r\r\r-----------------------------------------------------------------------------\r--\r-- join a table of things into an english list with commas and an \"and\" at the end\r-- returns nil if the table is empty\r--\r-----------------------------------------------------------------------------\rfunction str_join_english_list(t)\r\rlocal s\r\r	for i,v in ipairs(t) do\r	\r		if not s then -- first\r		\r			s=v\r			\r		elseif t[i+1]==nil then -- last\r		\r			s=s..\" and \"..v\r			\r		else -- middle\r		\r			s=s..\", \"..v\r			\r		end\r	\r	end\r\r	return s\r\rend\r\r-----------------------------------------------------------------------------\r--\r-- convert a string into a hex string\r--\r-----------------------------------------------------------------------------\rfunction str_to_hex(s)\r	return string.gsub(s, \".\", function (c)\r		return string.format(\"%02x\", string.byte(c))\r	end)\rend\r\r-----------------------------------------------------------------------------\r--\r-- replace any %xx with the intended char, eg \"%20\" becomes a \" \"\r--\r-----------------------------------------------------------------------------\rfunction url_decode(str)\r    return string.gsub(str, \"%%(%x%x)\", function(hex)\r        return string.char(tonumber(hex, 16))\r    end)\rend\r\r-----------------------------------------------------------------------------\r--\r-- replace % , & , # , ' , \" and = chars with %xx codes\r-- this is the bare minimum we need to escape so as not to confuse things\r--\r-----------------------------------------------------------------------------\rfunction url_encode(str)\r    return string.gsub(str, \"([&=%%#'\\\"])\", function(c)\r        return string.format(\"%%%02X\", string.byte(c))\r    end)\rend\r\r\r-----------------------------------------------------------------------------\r--\r-- trime whitespace from ends of string\r--\r-----------------------------------------------------------------------------\rfunction trim(s)\r  return (s:gsub(\"^%s*(.-)%s*$\", \"%1\"))\rend\rfunction trim_start(s)\r  return (s:gsub(\"^%s*(.-)\", \"%1\"))\rend\rfunction trim_end(s)\r  return (s:gsub(\"(.-)%s*$\", \"%1\"))\rend\r\r-----------------------------------------------------------------------------\r--\r-- split on \\n"
", each line also includes its own \\n"
"\r--\r-----------------------------------------------------------------------------\rfunction split_lines(text)\r	local separator = \"\\n"
"\"\r	\r	local parts = {}  \r	local start = 1\r	\r	local split_start, split_end = text:find(separator, start,true)\r	\r	while split_start do\r		table.insert(parts, text:sub(start, split_end))\r		start = split_end + 1\r		split_start, split_end = text:find(separator, start,true)\r	end\r	\r	if text:sub(start)~=\"\" then\r		table.insert(parts, text:sub(start) )\r	end\r	\r	return parts\rend\r\r-----------------------------------------------------------------------------\r--\r-- split on whitespace, throw away all whitespace return only the words\r--\r-----------------------------------------------------------------------------\rfunction split_words(text,split)\r	local separator = split or \"%s+\"\r	\r	local parts = {}  \r	local start = 1\r	\r	local split_start, split_end = text:find(separator, start)\r	\r	while split_start do\r		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end\r		start = split_end + 1\r		split_start, split_end = text:find(separator, start)\r	end\r	\r	if text:sub(start)~=\"\" then\r		table.insert(parts, text:sub(start) )\r	end\r	\r	return parts\rend\r\r\r-----------------------------------------------------------------------------\r--\r-- split on transition to or from whitespace, include this white space in the table result\r--\r-- such that a concat on the result would be a perfect reproduction of the original\r--\r-----------------------------------------------------------------------------\rfunction split_whitespace(text)\r	local separator = \"%s+\"\r	\r	local parts = {}  \r	local start = 1\r	\r	local split_start, split_end = text:find(separator, start)\r	\r	while split_start do\r		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end		-- the word\r		table.insert(parts, text:sub(split_start, split_end))	-- the white space\r		start = split_end + 1\r		split_start, split_end = text:find(separator, start)\r	end\r	\r	if text:sub(start)~=\"\" then\r		table.insert(parts, text:sub(start) )\r	end\r	\r	return parts\rend\r\r-----------------------------------------------------------------------------\r--\r-- split a string in two on first = \r--\r-----------------------------------------------------------------------------\rfunction split_equal(text)\r	local separator = \"=\"\r	\r	local parts = {}\r	local start = 1\r	\r	local split_start, split_end = text:find(separator, start,true)\r	\r	if split_start and split_start>1 and split_end<#text then -- data either side of seperator\r	\r		return text:sub(1,split_start-1) , text:sub(split_end+1)\r		\r	end\r	\r	return nil\rend\r\r\r\r-----------------------------------------------------------------------------\r--\r-- private replace utility function\r-- look up string a inside data d and return the string we found\r-- if we dont find anything then we return {a}\r--\r-- if we try to look up a table containing a plate field\r-- then that plate name will be used to format that table content as {d.it}\r-- if that table contains a [1] then it will be treated as an array of data\r-- and looped over to produce a result.\r--\r-----------------------------------------------------------------------------\rlocal replace_lookup\rreplace_lookup=function(a,d) -- look up a in table d\r	local t=d[a]\r	if t then\r		if type(t)==\"table\" then -- if a table then\r			if t[1] then -- a list of stuff\r				if t.plate then -- how to format\r					local tt={}\r					local it=d.it\r					for i,v in ipairs(t) do\r						d.it=v\r						tt[#tt+1]=macro_replace(d[t.plate] or t.plate,d)\r					end\r					d.it=it\r					return table.concat(tt)\r				end\r			else -- just one thing\r				if t.plate then -- how to format\r					local it=d.it\r					d.it=t\r					local tt=macro_replace(d[t.plate] or t.plate,d)\r					d.it=it\r					return tt\r				end\r			end\r			return nil -- no not expand\r		end\r		return tostring(t) -- simple find, make sure we return a string\r	end\r	\r	local a1,a2=string.find(a, \"%.\") -- try and split on first \".\"\r	if not a1 then return nil end -- didnt find a dot so return nil\r	\r	a1=string.sub(a,1,a1-1) -- the bit before the .\r	a2=string.sub(a,a2+1) -- the bit after the .\r	\r	local dd=d[a1] -- use the bit before the dot to find the sub table\r	\r	if type(dd)==\"table\" then -- check we got a table\r		return replace_lookup(a2,dd) -- tail call this function\r	end\r	\r	return nil -- couldnt find anything returnnil\rend\r\r\r-----------------------------------------------------------------------------\r--\r-- replace {tags} in the string with data provided\r-- allow sub table look up with a.b notation in the name\r--\r-----------------------------------------------------------------------------\rfunction replace(a,d)\r\rreturn (string.gsub( a , \"{([%w%._%-]-)}\" , function(a) -- find only words and \"._-!\" tightly encased in {}\r-- this means that almost all legal use of {} in javascript will not match at all.\r-- Even when it does (probably as a \"{}\") then it is unlikley to accidently find anything in the d table\r-- so the text will just be returned as is.\r-- So it may not be safe, but it is simple to understand and perfecty fine under most use cases.\r\r	return replace_lookup(a,d) or (\"{\"..a..\"}\")\r	\rend )) -- note gsub is in brackes so we just get its first return value\r\rend\r\r-----------------------------------------------------------------------------\r--\r-- like replace but allows for simple creation of temporary substitutions\r-- this enables very simple macro expansion\r-- so {var=}value{=var} would set var to value\r-- and that value would last for the rest of the chunk\r--\r-----------------------------------------------------------------------------\rlocal function macro_replace_once(text,old_d,opts)\r	opts=opts or {}\r	local opts_clean=opts.clean\r	local opts_htmldbg=opts.dbg_html_comments\r\r	local d={} -- we can store temporary vars in here\r	if old_d then setmetatable(d,{__index=old_d})	end -- wrap original d to protect it\r	\r	\r	local ret={}\r	\r	local separator = \"{[%w%._%-=]-}\"\r	\r	local parts = {}  \r	local start = 1\r	\r	local split_start, split_end = text:find(separator, start)\r	\r	while split_start do\r		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end		-- part1\r		table.insert(parts, text:sub(split_start, split_end))	-- part2\r		start = split_end + 1\r		split_start, split_end = text:find(separator, start)\r	end\r	\r	if text:sub(start)~=\"\" then\r		table.insert(parts, text:sub(start) )\r	end\r\r	local count=0\r	local capt=nil\r	\r\r-- step through	\r	for i=1,#parts do local v=parts[i]\r		local tag=nil\r		local dat=nil\r		local skip_capt=nil\r		if string.len(v)>=3 then -- must be at least this long\r			local fc=v:sub(1,1) -- first char\r			local lc=v:sub(-1) -- last char\r			if fc==\"{\" and lc==\"}\" then -- special part\r				tag=v:sub(2,#v-1)\r				local fc=tag:sub(1,1) -- first char\r				local lc=tag:sub(-1) -- last char\r				\r				if lc==\"=\" then -- start of capture\r					if capt==nil then\r						capt=tag:sub(1,-2)\r						d[capt]=\"\"\r						skip_capt=true\r						if opts_clean then\r							dat=\"\"\r						end\r					end\r				elseif fc==\"=\" then -- end of capture\r					if capt==tag:sub(2) then -- must match\r						capt=nil\r						if opts_clean then dat=\"\" end\r					end\r				else -- normal lookup\r					dat=replace_lookup(tag,d)\r				end\r			end\r		end\r		local s\r		if dat then\r			count=count+1\r			if opts_htmldbg and tag then\r				s=\"<!--{ \"..tag..\" }-->\\n"
"\"..dat\r			else\r				s=dat\r			end\r		else\r			s=v\r		end\r		\r		if not skip_capt then\r			if capt then -- record capture\r				d[capt]=d[capt]..s\r				if opts_clean then s=\"\" end\r			end\r		end\r		\r		ret[#ret+1]=s\r	end\r\r	return table.concat(ret,\"\"),count\rend\r\rfunction macro_replace(a,d,opts)\r\rlocal opts=opts or {} --{dbg_html_comments=true} to include html dbg, this will break some macro use inside javascript or html attributes so is off by default turn on to dbg\r	\r	local ret=a\r	local count=0\r\r	opts.clean=false\r	for i=1,100 do -- maximum recursion\r	\r		ret,count=macro_replace_once(ret,d,opts)\r		\r		if count==0 then break end -- nothing left to replace\r		\r	end\r	opts.clean=true\r	ret=macro_replace_once(ret,{},opts) -- finally remove temporary chunks\r	\r	return ret\rend\r",

"fenestra.console","\n"
"\n"
"local hex=function(str) return tonumber(str,16) end\n"
"\n"
"local string=string\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local math=math\n"
"local loadstring=loadstring\n"
"local pcall=pcall\n"
"\n"
"-- imported global functions\n"
"local sub = string.sub\n"
"local match = string.match\n"
"local find = string.find\n"
"local push = table.insert\n"
"local pop = table.remove\n"
"local append = table.insert\n"
"local concat = table.concat\n"
"local floor = math.floor\n"
"local write = io.write\n"
"local read = io.read\n"
"local type = type\n"
"local setfenv = setfenv\n"
"local tostring=tostring\n"
"local pairs=pairs\n"
"local ipairs=ipairs\n"
"local unpack=unpack\n"
"local require=require\n"
"\n"
"local _G = _G\n"
"\n"
"module(\"fenestra.console\")\n"
"local fenestra_buffedit=require(\"fenestra.buffedit\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split a string into a table\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function split(div,str)\n"
"\n"
"  if (div=='') or not div then error(\"div expected\", 2) end\n"
"  if (str=='') or not str then error(\"str expected\", 2) end\n"
"  \n"
"  local pos,arr = 0,{}\n"
"  \n"
"  -- for each divider found\n"
"  for st,sp in function() return string.find(str,div,pos,false) end do\n"
"	table.insert(arr,sub(str,pos,st-1)) -- Attach chars left of current divider\n"
"	pos = sp + 1 -- Jump past current divider\n"
"  end\n"
"  \n"
"  if pos~=0 then\n"
"	table.insert(arr,sub(str,pos)) -- Attach chars right of last divider\n"
"  else\n"
"	table.insert(arr,str) -- return entire string\n"
"  end\n"
"  \n"
"  \n"
"  return arr\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"function setup(fenestra)\n"
"\n"
"	local function print(...)\n"
"		fenestra._g.print(...)\n"
"	end\n"
"\n"
"	local ogl=fenestra.ogl\n"
"\n"
"	local it={}\n"
"	\n"
"	it.buff=fenestra_buffedit.create() -- create buff edit\n"
"	it.buff.enter=function(_,line) it.dump_eval(line) end\n"
"	\n"
"	it.lines={}\n"
"	it.lines_display={}\n"
"	\n"
"	it.x=0\n"
"	it.y=0\n"
"	it.y_show=8*8\n"
"	\n"
"	it.show=false\n"
"\n"
"	function it.clean()\n"
"\n"
"	end\n"
"	\n"
"	-- print out lua data in a somewhat sensible way, returns a string\n"
"	it.dump_limit = 20\n"
"	it.dump_depth = 7\n"
"	it.dump_stack = {}\n"
"\n"
"	it.call = {} -- name -> function : functions that should be easily to call on the console command line\n"
"	\n"
"	it.call.help=function()\n"
"		local t={}\n"
"		for n,f in pairs(it.call) do\n"
"			t[#t+1]=n\n"
"		end\n"
"		return table.concat(t,\" \")\n"
"	end\n"
"	\n"
"	function it.dump_table(tbl,delim)\n"
"		local n = #tbl\n"
"		local res = ''\n"
"		local k = 0\n"
"		-- very important to avoid disgracing ourselves with circular referencs...\n"
"		if #it.dump_stack > it.dump_depth then\n"
"			return \"...\"\n"
"		end\n"
"		for i,t in ipairs(it.dump_stack) do\n"
"			if tbl == t then\n"
"				return \"<self>\"\n"
"			end\n"
"		end\n"
"		push(it.dump_stack,tbl)\n"
"		\n"
"		for key,v in pairs(tbl) do\n"
"			if type(key) == 'number' then\n"
"				key = '['..tostring(key)..']'\n"
"			else\n"
"				key = tostring(key)\n"
"			end\n"
"			res = res..delim..key..'='..it.dump_string(v)\n"
"			k = k + 1\n"
"			if k > it.dump_limit then\n"
"				res = res..\" ... \"\n"
"				break\n"
"			end\n"
"		end\n"
"		\n"
"		pop(it.dump_stack)\n"
"		return sub(res,2)\n"
"	end\n"
"\n"
"\n"
"\n"
"	function it.dump_string(val)\n"
"		local tp = type(val)\n"
"		if tp == 'function' then\n"
"			return tostring(val)\n"
"		elseif tp == 'table' then\n"
"			if val.__tostring  then\n"
"				return tostring(val)\n"
"			else\n"
"				return '{'..it.dump_table(val,',\\n"
"')..'}'\n"
"			end\n"
"		elseif tp == 'string' then\n"
"			return val--\"'\"..val..\"'\"\n"
"		elseif tp == 'number' then\n"
"			return tostring(val)\n"
"		else\n"
"			return tostring(val)\n"
"		end\n"
"	end\n"
"	\n"
"-- based on ilua.lua\n"
"	function it.dump_eval(line)\n"
"	\n"
"		local function compile(line)\n"
"			local f,err = loadstring(line,'local')\n"
"			return err,f\n"
"		end\n"
"		\n"
"		\n"
"		local err,chunk\n"
"		local ret={}\n"
"		local args={}\n"
"		\n"
"		\n"
"		if line~=\"\" then args=split(\"%s\",line) end -- split input on whitespace\n"
"		\n"
"		if args[1] then\n"
"		\n"
"			function lookup(tab,name)\n"
"				local names=split(\"%.\",name)\n"
"				for i,v in ipairs(names) do\n"
"--				print(i..\" \"..v)\n"
"					if type(tab)==\"table\" then\n"
"						tab=tab[v]\n"
"					else\n"
"						tab=nil\n"
"					end\n"
"				end\n"
"				return tab\n"
"			end\n"
"			\n"
"			chunk=lookup(it.call,args[1]) -- check special console functions\n"
"			\n"
"			if chunk and type(chunk)==\"function\" then -- must be a function\n"
"			\n"
"				table.remove(args,1) -- remove the function name\n"
"			\n"
"				setfenv(chunk,fenestra._g) -- call with master environment?\n"
"			else\n"
"			\n"
"				chunk=lookup(fenestra._g,args[1]) -- check for functions in master environment\n"
"				\n"
"				if chunk and type(chunk)==\"function\" then -- must be a function\n"
"				\n"
"					table.remove(args,1) -- remove the function name\n"
"				\n"
"				else\n"
"					chunk=nil\n"
"				end\n"
"				\n"
"				-- do not try and change the fenv of a function in the main envronment...\n"
"			\n"
"			end\n"
"			\n"
"		end\n"
"		\n"
"		if not chunk then\n"
"		\n"
"			args={} -- no arguments\n"
"			\n"
"			-- is it an expression?\n"
"			err,chunk = compile('print('..line..')')\n"
"			if err then\n"
"				-- otherwise, a statement?\n"
"				err,chunk = compile(line)\n"
"			end\n"
"			\n"
"			if chunk then\n"
"				setfenv(chunk,fenestra._g) -- compile in master environment will have an overloaded print\n"
"			end\n"
"		end\n"
"\n"
"		-- if compiled ok, then evaluate the chunk\n"
"		if not err and chunk then\n"
"		\n"
"			ret = { pcall(chunk,unpack(args)) }\n"
"			\n"
"			if not ret[1] then\n"
"				err=ret[2]\n"
"				ret={}\n"
"			else\n"
"				table.remove(ret,1)\n"
"			end\n"
"			\n"
"		end\n"
"		\n"
"		-- if there was any error, print it out\n"
"		if err then\n"
"			fenestra._g.print(err)\n"
"		else\n"
"			for i,v in ipairs(ret) do\n"
"				fenestra._g.print(v)\n"
"			end\n"
"		end\n"
"	end\n"
"\n"
"	function it.update()\n"
"	\n"
"		it.buff:update()\n"
"		\n"
"		if it.show then\n"
"			if it.y~=it.y_show then\n"
"			\n"
"				local d=(it.y_show-it.y)/4\n"
"				if d>0 then d=math.ceil(d) else d=math.floor(d) end\n"
"				it.y= math.floor( it.y + d )\n"
"			\n"
"			end\n"
"		else\n"
"			if it.y~=0 then\n"
"			\n"
"				local d=(0-it.y)/4\n"
"				if d>0 then d=math.ceil(d) else d=math.floor(d) end\n"
"				it.y= math.floor( it.y + d )\n"
"			\n"
"			end\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	function it.draw()\n"
"	\n"
"		fenestra.debug_begin()\n"
"		\n"
"		local w=fenestra.get(\"width\")\n"
"		local h=it.y\n"
"		fenestra.debug_polygon_begin()\n"
"		fenestra.debug_polygon_vertex(0,0,hex\"ee00cc00\")\n"
"		fenestra.debug_polygon_vertex(w,0,hex\"ee00cc00\")\n"
"		fenestra.debug_polygon_vertex(w,h,hex\"ee004400\")\n"
"		fenestra.debug_polygon_vertex(0,h,hex\"ee004400\")\n"
"		fenestra.debug_polygon_end()\n"
"		\n"
"--		fenestra.debug_rect(0,0,fenestra.get(\"width\"),it.y,hex\"8800ff00\")\n"
"		\n"
"		local i=#it.lines\n"
"		local y=it.y-16\n"
"		while y>-8 and i>0 do\n"
"		\n"
"			fenestra.debug_print({x=0,y=y,size=8,color=hex\"ff00ff00\",s=it.lines[i]})\n"
"			\n"
"			y=y-8\n"
"			i=i-1\n"
"		end\n"
"		\n"
"		if it.show_hud then\n"
"			for i,v in ipairs(it.lines_display) do\n"
"			\n"
"				fenestra.debug_print({x=0,y=it.y+i*8-8,size=8,color=hex\"ffffffff\",s=v})\n"
"			\n"
"			end\n"
"		end\n"
"		\n"
"		fenestra.debug_print({x=0,y=it.y-8,size=8,color=hex\"ff00ff00\",s=\">\"..it.buff.line})\n"
"\n"
"		fenestra.debug_rect((it.buff.line_idx+1)*8,it.y-8,(it.buff.line_idx+2)*8,it.y,hex\"00ff00\"+it.buff.throb*256*256*256)\n"
"\n"
"		fenestra.debug_end()\n"
"\n"
"		it.lines_display={}\n"
"\n"
"	end\n"
"	\n"
"	function it.print(s)\n"
"	\n"
"		s=it.dump_string(s)\n"
"	\n"
"		table.insert(it.lines,s)\n"
"		\n"
"		while #it.lines > 64 do\n"
"		\n"
"			table.remove(it.lines,1)\n"
"		\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	function it.display(s)\n"
"	\n"
"		s=it.dump_string(s)\n"
"		\n"
"		table.insert(it.lines_display,s)\n"
"	\n"
"	end\n"
"	\n"
"	function it.mouse(act,x,y,key)\n"
"--		print(act..\" \"..x..\",\"..y..\" \"..key)\n"
"	end\n"
"	\n"
"	function it.keypress(ascii,key,act)\n"
"\n"
"		if act==\"down\" then\n"
"--			fenestra._g.print(ascii..\" \"..(key or \"\"))\n"
"		end\n"
"\n"
"		if act==\"down\" and ascii==\"`\" then\n"
"		\n"
"			if it.show then\n"
"			\n"
"				it.show=false\n"
"				it.show_hud=false\n"
"				\n"
"			elseif it.show_hud then\n"
"			\n"
"				it.show=true			\n"
"				throb=255\n"
"			else\n"
"				it.show_hud=true\n"
"			end\n"
"\n"
"			return true\n"
"		end\n"
"			\n"
"		if it.show then\n"
"		\n"
"			if act==\"down\" or act==\"repeat\" then\n"
"					\n"
"				if key==\"page up\" or key==\"prior\" then\n"
"				\n"
"					it.y_show=it.y_show-8\n"
"				\n"
"				elseif key==\"page down\" or key==\"next\" then\n"
"				\n"
"					it.y_show=it.y_show+8\n"
"\n"
"				end\n"
"				\n"
"			end\n"
"			\n"
"			return it.buff:keypress(ascii,key,act)\n"
"			\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"-- overload print function in the given (global) tab\n"
"-- returns a function to undo this act (however this function may fail...)\n"
"	function it.replace_print(g)\n"
"	\n"
"		local print_old=g.print\n"
"		it.print_old=g.print\n"
"		local print_new=function(...)\n"
"		\n"
"			local t={}\n"
"			for i,v in ipairs(arg) do\n"
"				table.insert(t, it.dump_string(v) )\n"
"			end\n"
"			if not t[1] then t[1]=\"nil\" end\n"
"			\n"
"			it.print( unpack(t) )\n"
"			if print_old then\n"
"				print_old( unpack(t) )\n"
"			end\n"
"		end\n"
"		g.print=print_new\n"
"		\n"
"		return function()\n"
"			if g.print==print_new then -- only change back if noone else changed it\n"
"				g.print=print_old\n"
"				return true\n"
"			end\n"
"		end\n"
"	end\n"
"\n"
"	\n"
"	return it\n"
"end\n"
"",

"wetgenes.html","\n"
"local table=table\n"
"local string=string\n"
"\n"
"local type=type\n"
"local tostring=tostring\n"
"local setmetatable=setmetatable\n"
"\n"
"-- my string functions\n"
"local str=require(\"wetgenes.string\")\n"
"\n"
"module(\"wetgenes.html\")\n"
"\n"
"--\n"
"-- use the replace function from wetgenes.string\n"
"--\n"
"replace=str.replace\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- build a string from a template,  with a table to be used as its environment\n"
"--\n"
"-- this environment will not get modified by the called function as it is wrapped here\n"
"--\n"
"-- even though the calling function is free to modify the table it gets\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"get=function(html,src,env)\n"
"\n"
"	local new_env={}\n"
"	if env then setmetatable(new_env,{__index=env})	end -- wrap to protect\n"
"\n"
"	if html[src] then src=html[src] end\n"
"	\n"
"	if type(src)==\"function\" then return src(new_env) end\n"
"	\n"
"	if type(src)==\"string\" and env then return replace(src,new_env) end\n"
"\n"
"	return tostring(src)\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- very basic html esc to stop tags and entities from doing bad things\n"
"-- running text submitted from a user through this function should stop it from doing\n"
"-- anything other than just being text, it doesnt guarantee that it is valid xhtml / whatever\n"
"-- We just turn a few important characters into entities.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function esc(s)\n"
"	local escaped = { ['<']='&lt;', ['>']='&gt;', [\"&\"]='&amp;' }\n"
"	return (s:gsub(\"[<>&]\", function(c) return escaped[c] end))\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- basic url escape, so as not to trigger url get params or anything else by mistake \n"
"-- so = & # % ? \" ' are bad and get replaced with %xx\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_esc(s)\n"
"	return string.gsub(s, \"([&=%%%#%?%'%\\\" ><])\", function(c)\n"
"		return string.format(\"%%%02x\", string.byte(c))\n"
"	end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- a url escape, that only escapes the string deliminators ' and \" \n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_esc_string(s)\n"
"	return string.gsub(s, \"(['%\\\" ])\", function(c)\n"
"		return string.format(\"%%%02x\", string.byte(c))\n"
"	end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert any %xx into single chars\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_unesc(s)\n"
"	return string.gsub(s, \"%%(%x%x)\", function(hex)\n"
"		return string.char(tonumber(hex, 16))\n"
"	end)\n"
"end\n"
"\n"
"",

"wetgenes.util","\r--local log=require(\"wetgenes.aelua.log\").log\r\rlocal string=string\rlocal table=table\rlocal math=math\r\rlocal type=type\rlocal pairs=pairs\rlocal ipairs=ipairs\rlocal tostring=tostring\rlocal setmetatable=setmetatable\r\r--\r-- Some useful functions.\r--\r\rmodule(\"wetgenes.util\")\r\r\r\r\r-----------------------------------------------------------------------------\r--\r-- safe lookup within a table that returns nil if any part of the lookup is nil\r-- so we never cause an error, just returns nil\r--\r-----------------------------------------------------------------------------\rfunction lookup(tab,...)\r	for i,v in ipairs{...} do\r		if type(tab)~=\"table\" then return nil end\r		tab=tab[v]\r	end\r	return tab\rend\r",

"wetgenes.json","--\n"
"-- wetjson\n"
"--         version 2011-02-04\n"
"--         use encode to encode a table and decode to decode a json string\n"
"--\n"
"-- other json encode/decode pure lua library seemed too slow\n"
"-- here is a fast and loose one lets see if it goes any faster :)\n"
"-- should be a direct replacement for JSON4Lua which is what I was using before\n"
"--\n"
"-- find the latest version online here\n"
"-- http://code.google.com/p/aelua/source/browse/trunk/aelua/lua/wetjson.lua\n"
"--\n"
"--\n"
"-- Copyright (C) 2011 by http://about.wetgenes.com/\n"
"--\n"
"-- Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"-- of this software and associated documentation files (the \"Software\"), to deal\n"
"-- in the Software without restriction, including without limitation the rights\n"
"-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"-- copies of the Software, and to permit persons to whom the Software is\n"
"-- furnished to do so, subject to the following conditions:\n"
"--\n"
"-- The above copyright notice and this permission notice shall be included in\n"
"-- all copies or substantial portions of the Software.\n"
"--\n"
"-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
"-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
"-- THE SOFTWARE.\n"
"--\n"
"\n"
"local table=table\n"
"local string=string\n"
"\n"
"\n"
"local print=print\n"
"local type=type\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"local tonumber=tonumber\n"
"local tostring=tostring\n"
"local math=math\n"
"local error=error\n"
"\n"
"module(...)\n"
"\n"
"null=function() return null end -- wetjson.null is a magick value to represent null\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- trim whitespace from ends of string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function trim(s)\n"
"  return (s:gsub(\"^%s*(.-)%s*$\", \"%1\"))\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- unescape a string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local unesc_tab={\n"
"	[\"b\"]=\"\\b\",\n"
"	[\"f\"]=\"\\f\",\n"
"	[\"n\"]=\"\\n"
"\",\n"
"	[\"r\"]=\"\\r\",\n"
"	[\"t\"]=\"\\t\",\n"
"}\n"
"local function unesc(s)\n"
"\n"
"	s=string.gsub(s, \"\\\\([^u])\", function(c)\n"
"		return unesc_tab[c] or c\n"
"    end)\n"
"\n"
"	s=string.gsub(s, \"\\\\u(%x%x%x%x)\", function(c)\n"
"		return string.char( tonumber(c,16) or 32 ) or \"\"\n"
"    end)\n"
"    \n"
"  return s\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- escape a string anything outside of basic printable 7bit ascii or a \" or a \\\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function esc(s)\n"
"\n"
"	s=string.gsub(s, \"([^#-Z_-~ !%^%[%]])\", function(c)\n"
"		return string.format( \"\\\\u%04x\" , string.byte( c ) )\n"
"    end)\n"
"    \n"
"  return s\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split on interesting characters to create a table\n"
"--\n"
"-- a concat on the result would be a perfect reproduction of the original\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function split(text)\n"
"	local separator = \"[\\\",:{}%[%]']\"\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	\n"
"	while split_start do\n"
"		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end		-- the word\n"
"		table.insert(parts, text:sub(split_start, split_end))	-- the white space\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	\n"
"	return parts\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- is this an array?\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function is_array(t)\n"
"	local len=#t\n"
"	if len==0 then return false end -- short circuit\n"
"	for i,v in pairs(t) do\n"
"		if type(i)==\"number\" then\n"
"			if math.floor(i)~=i then -- must be int\n"
"				return false\n"
"			end\n"
"			if i<1 or i>len then -- and in this range\n"
"				return false\n"
"			end\n"
"		else\n"
"			return false\n"
"		end\n"
"	end\n"
"	return true\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- json string to table\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function decode(s,opts)\n"
"opts=opts or {}\n"
"\n"
"local t\n"
"\n"
"-- start by adjusting all \\\" escapes in the string into \\u0000 escapes\n"
"-- that way we do not have to worry about \" being anywhere apart\n"
"-- from real string deliminators which makes parsing easier?\n"
"-- this way we wont have to ignore \\\" as a special case inside strings\n"
"\n"
"	s=string.gsub(s, \"\\\\([\\\"])\", function(c)\n"
"		return string.format(\"\\\\u%04x\",string.byte(c))\n"
"    end)\n"
"\n"
"\n"
"-- now we break the string using any of the following characters as deliminators\n"
"-- {}[]:,\"\n"
"-- this gives an array of interesting points to parse\n"
"\n"
"	t=split(s,opts)\n"
"	\n"
"	local chash=0\n"
"	local out={}\n"
"	local top={tab=out,idx=1,inc=true}\n"
"	local stack={ top }\n"
"	local sb -- string buffer building for the use of\n"
"	local sbend -- the string terminator\n"
"	\n"
"	function err(s)\n"
"		error(s..\" (\"..chash..\")\")\n"
"	end\n"
"	\n"
"	function push(v)\n"
"		top=v\n"
"		stack[#stack+1]=top\n"
"	end\n"
"	\n"
"	function pop()\n"
"		stack[#stack]=nil\n"
"		top=stack[#stack]\n"
"		if not top then err(\"too many close brackets\") end\n"
"	end\n"
"	\n"
"	function setval()\n"
"		if top.idx==nil then -- set idx not val\n"
"			if type(val)==\"table\" then err(\"cannot use table as index\") end\n"
"			top.idx=val\n"
"			val=nil\n"
"		else\n"
"--print(top.idx,\"=\",val)\n"
"			top.tab[top.idx]=val\n"
"			if top.inc then top.idx=top.idx+1 else top.idx=nil end\n"
"		end\n"
"	end\n"
"	\n"
"	for i,v in ipairs(t) do\n"
"			\n"
"		if sb then -- continue building a string\n"
"		\n"
"			if v==sbend then -- end of string\n"
"				if sb[2] then\n"
"					val=unesc(table.concat(sb))\n"
"				else\n"
"					val=unesc(sb[1])\n"
"				end\n"
"				sb=nil\n"
"				setval()\n"
"			else\n"
"				sb[#sb+1]=v\n"
"			end\n"
"			\n"
"		else\n"
"		\n"
"			local l=trim(v) -- remove any white space from both ends\n"
"--print(l,#stack)			\n"
"			if #l>0 then -- ignore whitespace\n"
"			\n"
"				if l==\"\\\"\" then -- start a string \n"
"					sb={}\n"
"					sbend=\"\\\"\"\n"
"				elseif l==\"'\" then -- start a string \n"
"					sb={}\n"
"					sbend=\"'\"\n"
"				elseif l==\"{\" then\n"
"					val={}\n"
"					setval()\n"
"					push({tab=val})\n"
"					val=nil\n"
"				elseif l==\"}\" then\n"
"					pop()\n"
"				elseif l==\"[\" then\n"
"					val={}\n"
"					setval()\n"
"					push({tab=val,idx=1,inc=true})\n"
"					val=nil\n"
"				elseif l==\"]\" then\n"
"					pop()\n"
"				elseif l==\":\" then\n"
"				elseif l==\",\" then\n"
"				else\n"
"					val=l\n"
"					if val==\"true\" then val=true\n"
"					elseif val==\"false\" then val=false\n"
"					elseif val==\"null\" then val=null\n"
"					else\n"
"						val=tonumber(val) or val\n"
"					end\n"
"					setval()\n"
"				end\n"
"				\n"
"			end\n"
"		end\n"
"	\n"
"		chash=chash+#v -- very basic error locator\n"
"	end\n"
"	\n"
"	\n"
"	\n"
"--print(#t)\n"
"\n"
"	return out and out[1] , \"OK\"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- table to json string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function encode(tab,opts)\n"
"opts=opts or {}\n"
"\n"
"local out={}\n"
"local put=function(s)\n"
"	out[#out+1]=s or \"\"\n"
"end\n"
"\n"
"local encode_str\n"
"local encode_it\n"
"local encode_tab\n"
"\n"
"	function err(s)\n"
"		error(s)\n"
"	end\n"
"	\n"
"	if not tab then return err(\"null inout\") end\n"
"\n"
"	encode_str=function(str)\n"
"		return \"\\\"\"..esc(tostring(str))..\"\\\"\"\n"
"	end\n"
"	\n"
"	encode_it=function(it,t)\n"
"		t=t or type(it)\n"
"		if t==\"number\" then\n"
"			return tostring(it)\n"
"		elseif t==\"boolean\" then\n"
"			if it then return \"true\" else return \"false\" end\n"
"		elseif t==\"function\" then\n"
"			if it==null then return \"null\" end\n"
"		else\n"
"			return encode_str(it)\n"
"		end\n"
"		\n"
"		return \"\"\n"
"	end\n"
"	\n"
"	encode_tab=function(vv,array)\n"
"		local t\n"
"		local comma=false\n"
"		if array then\n"
"			put(\"[\")\n"
"			for i=1,#vv do local v=vv[i]\n"
"				put(comma and \",\") comma=true\n"
"				t=type(v)\n"
"				if t==\"table\" then\n"
"					encode_tab(v,is_array(v))\n"
"				else\n"
"					put(encode_it(v,t))\n"
"				end\n"
"			end\n"
"			put(\"]\")\n"
"		else\n"
"			put(\"{\")\n"
"			for i,v in pairs(vv) do\n"
"				put(comma and \",\") comma=true\n"
"				put(encode_it(i)) -- allow numbers or strings\n"
"				put(\":\")\n"
"				t=type(v)\n"
"				if t==\"table\" then\n"
"					encode_tab(v,is_array(v))\n"
"				else\n"
"					put(encode_it(v,t))\n"
"				end\n"
"			end\n"
"			put(\"}\")\n"
"		end\n"
"	end\n"
"\n"
"	encode_tab(tab,is_array(tab)) -- technically this should not be an array but we allow it\n"
"\n"
"\n"
"	return table.concat(out)\n"
"end\n"
"\n"
"",

"box2d.wrap","\n"
"\n"
"local print=print\n"
"local table=table\n"
"local pairs=pairs\n"
"\n"
"local core = require(\"box2d.core\")\n"
"\n"
"\n"
"module(\"box2d.wrap\")\n"
"\n"
"--\n"
"-- Call new to get a unique table full of functions associated\n"
"-- with lots of tasty up values for easy use\n"
"--\n"
"-- this gives you a table full of functions to call\n"
"--\n"
"-- local world=require(\"box2d.wrap\").world()\n"
"--\n"
"function world(def) -- create a new world\n"
"\n"
"local world={}\n"
"\n"
"	if def then for i,v in pairs(def) do world[i]=v end end -- shallow copy def data \n"
"	\n"
"	world.hash={} -- a lookup table to turn internal lightuserdatas into associated lua tables (eg for safe callbacks)\n"
"\n"
"	world.core=core.setup(world) -- allocate a hard core\n"
"	core.get(world.core,world) -- update the soft body with current settings from the hard core\n"
"	\n"
"	function world.delete() -- delete this world\n"
"		return core.clean(world.core)\n"
"	end\n"
"	\n"
"	function world.step(tim,iter) -- run the simulation\n"
"		return core.step(world.core, tim or 1/50, iter or 10)\n"
"	end\n"
"\n"
"	function world.body(def) -- create a body in the world\n"
"		local body={}\n"
"		body.shapes={}\n"
"		body.core = core.body(world.core, def)\n"
"		\n"
"		function body.delete() -- delete this body\n"
"			core.body_delete(world.core, body.core)\n"
"		end\n"
"	\n"
"		function body.get()\n"
"			core.body_get(world.core, body.core, body)\n"
"		end\n"
"		\n"
"		function body.set(t)\n"
"			core.body_set(world.core, body.core,t)\n"
"		end\n"
"		\n"
"		function body.shape(def)\n"
"			world.shape(body,def)\n"
"		end\n"
"		\n"
"		core.body_get(world.core, body.core, body)\n"
"			\n"
"		return body\n"
"	end\n"
"	\n"
"	function world.shape(body,def) -- create a shape in the body\n"
"		local shape={}\n"
"		table.insert(body.shapes,shape)\n"
"		shape.core = core.body_shape(world.core, body.core , def)\n"
"		\n"
"		function shape.delete() -- delete this body\n"
"			core.body_shape_delete(world.core, body.core, shape.core )\n"
"		end\n"
"		\n"
"		return shape\n"
"	end\n"
"	\n"
"	function world.joint(def) -- create a joint\n"
"		local joint={}\n"
"		joint.core = core.joint(world.core, def)\n"
"		\n"
"		function joint.delete() -- delete this joint\n"
"			core.joint_delete(world.core, joint.core )\n"
"		end\n"
"		\n"
"		return shape\n"
"	end\n"
"	\n"
"	return world\n"
"end\n"
"\n"
"",

"socket.smtp","-----------------------------------------------------------------------------\n"
"-- SMTP client support for the Lua language.\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: smtp.lua,v 1.46 2007/03/12 04:08:40 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local coroutine = require(\"coroutine\")\n"
"local string = require(\"string\")\n"
"local math = require(\"math\")\n"
"local os = require(\"os\")\n"
"local socket = require(\"socket\")\n"
"local tp = require(\"socket.tp\")\n"
"local ltn12 = require(\"ltn12\")\n"
"local mime = require(\"mime\")\n"
"module(\"socket.smtp\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Program constants\n"
"-----------------------------------------------------------------------------\n"
"-- timeout for connection\n"
"TIMEOUT = 60\n"
"-- default server used to send e-mails\n"
"SERVER = \"localhost\"\n"
"-- default port\n"
"PORT = 25\n"
"-- domain used in HELO command and default sendmail\n"
"-- If we are under a CGI, try to get from environment\n"
"DOMAIN = os.getenv(\"SERVER_NAME\") or \"localhost\"\n"
"-- default time zone (means we don't know)\n"
"ZONE = \"-0000\"\n"
"\n"
"---------------------------------------------------------------------------\n"
"-- Low level SMTP API\n"
"-----------------------------------------------------------------------------\n"
"local metat = { __index = {} }\n"
"\n"
"function metat.__index:greet(domain)\n"
"    self.try(self.tp:check(\"2..\"))\n"
"    self.try(self.tp:command(\"EHLO\", domain or DOMAIN))\n"
"    return socket.skip(1, self.try(self.tp:check(\"2..\")))\n"
"end\n"
"\n"
"function metat.__index:mail(from)\n"
"    self.try(self.tp:command(\"MAIL\", \"FROM:\" .. from))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:rcpt(to)\n"
"    self.try(self.tp:command(\"RCPT\", \"TO:\" .. to))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:data(src, step)\n"
"    self.try(self.tp:command(\"DATA\"))\n"
"    self.try(self.tp:check(\"3..\"))\n"
"    self.try(self.tp:source(src, step))\n"
"    self.try(self.tp:send(\"\\r\\n"
".\\r\\n"
"\"))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:quit()\n"
"    self.try(self.tp:command(\"QUIT\"))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:close()\n"
"    return self.tp:close()\n"
"end\n"
"\n"
"function metat.__index:login(user, password)\n"
"    self.try(self.tp:command(\"AUTH\", \"LOGIN\"))\n"
"    self.try(self.tp:check(\"3..\"))\n"
"    self.try(self.tp:command(mime.b64(user)))\n"
"    self.try(self.tp:check(\"3..\"))\n"
"    self.try(self.tp:command(mime.b64(password)))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:plain(user, password)\n"
"    local auth = \"PLAIN \" .. mime.b64(\"\\0\" .. user .. \"\\0\" .. password)\n"
"    self.try(self.tp:command(\"AUTH\", auth))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:auth(user, password, ext)\n"
"    if not user or not password then return 1 end\n"
"    if string.find(ext, \"AUTH[^\\n"
"]+LOGIN\") then\n"
"        return self:login(user, password)\n"
"    elseif string.find(ext, \"AUTH[^\\n"
"]+PLAIN\") then\n"
"        return self:plain(user, password)\n"
"    else\n"
"        self.try(nil, \"authentication not supported\")\n"
"    end\n"
"end\n"
"\n"
"-- send message or throw an exception\n"
"function metat.__index:send(mailt)\n"
"    self:mail(mailt.from)\n"
"    if base.type(mailt.rcpt) == \"table\" then\n"
"        for i,v in base.ipairs(mailt.rcpt) do\n"
"            self:rcpt(v)\n"
"        end\n"
"    else\n"
"        self:rcpt(mailt.rcpt)\n"
"    end\n"
"    self:data(ltn12.source.chain(mailt.source, mime.stuff()), mailt.step)\n"
"end\n"
"\n"
"function open(server, port, create)\n"
"    local tp = socket.try(tp.connect(server or SERVER, port or PORT,\n"
"        TIMEOUT, create))\n"
"    local s = base.setmetatable({tp = tp}, metat)\n"
"    -- make sure tp is closed if we get an exception\n"
"    s.try = socket.newtry(function()\n"
"        s:close()\n"
"    end)\n"
"    return s\n"
"end\n"
"\n"
"-- convert headers to lowercase\n"
"local function lower_headers(headers)\n"
"    local lower = {}\n"
"    for i,v in base.pairs(headers or lower) do\n"
"        lower[string.lower(i)] = v\n"
"    end\n"
"    return lower\n"
"end\n"
"\n"
"---------------------------------------------------------------------------\n"
"-- Multipart message source\n"
"-----------------------------------------------------------------------------\n"
"-- returns a hopefully unique mime boundary\n"
"local seqno = 0\n"
"local function newboundary()\n"
"    seqno = seqno + 1\n"
"    return string.format('%s%05d==%05u', os.date('%d%m%Y%H%M%S'),\n"
"        math.random(0, 99999), seqno)\n"
"end\n"
"\n"
"-- send_message forward declaration\n"
"local send_message\n"
"\n"
"-- yield the headers all at once, it's faster\n"
"local function send_headers(headers)\n"
"    local h = \"\\r\\n"
"\"\n"
"    for i,v in base.pairs(headers) do\n"
"        h = i .. ': ' .. v .. \"\\r\\n"
"\" .. h\n"
"    end\n"
"    coroutine.yield(h)\n"
"end\n"
"\n"
"-- yield multipart message body from a multipart message table\n"
"local function send_multipart(mesgt)\n"
"    -- make sure we have our boundary and send headers\n"
"    local bd = newboundary()\n"
"    local headers = lower_headers(mesgt.headers or {})\n"
"    headers['content-type'] = headers['content-type'] or 'multipart/mixed'\n"
"    headers['content-type'] = headers['content-type'] ..\n"
"        '; boundary=\"' ..  bd .. '\"'\n"
"    send_headers(headers)\n"
"    -- send preamble\n"
"    if mesgt.body.preamble then\n"
"        coroutine.yield(mesgt.body.preamble)\n"
"        coroutine.yield(\"\\r\\n"
"\")\n"
"    end\n"
"    -- send each part separated by a boundary\n"
"    for i, m in base.ipairs(mesgt.body) do\n"
"        coroutine.yield(\"\\r\\n"
"--\" .. bd .. \"\\r\\n"
"\")\n"
"        send_message(m)\n"
"    end\n"
"    -- send last boundary\n"
"    coroutine.yield(\"\\r\\n"
"--\" .. bd .. \"--\\r\\n"
"\\r\\n"
"\")\n"
"    -- send epilogue\n"
"    if mesgt.body.epilogue then\n"
"        coroutine.yield(mesgt.body.epilogue)\n"
"        coroutine.yield(\"\\r\\n"
"\")\n"
"    end\n"
"end\n"
"\n"
"-- yield message body from a source\n"
"local function send_source(mesgt)\n"
"    -- make sure we have a content-type\n"
"    local headers = lower_headers(mesgt.headers or {})\n"
"    headers['content-type'] = headers['content-type'] or\n"
"        'text/plain; charset=\"iso-8859-1\"'\n"
"    send_headers(headers)\n"
"    -- send body from source\n"
"    while true do\n"
"        local chunk, err = mesgt.body()\n"
"        if err then coroutine.yield(nil, err)\n"
"        elseif chunk then coroutine.yield(chunk)\n"
"        else break end\n"
"    end\n"
"end\n"
"\n"
"-- yield message body from a string\n"
"local function send_string(mesgt)\n"
"    -- make sure we have a content-type\n"
"    local headers = lower_headers(mesgt.headers or {})\n"
"    headers['content-type'] = headers['content-type'] or\n"
"        'text/plain; charset=\"iso-8859-1\"'\n"
"    send_headers(headers)\n"
"    -- send body from string\n"
"    coroutine.yield(mesgt.body)\n"
"end\n"
"\n"
"-- message source\n"
"function send_message(mesgt)\n"
"    if base.type(mesgt.body) == \"table\" then send_multipart(mesgt)\n"
"    elseif base.type(mesgt.body) == \"function\" then send_source(mesgt)\n"
"    else send_string(mesgt) end\n"
"end\n"
"\n"
"-- set defaul headers\n"
"local function adjust_headers(mesgt)\n"
"    local lower = lower_headers(mesgt.headers)\n"
"    lower[\"date\"] = lower[\"date\"] or\n"
"        os.date(\"!%a, %d %b %Y %H:%M:%S \") .. (mesgt.zone or ZONE)\n"
"    lower[\"x-mailer\"] = lower[\"x-mailer\"] or socket._VERSION\n"
"    -- this can't be overriden\n"
"    lower[\"mime-version\"] = \"1.0\"\n"
"    return lower\n"
"end\n"
"\n"
"function message(mesgt)\n"
"    mesgt.headers = adjust_headers(mesgt)\n"
"    -- create and return message source\n"
"    local co = coroutine.create(function() send_message(mesgt) end)\n"
"    return function()\n"
"        local ret, a, b = coroutine.resume(co)\n"
"        if ret then return a, b\n"
"        else return nil, a end\n"
"    end\n"
"end\n"
"\n"
"---------------------------------------------------------------------------\n"
"-- High level SMTP API\n"
"-----------------------------------------------------------------------------\n"
"send = socket.protect(function(mailt)\n"
"    local s = open(mailt.server, mailt.port, mailt.create)\n"
"    local ext = s:greet(mailt.domain)\n"
"    s:auth(mailt.user, mailt.password, ext)\n"
"    s:send(mailt)\n"
"    s:quit()\n"
"    return s:close()\n"
"end)\n"
"",

"fenestra.widget.data","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"--\n"
"-- handle widgets data values\n"
"--\n"
"\n"
"\n"
"module(\"fenestra.widget.data\")\n"
"\n"
"\n"
"-- set number (may trigger hook)\n"
"local data_value=function(dat,num)\n"
"	if num and num~=dat.num then -- change value\n"
"		if num then dat.num=num end\n"
"		if dat.num<dat.min then dat.num=dat.min end\n"
"		if dat.num>dat.max then dat.num=dat.max end\n"
"--		dat.widget:call_hook(\"value\",dat) -- call value hook, which may choose to mod the num some more...\n"
"	end\n"
"	return dat.num\n"
"end\n"
"\n"
"\n"
"\n"
"-- a string to put in the handle\n"
"local data_get_string=function(dat)\n"
"	return math.floor(dat.num)..\"/\"..math.floor(dat.max)\n"
"end\n"
"\n"
"-- how wide or tall should the handle be given the size of the parent?\n"
"local data_get_size=function(dat,w)\n"
"	if dat.size==0 then\n"
"		if dat.min==dat.max then return w end -- fullsize		\n"
"		return w/4 -- else some room to scroll\n"
"	else\n"
"		return w*( dat.size / dat.max-dat.min )\n"
"	end\n"
"end\n"
"\n"
"\n"
"-- get display pos, given the size of the parent and our size?\n"
"local data_get_pos=function(dat,psiz,bsiz)\n"
"	if dat.step==0 then -- no snap\n"
"		return ((dat.num-dat.min)/(dat.max-dat.min))\n"
"	else\n"
"		return ((dat.num-dat.min)/(dat.max-dat.min))\n"
"	end\n"
"end\n"
"\n"
"-- given the parents size and our relative position/size within it\n"
"-- update dat.num and return a new position (for snapping)\n"
"local data_snap=function(dat,psiz,bsiz,bpos)\n"
"	if dat.step==0 then -- no snap\n"
"		if dat.max==dat.min then dat:value(dat.min) return 0 end -- do not move\n"
"		\n"
"		local f=bpos/(psiz-bsiz)\n"
"		dat:value(dat.min+((dat.max-dat.min)*f))\n"
"		\n"
"		return bpos\n"
"		\n"
"	else\n"
"	\n"
"		if dat.max==dat.min then dat:value(dat.min) return 0 end -- do not move\n"
"		\n"
"		local f=bpos/(psiz-bsiz)\n"
"		local n=math.floor(0.5+(((dat.max-dat.min)*f)/dat.step))\n"
"\n"
"		dat:value(dat.min+(n*dat.step))\n"
"		\n"
"		return math.floor((psiz-bsiz)*((dat.num-dat.min)/(dat.max-dat.min)))\n"
"	end\n"
"end\n"
"\n"
"\n"
"function new_data(dat)\n"
"\n"
"	local dat=dat or {} -- probably use what is passed in only fill in more values\n"
"--	dat.widget=it.widget\n"
"--	dat.it=it\n"
"--	dat.id=id\n"
"\n"
"	dat.class=dat.class or \"number\"\n"
"\n"
"-- make a default values and ranges for every possible class\n"
"-- this is heavy data...\n"
"\n"
"	dat.lst=dat.lst or {}\n"
"\n"
"	dat.str=dat.str or \"\"\n"
"	dat.str_idx=dat.str_idx or 0\n"
"\n"
"	dat.num=dat.num or 0\n"
"	dat.min=dat.min or 0\n"
"	dat.max=dat.max or 1\n"
"	dat.size=dat.size or 0 -- if 0 then button is auto sized to some value\n"
"	dat.step=dat.step or 0 -- if 0 then there is no quantization\n"
"	\n"
"	\n"
"-- setup callback functions\n"
"\n"
"	dat.get_string=data_get_string -- should be moved into value() ?\n"
"	dat.get_size=data_get_size\n"
"	dat.get_pos=data_get_pos\n"
"	\n"
"-- get or set the value\n"
"	dat.value=data_value\n"
"\n"
"-- work out snapping for scroll bars	\n"
"	dat.snap=data_snap\n"
"\n"
"	data_value(dat,dat.num) -- triger value changed/set callbacks\n"
"	\n"
"	return dat\n"
"	\n"
"end\n"
"\n"
"\n"
"",

"fenestra.test","\n"
"\n"
"local bit=require('bit')\n"
"local gl=require('gl')\n"
"\n"
"win=require('fenestra.wrap').win()\n"
"\n"
"\n"
"\n"
"win.setup(_G) -- create and associate with this global table, eg _G.print gets replaced\n"
"\n"
"win.width=win.get(\"width\")\n"
"win.height=win.get(\"height\")\n"
"\n"
"\n"
"local moddat,t=win.data.load(\"data/objects/xox/aball.xox\")\n"
"local xox=win.xox(moddat)\n"
"\n"
"\n"
"local xsx_dat,t=win.data.load(\"data/avatar/xsx/cycle_walk.xsx\")\n"
"local xsx=win.xsx(xsx_dat)\n"
"local soul=win.avatar.load_soul(\"local/avatar/soul/default.cthulhu.xml\")\n"
"\n"
"\n"
"local items={}\n"
"\n"
"world=require(\"box2d.wrap\").world({gravity={0,-10}})\n"
"\n"
"local ground = world.body{}\n"
"ground.shape{box={width=64,height=10},density=1,friction=0.3}\n"
"ground.set{x=0,y=-24-10,a=0}\n"
"\n"
"\n"
"function new_item(x,y,a)\n"
"\n"
"	local it={}\n"
"\n"
"	it.text=\"hello\"\n"
"	it.ts=1.6\n"
"	it.tc=0xff00ff00\n"
"	\n"
"	it.tx,it.ty=win.font_debug.size(it.text,it.ts)\n"
"	\n"
"	it.tx=-(it.tx/2)\n"
"	it.ty= (it.ty/2)\n"
"\n"
"	it.body=world.body{}\n"
"	it.body.shape{box={width=-it.tx,height=it.ty,center={0,0}},density=1,friction=0.3,restitution=0.25}\n"
"	it.body.set{mass=\"shapes\",x=x,y=y,a=a} -- calculate from shapes\n"
"	\n"
"	return it\n"
"end\n"
"\n"
"table.insert(items, new_item(0,10,0) )\n"
"\n"
"\n"
"function win.mouse(act,x,y,key)\n"
"\n"
"\n"
"	local hx=win.width/2\n"
"	local hy=win.height/2\n"
"\n"
"	local tx,ty\n"
"	\n"
"	if win.height/(win.width or 1) > (3/4) then -- deal with new viewport sizeing\n"
"	\n"
"		tx=(4/3)*(x-hx)/hx\n"
"		ty=(4/3)*(hy-y)/hx\n"
"		\n"
"	else\n"
"	\n"
"		tx=(x-hx)/hy\n"
"		ty=(hy-y)/hy\n"
"\n"
"	end\n"
"	\n"
"		\n"
"	win.widget.mouse(win.widget,act,320+tx*240,240+ty*240,key)\n"
"\n"
"	if act==\"down\" then\n"
"	\n"
"\n"
"		table.insert(items, new_item(tx*24,ty*24,0) )\n"
"	\n"
"	end\n"
"\n"
"end\n"
"	\n"
"--print(xsx)\n"
"--	xsx.set(t)\n"
"\n"
"	win.avatar.map_xsx(xsx,soul)\n"
"\n"
"\n"
"function modl(name)\n"
"\n"
"	moddat,t=win.data.load(\"data/avatar/xox/\"..name..\".xox\")\n"
"	\n"
"	if moddat then\n"
"	\n"
"		xox.clean()\n"
"		xox=win.xox(moddat)\n"
"		\n"
"	end\n"
"end\n"
"\n"
"local rx,ry,rz=0,0,0\n"
"local frame=0\n"
"\n"
"local last=win.time()\n"
"local frame_last=last\n"
"local frame_count=0\n"
"local fps=0\n"
"\n"
"local times={}\n"
"\n"
"local function times_setup()\n"
"	local t={}\n"
"	t.time=0\n"
"	t.time_live=0\n"
"	\n"
"	t.hash=0\n"
"	t.hash_live=0\n"
"	\n"
"	t.started=0\n"
"	\n"
"	function t.start()\n"
"		t.started=win.time()\n"
"	end\n"
"	\n"
"	function t.stop()\n"
"		local ended=win.time()\n"
"		\n"
"		t.time_live=t.time_live + ended-t.started\n"
"		t.hash_live=t.hash_live + 1\n"
"	end\n"
"	\n"
"	function t.done()\n"
"		t.time=t.time_live\n"
"		t.hash=t.hash_live\n"
"		t.time_live=0\n"
"		t.hash_live=0\n"
"		\n"
"	end\n"
"	\n"
"	return t\n"
"end\n"
"\n"
"\n"
"\n"
"times.update=times_setup()\n"
"times.draw=times_setup()\n"
"times.swap=times_setup()\n"
"\n"
"win.update=function()\n"
"\n"
"	win.width=win.get(\"width\")\n"
"	win.height=win.get(\"height\")\n"
"	\n"
"	\n"
"	local t=win.time()\n"
"	local d=t-last\n"
"	local d_orig=d\n"
"\n"
"-- count frames	\n"
"	if t-frame_last >= 1 then\n"
"	\n"
"		fps=frame_count\n"
"		frame_count=0\n"
"		frame_last=t\n"
"	\n"
"		times.update.done()\n"
"		times.draw.done()\n"
"		times.swap.done()\n"
"	end\n"
"	\n"
"-- update\n"
"\n"
"	local do_draw=false\n"
"	while d >= 0.020 do\n"
"	\n"
"		times.update.start()\n"
"		\n"
"		world.step(1/50,2)\n"
"		\n"
"		rx=(rx+1)%360\n"
"		ry=(ry+1)%360\n"
"		rz=(rz+1)%360\n"
"		\n"
"		frame=(frame+0.020)\n"
"		if frame>xsx.length then frame=frame-xsx.length end \n"
"		\n"
"		win.widget:update()\n"
"		\n"
"		win.console.update()\n"
"		\n"
"		times.update.stop()\n"
"		\n"
"		if d>1 then -- reset when very out of sync\n"
"			last=t\n"
"			d=0\n"
"		else\n"
"			last=last+0.020\n"
"			d=d-0.020\n"
"		end\n"
"		\n"
"		do_draw=true\n"
"	end\n"
"\n"
"-- draw\n"
"\n"
"\n"
"	if do_draw then\n"
"\n"
"		times.draw.start()\n"
"		win.begin()\n"
"		\n"
"		gl.MatrixMode(\"MODELVIEW\")\n"
"		gl.LoadIdentity()\n"
"		\n"
"\n"
"		\n"
"\n"
"--		for x=-10,10,10 do\n"
"--			for y=-10,10,10 do\n"
"\n"
"		local x,y=0,0\n"
"			\n"
"				gl.PushMatrix()\n"
"				\n"
"				gl.Translate(x/2,y/2, 0)\n"
"				\n"
"		gl.Translate(0,0, -32)\n"
"		gl.Scale(8,8,8)\n"
"		gl.Rotate(rz,0,0,1);\n"
"		gl.Rotate(ry,0,1,0);\n"
"		gl.Rotate(rx,1,0,0);\n"
"		\n"
"--				win.draw_cube(0.5)\n"
"--				xox.draw()\n"
"				xsx.draw(frame);\n"
"				\n"
"				gl.PopMatrix()\n"
"				\n"
"--			end\n"
"--		end\n"
"\n"
"\n"
"		for i,v in ipairs(items) do\n"
"		\n"
"			\n"
"			v.body.get()\n"
"			gl.PushMatrix()\n"
"			\n"
"			gl.Translate(v.body.x,v.body.y, -24)\n"
"			gl.Rotate(v.body.a,0,0,1);\n"
"--[[\n"
"			gl.Rotate(90,0,1,0);\n"
"			xsx.draw(frame);\n"
"			gl.Rotate(-90,0,1,0);\n"
"]]			\n"
"			win.font_debug.set(v.tx,v.ty,v.tc,v.ts)\n"
"			win.font_debug.draw(v.text)\n"
"\n"
"		\n"
"			gl.PopMatrix()\n"
"		end\n"
"		\n"
"		\n"
"		gl.PushMatrix()\n"
"		gl.Translate(-320,-240, -240*1.0)\n"
"		win.widget:draw()\n"
"		gl.PopMatrix()\n"
"		\n"
"		win.console.draw()\n"
"		\n"
"--		win.debug_rect(0,0,640,480,0x44000000)\n"
"	\n"
"		win.swap()\n"
"		times.draw.stop()\n"
"		\n"
"		frame_count=frame_count+1\n"
"		\n"
"		local gci=gcinfo()\n"
"		win.console.display(string.format(\"fps=%02.0f t=%03.0f u=%03.0f d=%03.0f gc=%0.0fk\",fps,math.floor(0.5+(10000/fps)),math.floor(0.5+times.update.time*10000),math.floor(0.5+times.draw.time*10000/times.draw.hash),math.floor(gci) ))\n"
"		\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"while win.msg(\"wait\") do\n"
"\n"
"	win.update()\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"win.clean()\n"
"\n"
"",

"socket.ftp","-----------------------------------------------------------------------------\n"
"-- FTP support for the Lua language\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: ftp.lua,v 1.45 2007/07/11 19:25:47 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local table = require(\"table\")\n"
"local string = require(\"string\")\n"
"local math = require(\"math\")\n"
"local socket = require(\"socket\")\n"
"local url = require(\"socket.url\")\n"
"local tp = require(\"socket.tp\")\n"
"local ltn12 = require(\"ltn12\")\n"
"module(\"socket.ftp\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Program constants\n"
"-----------------------------------------------------------------------------\n"
"-- timeout in seconds before the program gives up on a connection\n"
"TIMEOUT = 60\n"
"-- default port for ftp service\n"
"PORT = 21\n"
"-- this is the default anonymous password. used when no password is\n"
"-- provided in url. should be changed to your e-mail.\n"
"USER = \"ftp\"\n"
"PASSWORD = \"anonymous@anonymous.org\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Low level FTP API\n"
"-----------------------------------------------------------------------------\n"
"local metat = { __index = {} }\n"
"\n"
"function open(server, port, create)\n"
"    local tp = socket.try(tp.connect(server, port or PORT, TIMEOUT, create))\n"
"    local f = base.setmetatable({ tp = tp }, metat)\n"
"    -- make sure everything gets closed in an exception\n"
"    f.try = socket.newtry(function() f:close() end)\n"
"    return f\n"
"end\n"
"\n"
"function metat.__index:portconnect()\n"
"    self.try(self.server:settimeout(TIMEOUT))\n"
"    self.data = self.try(self.server:accept())\n"
"    self.try(self.data:settimeout(TIMEOUT))\n"
"end\n"
"\n"
"function metat.__index:pasvconnect()\n"
"    self.data = self.try(socket.tcp())\n"
"    self.try(self.data:settimeout(TIMEOUT))\n"
"    self.try(self.data:connect(self.pasvt.ip, self.pasvt.port))\n"
"end\n"
"\n"
"function metat.__index:login(user, password)\n"
"    self.try(self.tp:command(\"user\", user or USER))\n"
"    local code, reply = self.try(self.tp:check{\"2..\", 331})\n"
"    if code == 331 then\n"
"        self.try(self.tp:command(\"pass\", password or PASSWORD))\n"
"        self.try(self.tp:check(\"2..\"))\n"
"    end\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:pasv()\n"
"    self.try(self.tp:command(\"pasv\"))\n"
"    local code, reply = self.try(self.tp:check(\"2..\"))\n"
"    local pattern = \"(%d+)%D(%d+)%D(%d+)%D(%d+)%D(%d+)%D(%d+)\"\n"
"    local a, b, c, d, p1, p2 = socket.skip(2, string.find(reply, pattern))\n"
"    self.try(a and b and c and d and p1 and p2, reply)\n"
"    self.pasvt = {\n"
"        ip = string.format(\"%d.%d.%d.%d\", a, b, c, d),\n"
"        port = p1*256 + p2\n"
"    }\n"
"    if self.server then\n"
"        self.server:close()\n"
"        self.server = nil\n"
"    end\n"
"    return self.pasvt.ip, self.pasvt.port\n"
"end\n"
"\n"
"function metat.__index:port(ip, port)\n"
"    self.pasvt = nil\n"
"    if not ip then\n"
"        ip, port = self.try(self.tp:getcontrol():getsockname())\n"
"        self.server = self.try(socket.bind(ip, 0))\n"
"        ip, port = self.try(self.server:getsockname())\n"
"        self.try(self.server:settimeout(TIMEOUT))\n"
"    end\n"
"    local pl = math.mod(port, 256)\n"
"    local ph = (port - pl)/256\n"
"    local arg = string.gsub(string.format(\"%s,%d,%d\", ip, ph, pl), \"%.\", \",\")\n"
"    self.try(self.tp:command(\"port\", arg))\n"
"    self.try(self.tp:check(\"2..\"))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:send(sendt)\n"
"    self.try(self.pasvt or self.server, \"need port or pasv first\")\n"
"    -- if there is a pasvt table, we already sent a PASV command\n"
"    -- we just get the data connection into self.data\n"
"    if self.pasvt then self:pasvconnect() end\n"
"    -- get the transfer argument and command\n"
"    local argument = sendt.argument or\n"
"        url.unescape(string.gsub(sendt.path or \"\", \"^[/\\\\]\", \"\"))\n"
"    if argument == \"\" then argument = nil end\n"
"    local command = sendt.command or \"stor\"\n"
"    -- send the transfer command and check the reply\n"
"    self.try(self.tp:command(command, argument))\n"
"    local code, reply = self.try(self.tp:check{\"2..\", \"1..\"})\n"
"    -- if there is not a a pasvt table, then there is a server\n"
"    -- and we already sent a PORT command\n"
"    if not self.pasvt then self:portconnect() end\n"
"    -- get the sink, source and step for the transfer\n"
"    local step = sendt.step or ltn12.pump.step\n"
"    local readt = {self.tp.c}\n"
"    local checkstep = function(src, snk)\n"
"        -- check status in control connection while downloading\n"
"        local readyt = socket.select(readt, nil, 0)\n"
"        if readyt[tp] then code = self.try(self.tp:check(\"2..\")) end\n"
"        return step(src, snk)\n"
"    end\n"
"    local sink = socket.sink(\"close-when-done\", self.data)\n"
"    -- transfer all data and check error\n"
"    self.try(ltn12.pump.all(sendt.source, sink, checkstep))\n"
"    if string.find(code, \"1..\") then self.try(self.tp:check(\"2..\")) end\n"
"    -- done with data connection\n"
"    self.data:close()\n"
"    -- find out how many bytes were sent\n"
"    local sent = socket.skip(1, self.data:getstats())\n"
"    self.data = nil\n"
"    return sent\n"
"end\n"
"\n"
"function metat.__index:receive(recvt)\n"
"    self.try(self.pasvt or self.server, \"need port or pasv first\")\n"
"    if self.pasvt then self:pasvconnect() end\n"
"    local argument = recvt.argument or\n"
"        url.unescape(string.gsub(recvt.path or \"\", \"^[/\\\\]\", \"\"))\n"
"    if argument == \"\" then argument = nil end\n"
"    local command = recvt.command or \"retr\"\n"
"    self.try(self.tp:command(command, argument))\n"
"    local code = self.try(self.tp:check{\"1..\", \"2..\"})\n"
"    if not self.pasvt then self:portconnect() end\n"
"    local source = socket.source(\"until-closed\", self.data)\n"
"    local step = recvt.step or ltn12.pump.step\n"
"    self.try(ltn12.pump.all(source, recvt.sink, step))\n"
"    if string.find(code, \"1..\") then self.try(self.tp:check(\"2..\")) end\n"
"    self.data:close()\n"
"    self.data = nil\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:cwd(dir)\n"
"    self.try(self.tp:command(\"cwd\", dir))\n"
"    self.try(self.tp:check(250))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:type(type)\n"
"    self.try(self.tp:command(\"type\", type))\n"
"    self.try(self.tp:check(200))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:greet()\n"
"    local code = self.try(self.tp:check{\"1..\", \"2..\"})\n"
"    if string.find(code, \"1..\") then self.try(self.tp:check(\"2..\")) end\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:quit()\n"
"    self.try(self.tp:command(\"quit\"))\n"
"    self.try(self.tp:check(\"2..\"))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:close()\n"
"    if self.data then self.data:close() end\n"
"    if self.server then self.server:close() end\n"
"    return self.tp:close()\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- High level FTP API\n"
"-----------------------------------------------------------------------------\n"
"local function override(t)\n"
"    if t.url then\n"
"        local u = url.parse(t.url)\n"
"        for i,v in base.pairs(t) do\n"
"            u[i] = v\n"
"        end\n"
"        return u\n"
"    else return t end\n"
"end\n"
"\n"
"local function tput(putt)\n"
"    putt = override(putt)\n"
"    socket.try(putt.host, \"missing hostname\")\n"
"    local f = open(putt.host, putt.port, putt.create)\n"
"    f:greet()\n"
"    f:login(putt.user, putt.password)\n"
"    if putt.type then f:type(putt.type) end\n"
"    f:pasv()\n"
"    local sent = f:send(putt)\n"
"    f:quit()\n"
"    f:close()\n"
"    return sent\n"
"end\n"
"\n"
"local default = {\n"
"	path = \"/\",\n"
"	scheme = \"ftp\"\n"
"}\n"
"\n"
"local function parse(u)\n"
"    local t = socket.try(url.parse(u, default))\n"
"    socket.try(t.scheme == \"ftp\", \"wrong scheme '\" .. t.scheme .. \"'\")\n"
"    socket.try(t.host, \"missing hostname\")\n"
"    local pat = \"^type=(.)$\"\n"
"    if t.params then\n"
"        t.type = socket.skip(2, string.find(t.params, pat))\n"
"        socket.try(t.type == \"a\" or t.type == \"i\",\n"
"            \"invalid type '\" .. t.type .. \"'\")\n"
"    end\n"
"    return t\n"
"end\n"
"\n"
"local function sput(u, body)\n"
"    local putt = parse(u)\n"
"    putt.source = ltn12.source.string(body)\n"
"    return tput(putt)\n"
"end\n"
"\n"
"put = socket.protect(function(putt, body)\n"
"    if base.type(putt) == \"string\" then return sput(putt, body)\n"
"    else return tput(putt) end\n"
"end)\n"
"\n"
"local function tget(gett)\n"
"    gett = override(gett)\n"
"    socket.try(gett.host, \"missing hostname\")\n"
"    local f = open(gett.host, gett.port, gett.create)\n"
"    f:greet()\n"
"    f:login(gett.user, gett.password)\n"
"    if gett.type then f:type(gett.type) end\n"
"    f:pasv()\n"
"    f:receive(gett)\n"
"    f:quit()\n"
"    return f:close()\n"
"end\n"
"\n"
"local function sget(u)\n"
"    local gett = parse(u)\n"
"    local t = {}\n"
"    gett.sink = ltn12.sink.table(t)\n"
"    tget(gett)\n"
"    return table.concat(t)\n"
"end\n"
"\n"
"command = socket.protect(function(cmdt)\n"
"    cmdt = override(cmdt)\n"
"    socket.try(cmdt.host, \"missing hostname\")\n"
"    socket.try(cmdt.command, \"missing command\")\n"
"    local f = open(cmdt.host, cmdt.port, cmdt.create)\n"
"    f:greet()\n"
"    f:login(cmdt.user, cmdt.password)\n"
"    f.try(f.tp:command(cmdt.command, cmdt.argument))\n"
"    if cmdt.check then f.try(f.tp:check(cmdt.check)) end\n"
"    f:quit()\n"
"    return f:close()\n"
"end)\n"
"\n"
"get = socket.protect(function(gett)\n"
"    if base.type(gett) == \"string\" then return sget(gett)\n"
"    else return tget(gett) end\n"
"end)\n"
"\n"
"",

"fenestra.widget.scroll","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"-- a scrolling area, the widget is biger than display area but scroll bars allow you to see it all\n"
"\n"
"\n"
"\n"
"module(\"fenestra.widget.scroll\")\n"
"\n"
"\n"
"function mouse(widget,act,x,y,key)\n"
"--	widget.master.focus=widget\n"
"	return widget.meta.mouse(widget,act,x,y,key)\n"
"end\n"
"\n"
"\n"
"function key(widget,ascii,key,act)\n"
"	return widget.meta.key(widget,ascii,key,act)\n"
"end\n"
"\n"
"\n"
"function update(widget)\n"
"\n"
"	local pan=widget.pan\n"
"	\n"
"	local pan_px=-widget.slidex.datx.num*1000\n"
"	local pan_py=widget.slidey.daty.num*1000\n"
"	\n"
"	if pan_px~=pan.pan_px or pan_py~=pan.pan_py then\n"
"	\n"
"		pan.pan_px=pan_px\n"
"		pan.pan_py=pan_py\n"
"		\n"
"		pan:set_dirty()\n"
"	end\n"
"\n"
"	return widget.meta.update(widget)\n"
"end\n"
"\n"
"function draw(widget)\n"
"\n"
"--	local it=widget.scroll\n"
"	\n"
"	return widget.meta.draw(widget)\n"
"end\n"
"\n"
"function setup(widget,def)\n"
"--	local it={}\n"
"--	widget.scroll=it\n"
"	widget.class=\"scroll\"\n"
"	\n"
"	widget.key=key\n"
"	widget.mouse=mouse\n"
"	widget.update=update\n"
"	widget.draw=draw\n"
"\n"
"-- auto add the draging button as a child\n"
"	local ss=16\n"
"	if widget.hx<ss*2 then ss=widget.hx/2 end\n"
"	if widget.hy<ss*2 then ss=widget.hy/2 end\n"
"	\n"
"	widget.pan=		widget:add({class=\"pan\",	hx=widget.hx-ss,	hy=widget.hy-ss,	})\n"
"	widget.slidey=	widget:add({class=\"slide\",	hx=ss,				hy=widget.hy-ss,	px=widget.hx-ss,	py=0,\n"
"		datx={max=0},daty={max=1},color=0xffffffff})\n"
"	widget.slidex=	widget:add({class=\"slide\",	hx=widget.hx-ss,	hy=ss,           	px=0,           	py=widget.hy-ss,\n"
"		datx={max=1},daty={max=0},color=0xffffffff})\n"
"\n"
"	return widget\n"
"end\n"
"",

"spew.comm","\n"
"\n"
"\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local string=string\n"
"local math=math\n"
"local os=os\n"
"local print=print\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"--\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"module(\"spew.comm\")\n"
"\n"
"\n"
"-- all connections look up by client\n"
"cons=cons or {}\n"
"\n"
"-- waiting with data to read\n"
"active=active or {}\n"
"\n"
"-- create table of connections for use in socket.select\n"
"recvt=recvt or {}\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- create a con for this client\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function setup(client,opts)\n"
"\n"
"	if not client then return nil end\n"
"	\n"
"opts=opts or {}\n"
"\n"
"	local con={}\n"
"	cons[client]=con\n"
"	\n"
"	con.client=client\n"
"	con.format=opts.format\n"
"	con.linein={} -- lines come in here\n"
"	con.msg={} -- our current incoming msg for spew communication deltas\n"
"\n"
"-- keep a table for connect to use\n"
"	local n=#recvt+1\n"
"	recvt[n]=client\n"
"	recvt[client]=n\n"
"\n"
"	client:settimeout(0.00001) -- this is a hack fix?\n"
"	\n"
"	return con\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- remove this client from active clients, destroying the con\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function clean(client)\n"
"\n"
"local con=cons[client]\n"
"\n"
"	client:close()\n"
"	\n"
"	local n=recvt[client]\n"
"	recvt[client]=nil\n"
"	table.remove(recvt,n)\n"
"	\n"
"	cons[client]=nil\n"
"	active[client]=nil\n"
"\n"
"	return con\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get con from client\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function con(client)\n"
"	return cons[client]\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- client connect\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function connected(client,format)\n"
"\n"
"local con=cons[client]\n"
"\n"
"	client:settimeout(0.00001) -- this is a hack fix?\n"
"\n"
"	return con\n"
"end\n"
"				\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- client disconnect\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function disconnect(client)\n"
"	return clean(client)\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- send a line to a client\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function send(client,line)\n"
"\n"
"local con=cons[client]\n"
"\n"
"	if ( not client ) or ( not line ) or ( not con ) then return end\n"
"	\n"
"	if line~=\"\" then\n"
"	\n"
"		client:send(line)\n"
"		\n"
"--print(line)\n"
"\n"
"	end\n"
"\n"
"	return con\n"
"end\n"
"\n"
"	\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- receive some data from a client\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function received(client,line)\n"
"\n"
"local con=cons[client]\n"
"\n"
"local line_term=\"\\0\" -- spew default\n"
"\n"
"	if con.format==\"spew\" then -- default\n"
"--		line_term=\"\\0\"\n"
"	elseif con.format==\"telnet\" then -- break on \\n"
" not \\0\n"
"		line_term=\"\\n"
"\"\n"
"	elseif con.format==\"irc\" then -- break on \\n"
" not \\0\n"
"		line_term=\"\\n"
"\"\n"
"	elseif con.format==\"websocket\" then -- break on \\255 not \\0\n"
"		line_term=\"\\255\"\n"
"	end\n"
"	\n"
"	if con.lineparts then -- continue our cache\n"
"	\n"
"		con.lineparts=con.lineparts..line			\n"
"		\n"
"	else -- start new cache\n"
"	\n"
"		con.lineparts=line\n"
"		\n"
"	end\n"
"	\n"
"	if string.len(con.lineparts)>16384 then -- catch large packets\n"
"		return clean(client) -- and close connection on spam\n"
"	end\n"
"	\n"
"	local zero,linepart\n"
"	\n"
"	zero=string.find(con.lineparts,line_term)\n"
"	\n"
"	while zero do -- we have a command or more to split up\n"
"	\n"
"		if zero>1 then\n"
"		\n"
"			linepart=string.sub(con.lineparts,1,zero-1) -- command\n"
"			con.lineparts=string.sub(con.lineparts,zero+1) -- remainder\n"
"		\n"
"			table.insert(con.linein,linepart) -- handle this line later\n"
"		else\n"
"			con.lineparts=string.sub(con.lineparts,zero+1) -- remainder\n"
"		end\n"
"		\n"
"		zero=string.find(con.lineparts,line_term)\n"
"	end\n"
"\n"
"	if con.linein[1] then active[client]=con end -- flag the connection as waiting\n"
"\n"
"	return con\n"
"end\n"
"\n"
"\n"
"\n"
"",

"apps","\n"
"-- create a global function that can be called to fix lua paths so we can find things\n"
"-- unfortunatly you still have to know where this file is first and run a \n"
"-- dofile(\"thisfile\") need to come up with a better plan, possibly preload a module?\n"
"\n"
"local package=package\n"
"local require=require\n"
"local string=string\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local print=print\n"
"local os=os\n"
"local io=io\n"
"\n"
"module(\"apps\")\n"
"\n"
"function setpaths(dll,dirs)\n"
"\n"
"	local cpath={}\n"
"	for i,v in ipairs(dirs) do\n"
"		cpath[#cpath+1]=v .. \"?.\" .. dll\n"
"		cpath[#cpath+1]=v .. \"?/init.\" .. dll\n"
"	end\n"
"	cpath[#cpath+1]=package.cpath\n"
"	\n"
"	local path={}\n"
"	for i,v in ipairs(dirs) do\n"
"		path[#path+1]=v .. \"lua/?.lua\"\n"
"		path[#path+1]=v .. \"lua/?/init.lua\"\n"
"	end\n"
"	path[#path+1]=package.path\n"
"\n"
"\n"
"	package.cpath=table.concat(cpath,\";\")\n"
"	package.path=table.concat(path,\";\")\n"
"\n"
"end\n"
"\n"
"--\n"
"-- this needs to get more searchy so it can find where the lua app is without any explicit values\n"
"--\n"
"function find(name)\n"
"\n"
"	local lfs=require(\"lfs\")\n"
"\n"
"--\n"
"-- get/set current dir\n"
"--\n"
"	local get_cd=function()\n"
"\n"
"		return string.gsub(lfs.currentdir(),'\\\\','/')\n"
"\n"
"	end\n"
"	local set_cd=function(str)\n"
"\n"
"		lfs.chdir(str)\n"
"\n"
"	end\n"
"	local file_exists=function(str)\n"
"		local fp=io.open(str,\"r\")\n"
"		if fp then fp:close() return true end\n"
"		return false\n"
"	end\n"
"\n"
"-- we are looking for a dir/lua/name.lua and dir will be our base dir so look in various places\n"
"\n"
"	local osflavour=\"win\"\n"
"	local os_shell=os.getenv(\"SHELL\")\n"
"	if os_shell and string.sub(os_shell,1,5)== \"/bin/\" then -- if your shell is not here then we assume windows...\n"
"		osflavour=\"nix\"\n"
"	end\n"
"\n"
"	local dll=\"dll\"\n"
"	if osflavour==\"nix\" then dll=\"so\" end\n"
"\n"
"	local dir=get_cd()\n"
"\n"
"	local tdirs={ -- look in these dirs\n"
"		dir,\n"
"		dir..\"/bin\",\n"
"		dir..\"/..\",\n"
"		dir..\"/../bin\",\n"
"		dir..\"/../lua\",\n"
"		dir..\"/../lua/bin\",\n"
"	}\n"
"	local bin_dir=dir..\"/\"\n"
"	for i=1,#tdirs do local v=tdirs[i]\n"
"		if file_exists(v..\"/lua/apps.lua\") then bin_dir=v..\"/\" break end -- found a bin dir?\n"
"	end\n"
"\n"
"print(\"BIN PATH\",bin_dir,dll)\n"
"\n"
"\n"
"	local tdirs={ -- look in these dirs\n"
"	\n"
"		dir,\n"
"		dir..\"/\"..name,\n"
"		dir..\"/apps/\"..name,\n"
"		dir..\"/lua/\"..name,\n"
"		dir..\"/lua/apps/\"..name,\n"
"		\n"
"		dir..\"/..\",\n"
"		dir..\"/../\"..name,\n"
"		dir..\"/../apps/\"..name,\n"
"		dir..\"/../lua/\"..name,\n"
"		dir..\"/../lua/apps/\"..name,\n"
"		\n"
"		dir..\"/../..\",\n"
"		dir..\"/../../\"..name,\n"
"		dir..\"/../../apps/\"..name,\n"
"		dir..\"/../../lua/\"..name,\n"
"		dir..\"/../../lua/apps/\"..name,\n"
"		\n"
"	}\n"
"	local app_dir=dir..\"/\"\n"
"	local app_name=name\n"
"	for i=1,#tdirs do local v=tdirs[i]\n"
"		if file_exists(v..\"/lua/\"..name..\".lua\") then app_dir=v..\"/\" break end -- found a base dir?\n"
"		if file_exists(v..\"/lua/app.lua\") then app_dir=v..\"/\" app_name=\"app\" break end -- found a base dir?\n"
"	end\n"
"\n"
"print(\"APP PATH\",app_dir,dll)\n"
"\n"
"	setpaths(dll,{app_dir,bin_dir})\n"
"\n"
"	return app_dir,app_name\n"
"end\n"
"\n"
"\n"
"-- only call this once\n"
"-- probably on the commandline\n"
"function start(_name,...)\n"
"\n"
"	path_orig=package.path\n"
"	cpath_orig=package.cpath\n"
"\n"
"	exe=\"exe\"\n"
"	name=_name\n"
"	dll=\"so\"\n"
"\n"
"	dir,appname=find(name)\n"
"\n"
"	path=package.path\n"
"	cpath=package.cpath\n"
"\n"
"	print(\"appname \",appname)\n"
"	print(\"apps.exe\",exe)\n"
"	print(\"apps.name\",name)\n"
"	print(\"apps.dll\",dll)\n"
"	print(\"apps.dir\",dir)\n"
"	print(...)\n"
"\n"
"	return require(appname).start(...)\n"
"end\n"
"\n"
"\n"
"-- make sure we return the module so we can use it in a dofile(\"apps.lua\")\n"
"--return package.loaded.apps\n"
"",

"wetgenes.cgilua.misc","\n"
"local assert,error,getfenv,getmetatable,ipairs,loadstring,next,pairs,pcall,print,rawget,rawset,setfenv,setmetatable,tonumber,tostring,type,unpack,xpcall = assert,error,getfenv,getmetatable,ipairs,loadstring,next,pairs,pcall,print,rawget,rawset,setfenv,setmetatable,tonumber,tostring,type,unpack,xpcall\n"
"\n"
"local string,table=string,table\n"
"\n"
"\n"
"\n"
"module(\"wetgenes.cgilua.misc\")\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert an ipstr \"a.b.c.d\" to a number\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function ipstr_to_number(str)\n"
"\n"
"local num=0\n"
"\n"
"	for word in string.gmatch(str, \"[^.]+\") do num=num*256+tonumber(word) end\n"
"	\n"
"	return num\n"
"\n"
"end\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert a number to an ipstr \"a.b.c.d\"\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function number_to_ipstr(num)\n"
"\n"
"local h,s\n"
"\n"
"	h=string.format(\"%08x\",num)\n"
"\n"
"	s=tonumber( string.sub(h,1,2) , 16 ) .. \".\" ..\n"
"	  tonumber( string.sub(h,3,4) , 16 ) .. \".\" ..\n"
"	  tonumber( string.sub(h,5,6) , 16 ) .. \".\" ..\n"
"	  tonumber( string.sub(h,7,8) , 16 ) \n"
"\n"
"	return s\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split a string into a table\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function str_split(div,str)\n"
"\n"
"  if (div=='') or not div then error(\"div expected\", 2) end\n"
"  if not str then error(\"str expected\", 2) end\n"
"  if str==\"\" then return {\"\"} end\n"
"  \n"
"  local pos,arr = 0,{}\n"
"  \n"
"  -- for each divider found\n"
"  for st,sp in function() return string.find(str,div,pos,true) end do\n"
"	table.insert(arr,string.sub(str,pos,st-1)) -- Attach chars left of current divider\n"
"	pos = sp + 1 -- Jump past current divider\n"
"  end\n"
"  \n"
"  if pos~=0 then\n"
"	table.insert(arr,string.sub(str,pos)) -- Attach chars right of last divider\n"
"  else\n"
"	table.insert(arr,str) -- return entire string\n"
"  end\n"
"  \n"
"  \n"
"  return arr\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- join a table of things into an english list with commas and an \"and\" at the end\n"
"-- returns nil if the table is empty\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function str_join_english_list(t)\n"
"\n"
"local s\n"
"\n"
"	for i,v in ipairs(t) do\n"
"	\n"
"		if not s then -- first\n"
"		\n"
"			s=v\n"
"			\n"
"		elseif t[i+1]==nil then -- last\n"
"		\n"
"			s=s..\" and \"..v\n"
"			\n"
"		else -- middle\n"
"		\n"
"			s=s..\", \"..v\n"
"			\n"
"		end\n"
"	\n"
"	end\n"
"\n"
"	return s\n"
"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert a string into a hex string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function str_to_hex(s)\n"
"	return string.gsub(s, \".\", function (c)\n"
"		return string.format(\"%02x\", string.byte(c))\n"
"	end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- escape a string for mysql, convert to a (possibly large) number in hex\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function mysql_escape(s)\n"
"	return \"0x\"..str_to_hex(s)\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace any %xx with the intended char, eg \"%20\" becomes a \" \"\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_decode(str)\n"
"    return string.gsub(str, \"%%(%x%x)\", function(hex)\n"
"        return string.char(tonumber(hex, 16))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace % , & and = chars with %xx codes\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_encode(str)\n"
"    return string.gsub(str, \"([&=%%])\", function(c)\n"
"        return string.format(\"%%%02x\", string.byte(c))\n"
"    end)\n"
"--  return str\n"
"end\n"
"",

"fenestra.widget.pan","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"-- an fbo cached area, that is an area which should always be drawn to a special buffer\n"
"-- and then the special buffer should be displayed\n"
"\n"
"\n"
"\n"
"module(\"fenestra.widget.pan\")\n"
"\n"
"\n"
"function mouse(widget,act,x,y,key)\n"
"--	widget.master.focus=widget\n"
"	return widget.meta.mouse(widget,act,x,y,key)\n"
"end\n"
"\n"
"\n"
"function key(widget,ascii,key,act)\n"
"	return widget.meta.key(widget,ascii,key,act)\n"
"end\n"
"\n"
"\n"
"function update(widget)\n"
"	return widget.meta.update(widget)\n"
"end\n"
"\n"
"function draw(widget)\n"
"	return widget.meta.draw(widget)\n"
"end\n"
"\n"
"\n"
"function setup(widget,def)\n"
"--	local it={}\n"
"--	widget.pan=it\n"
"	widget.class=\"pan\"\n"
"	\n"
"	widget.pan_px=0\n"
"	widget.pan_py=0\n"
"	\n"
"	widget.key=key\n"
"	widget.mouse=mouse\n"
"	widget.update=update\n"
"	widget.draw=draw\n"
"	\n"
"	widget.fbo=_G.win.fbo(0,0,0)\n"
"\n"
"	return widget\n"
"end\n"
"",

"wetquire","\n"
"local oldmodule=module\n"
"local oldrequire=require\n"
"\n"
"-- unhappy modules, do not use this code with them\n"
"local cruft_list={\n"
"	[\"lanes\"]=true,\n"
"	[\"socket\"]=true,\n"
"}\n"
"\n"
"local os=os\n"
"\n"
"-- a small attempt to replace the module function and to impliment live reloading of lua code\n"
"-- on demand without restarting a lua state, this is dodgy but rather useful for testing\n"
"-- and live server situations where downtime is to be avoided. Small changes can be pushed\n"
"-- to a live server seamlessly with a little care.\n"
"\n"
"local _overload\n"
"local _rerequire\n"
"local _remodule\n"
"local _require\n"
"local _module\n"
"\n"
"\n"
"-- modules loaded before this time whould be reloaded when required\n"
"-- defaults to 0, just set to os.time() then rerequire your main module\n"
"-- and it should reload every lua module that supports reloading\n"
"local reload_time=0\n"
"\n"
"--\n"
"-- we are about to use this new module function in this file so it needs to be\n"
"-- defined here\n"
"--\n"
"function _remodule(name)\n"
"--print(name)\n"
"--print(package.loaded[name])\n"
"	local mod = package.loaded[name] -- reuse old environment on a reload\n"
"	if mod~=\"table\" then --  or make a new one\n"
"		mod={}\n"
"	end\n"
"	\n"
"-- push some extra data into the module, this flags the module as being a remodule\n"
"-- and provides what I need to reload it from disk\n"
"-- if _MOD_FILENAME is not going to work then do not use this version of module\n"
"-- if you are expecting side effects from the normal module function then again\n"
"-- do not use this version :)\n"
"	mod._MOD_NAME=name\n"
"	mod._MOD_FILENAME=debug.getinfo(2).short_src -- where to reload from\n"
"	mod._MOD_LOADTIME=os.time() -- the time that we where loaded \n"
"\n"
"	print(\"Loaded module : \".. mod._MOD_FILENAME)\n"
"\n"
"	package.loaded[name] = mod\n"
"	setfenv(2, mod)\n"
"	\n"
"	return mod\n"
"end\n"
"\n"
"\n"
"--\n"
"-- A require function that can reload the lua source when told to do so\n"
"--\n"
"function _rerequire(s)\n"
"	if cruft_list[s] then return _require(s) end -- use old require and module functions\n"
"\n"
"	local oldstate=_overload(false)\n"
"\n"
"	local mod=oldrequire(s)\n"
"\n"
"	if type(mod)==\"table\" and mod._MOD_LOADTIME and ( mod._MOD_LOADTIME < reload_time ) then -- force reload\n"
"\n"
"		if mod._MOD_FILENAME then\n"
"			if not mod._MOD_DISABLE_RELOAD then\n"
"				local f,err=loadfile(mod._MOD_FILENAME)\n"
"				if f then\n"
"					f()\n"
"				else\n"
"					print(err) -- treat as warning\n"
"				end\n"
"			end\n"
"		end\n"
"	\n"
"	end\n"
"\n"
"	_overload(oldstate)\n"
"	return mod\n"
"end\n"
"\n"
"function _require(s)\n"
"	local oldstate=_overload(true)\n"
"	local mod=oldrequire(s)\n"
"	_overload(oldstate)\n"
"	return mod\n"
"end\n"
"\n"
"_module=oldmodule\n"
"\n"
"--\n"
"-- replace global functions, or restore (restore=true)\n"
"-- returns true if they where the original functions\n"
"--\n"
"function _overload(restore)\n"
"\n"
"	local oldstate=(require==oldrequire) -- true if functions are not replaced\n"
"\n"
"	if restore then -- restore\n"
"\n"
"		require=oldrequire\n"
"		module=oldmodule\n"
"		\n"
"	else -- replace\n"
"	\n"
"		require=_rerequire\n"
"		module=_remodule\n"
"		\n"
"	end\n"
"\n"
"	return oldstate\n"
"end\n"
"\n"
"\n"
"_remodule(\"wetquire\")\n"
"\n"
"_MOD_DISABLE_RELOAD=true -- disable reload of this module\n"
"\n"
"module=_module\n"
"require=_require\n"
"\n"
"remodule=_remodule\n"
"rerequire=_rerequire\n"
"\n"
"overload=_overload\n"
"--overload=function() return true end -- disable\n"
"\n"
"function set_reload_time(t)\n"
"	reload_time=t or os.time() -- mark all modules loaded before now as requiring reload\n"
"end\n"
"",


0,0};

