
const char* wetgenes_cache_lua_mods[]={

"fenestra.widget.skin","-- copy all globals into locals, some locals are renamed to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,luaload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local bit=require('bit')\n"
"local gl=require('gl')\n"
"local grd=require('wetgenes.grd')\n"
"\n"
"\n"
"local apps=apps\n"
"\n"
"local function explode_color(c)\n"
"\n"
"	local r,g,b,a\n"
"	\n"
"	a=bit.band(bit.rshift(c,24),0xff)\n"
"	r=bit.band(bit.rshift(c,16),0xff)\n"
"	g=bit.band(bit.rshift(c, 8),0xff)\n"
"	b=bit.band(c,0xff)\n"
"\n"
"	return r/0xff,g/0xff,b/0xff,a/0xff\n"
"end\n"
"\n"
"local function implode_color(r,g,b,a)\n"
"\n"
"	if type(r)==\"table\" then a=r[4] b=r[3] g=r[2] r=r[1] end -- convert from table?\n"
"	\n"
"	local c\n"
"	\n"
"	c=             bit.band(b*0xff,0xff)\n"
"	c=c+bit.lshift(bit.band(g*0xff,0xff),8)\n"
"	c=c+bit.lshift(bit.band(r*0xff,0xff),16)\n"
"	c=c+bit.lshift(bit.band(a*0xff,0xff),24)\n"
"\n"
"	return c\n"
"end\n"
"\n"
"\n"
"\n"
"module(\"fenestra.widget.skin\")\n"
"\n"
"local mode=nil\n"
"local texs={}\n"
"\n"
"local margin=0 -- whitespace\n"
"local border=0 -- solidspace\n"
"--\n"
"-- unload a skin, go back to the \"builtin\" default\n"
"--\n"
"function unload(win)\n"
"\n"
"	mode=nil\n"
"	texs={}\n"
"	\n"
"end\n"
"\n"
"\n"
"--\n"
"-- load a skin\n"
"--\n"
"function load(win,name)\n"
"\n"
"	unload(win)\n"
"\n"
"	if name then -- load a named skin\n"
"	\n"
"		if name==\"test\" then\n"
"			mode=name\n"
"\n"
"			texs.border=win.tex( grd.create(\"GRD_FMT_U8_BGRA\",apps.dir..\"data/skins/test/border.png\") )\n"
"			\n"
"			texs.buttof=win.tex( grd.create(\"GRD_FMT_U8_BGRA\",apps.dir..\"data/skins/test/buttof.png\") )\n"
"			texs.button=win.tex( grd.create(\"GRD_FMT_U8_BGRA\",apps.dir..\"data/skins/test/button.png\") )\n"
"			texs.buttin=win.tex( grd.create(\"GRD_FMT_U8_BGRA\",apps.dir..\"data/skins/test/buttin.png\") )\n"
"		\n"
"			margin=15\n"
"			border=0\n"
"		end\n"
"			\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"function draw33(tw,th, mw,mh, vxs,vys, vw,vh)\n"
"		\n"
"--		local vw,vh=512,52\n"
"--		local mw,mh=24,24\n"
"\n"
"		if mw*2 > vw then mw=vw/2 end\n"
"		if mh*2 > vh then mh=vh/2 end\n"
"\n"
"		\n"
"		local tww={mw/tw,(tw-2*mw)/tw,mw/tw}\n"
"		local thh={mh/th,(th-2*mh)/th,mh/th}\n"
"		local vww={mw,vw-2*mw,mw}\n"
"		local vhh={mh,vh-2*mh,mh}\n"
"		\n"
"		gl.Disable(gl.DEPTH_TEST)\n"
"		gl.Disable(gl.LIGHTING)\n"
"		gl.Disable(gl.CULL_FACE)\n"
"		gl.Enable(gl.TEXTURE_2D)\n"
"\n"
"\n"
"		gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR)\n"
"		gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)\n"
"\n"
"\n"
"		gl.Begin(gl.QUADS)\n"
"--			gl.Color({1,1,1,1})\n"
"			\n"
"			local function drawbox( tx,ty, vx,vy , txp,typ, vxp,vyp )\n"
"				gl.TexCoord(tx    ,ty)     gl.Vertex(vx,    vy)\n"
"				gl.TexCoord(tx+txp,ty)     gl.Vertex(vx+vxp,vy)\n"
"				gl.TexCoord(tx+txp,ty+typ) gl.Vertex(vx+vxp,vy+vyp)\n"
"				gl.TexCoord(tx    ,ty+typ) gl.Vertex(vx,    vy+vyp)\n"
"			end\n"
"			\n"
"		local tx,ty=0,0\n"
"		local vx,vy=vxs,vys-- -vw/2,vh/2\n"
"\n"
"			for iy=1,3 do\n"
"				tx=0\n"
"				vx=vxs-- -vw/2\n"
"				for ix=1,3 do\n"
"\n"
"					drawbox( tx,ty, vx,vy , tww[ix],thh[iy], vww[ix],-vhh[iy] )\n"
"\n"
"					tx=tx+tww[ix]\n"
"					vx=vx+vww[ix]\n"
"				end\n"
"				ty=ty+thh[iy]\n"
"				vy=vy-vhh[iy]\n"
"			end\n"
"			\n"
"		gl.End()\n"
"\n"
"\n"
"end\n"
"\n"
"--\n"
"-- add meta functions\n"
"--\n"
"function setup(def)\n"
"\n"
"--	load(def.win,\"test\")\n"
"\n"
"\n"
"	local master=def.master\n"
"	local meta=def.meta\n"
"	local win=def.win\n"
"	local font=def.font\n"
"	\n"
"--\n"
"-- display this widget and its sub widgets\n"
"--\n"
"	function meta.draw(widget)\n"
"		\n"
"		if debug_hook then debug_hook(\"draw\",widget) end\n"
"		\n"
"		\n"
"\n"
"		-- draw rectangle\n"
"\n"
"\n"
"		gl.PopMatrix() -- expect the base to be pushed\n"
"		gl.PushMatrix()\n"
"		\n"
"		gl.Translate(widget.pxd,widget.pyd,0)\n"
"		\n"
"		if widget.fbo then\n"
"			if widget.fbo.width~=widget.sx or widget.fbo.height~=widget.sy then -- resize so we need a new fbo\n"
"				widget.fbo:clean()\n"
"				widget.fbo=nil\n"
"			end\n"
"			if not widget.fbo then -- allocate a new fbo\n"
"--print(\"new fbo\",widget.sx,widget.sy)\n"
"				widget.fbo=_G.win.fbo(widget.sx,widget.sy,0)\n"
"				widget.dirty=true -- flag redraw\n"
"			end\n"
"				\n"
"		end\n"
"\n"
"if ( not widget.fbo ) or widget.dirty then -- if no fbo and then we are always dirty... Dirty, dirty, dirty.\n"
"\n"
"		if widget.fbo then\n"
"--print(\"into fbo\")\n"
"			\n"
"			gl.MatrixMode(gl.PROJECTION)\n"
"			gl.PushMatrix()\n"
"\n"
"			widget.fbo:bind()\n"
"			\n"
"--			gl.ClearColor(14/15,14/15,14/15,1)\n"
"			gl.ClearColor(0,0,0,0)\n"
"			gl.Clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT)\n"
"\n"
"			win.project23d(widget.sx/widget.sy,1,1024)\n"
"						\n"
"			gl.MatrixMode(gl.MODELVIEW)\n"
"			gl.LoadIdentity()\n"
"			gl.Translate(-widget.sx/2,widget.sy/2,-widget.sy/2)\n"
"			gl.Translate(-widget.pxd,-widget.pyd,0)\n"
"\n"
"			if widget.pan_px and widget.pan_py then -- fidle everything\n"
"				gl.Translate(widget.pan_px,widget.pan_py,0)\n"
"			end\n"
"						\n"
"			gl.PushMatrix() -- put new base matrix onto stack\n"
"		end\n"
"		\n"
"		widget.dirty=nil\n"
"				\n"
"		gl.Disable(gl.LIGHTING)\n"
"		gl.Disable(gl.DEPTH_TEST)\n"
"		gl.Disable(gl.CULL_FACE)\n"
"		gl.Disable(gl.TEXTURE_2D)\n"
"		\n"
"		local txp,typ=0,0\n"
"		\n"
"		if widget.color then\n"
"		\n"
"			if widget.highlight==\"shrink\" then\n"
"			\n"
"				gl.Color( explode_color(widget.color))\n"
"					\n"
"				if master.over==widget then\n"
"					gl.Translate(widget.hx/16,-widget.hy/16,0)\n"
"					gl.Scale(7/8,7/8,1)\n"
"				end\n"
"			\n"
"			elseif widget.highlight==\"none\" then\n"
"			\n"
"				gl.Color( explode_color(widget.color))\n"
"				\n"
"			elseif widget.highlight==\"text\" then\n"
"			\n"
"				gl.Color( explode_color(widget.color))\n"
"				\n"
"			else -- default is to darken everything slightly when it is not the active widget\n"
"			\n"
"				if master.over==widget then\n"
"					gl.Color( explode_color(widget.color))\n"
"				else\n"
"					local c={explode_color(widget.color)}\n"
"					c[3]=c[3]*14/15\n"
"					c[2]=c[2]*14/15\n"
"					c[1]=c[1]*14/15\n"
"					gl.Color( c )\n"
"				end\n"
"				\n"
"			end\n"
"			\n"
"			local hx=widget.hx\n"
"			local hy=widget.hy\n"
"			local bb=2\n"
"			local tl={1,1,1,0.25}\n"
"			local br={0,0,0,0.25}\n"
"			\n"
"			if ( master.active==widget and master.over==widget ) or widget.state==\"selected\" then\n"
"				tl,br=br,tl\n"
"				txp=1\n"
"				typ=1\n"
"			end\n"
"			\n"
"			if mode then\n"
"			\n"
"				if ( master.active==widget and master.over==widget ) or widget.state==\"selected\" then\n"
"					texs.buttin:bind()\n"
"					txp=0\n"
"					typ=-1\n"
"				else\n"
"					texs.button:bind()\n"
"					txp=0\n"
"					typ=-2\n"
"				end\n"
"				\n"
"				if widget.class==\"string\" then -- hack\n"
"					texs.border:bind()\n"
"				end\n"
"			\n"
"				draw33(128,128, 24,24, 0-margin,0+margin, hx+(margin*2),hy+(margin*2))\n"
"			\n"
"			else -- builtin\n"
"			\n"
"				gl.Begin(gl.QUADS)\n"
"					gl.Vertex(  0,   0)\n"
"					gl.Vertex( hx,   0)\n"
"					gl.Vertex( hx, -hy)\n"
"					gl.Vertex(  0, -hy)\n"
"				gl.End()\n"
"				gl.Color( tl )\n"
"				gl.Begin(gl.QUADS)\n"
"					gl.Vertex(  0,   0  )\n"
"					gl.Vertex( hx,   0  )\n"
"					gl.Vertex( hx-bb, -bb)\n"
"					gl.Vertex(  0+bb, -bb)\n"
"					\n"
"					gl.Vertex(  0,    0   )\n"
"					gl.Vertex(  0+bb, -bb )\n"
"					gl.Vertex(  0+bb, -hy+bb)\n"
"					gl.Vertex(  0,    -hy  )\n"
"				gl.End()\n"
"				gl.Color( br )\n"
"				gl.Begin(gl.QUADS)\n"
"					gl.Vertex( hx,   -hy  )\n"
"					gl.Vertex(  0,   -hy  )\n"
"					gl.Vertex(  0+bb, -hy+bb)\n"
"					gl.Vertex( hx-bb, -hy+bb)\n"
"					\n"
"					gl.Vertex(  hx,    0   )\n"
"					gl.Vertex(  hx,    -hy  )\n"
"					gl.Vertex(  hx-bb, -hy+bb)\n"
"					gl.Vertex(  hx-bb, -bb )\n"
"				gl.End()\n"
"			end\n"
"			\n"
"		end\n"
"		\n"
"		if widget.text then\n"
"		\n"
"			local tx,ty=font.size(widget.text,widget.text_size)\n"
"			\n"
"			local c=widget.text_color\n"
"			\n"
"			if widget.text_color_over then\n"
"				if master.over==widget then\n"
"					c=widget.text_color_over\n"
"				end\n"
"			end\n"
"			\n"
"			if widget.text_align==\"left\" then\n"
"				tx=0\n"
"				ty=0			\n"
"			elseif widget.text_align==\"right\" then\n"
"				tx=(widget.hx-tx)\n"
"				ty=(widget.hy-ty)			\n"
"			else\n"
"				tx=(widget.hx-tx)/2\n"
"				ty=(widget.hy-ty)/2\n"
"			end\n"
"			\n"
"			tx=tx+txp\n"
"			ty=ty+typ\n"
"			\n"
"			widget.text_x=tx\n"
"			widget.text_y=ty\n"
"\n"
"			font.set(tx,-ty,c,widget.text_size)\n"
"			font.draw(widget.text)\n"
"		\n"
"\n"
"				if widget.class==\"textedit\" then -- hack\n"
"					if widget.master.focus==widget then --only draw curser in active widget\n"
"						if widget.master.throb>=128 then\n"
"							local sw=font.size(widget.text:sub(1,widget.data.str_idx))\n"
"							gl.Enable(gl.COLOR_MATERIAL)\n"
"							win.flat_rect(\n"
"								tx+sw+0,-ty,\n"
"								tx+sw+2,-ty-widget.text_size,\n"
"								255*256*256*256)\n"
"							gl.Disable(gl.COLOR_MATERIAL)\n"
"						end\n"
"					end\n"
"				end\n"
"\n"
"		end\n"
"		\n"
"		for i,v in ipairs(widget) do\n"
"			if not v.fbo or not v.dirty then -- terminate recursion at dirty fbo\n"
"				v:draw()\n"
"			end\n"
"		end\n"
"\n"
"		if widget.fbo then -- we have drawn into the fbo\n"
"			\n"
"			gl.MatrixMode(gl.PROJECTION)\n"
"			gl.PopMatrix()\n"
"			\n"
"			gl.MatrixMode(gl.MODELVIEW)\n"
"			gl.PopMatrix()\n"
"			\n"
"			win.fbo_bind()\n"
"		end\n"
"		\n"
"else -- we can only draw once\n"
"\n"
"		if widget.fbo then -- we need to draw our cached fbo\n"
"		\n"
"			gl.Disable(gl.LIGHTING)\n"
"			gl.Disable(gl.DEPTH_TEST)\n"
"			gl.Disable(gl.CULL_FACE)\n"
"			gl.Disable(gl.TEXTURE_2D)\n"
"		\n"
"			gl.Translate(widget.sx/2,-widget.sy/2,0)\n"
"			gl.Color(1,1,1,1)\n"
"			widget.fbo:draw()\n"
"--print(\"draw fbo\")\n"
"		end\n"
"		\n"
"end\n"
"	\n"
"		\n"
"		return widget\n"
"	end\n"
"\n"
"\n"
"\n"
"end\n"
"",

"wetgenes.tardis","\n"
"--\n"
"-- time and relative dimensions in space\n"
"--\n"
"-- a lua library for manipulating time and space\n"
"-- pure lua by default and opengl in flavour\n"
"--\n"
"-- recoil in terror as we use two glyph names to describe structures\n"
"-- whilst typing in random strings of numbers that may or may not contain tyops\n"
"--\n"
"-- v# vector [#]\n"
"-- m# matrix [#][#]\n"
"-- q4 quaternion (yeah its just a repackaged v4)\n"
"--\n"
"-- each class is a table of # values [1] to [#] , just access them directly\n"
"-- they are number streams formated the same way as opengl (row-major)\n"
"-- metatables are used to provide advanced functionality\n"
"--\n"
"-- currently this is not terribly optimised and may be broken in many places due to lack of testing\n"
"-- which means it is really not advisable to use this if you are not prepared to fix it :)\n"
"\n"
"local math=require(\"math\")\n"
"local table=require(\"table\")\n"
"local string=require(\"string\")\n"
"\n"
"local unpack=unpack\n"
"local getmetatable=getmetatable\n"
"local setmetatable=setmetatable\n"
"local type=type\n"
"local pairs=pairs\n"
"local ipairs=ipairs\n"
"local tostring=tostring\n"
"local tonumber=tonumber\n"
"local require=require\n"
"local error=error\n"
"\n"
"module(...)\n"
"local _M=require(...) -- do not rely on *any* questionable side effects of module\n"
"\n"
"-- a metatable typeof function\n"
"mtype_lookup=mtype_lookup or {}\n"
"function mtype(it)\n"
"	return mtype_lookup[getmetatable(it) or 0] or type(it)\n"
"end\n"
"\n"
"-- dumb class inheritance metatable creation\n"
"local function class(name,...)\n"
"\n"
"	local tab=_M[name] or {} -- use old or create new?\n"
"	local sub={...} -- possibly multiple sub classes\n"
"\n"
"	if #sub>0 then -- inherit?\n"
"		for idx=#sub,1,-1 do -- reverse sub class order, so the ones to the left overwrite the ones on the right\n"
"			for i,v in pairs(sub[idx]) do tab[i]=v end -- each subclass overwrites all values\n"
"		end\n"
"	end\n"
"\n"
"	tab.__index=tab -- this metatable is its own index\n"
"\n"
"	mtype_lookup[name]=tab -- classtype metatable lookup\n"
"	mtype_lookup[tab]=name -- tab->name or name->tab\n"
"\n"
"	_M[name]=tab\n"
"	return tab\n"
"end\n"
"\n"
"\n"
"\n"
"class(\"array\")\n"
"\n"
"function array.__tostring(it) -- these classes are all just 1d arrays of numbers\n"
"	local t={}\n"
"	t[#t+1]=mtype(it)\n"
"	t[#t+1]=\"={\"\n"
"	for i=1,#it do\n"
"		t[#t+1]=tostring(it[i])\n"
"		if i~=#it then t[#t+1]=\", \" end\n"
"	end\n"
"	t[#t+1]=\"}\"\n"
"	return table.concat(t)\n"
"end\n"
"\n"
"function array.set(it,...)\n"
"	local n=1\n"
"	for i,v in ipairs{...} do\n"
"		if not it[n] then return it end -- got all the data we need (#it)\n"
"		if type(v)==\"number\" then\n"
"			it[n]=v\n"
"			n=n+1\n"
"		else\n"
"			for ii,vv in ipairs(v) do -- allow one depth of tables\n"
"				it[n]=vv\n"
"				n=n+1\n"
"			end\n"
"		end\n"
"	end\n"
"	return it\n"
"end\n"
"\n"
"function array.product(a,b,r)\n"
"	local mta=mtype(a)\n"
"	local mtb=mtype(b)\n"
"	if mta==\"m4\" then\n"
"		if     mtb==\"v3\" then\n"
"			return m4_product_v3(a,b,r)\n"
"		elseif mtb==\"v4\" then\n"
"			return m4_product_v4(a,b,r)\n"
"		elseif mtb==\"m4\" then\n"
"			return m4_product_m4(a,b,r)\n"
"		end\n"
"	end\n"
"	error(\"tardis : \"..mta..\" product \"..mtb..\" not supported\",2)\n"
"end\n"
"\n"
"\n"
"class(\"m2\",array)\n"
"function m2.new(...) return setmetatable({0,0,0,0},m2):set(...) end\n"
"function m2.determinant(it)\n"
"	return	 ( it[ 1 ]*it[ 2+2 ] )\n"
"			+( it[ 2 ]*it[ 2+1 ] )\n"
"			-( it[ 1 ]*it[ 2+1 ] )\n"
"			-( it[ 2 ]*it[ 2+1 ] )\n"
"end\n"
"function m2.minor_xy(it,x,y)\n"
"	return it[1+(2-(x-1))+((2-(y-1))*2)]\n"
"end\n"
"function m2.transpose(it,r)\n"
"	r=r or it\n"
"	return	 r:set(it[1],it[2+1], it[2],it[2+2])\n"
"end\n"
"function m2.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set(it[1]*s,it[2]*s, it[2+1]*s,it[2+2]*s)\n"
"end\n"
"function m2.cofactor(it,r)\n"
"	r=r or it\n"
"	local t={}\n"
"	for iy=1,2 do\n"
"		for ix=1,2 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=m2.minor_xy(it,ix,iy)\n"
"				if ((ix+iy)%2)==1 then t[#t]=-t[#t] end\n"
"			end\n"
"		end\n"
"	end\n"
"	return r\n"
"end\n"
"function m2.adjugate(it,r)\n"
"	r=r or it\n"
"	return m2.cofactor(m2.transpose(it,m2.new()),r)\n"
"end\n"
"function m2.inverse(it,r)\n"
"	r=r or it\n"
"	local ood=1/m2.determinant(it)	\n"
"	return m2.scale(m2.cofactor(m2.transpose(it,m2.new())),ood,r)\n"
"end\n"
"\n"
"class(\"m3\",m2)\n"
"function m3.new(...) return setmetatable({0,0,0,0,0,0,0,0,0},m3):set(...) end\n"
"function m3.determinant(it)\n"
"	return	 ( it[ 1 ]*it[ 3+2 ]*it[ 6+3 ] )\n"
"			+( it[ 2 ]*it[ 3+3 ]*it[ 6+1 ] )\n"
"			+( it[ 3 ]*it[ 3+1 ]*it[ 6+2 ] )\n"
"			-( it[ 1 ]*it[ 3+3 ]*it[ 6+2 ] )\n"
"			-( it[ 2 ]*it[ 3+1 ]*it[ 6+3 ] )\n"
"			-( it[ 3 ]*it[ 3+2 ]*it[ 6+1 ] )\n"
"end\n"
"function m3.minor_xy(it,x,y)\n"
"	local t={}\n"
"	for ix=1,3 do\n"
"		for iy=1,3 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=it[ix+((iy-1)*3)]\n"
"			end\n"
"		end\n"
"	end\n"
"	return m2.determinant(t)\n"
"end\n"
"function m3.transpose(it,r)\n"
"	r=r or it\n"
"	return	 r:set(it[1],it[3+1],it[6+1], it[2],it[3+2],it[6+2], it[3],it[3+3],it[6+3])\n"
"end\n"
"function m3.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set(it[1]*s,it[2]*s,it[3]*s, it[3+1]*s,it[3+2]*s,it[3+3]*s, it[6+1]*s,it[6+2]*s,it[6+3]*s)\n"
"end\n"
"function m3.cofactor(it,r)\n"
"	r=r or it\n"
"	local t={}\n"
"	for iy=1,3 do\n"
"		for ix=1,3 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=m3.minor_xy(it,ix,iy)\n"
"				if ((ix+iy)%2)==1 then t[#t]=-t[#t] end\n"
"			end\n"
"		end\n"
"	end\n"
"	return r:set(t)\n"
"end\n"
"function m3.adjugate(it,r)\n"
"	r=r or it\n"
"	return m3.cofactor(m3.transpose(it,m3.new()),r)\n"
"end\n"
"function m3.inverse(it,r)\n"
"	r=r or it\n"
"	local ood=1/m3.determinant(it)	\n"
"	return m3.scale(m3.cofactor(m3.transpose(it,m3.new())),ood,r)\n"
"end\n"
"\n"
"class(\"m4\",m3)\n"
"function m4.new(...) return setmetatable({0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},m4):set(...) end\n"
"function m4.determinant(it)\n"
"return	(it[ 4 ] * it[ 4+3 ] * it[ 8+2 ] * it[ 12+1 ])-(it[ 3 ] * it[ 4+4 ] * it[ 8+2 ] * it[ 12+1 ])-\n"
"		(it[ 4 ] * it[ 4+2 ] * it[ 8+3 ] * it[ 12+1 ])+(it[ 2 ] * it[ 4+4 ] * it[ 8+3 ] * it[ 12+1 ])+\n"
"		(it[ 3 ] * it[ 4+2 ] * it[ 8+4 ] * it[ 12+1 ])-(it[ 2 ] * it[ 4+3 ] * it[ 8+4 ] * it[ 12+1 ])-\n"
"		(it[ 4 ] * it[ 4+3 ] * it[ 8+1 ] * it[ 12+2 ])+(it[ 3 ] * it[ 4+4 ] * it[ 8+1 ] * it[ 12+2 ])+\n"
"		(it[ 4 ] * it[ 4+1 ] * it[ 8+3 ] * it[ 12+2 ])-(it[ 1 ] * it[ 4+4 ] * it[ 8+3 ] * it[ 12+2 ])-\n"
"		(it[ 3 ] * it[ 4+1 ] * it[ 8+4 ] * it[ 12+2 ])+(it[ 1 ] * it[ 4+3 ] * it[ 8+4 ] * it[ 12+2 ])+\n"
"		(it[ 4 ] * it[ 4+2 ] * it[ 8+1 ] * it[ 12+3 ])-(it[ 2 ] * it[ 4+4 ] * it[ 8+1 ] * it[ 12+3 ])-\n"
"		(it[ 4 ] * it[ 4+1 ] * it[ 8+2 ] * it[ 12+3 ])+(it[ 1 ] * it[ 4+4 ] * it[ 8+2 ] * it[ 12+3 ])+\n"
"		(it[ 2 ] * it[ 4+1 ] * it[ 8+4 ] * it[ 12+3 ])-(it[ 1 ] * it[ 4+2 ] * it[ 8+4 ] * it[ 12+3 ])-\n"
"		(it[ 3 ] * it[ 4+2 ] * it[ 8+1 ] * it[ 12+4 ])+(it[ 2 ] * it[ 4+3 ] * it[ 8+1 ] * it[ 12+4 ])+\n"
"		(it[ 3 ] * it[ 4+1 ] * it[ 8+2 ] * it[ 12+4 ])-(it[ 1 ] * it[ 4+3 ] * it[ 8+2 ] * it[ 12+4 ])-\n"
"		(it[ 2 ] * it[ 4+1 ] * it[ 8+3 ] * it[ 12+4 ])+(it[ 1 ] * it[ 4+2 ] * it[ 8+3 ] * it[ 12+4 ])	\n"
"end\n"
"function m4.minor_xy(it,x,y)\n"
"	local t={}\n"
"	for ix=1,4 do\n"
"		for iy=1,4 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=it[ix+((iy-1)*4)]\n"
"			end\n"
"		end\n"
"	end\n"
"	return m3.determinant(t)\n"
"end\n"
"function m4.transpose(it,r)\n"
"	r=r or r\n"
"	return	 r:set(it[1],it[4+1],it[8+1],it[12+1], it[2],it[4+2],it[8+2],it[12+2], it[3],it[4+3],it[8+3],it[12+3], it[4],it[4+4],it[8+4],it[12+4])\n"
"end\n"
"function m4.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set(it[1]*s,it[2]*s,it[3]*s,it[4]*s, it[4+1]*s,it[4+2]*s,it[4+3]*s,it[4+4]*s, it[8+1]*s,it[8+2]*s,it[8+3]*s,it[8+4]*s, it[12+1]*s,it[12+2]*s,it[12+3]*s,it[12+4]*s)\n"
"end\n"
"function m4.cofactor(it,r)\n"
"	r=r or it\n"
"	local t={}\n"
"	for iy=1,4 do\n"
"		for ix=1,4 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=m4.minor_xy(it,ix,iy)\n"
"				if ((ix+iy)%2)==1 then t[#t]=-t[#t] end\n"
"			end\n"
"		end\n"
"	end\n"
"	return r:set(t)\n"
"end\n"
"function m4.adjugate(it,r)\n"
"	r=r or it\n"
"	return 	m4.cofactor(m4.transpose(it,m4.new()),r)\n"
"end\n"
"function m4.inverse(it,r)\n"
"	r=r or it\n"
"	local ood=1/m4.determinant(it)	\n"
"	return m4.scale(m4.cofactor(m4.transpose(it,m4.new())),ood,r)\n"
"end\n"
"\n"
"\n"
"\n"
"class(\"v2\",array)\n"
"function v2.new(...) return setmetatable({0,0},v2):set(...) end\n"
"function v2.lenlen(it)\n"
"	return (it[1]*it[1]) + (it[2]*it[2])\n"
"end\n"
"function v2.len(it)\n"
"	return math.sqrt( (it[1]*it[1]) + (it[2]*it[2]) )\n"
"end\n"
"function v2.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set( it[1]*s , it[2]*s )\n"
"end\n"
"function v2.normalize(it,r)\n"
"	return v2.scale(it,1/v2.len(it),r)\n"
"end\n"
"\n"
"class(\"v3\",v2)\n"
"function v3.new(...) return setmetatable({0,0,0},v3):set(...) end\n"
"function v3.lenlen(it)\n"
"	return (it[1]*it[1]) + (it[2]*it[2]) + (it[3]*it[3])\n"
"end\n"
"function v3.len(it)\n"
"	return math.sqrt( (it[1]*it[1]) + (it[2]*it[2]) + (it[3]*it[3]) )\n"
"end\n"
"function v3.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set( it[1]*s , it[2]*s , it[3]*s )\n"
"end\n"
"function v3.normalize(it,r)\n"
"	return v3.scale(it,1/v3.len(it),r)\n"
"end\n"
"function v3.add(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( va[1]+vb[1] , va[2]+vb[2] , va[3]+vb[3] )\n"
"end\n"
"function v3.sub(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( va[1]-vb[1] , va[2]-vb[2] , va[3]-vb[3] )\n"
"end\n"
"function v3.mul(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( (va[1]*vb[1]) , (va[2]*vb[2]) , (va[3]*vb[3]) )\n"
"end\n"
"function v3.dot(va,vb)\n"
"	return ( (va[1]*vb[1]) + (va[2]*vb[2]) + (va[3]*vb[3]) )\n"
"end\n"
"function v3.cross(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( (va[2]*vb[3])-(va[3]*vb[2]) , (va[3]*vb[1])-(va[1]*vb[3]) , (va[1]*vb[2])-(va[2]*vb[1]) )\n"
"end\n"
"\n"
"\n"
"class(\"v4\",v3)\n"
"function v4.new(...) return setmetatable({0,0,0,0},v4):set(...) end\n"
"function v4.to_v3(it,r) -- scale [4] to 1 then throw it away so we have a v3 xyz\n"
"	r=r or v3.new()\n"
"	local oow=1/it[4]\n"
"	return r:set( it[1]*oow , it[2]*oow , it[3]*oow )\n"
"end\n"
"function v4.lenlen(it)\n"
"	return (it[1]*it[1]) + (it[2]*it[2]) + (it[3]*it[3]) + (it[4]*it[4])\n"
"end\n"
"function v4.len(it)\n"
"	return math.sqrt( (it[1]*it[1]) + (it[2]*it[2]) + (it[3]*it[3]) + (it[4]*it[4]) )\n"
"end\n"
"function v4.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set( it[1]*s , it[2]*s , it[3]*s , it[4]*s )\n"
"end\n"
"function v4.normalize(it,r)\n"
"	return v4.scale(it,1/v4.len(it),r)\n"
"end\n"
"\n"
"class(\"q4\",v4)\n"
"function q4.new(...) return setmetatable({0,0,0,0},q4):set(...) end\n"
"\n"
"\n"
"class(\"line\",array)\n"
"line.set=nil -- disable\n"
"function line.new(...) return setmetatable({v3.new(),v3.new()},line) end -- [1]position , [2]normal\n"
"\n"
"class(\"plane\",line)\n"
"function plane.new(...) return setmetatable({v3.new(),v3.new()},plane) end -- [1]position , [2]normal\n"
"\n"
"\n"
"function line_intersect_plane(l,p,r)\n"
"	r=r or v3.new()\n"
"	local t=v3.new(p[1]):sub(l[1]) -- the line position relative to the plane\n"
"	local d=l[2]:dot(p[2]) -- the length of the line until it hits the plane\n"
"	if d~=0 then -- less errors please\n"
"		d=t:dot(p[2])/d\n"
"	end\n"
"	return r:set( l[1][1]+(l[2][1]*d) , l[1][2]+(l[2][2]*d) , l[1][3]+(l[2][3]*d) ) -- the point of intersection\n"
"end\n"
"\n"
"function m4_product_v4(m4a,v4b,r)\n"
"	r=r or v4b\n"
"	local r1= (m4a[   1]*v4b[1]) + (m4a[ 4+1]*v4b[2]) + (m4a[ 8+1]*v4b[3]) + (m4a[12+1]*v4b[4])\n"
"	local r2= (m4a[   2]*v4b[1]) + (m4a[ 4+2]*v4b[2]) + (m4a[ 8+2]*v4b[3]) + (m4a[12+2]*v4b[4])\n"
"	local r3= (m4a[   3]*v4b[1]) + (m4a[ 4+3]*v4b[2]) + (m4a[ 8+3]*v4b[3]) + (m4a[12+3]*v4b[4])\n"
"	local r4= (m4a[   4]*v4b[1]) + (m4a[ 4+4]*v4b[2]) + (m4a[ 8+4]*v4b[3]) + (m4a[12+4]*v4b[4])\n"
"	return r:set(r1,r2,r3,r4)\n"
"end\n"
"\n"
"function m4_product_v3(m4a,v3b,r)\n"
"	r=r or v3b\n"
"	local oow=1/( (m4a[   4]*v3b[1]) + (m4a[ 4+4]*v3b[2]) + (m4a[ 8+4]*v3b[3]) + (m4a[12+4] ) )\n"
"	local r1= oow * ( (m4a[   1]*v3b[1]) + (m4a[ 4+1]*v3b[2]) + (m4a[ 8+1]*v3b[3]) + (m4a[12+1] ) )\n"
"	local r2= oow * ( (m4a[   2]*v3b[1]) + (m4a[ 4+2]*v3b[2]) + (m4a[ 8+2]*v3b[3]) + (m4a[12+2] ) )\n"
"	local r3= oow * ( (m4a[   3]*v3b[1]) + (m4a[ 4+3]*v3b[2]) + (m4a[ 8+3]*v3b[3]) + (m4a[12+3] ) )\n"
"	return r:set(r1,r2,r3)\n"
"end\n"
"\n"
"function m4_product_m4(m4a,m4b,r)\n"
"	r=r or m4b\n"
"	local r1 = (m4a[   1]*m4b[   1]) + (m4a[   2]*m4b[ 4+1]) + (m4a[   3]*m4b[ 8+1]) + (m4a[   4]*m4b[12+1])\n"
"	local r2 = (m4a[   1]*m4b[   2]) + (m4a[   2]*m4b[ 4+2]) + (m4a[   3]*m4b[ 8+2]) + (m4a[   4]*m4b[12+2])\n"
"	local r3 = (m4a[   1]*m4b[   3]) + (m4a[   2]*m4b[ 4+3]) + (m4a[   3]*m4b[ 8+3]) + (m4a[   4]*m4b[12+3])\n"
"	local r4 = (m4a[   1]*m4b[   4]) + (m4a[   2]*m4b[ 4+4]) + (m4a[   3]*m4b[ 8+4]) + (m4a[   4]*m4b[12+4])\n"
"	local r5 = (m4a[ 4+1]*m4b[   1]) + (m4a[ 4+2]*m4b[ 4+1]) + (m4a[ 4+3]*m4b[ 8+1]) + (m4a[ 4+4]*m4b[12+1])\n"
"	local r6 = (m4a[ 4+1]*m4b[   2]) + (m4a[ 4+2]*m4b[ 4+2]) + (m4a[ 4+3]*m4b[ 8+2]) + (m4a[ 4+4]*m4b[12+2])\n"
"	local r7 = (m4a[ 4+1]*m4b[   3]) + (m4a[ 4+2]*m4b[ 4+3]) + (m4a[ 4+3]*m4b[ 8+3]) + (m4a[ 4+4]*m4b[12+3])\n"
"	local r8 = (m4a[ 4+1]*m4b[   4]) + (m4a[ 4+2]*m4b[ 4+4]) + (m4a[ 4+3]*m4b[ 8+4]) + (m4a[ 4+4]*m4b[12+4])\n"
"	local r9 = (m4a[ 8+1]*m4b[   1]) + (m4a[ 8+2]*m4b[ 4+1]) + (m4a[ 8+3]*m4b[ 8+1]) + (m4a[ 8+4]*m4b[12+1])\n"
"	local r10= (m4a[ 8+1]*m4b[   2]) + (m4a[ 8+2]*m4b[ 4+2]) + (m4a[ 8+3]*m4b[ 8+2]) + (m4a[ 8+4]*m4b[12+2])\n"
"	local r11= (m4a[ 8+1]*m4b[   3]) + (m4a[ 8+2]*m4b[ 4+3]) + (m4a[ 8+3]*m4b[ 8+3]) + (m4a[ 8+4]*m4b[12+3])\n"
"	local r12= (m4a[ 8+1]*m4b[   4]) + (m4a[ 8+2]*m4b[ 4+4]) + (m4a[ 8+3]*m4b[ 8+4]) + (m4a[ 8+4]*m4b[12+4])\n"
"	local r13= (m4a[12+1]*m4b[   1]) + (m4a[12+2]*m4b[ 4+1]) + (m4a[12+3]*m4b[ 8+1]) + (m4a[12+4]*m4b[12+1])\n"
"	local r14= (m4a[12+1]*m4b[   2]) + (m4a[12+2]*m4b[ 4+2]) + (m4a[12+3]*m4b[ 8+2]) + (m4a[12+4]*m4b[12+2])\n"
"	local r15= (m4a[12+1]*m4b[   3]) + (m4a[12+2]*m4b[ 4+3]) + (m4a[12+3]*m4b[ 8+3]) + (m4a[12+4]*m4b[12+3])\n"
"	local r16= (m4a[12+1]*m4b[   4]) + (m4a[12+2]*m4b[ 4+4]) + (m4a[12+3]*m4b[ 8+4]) + (m4a[12+4]*m4b[12+4])\n"
"	return r:set(r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15,r16)\n"
"end\n"
"\n"
"",

"spew.client.comm","\n"
"\n"
"local comm=require(\"spew.comm\")\n"
"local util=require(\"spew.util\")\n"
"\n"
"local socket = require(\"socket\")\n"
"\n"
"local _G=_G\n"
"\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"local string=string\n"
"local math=math\n"
"local os=os\n"
"local print=print\n"
"\n"
"local unpack=unpack\n"
"local tostring=tostring\n"
"\n"
"\n"
"local spew_host=\"swf.wetgenes.com\"\n"
"--local spew_host=\"swf.wetgenes.local\"\n"
"local spew_port=5223\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- basic client communication with a spew server\n"
"-- uses lua sockets to connect\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module(\"spew.client.comm\")\n"
"\n"
"-- callback hooks\n"
"hooks={}\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- setup and connect to the spew server\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function setup()\n"
"\n"
"	con=comm.setup( socket.connect(spew_host,spew_port) , {format=\"spew\"} ) -- connect\n"
"	if not con then\n"
"		print( \"failed to connect to \"..spew_host )\n"
"	else\n"
"		if con.error then print(con.error) end\n"
"	end\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- clean and disconnect from the spew server\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function clean()\n"
"\n"
"	if con then\n"
"		comm.clean(con.client)\n"
"	end\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- This handles any incoming data waiting but does not block\n"
"-- so call it a few times a second, every frame should be good\n"
"-- the data will be processed and you will receive callbacks for events\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"function update()\n"
"\n"
"	local tab,_,err=socket.select(comm.recvt,nil,0.00001)\n"
"-- read from sockets\n"
"	for i,v in ipairs(tab or {}) do\n"
"	\n"
"			local p1, error ,p2 = v:receive(\"*a\")\n"
"			local line=p1 or p2\n"
"			\n"
"			if error==\"timeout\" then -- a timeout is not an error, it is actually success\n"
"				error=nil\n"
"			end\n"
"\n"
"			if error then -- error causes disconenct\n"
"			\n"
"				comm.disconnect(v)\n"
"				\n"
"			elseif line then -- got data\n"
"			\n"
"				comm.received(v , line)\n"
"				\n"
"			end\n"
"	end\n"
"	\n"
"-- handle any input\n"
"\n"
"	for client,con in pairs(comm.active) do\n"
"		for i,line in ipairs(con.linein) do\n"
"\n"
"-- as a client we only have one connection\n"
"			util.str_to_msg(line,con.msg)\n"
"			\n"
"			got_amsg(con.msg)\n"
"--			print(con.msg)\n"
"		end\n"
"		con.linein={} -- readit\n"
"	end\n"
"	comm.active={} -- clear active table\n"
"\n"
"end\n"
"\n"
"-- send a msg\n"
"function send(msg)\n"
"\n"
"	comm.send( con.client , util.msg_to_str(msg)..\"\\0\" )\n"
"\n"
"	if hooks.sent then hooks.sent(msg) end\n"
"end\n"
"\n"
"-- all msgs\n"
"function got_amsg(msg)\n"
"	if hooks.amsg then hooks.amsg(msg) end\n"
"	if msg.cmd==\"ville\" then\n"
"		got_vmsg(msg) \n"
"	else\n"
"		got_cmsg(msg)\n"
"	end\n"
"end\n"
"\n"
"-- chat msgs\n"
"function got_cmsg(msg)\n"
"--	print(msg.cmd)\n"
"	if hooks.cmsg then hooks.cmsg(msg) end\n"
"end\n"
"\n"
"-- game msgs\n"
"function got_gmsg(msg)\n"
"--	print(msg.gcmd)\n"
"	if hooks.gmsg then hooks.gmsg(msg) end\n"
"end\n"
"\n"
"-- ville msgs\n"
"function got_vmsg(msg)\n"
"--	print(msg.vcmd)\n"
"	if hooks.vmsg then hooks.vmsg(msg) end\n"
"end\n"
"\n"
"\n"
"\n"
"",

"wetgenes.www.ngx.cache","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.cache\"]=_M\n"
"\n"
"hax={}\n"
"\n"
"\n"
"function countzero()\n"
"	count=0\n"
"	count_got=0\n"
"	api_time=0\n"
"\n"
"end\n"
"countzero()\n"
"\n"
"local start_time -- handle simple api benchmarking of some calls\n"
"local function apis()\n"
"	start_time=os.time()\n"
"end\n"
"local function apie(...)\n"
"	api_time=api_time+os.time()-start_time\n"
"	return ...\n"
"end\n"
"\n"
"\n"
"function clear(srv)\n"
"--	log(\"cache.clear:\")\n"
"	apis()\n"
"\n"
"	hax={}\n"
"\n"
"	apie()\n"
"end\n"
"\n"
"\n"
"function del(srv,id)\n"
"--	log(\"cache.del:\")\n"
"	apis()\n"
"\n"
"	hax[id]=nil\n"
"\n"
"	apie()\n"
"end\n"
"\n"
"function put(srv,id,tab,ttl)\n"
"--	log(\"cache.put:\",id)\n"
"	apis()\n"
"	\n"
"	hax[id]=tab\n"
"	\n"
"	apie()\n"
"end\n"
"\n"
"function get(srv,id)\n"
"--	log(\"cache.get:\",id)	\n"
"	apis()\n"
"	count=count+1\n"
"\n"
"	r=hax[id]\n"
"--log(wstr.serialize(r))\n"
"	apie()\n"
"	return r\n"
"end\n"
"\n"
"function inc(srv,id,num,start)\n"
"--	log(\"cache.inc:\",id)\n"
"	apis()\n"
"\n"
"	local r=(hax[id] or start)+num\n"
"	hax[id]=r\n"
"	\n"
"--log(r)\n"
"	apie()\n"
"	return r\n"
"end\n"
"\n"
"",

"wetgenes.json","--\n"
"-- wetjson\n"
"--         version 2011-02-04\n"
"--         use encode to encode a table and decode to decode a json string\n"
"--\n"
"-- other json encode/decode pure lua library seemed too slow\n"
"-- here is a fast and loose one lets see if it goes any faster :)\n"
"-- should be a direct replacement for JSON4Lua which is what I was using before\n"
"--\n"
"-- find the latest version online here\n"
"-- http://code.google.com/p/aelua/source/browse/trunk/aelua/lua/wetjson.lua\n"
"--\n"
"--\n"
"-- Copyright (C) 2011 by http://about.wetgenes.com/\n"
"--\n"
"-- Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"-- of this software and associated documentation files (the \"Software\"), to deal\n"
"-- in the Software without restriction, including without limitation the rights\n"
"-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"-- copies of the Software, and to permit persons to whom the Software is\n"
"-- furnished to do so, subject to the following conditions:\n"
"--\n"
"-- The above copyright notice and this permission notice shall be included in\n"
"-- all copies or substantial portions of the Software.\n"
"--\n"
"-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
"-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
"-- THE SOFTWARE.\n"
"--\n"
"\n"
"local table=table\n"
"local string=string\n"
"\n"
"\n"
"local print=print\n"
"local type=type\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"local tonumber=tonumber\n"
"local tostring=tostring\n"
"local math=math\n"
"local error=error\n"
"\n"
"module(...)\n"
"\n"
"null=function() return null end -- wetjson.null is a magick value to represent null\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- trim whitespace from ends of string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function trim(s)\n"
"  return (s:gsub(\"^%s*(.-)%s*$\", \"%1\"))\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- unescape a string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local unesc_tab={\n"
"	[\"b\"]=\"\\b\",\n"
"	[\"f\"]=\"\\f\",\n"
"	[\"n\"]=\"\\n"
"\",\n"
"	[\"r\"]=\"\\r\",\n"
"	[\"t\"]=\"\\t\",\n"
"}\n"
"local function unesc(s)\n"
"\n"
"	s=string.gsub(s, \"\\\\([^u])\", function(c)\n"
"		return unesc_tab[c] or c\n"
"    end)\n"
"\n"
"	s=string.gsub(s, \"\\\\u(%x%x%x%x)\", function(c)\n"
"		return string.char( tonumber(c,16) or 32 ) or \"\"\n"
"    end)\n"
"    \n"
"  return s\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- escape a string anything outside of basic printable 7bit ascii or a \" or a \\\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function esc(s)\n"
"\n"
"	s=string.gsub(s, \"([^#-Z_-~ !%^%[%]])\", function(c)\n"
"		return string.format( \"\\\\u%04x\" , string.byte( c ) )\n"
"    end)\n"
"    \n"
"  return s\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split on interesting characters to create a table\n"
"--\n"
"-- a concat on the result would be a perfect reproduction of the original\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function split(text)\n"
"	local separator = \"[\\\",:{}%[%]']\"\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	\n"
"	while split_start do\n"
"		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end		-- the word\n"
"		table.insert(parts, text:sub(split_start, split_end))	-- the white space\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	\n"
"	return parts\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- is this an array?\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function is_array(t)\n"
"	local len=#t\n"
"	if len==0 then return false end -- short circuit\n"
"	for i,v in pairs(t) do\n"
"		if type(i)==\"number\" then\n"
"			if math.floor(i)~=i then -- must be int\n"
"				return false\n"
"			end\n"
"			if i<1 or i>len then -- and in this range\n"
"				return false\n"
"			end\n"
"		else\n"
"			return false\n"
"		end\n"
"	end\n"
"	return true\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- json string to table\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function decode(s,opts)\n"
"opts=opts or {}\n"
"\n"
"local t\n"
"\n"
"-- start by adjusting all \\\" escapes in the string into \\u0000 escapes\n"
"-- that way we do not have to worry about \" being anywhere apart\n"
"-- from real string deliminators which makes parsing easier?\n"
"-- this way we wont have to ignore \\\" as a special case inside strings\n"
"\n"
"	s=string.gsub(s, \"\\\\([\\\"])\", function(c)\n"
"		return string.format(\"\\\\u%04x\",string.byte(c))\n"
"    end)\n"
"\n"
"\n"
"-- now we break the string using any of the following characters as deliminators\n"
"-- {}[]:,\"\n"
"-- this gives an array of interesting points to parse\n"
"\n"
"	t=split(s,opts)\n"
"	\n"
"	local chash=0\n"
"	local out={}\n"
"	local top={tab=out,idx=1,inc=true}\n"
"	local stack={ top }\n"
"	local sb -- string buffer building for the use of\n"
"	local sbend -- the string terminator\n"
"	\n"
"	function err(s)\n"
"		error(s..\" (\"..chash..\")\")\n"
"	end\n"
"	\n"
"	function push(v)\n"
"		top=v\n"
"		stack[#stack+1]=top\n"
"	end\n"
"	\n"
"	function pop()\n"
"		stack[#stack]=nil\n"
"		top=stack[#stack]\n"
"		if not top then err(\"too many close brackets\") end\n"
"	end\n"
"	\n"
"	function setval()\n"
"		if top.idx==nil then -- set idx not val\n"
"			if type(val)==\"table\" then err(\"cannot use table as index\") end\n"
"			top.idx=val\n"
"			val=nil\n"
"		else\n"
"--print(top.idx,\"=\",val)\n"
"			top.tab[top.idx]=val\n"
"			if top.inc then top.idx=top.idx+1 else top.idx=nil end\n"
"		end\n"
"	end\n"
"	\n"
"	for i,v in ipairs(t) do\n"
"			\n"
"		if sb then -- continue building a string\n"
"		\n"
"			if v==sbend then -- end of string\n"
"				if sb[2] then\n"
"					val=unesc(table.concat(sb))\n"
"				else\n"
"					val=unesc(sb[1])\n"
"				end\n"
"				sb=nil\n"
"				setval()\n"
"			else\n"
"				sb[#sb+1]=v\n"
"			end\n"
"			\n"
"		else\n"
"		\n"
"			local l=trim(v) -- remove any white space from both ends\n"
"--print(l,#stack)			\n"
"			if #l>0 then -- ignore whitespace\n"
"			\n"
"				if l==\"\\\"\" then -- start a string \n"
"					sb={}\n"
"					sbend=\"\\\"\"\n"
"				elseif l==\"'\" then -- start a string \n"
"					sb={}\n"
"					sbend=\"'\"\n"
"				elseif l==\"{\" then\n"
"					val={}\n"
"					setval()\n"
"					push({tab=val})\n"
"					val=nil\n"
"				elseif l==\"}\" then\n"
"					pop()\n"
"				elseif l==\"[\" then\n"
"					val={}\n"
"					setval()\n"
"					push({tab=val,idx=1,inc=true})\n"
"					val=nil\n"
"				elseif l==\"]\" then\n"
"					pop()\n"
"				elseif l==\":\" then\n"
"				elseif l==\",\" then\n"
"				else\n"
"					val=l\n"
"					if val==\"true\" then val=true\n"
"					elseif val==\"false\" then val=false\n"
"					elseif val==\"null\" then val=null\n"
"					else\n"
"						val=tonumber(val) or val\n"
"					end\n"
"					setval()\n"
"				end\n"
"				\n"
"			end\n"
"		end\n"
"	\n"
"		chash=chash+#v -- very basic error locator\n"
"	end\n"
"	\n"
"	\n"
"	\n"
"--print(#t)\n"
"\n"
"	return out and out[1] , \"OK\"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- table to json string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function encode(tab,opts)\n"
"opts=opts or {}\n"
"\n"
"local out={}\n"
"local put=function(s)\n"
"	out[#out+1]=s or \"\"\n"
"end\n"
"\n"
"local encode_str\n"
"local encode_it\n"
"local encode_tab\n"
"\n"
"	function err(s)\n"
"		error(s)\n"
"	end\n"
"	\n"
"	if not tab then return err(\"null inout\") end\n"
"\n"
"	encode_str=function(str)\n"
"		return \"\\\"\"..esc(tostring(str))..\"\\\"\"\n"
"	end\n"
"	\n"
"	encode_it=function(it,t)\n"
"		t=t or type(it)\n"
"		if t==\"number\" then\n"
"			return tostring(it)\n"
"		elseif t==\"boolean\" then\n"
"			if it then return \"true\" else return \"false\" end\n"
"		elseif t==\"function\" then\n"
"			if it==null then return \"null\" end\n"
"		else\n"
"			return encode_str(it)\n"
"		end\n"
"		\n"
"		return \"\"\n"
"	end\n"
"	\n"
"	encode_tab=function(vv,array)\n"
"		local t\n"
"		local comma=false\n"
"		if array then\n"
"			put(\"[\")\n"
"			for i=1,#vv do local v=vv[i]\n"
"				put(comma and \",\") comma=true\n"
"				t=type(v)\n"
"				if t==\"table\" then\n"
"					encode_tab(v,is_array(v))\n"
"				else\n"
"					put(encode_it(v,t))\n"
"				end\n"
"			end\n"
"			put(\"]\")\n"
"		else\n"
"			put(\"{\")\n"
"			for i,v in pairs(vv) do\n"
"				put(comma and \",\") comma=true\n"
"				put(encode_it(i)) -- allow numbers or strings\n"
"				put(\":\")\n"
"				t=type(v)\n"
"				if t==\"table\" then\n"
"					encode_tab(v,is_array(v))\n"
"				else\n"
"					put(encode_it(v,t))\n"
"				end\n"
"			end\n"
"			put(\"}\")\n"
"		end\n"
"	end\n"
"\n"
"	encode_tab(tab,is_array(tab)) -- technically this should not be an array but we allow it\n"
"\n"
"\n"
"	return table.concat(out)\n"
"end\n"
"\n"
"",

"socket.url","-----------------------------------------------------------------------------\n"
"-- URI parsing, composition and relative URL resolution\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: url.lua,v 1.38 2006/04/03 04:45:42 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module\n"
"-----------------------------------------------------------------------------\n"
"local string = require(\"string\")\n"
"local base = _G\n"
"local table = require(\"table\")\n"
"module(\"socket.url\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Module version\n"
"-----------------------------------------------------------------------------\n"
"_VERSION = \"URL 1.0.1\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Encodes a string into its escaped hexadecimal representation\n"
"-- Input\n"
"--   s: binary string to be encoded\n"
"-- Returns\n"
"--   escaped representation of string binary\n"
"-----------------------------------------------------------------------------\n"
"function escape(s)\n"
"    return string.gsub(s, \"([^A-Za-z0-9_])\", function(c)\n"
"        return string.format(\"%%%02x\", string.byte(c))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Protects a path segment, to prevent it from interfering with the\n"
"-- url parsing.\n"
"-- Input\n"
"--   s: binary string to be encoded\n"
"-- Returns\n"
"--   escaped representation of string binary\n"
"-----------------------------------------------------------------------------\n"
"local function make_set(t)\n"
"	local s = {}\n"
"	for i,v in base.ipairs(t) do\n"
"		s[t[i]] = 1\n"
"	end\n"
"	return s\n"
"end\n"
"\n"
"-- these are allowed withing a path segment, along with alphanum\n"
"-- other characters must be escaped\n"
"local segment_set = make_set {\n"
"    \"-\", \"_\", \".\", \"!\", \"~\", \"*\", \"'\", \"(\",\n"
"	\")\", \":\", \"@\", \"&\", \"=\", \"+\", \"$\", \",\",\n"
"}\n"
"\n"
"local function protect_segment(s)\n"
"	return string.gsub(s, \"([^A-Za-z0-9_])\", function (c)\n"
"		if segment_set[c] then return c\n"
"		else return string.format(\"%%%02x\", string.byte(c)) end\n"
"	end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Encodes a string into its escaped hexadecimal representation\n"
"-- Input\n"
"--   s: binary string to be encoded\n"
"-- Returns\n"
"--   escaped representation of string binary\n"
"-----------------------------------------------------------------------------\n"
"function unescape(s)\n"
"    return string.gsub(s, \"%%(%x%x)\", function(hex)\n"
"        return string.char(base.tonumber(hex, 16))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Builds a path from a base path and a relative path\n"
"-- Input\n"
"--   base_path\n"
"--   relative_path\n"
"-- Returns\n"
"--   corresponding absolute path\n"
"-----------------------------------------------------------------------------\n"
"local function absolute_path(base_path, relative_path)\n"
"    if string.sub(relative_path, 1, 1) == \"/\" then return relative_path end\n"
"    local path = string.gsub(base_path, \"[^/]*$\", \"\")\n"
"    path = path .. relative_path\n"
"    path = string.gsub(path, \"([^/]*%./)\", function (s)\n"
"        if s ~= \"./\" then return s else return \"\" end\n"
"    end)\n"
"    path = string.gsub(path, \"/%.$\", \"/\")\n"
"    local reduced\n"
"    while reduced ~= path do\n"
"        reduced = path\n"
"        path = string.gsub(reduced, \"([^/]*/%.%./)\", function (s)\n"
"            if s ~= \"../../\" then return \"\" else return s end\n"
"        end)\n"
"    end\n"
"    path = string.gsub(reduced, \"([^/]*/%.%.)$\", function (s)\n"
"        if s ~= \"../..\" then return \"\" else return s end\n"
"    end)\n"
"    return path\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Parses a url and returns a table with all its parts according to RFC 2396\n"
"-- The following grammar describes the names given to the URL parts\n"
"-- <url> ::= <scheme>://<authority>/<path>;<params>?<query>#<fragment>\n"
"-- <authority> ::= <userinfo>@<host>:<port>\n"
"-- <userinfo> ::= <user>[:<password>]\n"
"-- <path> :: = {<segment>/}<segment>\n"
"-- Input\n"
"--   url: uniform resource locator of request\n"
"--   default: table with default values for each field\n"
"-- Returns\n"
"--   table with the following fields, where RFC naming conventions have\n"
"--   been preserved:\n"
"--     scheme, authority, userinfo, user, password, host, port,\n"
"--     path, params, query, fragment\n"
"-- Obs:\n"
"--   the leading '/' in {/<path>} is considered part of <path>\n"
"-----------------------------------------------------------------------------\n"
"function parse(url, default)\n"
"    -- initialize default parameters\n"
"    local parsed = {}\n"
"    for i,v in base.pairs(default or parsed) do parsed[i] = v end\n"
"    -- empty url is parsed to nil\n"
"    if not url or url == \"\" then return nil, \"invalid url\" end\n"
"    -- remove whitespace\n"
"    -- url = string.gsub(url, \"%s\", \"\")\n"
"    -- get fragment\n"
"    url = string.gsub(url, \"#(.*)$\", function(f)\n"
"        parsed.fragment = f\n"
"        return \"\"\n"
"    end)\n"
"    -- get scheme\n"
"    url = string.gsub(url, \"^([%w][%w%+%-%.]*)%:\",\n"
"        function(s) parsed.scheme = s; return \"\" end)\n"
"    -- get authority\n"
"    url = string.gsub(url, \"^//([^/]*)\", function(n)\n"
"        parsed.authority = n\n"
"        return \"\"\n"
"    end)\n"
"    -- get query stringing\n"
"    url = string.gsub(url, \"%?(.*)\", function(q)\n"
"        parsed.query = q\n"
"        return \"\"\n"
"    end)\n"
"    -- get params\n"
"    url = string.gsub(url, \"%;(.*)\", function(p)\n"
"        parsed.params = p\n"
"        return \"\"\n"
"    end)\n"
"    -- path is whatever was left\n"
"    if url ~= \"\" then parsed.path = url end\n"
"    local authority = parsed.authority\n"
"    if not authority then return parsed end\n"
"    authority = string.gsub(authority,\"^([^@]*)@\",\n"
"        function(u) parsed.userinfo = u; return \"\" end)\n"
"    authority = string.gsub(authority, \":([^:]*)$\",\n"
"        function(p) parsed.port = p; return \"\" end)\n"
"    if authority ~= \"\" then parsed.host = authority end\n"
"    local userinfo = parsed.userinfo\n"
"    if not userinfo then return parsed end\n"
"    userinfo = string.gsub(userinfo, \":([^:]*)$\",\n"
"        function(p) parsed.password = p; return \"\" end)\n"
"    parsed.user = userinfo\n"
"    return parsed\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Rebuilds a parsed URL from its components.\n"
"-- Components are protected if any reserved or unallowed characters are found\n"
"-- Input\n"
"--   parsed: parsed URL, as returned by parse\n"
"-- Returns\n"
"--   a stringing with the corresponding URL\n"
"-----------------------------------------------------------------------------\n"
"function build(parsed)\n"
"    local ppath = parse_path(parsed.path or \"\")\n"
"    local url = build_path(ppath)\n"
"    if parsed.params then url = url .. \";\" .. parsed.params end\n"
"    if parsed.query then url = url .. \"?\" .. parsed.query end\n"
"	local authority = parsed.authority\n"
"	if parsed.host then\n"
"		authority = parsed.host\n"
"		if parsed.port then authority = authority .. \":\" .. parsed.port end\n"
"		local userinfo = parsed.userinfo\n"
"		if parsed.user then\n"
"			userinfo = parsed.user\n"
"			if parsed.password then\n"
"				userinfo = userinfo .. \":\" .. parsed.password\n"
"			end\n"
"		end\n"
"		if userinfo then authority = userinfo .. \"@\" .. authority end\n"
"	end\n"
"    if authority then url = \"//\" .. authority .. url end\n"
"    if parsed.scheme then url = parsed.scheme .. \":\" .. url end\n"
"    if parsed.fragment then url = url .. \"#\" .. parsed.fragment end\n"
"    -- url = string.gsub(url, \"%s\", \"\")\n"
"    return url\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Builds a absolute URL from a base and a relative URL according to RFC 2396\n"
"-- Input\n"
"--   base_url\n"
"--   relative_url\n"
"-- Returns\n"
"--   corresponding absolute url\n"
"-----------------------------------------------------------------------------\n"
"function absolute(base_url, relative_url)\n"
"    if base.type(base_url) == \"table\" then\n"
"        base_parsed = base_url\n"
"        base_url = build(base_parsed)\n"
"    else\n"
"        base_parsed = parse(base_url)\n"
"    end\n"
"    local relative_parsed = parse(relative_url)\n"
"    if not base_parsed then return relative_url\n"
"    elseif not relative_parsed then return base_url\n"
"    elseif relative_parsed.scheme then return relative_url\n"
"    else\n"
"        relative_parsed.scheme = base_parsed.scheme\n"
"        if not relative_parsed.authority then\n"
"            relative_parsed.authority = base_parsed.authority\n"
"            if not relative_parsed.path then\n"
"                relative_parsed.path = base_parsed.path\n"
"                if not relative_parsed.params then\n"
"                    relative_parsed.params = base_parsed.params\n"
"                    if not relative_parsed.query then\n"
"                        relative_parsed.query = base_parsed.query\n"
"                    end\n"
"                end\n"
"            else    \n"
"                relative_parsed.path = absolute_path(base_parsed.path or \"\",\n"
"                    relative_parsed.path)\n"
"            end\n"
"        end\n"
"        return build(relative_parsed)\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Breaks a path into its segments, unescaping the segments\n"
"-- Input\n"
"--   path\n"
"-- Returns\n"
"--   segment: a table with one entry per segment\n"
"-----------------------------------------------------------------------------\n"
"function parse_path(path)\n"
"	local parsed = {}\n"
"	path = path or \"\"\n"
"	--path = string.gsub(path, \"%s\", \"\")\n"
"	string.gsub(path, \"([^/]+)\", function (s) table.insert(parsed, s) end)\n"
"	for i = 1, table.getn(parsed) do\n"
"		parsed[i] = unescape(parsed[i])\n"
"	end\n"
"	if string.sub(path, 1, 1) == \"/\" then parsed.is_absolute = 1 end\n"
"	if string.sub(path, -1, -1) == \"/\" then parsed.is_directory = 1 end\n"
"	return parsed\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Builds a path component from its segments, escaping protected characters.\n"
"-- Input\n"
"--   parsed: path segments\n"
"--   unsafe: if true, segments are not protected before path is built\n"
"-- Returns\n"
"--   path: corresponding path stringing\n"
"-----------------------------------------------------------------------------\n"
"function build_path(parsed, unsafe)\n"
"	local path = \"\"\n"
"	local n = table.getn(parsed)\n"
"	if unsafe then\n"
"		for i = 1, n-1 do\n"
"			path = path .. parsed[i]\n"
"			path = path .. \"/\"\n"
"		end\n"
"		if n > 0 then\n"
"			path = path .. parsed[n]\n"
"			if parsed.is_directory then path = path .. \"/\" end\n"
"		end\n"
"	else\n"
"		for i = 1, n-1 do\n"
"			path = path .. protect_segment(parsed[i])\n"
"			path = path .. \"/\"\n"
"		end\n"
"		if n > 0 then\n"
"			path = path .. protect_segment(parsed[n])\n"
"			if parsed.is_directory then path = path .. \"/\" end\n"
"		end\n"
"	end\n"
"	if parsed.is_absolute then path = \"/\" .. path end\n"
"	return path\n"
"end\n"
"",

"wetgenes.www.gae.data","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local json=require(\"wetgenes.json\")\n"
"\n"
"local core=require(\"wetgenes.www.gae.data.core\")\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"module(...)\n"
"local wdata=require(...) -- this is us\n"
"package.loaded[\"wetgenes.www.any.data\"]=wdata\n"
"local cache=require(\"wetgenes.www.any.cache\")\n"
"local wdatadef=require(\"wetgenes.www.any.datadef\")\n"
"\n"
"\n"
"function countzero()\n"
"	count=0\n"
"	api_time=0\n"
"end\n"
"countzero()\n"
"\n"
"local kind_props={}	-- default global props mapped to kinds\n"
"\n"
"local start_time -- handle simple api benchmarking of some calls\n"
"local function apis()\n"
"	start_time=os.time()\n"
"end\n"
"local function apie(...)\n"
"	api_time=api_time+os.time()-start_time\n"
"	return ...\n"
"end\n"
"\n"
"\n"
"\n"
"function keyinfo(keystr)\n"
"	\n"
"	return core.keyinfo(keystr)\n"
"end\n"
"\n"
"function keystr(kind,id,parent)\n"
"\n"
"	return core.keystr(kind,id,parent)\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"function del(ent)\n"
"	apis()\n"
"	\n"
"	count=count+0.5\n"
"	\n"
"	return apie(core.del(nil,ent))\n"
"end\n"
"\n"
"function put(ent)\n"
"	apis()\n"
"	count=count+0.5\n"
"	\n"
"	return apie(core.put(nil,ent))\n"
"end\n"
"\n"
"function get(ent)\n"
"	apis()\n"
"	count=count+0.5\n"
"	return apie(core.get(nil,ent))\n"
"end\n"
"\n"
"function query(q)\n"
"	apis()\n"
"	count=count+1\n"
"--log(tostring(q))	\n"
"\n"
"	return apie(core.query(nil,q))\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- Begin a transaction, use the functions inside the returned table\n"
"-- to perform actions within this transaction\n"
"--\n"
"-- the basic code flow is that you should begin one transaction per entity(parent)\n"
"-- and then rollback all when one fails. the first del/put/get locks the entity\n"
"-- we are dealing with in this transaction\n"
"--\n"
"-- after the t.fail flag gets set on a put/del then everything apart from rollback just returns nil\n"
"-- and commit is turned into an auto rollback\n"
"--\n"
"-- so this is OK transaction code, just remember that puts may not auto generate a key\n"
"-- and there may be other reasons for fails\n"
"--\n"
"-- for _=1,10 do -- try a few times\n"
"--     t=begin()\n"
"--     if t.get(e) then e.props.data=e.props.data..\"new data\" end\n"
"--     t.put(e)\n"
"--     if t.commit() then break end -- success\n"
"-- end\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function begin()\n"
"\n"
"	local t={}\n"
"	t.core=core.begin()\n"
"	\n"
"	t.fail=false -- this will be set to true when a transaction action fails and you should rollback and retry\n"
"	t.done=false -- set to true on commit or rollback to disable all methods\n"
"	\n"
" -- these methods are the same as the global ones but operate on this transaction\n"
" 	t.del=function(ent)	if t.fail or t.done then return nil end apis() return apie(core.del(t,ent)) end\n"
"	t.put=function(ent)	if t.fail or t.done then return nil end apis() return apie(core.put(t,ent)) end\n"
"	t.get=function(ent)	if t.fail or t.done then return nil end apis() return apie(core.get(t,ent)) end\n"
"	t.query=function(q)	if t.fail or t.done then return nil end apis() return apie(core.query(t,q)) end\n"
"	\n"
"	t.rollback=function() -- returns false to imply that nothing was commited\n"
"		if t.done then return false end -- safe to rollback repeatedly\n"
"		t.done=true\n"
"		apis()\n"
"		t.fail=not apie(core.rollback(t.core)) -- we always set fail and return false\n"
"		return not t.fail\n"
"	end	\n"
"	\n"
"	t.commit=function() -- returns true if commited, false if not\n"
"		if t.done then return false end -- safe to rollback repeatedly\n"
"		if t.fail then -- rollback rather than commit\n"
"			apis()\n"
"			return apie(t.rollback())\n"
"		end\n"
"		t.done=true\n"
"		apis()\n"
"		t.fail=not apie(core.commit(t.core))\n"
"		return not t.fail\n"
"	end\n"
"\n"
"	return t\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- build cache which is a mixture of decoded json vars (this may contain sub tables)\n"
"-- overiden by database props which do not contain tables but are mildly searchable\n"
"-- props.json should contain this json data string on input\n"
"-- cache will be a filled in table to be used instead of props\n"
"--\n"
"-- Not sure if this is more compact than just creating many real key/value pairs\n"
"-- but it feels like a better way to organize. :)\n"
"--\n"
"-- At least it is a bit more implicit about what can and cannot be searched for.\n"
"--\n"
"-- the idea is everything we need is copied into the cache, you can edit it there\n"
"-- and then build_props will do the reverse in preperation for a put\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function build_cache(e)\n"
"\n"
"	if e.props.json then -- expand the json data\n"
"	\n"
"		e.cache=json.decode(e.props.json)\n"
"		\n"
"	else\n"
"	\n"
"		e.cache={}\n"
"	\n"
"	end\n"
"\n"
"	for i,v in pairs(e.props) do -- override cache by props\n"
"		e.cache[i]=v\n"
"	end\n"
"	\n"
"	e.cache.json=nil -- not the json prop\n"
"	\n"
"	if e.key then -- copy the key data\n"
"		e.cache.parent=e.key.parent\n"
"		e.cache.kind=e.key.kind\n"
"		e.cache.id=e.key.id\n"
"	end\n"
"	\n"
"	return e\n"
"end\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- a simplistic reverse of build cache\n"
"-- any props of the same name will get updated from this cache\n"
"-- rather than encoded into props.json\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function build_props(e)\n"
"\n"
"	local t={}\n"
"	local ignore={kind=true,id=true,parent=true,json=true,} -- special names to ignore\n"
"	\n"
"	for i,v in pairs(e.cache) do\n"
"		if ignore[i] then -- ignore these special names\n"
"		elseif e.props[i] then\n"
"			e.props[i]=v -- if it exists as a prop then the prop is updated\n"
"		else\n"
"			t[i]=v -- else it just goes into the json prop\n"
"		end\n"
"	end\n"
"	e.props.json=json.encode(t)\n"
"	\n"
"	return e\n"
"end\n"
"\n"
"\n"
"\n"
"function set_defs(env)\n"
"	return wdatadef.set_defs(env)\n"
"end\n"
"\n"
"--no need for this, so just a stub\n"
"function setup_db(env,srv)\n"
"end\n"
"\n"
"\n"
"",

"state","package.cpath=apps.cpath -- and set paths so we can find things (we may be in a sub thread)\r\n"
"package.path=apps.path\r\n"
"\r\n"
"local wetquire=require(\"wetquire\")\r\n"
"wetquire.overload() -- replace require and module\r\n"
"\r\n"
"local debug=debug\r\n"
"local xpcall=xpcall\r\n"
"local assert=assert\r\n"
"\r\n"
"--package.path =package.path.. \";./lua/?.lua;./lua/?/init.lua\"\r\n"
"--package.cpath=package.cpath..\";./lua/?.so;./lua/init.dll\"\r\n"
"\r\n"
"\r\n"
"if not main_next or main_next==\"\" then main_next=\"menu\" end\r\n"
"\r\n"
"local work=require('work')\r\n"
"\r\n"
"local bit=require('bit')\r\n"
"local gl=require('gl')\r\n"
"\r\n"
"local widget = require(\"fenestra.widget\")\r\n"
"local np_check_msg=oldmain and oldmain.np_check_msg\r\n"
"\r\n"
"function goto(s) main_next=s end -- request a main state change with a goto, oh my.\r\n"
"local goto=goto\r\n"
"\r\n"
"-- win is global and contains all state data\r\n"
"win=require('fenestra.wrap').win(wet_setup_hwnd)\r\n"
"\r\n"
"local menu\r\n"
"\r\n"
"local win=win\r\n"
"local _G=_G\r\n"
"local gcinfo=gcinfo\r\n"
"local string=string\r\n"
"local math=math\r\n"
"\r\n"
"local function print(...) _G.print(...) end\r\n"
"\r\n"
"local times={}\r\n"
"\r\n"
"local function state_change(force)\r\n"
"\r\n"
"-- handle state changes\r\n"
"\r\n"
"	if main_next or force then\r\n"
"	\r\n"
"		if main and main.clean then\r\n"
"			times.clean.start()\r\n"
"			main:clean()\r\n"
"			times.clean.stop()\r\n"
"		end\r\n"
"		\r\n"
"		if type(main_next)==\"string\" then\r\n"
"		\r\n"
"			main_name=main_next\r\n"
"			main_next=require(\"state.\"..main_next)\r\n"
"		end\r\n"
"\r\n"
"		main_last=main\r\n"
"		main=main_next\r\n"
"		main_next=nil\r\n"
"		\r\n"
"		if main and main.setup then\r\n"
"			times.setup.start()\r\n"
"			main:setup()\r\n"
"			times.setup.stop()\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"\r\n"
"local _M=module(...)\r\n"
"\r\n"
"\r\n"
"function setup()\r\n"
"\r\n"
"	work.lanes_setup() -- create some worker threads\r\n"
"\r\n"
"menu_active=false\r\n"
"end_now=false\r\n"
"\r\n"
"	win.setup(_G) -- create and associate with this global table, eg _G.print gets replaced\r\n"
"\r\n"
"\r\n"
"	local last=win.time()\r\n"
"	local frame_last=last\r\n"
"	local frame_count=0\r\n"
"	local fps=0\r\n"
"\r\n"
"\r\n"
"	local function times_setup()\r\n"
"		local t={}\r\n"
"		t.time=0\r\n"
"		t.time_live=0\r\n"
"		\r\n"
"		t.hash=0\r\n"
"		t.hash_live=0\r\n"
"		\r\n"
"		t.started=0\r\n"
"		\r\n"
"		function t.start()\r\n"
"			t.started=win.time()\r\n"
"		end\r\n"
"		\r\n"
"		function t.stop()\r\n"
"			local ended=win.time()\r\n"
"			\r\n"
"			t.time_live=t.time_live + ended-t.started\r\n"
"			t.hash_live=t.hash_live + 1\r\n"
"		end\r\n"
"		\r\n"
"		function t.done()\r\n"
"			t.time=t.time_live\r\n"
"			t.hash=t.hash_live\r\n"
"			t.time_live=0\r\n"
"			t.hash_live=0\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"		return t\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"\r\n"
"	times.update=times_setup()\r\n"
"	times.draw=times_setup()\r\n"
"	times.swap=times_setup()\r\n"
"	times.setup=times_setup()\r\n"
"	times.clean=times_setup()\r\n"
"\r\n"
"	win.update=function()\r\n"
"\r\n"
"		win.width=win.get(\"width\")\r\n"
"		win.height=win.get(\"height\")\r\n"
"\r\n"
"		state_change()	\r\n"
"		\r\n"
"		local t=win.time()\r\n"
"		local d=t-last\r\n"
"		local d_orig=d\r\n"
"\r\n"
"	-- count frames	\r\n"
"		if t-frame_last >= 1 then\r\n"
"		\r\n"
"			fps=frame_count\r\n"
"			frame_count=0\r\n"
"			frame_last=t\r\n"
"		\r\n"
"			times.update.done()\r\n"
"			times.draw.done()\r\n"
"			times.swap.done()\r\n"
"		end\r\n"
"		\r\n"
"	-- update\r\n"
"\r\n"
"		local do_draw=false\r\n"
"		while d >= 0.020 do\r\n"
"		\r\n"
"			times.update.start()\r\n"
"			\r\n"
"			win.console.update()\r\n"
"				\r\n"
"			if menu_active then\r\n"
"			\r\n"
"				menu:update()\r\n"
"				\r\n"
"			else\r\n"
"\r\n"
"				win.widget:update()\r\n"
"				\r\n"
"				if _G.main and _G.main.update then\r\n"
"					_G.main:update()\r\n"
"				end\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"			times.update.stop()\r\n"
"			\r\n"
"			if d>1 then -- reset when very out of sync\r\n"
"				last=t\r\n"
"				d=0\r\n"
"			else\r\n"
"				last=last+0.020\r\n"
"				d=d-0.020\r\n"
"			end\r\n"
"			\r\n"
"			do_draw=true\r\n"
"		end\r\n"
"\r\n"
"	-- draw\r\n"
"\r\n"
"\r\n"
"		if do_draw then\r\n"
"\r\n"
"			times.draw.start()\r\n"
"			\r\n"
"			if menu_active then\r\n"
"			\r\n"
"				win.begin()\r\n"
"				gl.ClearColor(0,0,0.25,0)\r\n"
"				gl.Clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT);\r\n"
"				\r\n"
"				win.clip2d(0,0,0,0)\r\n"
"				win.project23d(640/480,1,1024)\r\n"
"				gl.MatrixMode(\"MODELVIEW\")\r\n"
"				gl.LoadIdentity()\r\n"
"			\r\n"
"				gl.PushMatrix()\r\n"
"				gl.Translate(-320,-240, -240*1.0)\r\n"
"				menu:draw()\r\n"
"				gl.PopMatrix()\r\n"
"				\r\n"
"			else\r\n"
"				local skipwidge\r\n"
"				if _G.main and _G.main.draw then\r\n"
"					skipwidge=_G.main:draw()\r\n"
"				else\r\n"
"					win.begin()\r\n"
"					gl.ClearColor(0,0,0.25,0)\r\n"
"					gl.Clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT);\r\n"
"					\r\n"
"					win.clip2d(0,0,0,0)\r\n"
"					win.project23d(640/480,1,1024)\r\n"
"					gl.MatrixMode(\"MODELVIEW\")\r\n"
"					gl.LoadIdentity()\r\n"
"				end\r\n"
"				\r\n"
"				if not skipwidge then\r\n"
"					win.clip2d(0,0,0,0)\r\n"
"					win.project23d(640/480,1,1024) -- undo any changes\r\n"
"					gl.MatrixMode(\"MODELVIEW\")\r\n"
"					gl.PushMatrix()\r\n"
"					gl.Translate(-320,-240, -240*1.0)\r\n"
"					win.widget:draw()\r\n"
"					gl.PopMatrix()\r\n"
"				end\r\n"
"			end\r\n"
"			\r\n"
"			win.console.draw()\r\n"
"		\r\n"
"			win.swap()\r\n"
"			times.draw.stop()\r\n"
"			\r\n"
"			frame_count=frame_count+1\r\n"
"			\r\n"
"			local gci=gcinfo()\r\n"
"			win.console.display(string.format(\"fps=%02.0f t=%03.0f u=%03.0f d=%03.0f gc=%0.0fk\",fps,math.floor(0.5+(10000/fps)),math.floor(0.5+times.update.time*10000),math.floor(0.5+times.draw.time*10000/times.draw.hash),math.floor(gci) ))\r\n"
"			\r\n"
"		end\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"-- create a simple master menu\r\n"
"\r\n"
"	\r\n"
"\r\n"
"	menu=widget.setup(win,{font=win.font_sans})\r\n"
"\r\n"
"-- call update once before setting the mouse or key functions\r\n"
"\r\n"
"	win.update()\r\n"
"\r\n"
"local hooks={}\r\n"
"	function hooks.click(widget)\r\n"
"print(widget.id)\r\n"
"		if widget.id then\r\n"
"			if widget.id==\"continue\" then\r\n"
"				menu_active=false\r\n"
"			elseif widget.id==\"menu\" then\r\n"
"				menu_active=false\r\n"
"				goto(\"menu\")\r\n"
"			elseif widget.id==\"reload\" then\r\n"
"				wetquire.set_reload_time() -- ask for reload\r\n"
"				goto(_G[\"main_name\"])\r\n"
"				menu_active=false\r\n"
"			elseif widget.id==\"quit\" then\r\n"
"				end_now=true\r\n"
"				menu_active=false\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	local top=menu:add({hx=640,hy=480,mx=1,class=\"hx\",ax=0,ay=0})\r\n"
"	top:add({sy=4,sx=1})\r\n"
"	top:add({text=\"Continue\",color=0x8800ff00,id=\"continue\",hooks=hooks})\r\n"
"	top:add({text=\"Main Menu\",color=0x88ffff00,id=\"menu\",hooks=hooks})\r\n"
"	top:add({text=\"Reload\",color=0x88ff8800,id=\"reload\",hooks=hooks})\r\n"
"	top:add({text=\"Quit\",color=0x88ff0000,id=\"quit\",hooks=hooks})\r\n"
"	top:add({sy=4,sx=1})\r\n"
"	\r\n"
"	menu:layout()\r\n"
"	\r\n"
"	menu.state=\"ready\"\r\n"
"\r\n"
"\r\n"
"-- setup mouse and key handlers\r\n"
"	\r\n"
"	function win.keypress(ascii,key,act)\r\n"
"	\r\n"
"		key=string.lower(key)\r\n"
"	\r\n"
"		if act==\"up\" and (key==\"esc\" or key==\"escape\") then\r\n"
"			menu_active=not menu_active\r\n"
"		end\r\n"
"	\r\n"
"			\r\n"
"		if not win.console.keypress(ascii,key,act) then -- console didnt want it\r\n"
"		\r\n"
"			if _G.main and _G.main.keypress then\r\n"
"			\r\n"
"				_G.main.keypress(ascii,key,act)\r\n"
"			\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"-- transform mouse data to widget view and tell the widgets\r\n"
"	function win.mouse(act,x,y,key)\r\n"
"\r\n"
"		local hx=win.width/2\r\n"
"		local hy=win.height/2\r\n"
"\r\n"
"		local tx,ty\r\n"
"		\r\n"
"		if win.height/(win.width or 1) > (3/4) then -- deal with new smart viewport sizeing\r\n"
"		\r\n"
"			tx=(4/3)*(x-hx)/hx\r\n"
"			ty=(4/3)*(hy-y)/hx\r\n"
"			\r\n"
"		else\r\n"
"		\r\n"
"			tx=(x-hx)/hy\r\n"
"			ty=(hy-y)/hy\r\n"
"\r\n"
"		end\r\n"
"		\r\n"
"		if menu_active then\r\n"
"			\r\n"
"			menu:mouse(act,320+tx*240,240+ty*240,key)\r\n"
"		else\r\n"
"			win.widget:mouse(act,320+tx*240,240+ty*240,key)\r\n"
"			\r\n"
"			\r\n"
"			if _G.main and _G.main.mouse then\r\n"
"			\r\n"
"				_G.main.mouse(act,x,win.height-y,key)\r\n"
"			\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update()\r\n"
"\r\n"
"	while win.msg(\"wait\") do\r\n"
"\r\n"
"		if np_check_msg then\r\n"
"			local si,sv=np_check_msg()\r\n"
"			if si and sv then\r\n"
"				if si==\"state\" then\r\n"
"					if sv==\"quit\" then\r\n"
"						end_now=true\r\n"
"					else\r\n"
"						goto(sv)\r\n"
"					end\r\n"
"				end\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"--		print(\"lanes_update\")\r\n"
"		work.lanes_update()\r\n"
"		win.update()\r\n"
"		\r\n"
"		if end_now then break end\r\n"
"	end\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function clean()\r\n"
"\r\n"
"	menu:remove_all()\r\n"
"	\r\n"
"	-- cleanup any state\r\n"
"	state_change(true)\r\n"
"\r\n"
"\r\n"
"	-- display final setup/clean timers\r\n"
"	times.setup.done()\r\n"
"	times.clean.done()\r\n"
"	print(\"setup:\"..times.setup.time..\" / \"..times.setup.hash..\" = \"..(times.setup.time/times.setup.hash))\r\n"
"	print(\"clean:\"..times.clean.time..\" / \"..times.clean.hash..\" = \"..(times.clean.time/times.clean.hash))\r\n"
"\r\n"
"	win.clean()\r\n"
"\r\n"
"	work.lanes_clean()\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"					\r\n"
"					\r\n"
"\r\n"
"-- start? only if main_next is already set\r\n"
"\r\n"
"if _G.main_next then\r\n"
"\r\n"
"	local function f()\r\n"
"		setup()\r\n"
"		update()\r\n"
"		clean()\r\n"
"	end\r\n"
"	\r\n"
"	assert( xpcall(f,debug.traceback) )\r\n"
"	\r\n"
"end\r\n"
"",

"swordstone.items","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local dbg=dbg or function()end\n"
"\n"
"\n"
"module(...)\n"
"\n"
"function ascii(a) return string.byte(a,1) end\n"
"\n"
"local can=require(\"swordstone.can\")\n"
"\n"
"local strings=require(\"yarn.strings\")\n"
"\n"
"local yarn_attrs=require(\"yarn.attrs\")\n"
"\n"
"local yarn=require(\"yarn\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- look up an items attrs data\n"
"-----------------------------------------------------------------------------\n"
"function get_item(dd,name,pow,xtra)\n"
"\n"
"	local aa=strings.split(name,\"%.\")\n"
"	\n"
"	if #aa>1 then -- must be two parts or more\n"
"		local p=tonumber(aa[#aa]) -- the last bit may be a number\n"
"		if p then\n"
"			pow=p -- override with power in name\n"
"			aa[#aa]=nil\n"
"			name=table.concat(aa,\".\")\n"
"		end\n"
"	end\n"
"	\n"
"	pow=pow or 0 -- pow is a +1 -1 etc, base item adjustment\n"
"\n"
"	local d,parent_name\n"
"\n"
"\n"
"	d=dd[name..\".\"..pow] or dd[name] -- check with a trailing .pow first\n"
"\n"
"	if not d then return nil end -- no data to get?\n"
"\n"
"	if aa[2] then\n"
"		aa[#aa]=nil -- lose trailing part\n"
"		parent_name=table.concat(aa,\".\") -- and build parents name\n"
"	end\n"
"	\n"
"	local it={}\n"
"	\n"
"	for i,v in pairs(d) do it[i]=v end -- copy 1 deep only\n"
"	if d.powadd then for i,v in pairs(d.powadd) do it[i]=(it[i] or 0)+ (v*pow) end end\n"
"	if d.powmul then for i,v in pairs(d.powmul) do it[i]=(it[i] or 0)* math.pow(v,pow) end end\n"
"		\n"
"	it.pow=pow -- remember pow\n"
"	it.name=name -- make sure name is always base name without POW\n"
"	\n"
"	for i,v in pairs(xtra or {}) do\n"
"		it[i]=v\n"
"	end\n"
"	\n"
"	if parent_name then -- we can inherit, so try it\n"
"		return get_item(dd,parent_name,pow,it) or it -- recurse if we can. merging these things together\n"
"	end\n"
"	\n"
"	return it\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- add a new item into the attrs data\n"
"-----------------------------------------------------------------------------\n"
"function add_item(v)\n"
"	v.id=#yarn_attrs.data+1 -- every data gets a unique id\n"
"	yarn_attrs.data[ v.id ] = v\n"
"	if v.name then\n"
"		yarn_attrs.data[ v.name ] = v -- we can also look up by name		\n"
"	end\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- setup items into attrs\n"
"-----------------------------------------------------------------------------\n"
"function setup()\n"
"\n"
"	yarn_attrs.data=yarn_attrs.data or {}\n"
"	\n"
"	yarn_attrs.get=function(name,pow,xtra) return get_item(yarn_attrs.data,name,pow,xtra) end\n"
"\n"
"local a=add_item\n"
"\n"
"a{\n"
"	name=\"cell\",\n"
"}\n"
"a{\n"
"	name=\"wall\",\n"
"}\n"
"a{\n"
"	name=\"floor\",\n"
"}\n"
"\n"
"\n"
"a{\n"
"	name=\"room\",\n"
"}\n"
"a{\n"
"	name=\"player\",\n"
"	desc=\"a human\",\n"
"	asc=ascii(\"@\"),\n"
"	form=\"char\",\n"
"	player=true,\n"
"	hp=10,\n"
"	\n"
"	wheel=0,\n"
"	dam_min=1,\n"
"	dam_max=2,\n"
"	def_add=0,\n"
"	def_mul=1,\n"
"	\n"
"	can=\n"
"	{\n"
"		fight=true,\n"
"		loot=true,\n"
"		make_room_visible=true,\n"
"		operate=true,\n"
"	},\n"
"	\n"
"}\n"
"a{\n"
"	name=\"sensei\",\n"
"	form=\"char\",\n"
"	class=\"sensei\",\n"
"	asc=ascii(\"8\"),\n"
"	desc=\"a sensei\",\n"
"		\n"
"	can=can.talk,\n"
"\n"
"	chat={\n"
"		[\"welcome\"]={\n"
"			text=[[Anybody there?]],\n"
"			says={\"hello\"},\n"
"		},\n"
"		[\"hello\"]={\n"
"			text=[[Why hello there.]],\n"
"			says={\"TTFN\"},\n"
"		},\n"
"	},\n"
"}\n"
"a{\n"
"	name=\"sensei.dump\",\n"
"	sensei=\"dump\",\n"
"	asc=ascii(\"1\"),\n"
"	desc=\"a sensei named hobob\",\n"
"	longdesc=\"Although it must be assumed that this is a person it looks more like a walking talking ball of fluff wearing leather Y-fronts.\",\n"
"	chat={\n"
"		[\"welcome\"]=function(it,by)\n"
"			if it.level.name==\"level.dump\" then\n"
"				if it.level.pow==1 then\n"
"					return it.chat[\"welcome.0\"]\n"
"				end\n"
"			end\n"
"			return it.chat[\"welcome.0\"]\n"
"		end,\n"
"		[\"welcome.0\"]={\n"
"			text=[[That you, Maud?]],\n"
"			says={{say=\"hello\",text=\"Were you expecting the queen?\"},{say=\"maud\",text=\"Maud?\"}},\n"
"		},\n"
"		[\"hello\"]={\n"
"			text=[[You sure took your time. You know I can't stand being by myself.]],\n"
"			says={\"TTFN\"},\n"
"		},\n"
"		[\"maud\"]={\n"
"			text=[[Oh, nevermind. It must be the fumes. They get things all confused with each other.]],\n"
"			says={\"TTFN\"},\n"
"		},\n"
"	},\n"
"}\n"
"a{\n"
"	name=\"sensei.twin1\",\n"
"	sensei=\"dump\",\n"
"	desc=\"a young girl\",\n"
"	longdesc=\"A normal looking young girl with long braids on each side of her head, fashioned from her dark brown hair.\",\n"
"	chat={\n"
"		[\"welcome\"]={\n"
"			text=[[Would you like to play with us?]],\n"
"			says={{say=\"yes\",text=\"Sure, why not.\"},{say=\"no\",text=\"I think i'll pass.\"}},\n"
"		},\n"
"		[\"yes\"]={\n"
"			text=[[Oh, good! I've been waiting for someone to try this new game I'll think of in a while.]],\n"
"			says={\"If you say so.\"},\n"
"		},\n"
"		[\"no\"]={\n"
"			text=[[You should really speak to my sister.]],\n"
"			says={\"If you say so\"},\n"
"		},\n"
"	},\n"
"}\n"
"a{\n"
"	name=\"sensei.twin2\",\n"
"	sensei=\"dump\",\n"
"	desc=\"a young girl\",\n"
"	longdesc=\"Although it looks as if this young girl looks eerily similar to the other one, she actually does.\",\n"
"	chat={\n"
"		[\"welcome\"]={\n"
"			text=[[Would you like to play with us?]],\n"
"			says={{say=\"yes\",text=\"What if i said yes?\"},{say=\"no\",text=\"No, thanks.\"}},\n"
"		},\n"
"		[\"yes\"]={\n"
"			text=[[Then you should speak to my sister.]],\n"
"			says={\"Ok, I'll do that now.\"},\n"
"		},\n"
"		[\"no\"]={\n"
"			text=[[Well, I really think you should speak to my sister.]],\n"
"			says={\"Fine.\"},\n"
"		},\n"
"	},\n"
"}\n"
"\n"
"a{\n"
"	name=\"stairs\",\n"
"	form=\"char\",\n"
"	class=\"stairs\",\n"
"	asc=ascii(\"<\"),\n"
"	desc=\"a doorstone inscribed, stairs\",\n"
"	stairs=\"town\",\n"
"	stairs_min=0,\n"
"	stairs_max=0,\n"
"	\n"
"	can=\n"
"	{\n"
"		use=\"menu\",\n"
"		acts=function(it,by)\n"
"			if by.can.operate then return {\"menu\"} end\n"
"		end,\n"
"		look=function(it,by)\n"
"			it.level.menu.show_text(it.desc,it.longdesc or it.desc)\n"
"		end,\n"
"		menu=function(it,by)\n"
"			it.level.menu.show_stairs_menu(it,by)\n"
"		end,\n"
"	}\n"
"}\n"
"a{\n"
"	name=\"stairs.home\",\n"
"	stairs=\"home\",\n"
"	desc=\"a doorstone inscribed, home\",\n"
"	stairs_min=1,\n"
"	stairs_max=1,\n"
"}\n"
"a{\n"
"	name=\"stairs.dump\",\n"
"	stairs=\"dump\",\n"
"	desc=\"a doorstone inscribed, garbage dump\",\n"
"	stairs_min=1,\n"
"	stairs_max=5,\n"
"}\n"
"a{\n"
"	name=\"cryo_bed\",\n"
"	form=\"char\",\n"
"	class=\"story\",\n"
"	asc=ascii(\"<\"),\n"
"	desc=\"your SwordStone vault capsule\",\n"
"	\n"
"	open=true,\n"
"	\n"
"	can=\n"
"	{\n"
"		use=\"menu\",\n"
"		acts=function(it,by)\n"
"			local t={\"read welcome\",\"read license\",\"look\"}\n"
"			if it.is.open then\n"
"				t[#t+1]=\"close\"\n"
"			else\n"
"				t[#t+1]=\"open\"\n"
"			end\n"
"			return t\n"
"		end,\n"
"		\n"
"		look=function(it,by)\n"
"			it.level.menu.show_text(it.desc,\n"
"			\"Your SwordStone vault capsule is \".. (it.is.open and \"open\" or \"closed\")..\".\" )\n"
"		end,\n"
"		open=function(it,by)\n"
"			if not it.open then\n"
"				it.level.menu.show_text(it.desc,\n"
"				\"Your SwordStone vault capsule is held shut by something inside.\")\n"
"			end\n"
"		end,\n"
"		close=function(it,by)\n"
"			if it.open then\n"
"				it.can.set_close(it)\n"
"				it.level.menu.show_text(it.desc,\n"
"				\"Your SwordStone vault capsule closes very very very slowly.\")\n"
"			end\n"
"		end,\n"
"		set_close=function(it)\n"
"			it.is.open=false\n"
"			it.is.asc=ascii(\"=\")\n"
"		end,\n"
"		set_open=function(it)\n"
"			it.is.open=true\n"
"			it.is.asc=ascii(\"<\")\n"
"		end,\n"
"		\n"
"		[\"read welcome\"]=function(it,by)\n"
"			it.level.menu.show_text(\"Running Swordstone v\"..yarn.version.number,\n"
"[[\n"
"\n"
"Press the CURSOR keys to move up/down/left/right.\n"
"\n"
"Press SPACE bar for a menu or to select a menu item.\n"
"\n"
"If you are standing near anything interesting press SPACE bar to interact with it.\n"
"\n"
"Press SPACE to continue.\n"
"]])\n"
"		end,\n"
"		\n"
"		[\"read license\"]=function(it,by)\n"
"			it.level.menu.show_text(it.desc,\n"
"[[\n"
"SwordStone technologies: Where your future, is our business.\n"
"\n"
"Handling this license* creates a binding and unbreakable contract between SwordStone technologies and you.\n"
"\n"
"Please remain calm.\n"
"\n"
"Our patent pending hero from the past vault is guaranteed to create a successful hero.\n"
"\n"
"Eventually.\n"
"\n"
"*The full text of this license is copyright SwordStone technologies and cannot be reproduced here.\n"
"]])\n"
"		end,\n"
"		\n"
"	},\n"
"}\n"
"a{\n"
"	name=\"cryo_door\",\n"
"	form=\"char\",\n"
"	class=\"story\",\n"
"	asc=ascii(\"|\"),\n"
"	desc=\"your SwordStone vault door\",\n"
"	\n"
"	open=false,\n"
"	\n"
"	can=\n"
"	{\n"
"		use=\"menu\",\n"
"		acts=function(it,by)\n"
"			local t={\"look\"}\n"
"			if it.open then\n"
"				t[#t+1]=\"close\"\n"
"			else\n"
"				t[#t+1]=\"open\"\n"
"			end\n"
"			return t\n"
"		end,\n"
"		\n"
"		look=function(it,by)\n"
"			it.level.menu.show_text(it.desc,\"your SwordStone vault door is \".. (it.is.open and \"open\" or \"closed\") )\n"
"		end,\n"
"		open=function(it,by)\n"
"			local capsule=it.level.find_item(\"cryo_bed\")\n"
"			if not capsule or capsule.is.open==true then\n"
"				it.level.menu.show_text(it.desc,\"please ensure that your SwordStone vault capsule is closed before exiting your SwordStone vault\")\n"
"			else\n"
"				it.can.set_open(it)\n"
"				it.can.look(it,by)\n"
"			end\n"
"		end,\n"
"		close=function(it,by)\n"
"			it.can.set_close(it)\n"
"			it.can.look(it,by)\n"
"		end,\n"
"		set_close=function(it)\n"
"			it.is.open=false\n"
"			it.is.form=\"char\"\n"
"			it.is.asc=ascii(\"|\")\n"
"		end,\n"
"		set_open=function(it)\n"
"			it.is.open=true\n"
"			it.is.form=\"item\"\n"
"			it.is.asc=ascii(\"/\")\n"
"		end,\n"
"	},\n"
"}\n"
"a{\n"
"	name=\"ant\",\n"
"	desc=\"an ant\",\n"
"	asc=ascii(\"a\"),\n"
"	form=\"char\",\n"
"	ant=true,\n"
"	hp=2,\n"
"	\n"
"	wheel=0,\n"
"	dam_min=1,\n"
"	dam_max=2,\n"
"	def_add=0,\n"
"	def_mul=1,\n"
"	\n"
"	can=can.fight,\n"
"	\n"
"	powadd={\n"
"		hp=2,\n"
"		dam_min=0,\n"
"		dam_max=1,\n"
"		def_add=-1,\n"
"		def_mul=0,\n"
"		},\n"
"\n"
"	loot={\n"
"		[\"pointy_stick\"]=5/10,\n"
"	},\n"
"}\n"
"a{\n"
"	name=\"blob\",\n"
"	desc=\"a blob\",\n"
"	asc=ascii(\"b\"),\n"
"	form=\"char\",\n"
"	blob=true,\n"
"	hp=10,\n"
"	\n"
"	wheel=0,\n"
"	dam_min=2,\n"
"	dam_max=4,\n"
"	def_add=0,\n"
"	def_mul=0.75,\n"
"	\n"
"	can=can.fight,\n"
"	\n"
"	powadd={\n"
"		hp=10,\n"
"		dam_min=2,\n"
"		dam_max=2,\n"
"		def_add=-1,\n"
"		def_mul=0,\n"
"		},\n"
"		\n"
"	loot={\n"
"		[\"pointy_stick.2\"]=5/10,\n"
"	},\n"
"}\n"
"a{\n"
"	name=\"ant_corpse\",\n"
"	desc=\"a corpse of an ant\",\n"
"	asc=ascii(\"%\"),\n"
"	form=\"item\",\n"
"	corpse=true,\n"
"	ant=true,\n"
"	can=can.item,\n"
"	weight=1,\n"
"}\n"
"a{\n"
"	name=\"blob_corpse\",\n"
"	desc=\"a corpse of a blob\",\n"
"	asc=ascii(\"%\"),\n"
"	form=\"item\",\n"
"	corpse=true,\n"
"	blob=true,\n"
"	can=can.item,\n"
"	weight=1,\n"
"}\n"
"a{\n"
"	name=\"rat\",\n"
"	desc=\"a rat\",\n"
"	asc=ascii(\"r\"),\n"
"	form=\"char\",\n"
"	rat=true,\n"
"	hp=5,\n"
"	\n"
"	wheel=0,\n"
"	dam_min=1,\n"
"	dam_max=2,\n"
"	def_add=0,\n"
"	def_mul=1,\n"
"	\n"
"	can=can.fight,\n"
"	\n"
"	powadd={\n"
"		hp=10,\n"
"		dam_min=2,\n"
"		dam_max=2,\n"
"		def_add=-1,\n"
"		def_mul=0,\n"
"		},\n"
"\n"
"	loot={\n"
"		[\"pointy_stick\"]=5/10,\n"
"	},\n"
"}\n"
"a{\n"
"	name=\"rat_corpse\",\n"
"	desc=\"a corpse of a rat\",\n"
"	asc=ascii(\"%\"),\n"
"	form=\"item\",\n"
"	corpse=true,\n"
"	rat=true,\n"
"	can=can.item,\n"
"	weight=1,\n"
"}\n"
"a{\n"
"	name=\"rat_gibs\",\n"
"	desc=\"a rats gibs\",\n"
"	asc=ascii(\",\"),\n"
"	form=\"item\",\n"
"	meat=true,\n"
"	rat=true,\n"
"	can=can.item,\n"
"	weight=0.1,\n"
"}\n"
"a{\n"
"	name=\"rat_tail\",\n"
"	desc=\"a rats tail\",\n"
"	asc=ascii(\",\"),\n"
"	form=\"item\",\n"
"	meat=true,\n"
"	rat=true,\n"
"	can=can.item,\n"
"	weight=0.1,\n"
"}\n"
"a{\n"
"	name=\"rat_tooth\",\n"
"	desc=\"a rats tooth\",\n"
"	asc=ascii(\",\"),\n"
"	form=\"item\",\n"
"	meat=true,\n"
"	rat=true,\n"
"	can=can.item,\n"
"	weight=0.1,\n"
"}\n"
"a{\n"
"	name=\"pointy_stick\",\n"
"	desc=\"a pointy stick\",\n"
"	asc=ascii(\"!\"),\n"
"	form=\"item\",\n"
"	weapon=true,\n"
"	stick=true,\n"
"	wood=true,\n"
"	can=can.item,\n"
"	weight=1,\n"
"\n"
"	wheel=0,\n"
"	dam_min=0,\n"
"	dam_max=1,\n"
"	def_add=0,\n"
"	def_mul=1,\n"
"\n"
"	powadd={\n"
"		dam_min=0,\n"
"		dam_max=1,\n"
"		def_add=0,\n"
"		def_mul=0,\n"
"	},\n"
"}\n"
"\n"
"a{\n"
"	name=\"wood_chair\",\n"
"	desc=\"a small wooden chair\",\n"
"	asc=ascii(\"~\"),\n"
"	form=\"item\",\n"
"	can=can.item,\n"
"	weight=1,\n"
"	wood=true,\n"
"}\n"
"\n"
"a{\n"
"	name=\"wood_plank\",\n"
"	desc=\"a small plank of wood\",\n"
"	asc=ascii(\"~\"),\n"
"	form=\"item\",\n"
"	can=can.item,\n"
"	weight=1,\n"
"	wood=true,\n"
"}\n"
"\n"
"a{\n"
"	name=\"wood_fag\",\n"
"	desc=\"a bundle of small sticks\",\n"
"	asc=ascii(\"~\"),\n"
"	form=\"item\",\n"
"	can=can.item,\n"
"	weight=1,\n"
"	wood=true,\n"
"}\n"
"\n"
"a{\n"
"	name=\"wood_log\",\n"
"	desc=\"a friendly wooden log\",\n"
"	asc=ascii(\"~\"),\n"
"	form=\"item\",\n"
"	can=can.item,\n"
"	weight=1,\n"
"	wood=true,\n"
"}\n"
"\n"
"\n"
"end\n"
"",

"swordstone.levels_test","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local dbg=dbg or function()end\n"
"\n"
"\n"
"module(...)\n"
"\n"
"local can=require(\"swordstone.can\")\n"
"\n"
"local items=require(\"swordstone.items\")\n"
"local maps=require(\"swordstone.maps\")\n"
"local levels=require(\"swordstone.levels\")\n"
"\n"
"\n"
"\n"
"\n"
"function level01(opts)\n"
"\n"
"	local r\n"
"	\n"
"	r=opts.add_room(\"test_stairs_1\")\n"
"	r=opts.add_room(\"test_lair_1\")\n"
"	\n"
"	opts.generate=function(level)\n"
"		levels.generate_player_bystairs(level)\n"
"		levels.generate_junk(level)\n"
"	end\n"
"\n"
"	return opts\n"
"end\n"
"\n"
"\n"
"function level02(opts)\n"
"\n"
"	local r\n"
"	\n"
"	r=opts.add_room(\"test_stairs\")\n"
"\n"
"	r=opts.add_room(\"test_hut1\")\n"
"	r=opts.add_room(\"test_hut2\")\n"
"	r=opts.add_room(\"test_hut3\")\n"
"	r=opts.add_room(\"test_hut4\")\n"
"	\n"
"	r=opts.add_room(\"test_hut0\")\n"
"	r=opts.add_room(\"test_hut0\")\n"
"	r=opts.add_room(\"test_hut0\")\n"
"	\n"
"	opts.mode=\"town\"\n"
"	opts.only_these_rooms=true\n"
"\n"
"	opts.generate=function(level)\n"
"		levels.generate_player_bystairs(level)\n"
"		levels.generate_junk(level)\n"
"	end\n"
"\n"
"	return opts\n"
"end\n"
"\n"
"function setup()\n"
"\n"
"local add_item=items.add_item\n"
"local ascii=items.ascii\n"
"local add_room=maps.add_room\n"
"\n"
"add_item{\n"
"	name=\"level.test\",\n"
"	desc=\"{best_score} Test level {pow}\",\n"
"	best_score=0,\n"
"}\n"
"\n"
"add_item{\n"
"	name=\"level.test.1\",\n"
"	desc=\"{best_score} : Give me tools\",\n"
"	best_score=0,\n"
"}\n"
"\n"
"add_item{\n"
"	name=\"level.test.2\",\n"
"	desc=\"{best_score} : I lost the plot\",\n"
"	best_score=0,\n"
"}\n"
"\n"
"add_item{\n"
"	name=\"stairs.test\",\n"
"	stairs=\"test\",\n"
"	desc=\"a doorstone inscribed, testing123\",\n"
"	stairs_min=1,\n"
"	stairs_max=2,\n"
"}\n"
"\n"
"local function best_score(it)\n"
"	if it.level.best_score then\n"
"		it.level.soul.best_score=it.level.soul.best_score or {}\n"
"		if not it.this_score then -- calculate new score?\n"
"		\n"
"			local score=1000-it.level.time_total\n"
"			if score<0 then score=0 end\n"
"			local n=it.level.name..\".\"..it.level.pow\n"
"			local t=it.level.soul.best_score\n"
"									\n"
"			if not t[n] or t[n]<score then t[n]=score end\n"
"\n"
"			it.this_score=score -- save to be printed\n"
"			it.best_score=t[n]\n"
"			\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"local chat=\n"
"{\n"
"	[\"welcome\"]=function(it,by)\n"
"		if it.level.name==\"level.test\" then\n"
"			if it.level.pow==1 then\n"
"				local rats=it.level.find_items(\"rat\")\n"
"				if #rats==24 then\n"
"					return it.chat[\"welcome.1\"]\n"
"				elseif #rats>0 then\n"
"					return it.chat[\"welcome.1.rats\"]\n"
"				else\n"
"					best_score(it)\n"
"					return it.chat[\"welcome.1.rat0\"]\n"
"				end\n"
"			elseif it.level.pow==2 then\n"
"				if it.level.is[\"plot_6\"] then -- the end\n"
"					best_score(it)\n"
"					return it.chat[\"welcome.2.score\"]\n"
"				else\n"
"					return it.chat[\"welcome.2\"]\n"
"				end\n"
"			end\n"
"		end\n"
"		return it.chat[\"question\"]\n"
"	end,\n"
"	[\"welcome.0\"]={\n"
"		text=[[Anybody there?]],\n"
"		says={\"hello\",{say=\"nobody\",text=\"There's nobody here but us chickens.\"}},\n"
"	},\n"
"	[\"question\"]={\n"
"		sticky=true,\n"
"		text=[[\n"
"		I am the master of the unitests.\n"
"		\n"
"		I can provide you with trials and tribbles through which we can both understand each other better.\n"
"		\n"
"		But always remember.\n"
"		\n"
"		What happens in the unitests, stays in the unitests.\n"
"		]],\n"
"		says={{say=\"teach\",text=\"Teach me, oh great one.\"},{say=\"no\",text=\"Nope.\"}},\n"
"	},\n"
"	[\"hello\"]={\n"
"		text=[[\n"
"		!!!\n"
"		Gorden Freeman Bennett, don't be suprisin' on me like that.\n"
"		]],\n"
"		says={{say=\"question\",text=\"...\"}},\n"
"	},\n"
"	[\"nobody\"]={\n"
"		text=[[\n"
"		Good to hear it.\n"
"		I can't be 'avin with ninjas sneaking up on me all sneaky like.\n"
"		The smoke bombs play 'avok with me poor sinuses.\n"
"		]],\n"
"		says={{say=\"question\",text=\"...\"}},\n"
"	},\n"
"	[\"teach\"]={\n"
"		text=[[\n"
"		Nip over to that doorstone next to me and pick a level.\n"
"		\n"
"		I'll follow you down and let you know what you 'ave to be doing when you get there.\n"
"		\n"
"		Down there is my domain, you may not take anything with you nor bring anything back and every time you enter everything will reset.\n"
"		\n"
"		The only thing that you may return with is knowledge.\n"
"		]],\n"
"		says={\"...\"},\n"
"	},\n"
"	[\"welcome.1\"]={\n"
"		text=[[\n"
"		Here you must learn the importance of items and equipment.\n"
"		\n"
"		Without tools we are but shaved monkeys.\n"
"		With tools we are shaved monkeys in suits.\n"
"		\n"
"		It's dangerous out there.\n"
"		Take this pointy stick and equip it.\n"
"		\n"
"		Find the mass of daemon hordes.\n"
"		Destroy them and return to me victorious.\n"
"		\n"
"		Or just nip back upstairs, your call blud.\n"
"		]],\n"
"		says={\"...\"},\n"
"	},\n"
"	[\"welcome.1.rats\"]={\n"
"		text=[[\n"
"		The daemon hordes still live.\n"
"\n"
"		Destroy them all and then return to me victorious.\n"
"		]],\n"
"		says={\"...\"},\n"
"	},\n"
"	[\"welcome.1.rat0\"]={\n"
"		text=[[\n"
"		Congratulations for showing courage under fire.\n"
"			\n"
"		Now that all the rat daemon spirits have departed this majestic world you may return to town a talented hero.\n"
"		\n"
"		You scored {this_score}\n"
"		]],\n"
"		says={\"...\"},\n"
"	},\n"
"	[\"welcome.2\"]={\n"
"		text=[[\n"
"		The villagers have stolen the plot.\n"
"		\n"
"		Go talk to them and see if you can find it.\n"
"		\n"
"		Remember this is just a practise.\n"
"		\n"
"		Plot stealing villagers are normally much more devious.\n"
"		]],\n"
"		says={\"...\"},\n"
"	},\n"
"	[\"welcome.2.score\"]={\n"
"		text=[[\n"
"		Well done, that wasnt a waste of time at all.\n"
"		\n"
"		I'm sure you learned a number of very important things.\n"
"				\n"
"		You scored {this_score}\n"
"		]],\n"
"		says={\"...\"},\n"
"	},\n"
"}\n"
"add_item{\n"
"	name=\"sensei.test\",\n"
"	sensei=\"test\",\n"
"	asc=ascii(\"0\"),\n"
"	desc=\"a sensei named chester\",\n"
"	longdesc=\"Cauliflower ears are the least of his worries, worries that include broccoli nose and turnip tongue. One can only assume that the best years of his fighting career are far, far behind him.\",\n"
"	chat=chat\n"
"}\n"
"\n"
"add_item{\n"
"	name=\"testvilager\",\n"
"	form=\"char\",\n"
"	class=\"vilager\",\n"
"	asc=ascii(\"8\"),\n"
"	desc=\"a vilager\",\n"
"		\n"
"	can=can.talkroam,\n"
"\n"
"	chat={\n"
"		[\"welcome\"]={\n"
"			text=[[Anybody there?]],\n"
"			says={say=\"no\"},\n"
"		},\n"
"	},\n"
"\n"
"}\n"
"\n"
"add_item{\n"
"	name=\"testvilager.butcher\",\n"
"	asc=ascii(\"1\"),\n"
"	desc=\"Mr Bacon the butcher\",\n"
"	longdesc=\"Oh my god, he is made out of meat!\",\n"
"\n"
"	chat={\n"
"		[\"welcome\"]={\n"
"			text=[[Anybody there?]],\n"
"			says={\n"
"				{say=\"plot\",text=\"Hello, I'm looking for the plot.\"},\n"
"				{say=\"postcard\",text=\"Did Mrs field give you a postcard?\",test=\"plot_5\"},\n"
"			},\n"
"		},\n"
"		[\"plot\"]={\n"
"			text=[[\n"
"			The plot you say?\n"
"			\n"
"			Well personally I like to find my plot in a large portion of black puddin'.\n"
"			\n"
"			Not to everyones taste sure, but different strokes keep the rhythm interesting.\n"
"			]],\n"
"			says={\"TTFN\"},\n"
"		},\n"
"		[\"postcard\"]={\n"
"			text=[[\n"
"			She gives me lots of things.\n"
"			\n"
"			Mostly things she wants to get rid of.\n"
"			\n"
"			I still have it and could show it to you if you like.\n"
"			]],\n"
"			says={\n"
"				{say=\"TTFN\",text=\"Don't trouble yourself.\",test=\"plot_5\"},\n"
"				{say=\"postcard2\",text=\"Show it to me.\",test=\"plot_5\"},\n"
"			},\n"
"		},\n"
"		[\"postcard2\"]={\n"
"			text=[[\n"
"			The postcard reads:\n"
"			\n"
"			Congratulations.\n"
"			\n"
"			You have found the plot.\n"
"			\n"
"			Wasn't that all fun and games?\n"
"			\n"
"			You can go talk to Chester now and find out your score.\n"
"			]],\n"
"			says={\n"
"				\"TTFN\",\n"
"			},\n"
"			flag=\"plot_6\",\n"
"		},\n"
"	},\n"
"}\n"
"\n"
"add_item{\n"
"	name=\"testvilager.farmer\",\n"
"	asc=ascii(\"2\"),\n"
"	desc=\"Mrs Field the farmer\",\n"
"	longdesc=\"Oh my god, she smells like a field!\",\n"
"\n"
"	chat={\n"
"		[\"welcome\"]={\n"
"			text=[[Anybody there?]],\n"
"			says={\n"
"				{say=\"plot\",text=\"Hello, I'm looking for the plot.\"},\n"
"				{say=\"post\",text=\"The postman says you receive all off the post?\",test=\"plot_3\"},\n"
"				{say=\"postcard\",text=\"Where is the postcard?\",test=\"plot_4\"},\n"
"			},\n"
"		},\n"
"		[\"plot\"]={\n"
"			text=[[\n"
"			Oh we don't have any of that sort of thing around here.\n"
"			\n"
"			We are a tidy anarcho-collective, nothing of interest to see here luv, you should move along.\n"
"			]],\n"
"			says={\"TTFN\"},\n"
"		},\n"
"		[\"post\"]={\n"
"			text=[[\n"
"			I told you we don't haver any plot around here.\n"
"			\n"
"			I make it my job to ensure that things stay that way.\n"
"			\n"
"			Outside influences are dangerous and could easily topple our fragile economy.\n"
"			]],\n"
"			says={\n"
"				\"TTFN\",\n"
"				{say=\"postcard\",text=\"Where is the postcard?\",test=\"plot_4\"},\n"
"			},\n"
"			flag=\"plot_4\",\n"
"		},\n"
"		[\"postcard\"]={\n"
"			text=[[\n"
"			Well, if it will get rid of you...\n"
"			\n"
"			Mr Bacon has it.\n"
"			\n"
"			He gets all of my very special jobs.\n"
"			\n"
"			Maybe he hasn't disposed of it yet.\n"
"			]],\n"
"			says={\"TTFN\"},\n"
"			flag=\"plot_5\",\n"
"		},\n"
"	},\n"
"}\n"
"\n"
"add_item{\n"
"	name=\"testvilager.postman\",\n"
"	asc=ascii(\"3\"),\n"
"	desc=\"Mr Stamp the postman\",\n"
"	longdesc=\"Oh my god, his fingers are sticky!\",\n"
"\n"
"	chat={\n"
"		[\"welcome\"]={\n"
"			text=[[Anybody there?]],\n"
"			says={\n"
"				{say=\"plot\",text=\"Hello, I'm looking for the plot.\"},\n"
"				{say=\"postcard\",text=\"Master Chip didn't get any postcard.\",test=\"plot_2\"},\n"
"			},\n"
"		},\n"
"		[\"plot\"]={\n"
"			text=[[\n"
"			I find plot is an overrated narrative device.\n"
"			\n"
"			Give me a nice postcard everyday of the week.\n"
"			\n"
"			Not only does it have pictures but they are always easier to read than any letter.\n"
"			\n"
"			Only the other day young Master Chip was sent a nice postcard.\n"
"			\n"
"			Full of saucy seaside humour it was, his gran's still a bit of a goer if you ask me.\n"
"			]],\n"
"			says={\"TTFN\"},\n"
"			flag=\"plot_1\",\n"
"		},\n"
"		[\"postcard\"]={\n"
"			text=[[\n"
"			I said he was sent one.\n"
"			\n"
"			I didn't say I delivered one to him.\n"
"			\n"
"			I deliver all the mail to Mrs Field, kinda makes my job redundant when you think about it but she says we need a postman.\n"
"			]],\n"
"			says={\"TTFN\"},\n"
"			flag=\"plot_3\",\n"
"		},\n"
"	},\n"
"}\n"
"\n"
"add_item{\n"
"	name=\"testvilager.carpenter\",\n"
"	asc=ascii(\"4\"),\n"
"	desc=\"Master Chip the carpenters son\",\n"
"	longdesc=\"Oh my god, his nose, it just keeps growing!\",\n"
"\n"
"	chat={\n"
"		[\"welcome\"]={\n"
"			text=[[Anybody there?]],\n"
"			says={\n"
"				{say=\"plot\",text=\"Hello, I'm looking for the plot.\"},\n"
"				{say=\"postcard\",text=\"Did you get a postcard yesterday?\",test=\"plot_1\"},\n"
"			},\n"
"		},\n"
"		[\"plot\"]={\n"
"			text=[[\n"
"			I don't know what you are talking about.\n"
"			]],\n"
"			says={\"TTFN\"},\n"
"		},\n"
"		[\"postcard\"]={\n"
"			text=[[\n"
"			I still don't know what you are talking about.\n"
"			]],\n"
"			says={\"TTFN\"},\n"
"			flag=\"plot_2\",\n"
"		},\n"
"	},\n"
"}\n"
"\n"
"add_room(\"test_stairs\",[[\n"
"# # # # # #\n"
"# . . . . #\n"
"# . < @1. #\n"
"# . . . . #\n"
"# # # # # #\n"
"]],{   \n"
"	[\"< \"]=\"stairs.test\",\n"
"	[\"@1\"]=\"sensei.test\",\n"
"})\n"
"\n"
"\n"
"add_room(\"test_stairs_1\",[[\n"
"# # # # # # # # # # # #\n"
"# . . . . . . . . . . #\n"
"# . . . . . . . . . . #\n"
"# . . < @1. . . ! . . #\n"
"# . . . . . . . . . . #\n"
"# . . . . . . . . . . #\n"
"# # # # # # # # # # # #\n"
"]],{   \n"
"	[\"< \"]=\"stairs.test\",\n"
"	[\"@1\"]=\"sensei.test\",\n"
"	[\"! \"]=\"pointy_stick.10\",\n"
"})\n"
"\n"
"add_room(\"test_lair_1\",[[\n"
"# # # # # # # # # # # #\n"
"# . . . . . . . . . . #\n"
"# . r r r r r r r r . #\n"
"# . r r r r r r r r . #\n"
"# . r r r r r r r r . #\n"
"# . . . . . . . . . . #\n"
"# # # # # # # # # # # #\n"
"]],{   \n"
"	[\"r \"]=\"rat\",\n"
"})\n"
"\n"
"\n"
"add_room(\"test_hut0\",[[\n"
"# # # # #\n"
"# . . . #\n"
"# . . . #\n"
"# . . . #\n"
"# # # # #\n"
"]],{\n"
"})\n"
"add_room(\"test_hut1\",[[\n"
"# # # # #\n"
"# . . . #\n"
"# . @1. #\n"
"# . . . #\n"
"# # # # #\n"
"]],{   \n"
"	[\"@1\"]=\"testvilager.butcher\",\n"
"})\n"
"add_room(\"test_hut2\",[[\n"
"# # # # #\n"
"# . . . #\n"
"# . @1. #\n"
"# . . . #\n"
"# # # # #\n"
"]],{   \n"
"	[\"@1\"]=\"testvilager.farmer\",\n"
"})\n"
"add_room(\"test_hut3\",[[\n"
"# # # # #\n"
"# . . . #\n"
"# . @1. #\n"
"# . . . #\n"
"# # # # #\n"
"]],{   \n"
"	[\"@1\"]=\"testvilager.postman\",\n"
"})\n"
"add_room(\"test_hut4\",[[\n"
"# # # # #\n"
"# . . . #\n"
"# . @1. #\n"
"# . . . #\n"
"# # # # #\n"
"]],{   \n"
"	[\"@1\"]=\"testvilager.carpenter\",\n"
"})\n"
"\n"
"end\n"
"\n"
"",

"swordstone.can","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local dbg=dbg or function()end\n"
"\n"
"\n"
"module(...)\n"
"\n"
"local yarn_fight=require(\"yarn.fight\")\n"
"local yarn_level=require(\"yarn.level\")\n"
"local strings=require(\"yarn.strings\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- base can flags and functions for a fighter\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"fight={\n"
"	fight=true,\n"
"	roam=\"random\",\n"
"	acts=function(it,by)\n"
"		if it.can.fight and by.can.fight then return {\"hit\",\"look\"} end\n"
"		return {\"look\"}\n"
"	end,\n"
"	hit=function(it,by)\n"
"		if it.can.fight and by.can.fight then yarn_fight.hit(by,it) end\n"
"		it.level.menu.hide()\n"
"		it.level.step(1)\n"
"--		it.level.update()\n"
"	end,\n"
"	look=function(it,by)\n"
"		it.level.menu.show_text(it.desc_text(),it.look_text())\n"
"	end,\n"
"}\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- base can flags and functions for a talker\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"talk={\n"
"	use=\"talk\",\n"
"	acts=function(it,by)\n"
"		if by.can.operate then return {\"talk\",\"look\"} end\n"
"		return {\"look\"}\n"
"	end,\n"
"	talk=function(it,by)\n"
"		if by.can.operate then\n"
"			it.level.menu.show_talk_menu(it,by)\n"
"		end\n"
"	end,\n"
"	look=function(it,by)\n"
"		it.level.menu.show_text(it.desc_text(),it.look_text())\n"
"	end,\n"
"}\n"
"\n"
"-- a talker who also wanders\n"
"talkroam={}\n"
"for i,v in pairs(talk) do talkroam[i]=v end\n"
"talkroam.roam=\"random\"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- base can flags and functions for an item\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"item={\n"
"	acts=function(it,by)\n"
"		if by.can.operate then\n"
"			if by.items and by.items[it] then\n"
"				if it.can.equip then\n"
"					if it.is.equiped then\n"
"						return {\"unequip\",\"drop\",\"look\"}\n"
"					else\n"
"						return {\"equip\",\"drop\",\"look\"}\n"
"					end\n"
"				else\n"
"					return {\"drop\",\"look\"}\n"
"				end\n"
"			else\n"
"				return {\"get\",\"get and equip\",\"look\"}\n"
"			end\n"
"		end\n"
"		return {\"look\"}\n"
"	end,\n"
"	[\"get and equip\"]=function(it,by)\n"
"		it.set_cell(by)\n"
"		it.is.equiped=true\n"
"		it.level.menu.hide()\n"
"		it.level.step(1)\n"
"	end,\n"
"	get=function(it,by)\n"
"		it.set_cell(by)\n"
"		it.level.menu.hide()\n"
"		it.level.step(1)\n"
"	end,\n"
"	drop=function(it,by)\n"
"		it.is.equiped=false\n"
"		it.set_cell(by.cell)\n"
"		it.level.menu.hide()\n"
"		it.level.step(1)\n"
"	end,\n"
"	equip=function(it,by)\n"
"		it.is.equiped=true\n"
"		it.level.menu.hide()\n"
"		it.level.step(1)\n"
"	end,\n"
"	unequip=function(it,by)\n"
"		it.is.equiped=false\n"
"		it.level.menu.hide()\n"
"		it.level.step(1)\n"
"	end,\n"
"	look=function(it,by)\n"
"		it.level.menu.show_text(it.desc_text(),it.look_text())\n"
"	end,\n"
"}\n"
"",

"swordstone.levels","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local dbg=dbg or function()end\n"
"\n"
"\n"
"module(...)\n"
"\n"
"local yarn_attr=require(\"yarn.attr\")\n"
"local yarn_attrs=require(\"yarn.attrs\")\n"
"local yarn_fight=require(\"yarn.fight\")\n"
"local yarn_level=require(\"yarn.level\")\n"
"local strings=require(\"yarn.strings\")\n"
"\n"
"local items=require(\"swordstone.items\")\n"
"local maps=require(\"swordstone.maps\")\n"
"local get_room=maps.get_room\n"
"\n"
"function setup()\n"
"	yarn_attrs.get_map=get_map\n"
"	yarn_attrs.generate_player=generate_player\n"
"	yarn_attrs.generate_player_bystairs=generate_player_bystairs\n"
"\n"
"local add_item=items.add_item\n"
"\n"
"add_item{\n"
"	name=\"level\",\n"
"	desc=\"level {pow}\",\n"
"	addjunk={\n"
"		[\"wood_chair\"]=0.5,\n"
"		[\"wood_plank\"]=0.5,\n"
"		[\"wood_fag\"]=0.5,\n"
"		[\"wood_log\"]=0.5,\n"
"		[\"pointy_stick\"]=0.5,\n"
"	}\n"
"}\n"
"add_item{\n"
"	name=\"level.home\",\n"
"	desc=\"Home level {pow}\",\n"
"}\n"
"add_item{\n"
"	name=\"level.town\",\n"
"	desc=\"Town level {pow}\",\n"
"}\n"
"add_item{\n"
"	name=\"level.dump\",\n"
"	desc=\"Dump level {pow}\",\n"
"}\n"
"\n"
"end\n"
"\n"
"\n"
"function callback(d) -- default callback when building maps\n"
"	if d.call==\"cell\" then\n"
"	\n"
"		for _,n in ipairs(yarn_attr.keys_name_and_subnames(d.name)) do\n"
"		\n"
"			d.level.cellfind[n]=d.cell -- last generated cell of this type\n"
"			\n"
"			local l=d.level.celllist[n] or {} -- all generated cells of this type\n"
"			l[#l+1]=d.cell\n"
"			d.level.celllist[n]=l\n"
"			\n"
"		end\n"
"		\n"
"		local at\n"
"		if d.name==\"wall\" then\n"
"			d.cell.set.name(\"wall\")\n"
"		else\n"
"			at=yarn_attrs.get(d.name)\n"
"		end\n"
"		if at then\n"
"			local it=d.level.new_item( at )\n"
"			if it then\n"
"				it.set_cell( d.cell)\n"
"			end\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"\n"
"\n"
"function generate_player(level)\n"
"	if level.flags.clean_slate then\n"
"		level.player=level.new_item( \"player\" )\n"
"	else\n"
"		level.player=level.player or level.main.player or level.new_item( \"player\" )\n"
"		level.main.player=level.player\n"
"	end\n"
"	level.main.player=level.player		\n"
"	level.player.level=level\n"
"	level.player.is.soul=level.main.soul -- we got soul\n"
"	level.player.set_cell( level.cellfind[\"player_spawn\"] or level.rand_room_cell({}) )\n"
"end\n"
"\n"
"function generate_player_bystairs(level)\n"
"	if level.flags.clean_slate then\n"
"		level.player=level.new_item( \"player\" )\n"
"	else\n"
"		level.player=level.player or level.main.player or level.new_item( \"player\" )\n"
"		level.main.player=level.player\n"
"	end\n"
"	level.player.level=level\n"
"	level.player.is.soul=level.main.soul -- we got soul\n"
"	\n"
"	local stairs\n"
"	if level.soul.last_stairs then -- aim to stick to the same stairs\n"
"		stairs=level.cellfind[level.soul.last_stairs]\n"
"dbg(\"fond real stairs : \"..tostring(stairs))\n"
"	end\n"
"	if not stairs then stairs=level.cellfind[\"stairs\"] end\n"
"	\n"
"	if stairs then\n"
"		for i,v in stairs.neighbours() do\n"
"			if v.is_empty() then --empty so place palyer here\n"
"				level.player.set_cell( v )\n"
"				break\n"
"			end\n"
"		end\n"
"	else -- if we got here then just pick a random place\n"
"		level.player.set_cell( level.rand_room_cell({}) )\n"
"	end\n"
"end\n"
"\n"
"function generate_ants(level)\n"
"	for i=1,10 do\n"
"		local c=level.rand_room_cell({})\n"
"		if not c.char then\n"
"			local p=level.new_item( \"ant\" )\n"
"			p.set_cell( c )\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"function generate_blobs(level)\n"
"	for i=1,5 do\n"
"		local c=level.rand_room_cell({})\n"
"		if not c.char then\n"
"			local p=level.new_item( \"blob\" )\n"
"			p.set_cell( c )\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"function generate_junk(level)\n"
"\n"
"-- first count number of empty cells\n"
"\n"
"local empty_cells={}\n"
"\n"
"local add\n"
"\n"
"	for i=0,#level.cells do local v=level.cells[i]\n"
"		if v.is_empty() then empty_cells[#empty_cells+1]=v end\n"
"	end\n"
"\n"
"	for n,v in pairs(level.addjunk) do\n"
"		local count=math.floor(#empty_cells * v/100)\n"
"		if count>0 then\n"
"			for i=1,count do\n"
"				local idx=math.random(1,#empty_cells)\n"
"				local c=table.remove(empty_cells,idx)\n"
"				local p=level.new_item( n )\n"
"				p.set_cell( c )\n"
"			end\n"
"		end\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- this handles the creation of levels by building options to be fed\n"
"-- to the level creator\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function get_map(name,pow)\n"
"\n"
"	local aa=strings.split(name,\"%.\")\n"
"	\n"
"	if #aa>1 then -- must be two parts or more\n"
"		local p=tonumber(aa[#aa]) -- the last bit may be a number\n"
"		if p then\n"
"			pow=p -- override with power in name\n"
"			aa[#aa]=nil\n"
"			name=table.concat(aa,\".\")\n"
"		end\n"
"	end\n"
"\n"
"	local opts={}\n"
"	opts.rooms={} -- required rooms for this map\n"
"	opts.flags={} -- this stuff MUST be remembered on save, the rest is inconsequential\n"
"\n"
"	function opts.add_room(s)\n"
"		local r=maps.get_room(s)\n"
"		opts.rooms[#opts.rooms+1]=r\n"
"		r.callback=callback\n"
"		return r\n"
"	end\n"
"	local add_room=opts.add_room\n"
"\n"
"\n"
"--default generation	\n"
"	opts.generate=function(level)\n"
"		generate_player(level)\n"
"		generate_ants(level)\n"
"		generate_blobs(level)\n"
"	end\n"
"	\n"
"	local r\n"
"	if pow==0 then -- level 0 is always town no matter what the name\n"
"	\n"
"		r=add_room(\"home_stairs\")\n"
"		r=add_room(\"dump_stairs\")\n"
"		r=add_room(\"test_stairs\")\n"
"--		r=add_room(\"pub\")\n"
"--		r=add_room(\"bank\")\n"
"--		r=add_room(\"shop\")\n"
"--		r=add_room(\"hotel\")\n"
"		r=add_room(\"redroom\")\n"
"				\n"
"		opts.mode=\"town\"\n"
"		opts.only_these_rooms=true\n"
"\n"
"		opts.generate=function(level)\n"
"			generate_player_bystairs(level)\n"
"			generate_junk(level)\n"
"		end\n"
"	\n"
"	elseif name==\"level.home\" then\n"
"	\n"
"		r=add_room(\"home_stairs\")\n"
"		r=add_room(\"home_bedroom\")\n"
"		r=add_room(\"home_mainroom\")\n"
"		\n"
"		opts.generate=function(level)\n"
"				\n"
"			if level.soul.capsule_done then\n"
"				generate_player_bystairs(level)\n"
"			else\n"
"				generate_player(level)\n"
"			end\n"
"			\n"
"			generate_junk(level)\n"
"\n"
"			level.soul.capsule_done=true\n"
"\n"
"		end\n"
"		\n"
"		\n"
"	elseif name==\"level.dump\" then\n"
"\n"
"		r=add_room(\"dump_stairs\")\n"
"\n"
"			opts.generate=function(level)\n"
"			\n"
"				generate_player(level)\n"
"				generate_ants(level)\n"
"				generate_blobs(level)\n"
"				\n"
"				generate_junk(level)\n"
"				\n"
"			end\n"
"	\n"
"	elseif name==\"level.test\" then\n"
"\n"
"		opts.flags.clean_slate=true -- always regen level and do not take items into it or out of it\n"
"\n"
"		if pow==1 then\n"
"\n"
"			require(\"swordstone.levels_test\").level01(opts)\n"
"\n"
"		elseif pow==2 then\n"
"\n"
"			require(\"swordstone.levels_test\").level02(opts)\n"
"\n"
"		else\n"
"		\n"
"			r=add_room(\"test_stairs\")\n"
"			\n"
"		end\n"
"	\n"
"	else\n"
"\n"
"		r=add_room(\"stairs\")\n"
"	\n"
"	end\n"
"	\n"
"	\n"
"	return opts\n"
"\n"
"end\n"
"",

"wetgenes.www.gae","\r\r\r\rmodule(...)\r\r",

"wetgenes.simpxml","\r\n"
"local table=table\r\n"
"local string=string\r\n"
"\r\n"
"local ipairs=ipairs\r\n"
"local pairs=pairs\r\n"
"\r\n"
"local type=type\r\n"
"\r\n"
"local print=log or print\r\n"
"local assert=assert\r\n"
"\r\n"
"module(...)\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- some old simple xml parsing code, found here and fixed up a little :)\r\n"
"--\r\n"
"-- http://lua-users.org/lists/lua-l/2002-06/msg00040.html\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- auxiliar function to parse tag attributes\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function parse_args(s,label)\r\n"
"  local arg = {}\r\n"
"  arg[0]=label or \"?\"\r\n"
"  string.gsub(s, \"([%w_]+)%s*=%s*([\\\"'])(.-)%2\", function (w, _, a)\r\n"
"    arg[string.lower(w)] = a\r\n"
"  end)\r\n"
"  return arg\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- string \"s\" is a string with XML marks. This function parses the string\r\n"
"-- and returns the resulting tree.\r\n"
"--\r\n"
"-- simple but will parse small basic data xml files just fine and thats what im using it for\r\n"
"--\r\n"
"-- it is however very easy to produce a valid xml file that will break this...\r\n"
"-- but, as long as you are just using tags/data then this is fine\r\n"
"--\r\n"
"-- by putting the tag name in [0] we can use the string namespace for all attributes\r\n"
"-- and can iterate over the table entries 1+ in a normal way\r\n"
"--\r\n"
"-- [0] == tag name\r\n"
"-- [1++] == contained strings or tables (sub tags)\r\n"
"-- [stringnames] == attributes IE all string keys\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function parse(s)\r\n"
"  local stack = {}\r\n"
"  local top = {}\r\n"
"  table.insert(stack, top)\r\n"
"  local i = 1\r\n"
"\r\n"
"local ret_stack=2 -- we start by assuming we will be skipping a header\r\n"
"\r\n"
"  local warnings\r\n"
"  local warn=function(s)\r\n"
"	if not warnings then warnings={} end\r\n"
"	warnings[#warnings+1]=s\r\n"
"  end\r\n"
"\r\n"
"\r\n"
"\r\n"
"	local j2\r\n"
"-- find header\r\n"
"  local ni,j,c,label,args, empty = string.find(s, \"<%?(%/?)([%w_]+)(.-)(%/?)%?>\")\r\n"
"  \r\n"
"  if not ni then -- ignore missing <? tag header at start\r\n"
"	ret_stack=1\r\n"
"	ni,j,c,label,args, empty = string.find(s, \"<(%/?)([%w_]+)(.-)(%/?)>\")\r\n"
"  end\r\n"
"  \r\n"
"  \r\n"
"  while ni do\r\n"
"--print(ni,j,c,label,args,empty)\r\n"
"    local text = string.sub(s, i, ni-1)\r\n"
"\r\n"
"--print(text)\r\n"
"    \r\n"
"    if not string.find(text, \"^%s*$\") then -- if not just white space\r\n"
"      table.insert(top, text)\r\n"
"    end\r\n"
"    if empty == \"/\" then  -- empty element tag\r\n"
"      table.insert(top, parse_args(args,label) )\r\n"
"    elseif c == \"xml\" then   -- top tag\r\n"
"      top = parse_args(args,label)\r\n"
"      table.insert(stack, top)   -- new level\r\n"
"    elseif c == \"\" then   -- start tag\r\n"
"      top = parse_args(args,label)\r\n"
"      table.insert(stack, top)   -- new level\r\n"
"    else  -- end tag\r\n"
"		local autoclose=true -- autoclose\r\n"
"		while autoclose do\r\n"
"		  local toclose = table.remove(stack)  -- remove top\r\n"
"		  top = stack[#stack]\r\n"
"		  if #stack < 1 then\r\n"
"			warn(\"Tag <\"..label..\"> not matched \")\r\n"
"		  else\r\n"
"			  if toclose[0] ~= label then\r\n"
"				warn(\"Tag <\"..(toclose[0] or \"?\")..\"> doesnt match <\"..(label or \"?\")..\">.\")\r\n"
"				else\r\n"
"				autoclose=false\r\n"
"			  end\r\n"
"		  end\r\n"
"		  table.insert(top, toclose)\r\n"
"		end\r\n"
"    end \r\n"
"    i = j+1\r\n"
"\r\n"
"-- catch cdata in tag\r\n"
"    ni,j2,text = string.find(s, \"^%<%!%[CDATA%[(.-)%]%]%>\", i)\r\n"
"    if ni then\r\n"
"--print(text)\r\n"
"		table.insert(top, text) -- just insert the content\r\n"
"		j=j2\r\n"
"		i = j+1\r\n"
"	end\r\n"
"    \r\n"
"    \r\n"
"    ni,j,c,label,args, empty = string.find(s, \"<(%/?)([%w_]+)(.-)(%/?)>\", i)\r\n"
"  end\r\n"
"  local text = string.sub(s, i)\r\n"
"  if not string.find(text, \"^%s*$\") then\r\n"
"    table.insert(stack[#stack], text)\r\n"
"  end\r\n"
"  return stack[ret_stack],warnings\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert everything within this chunk, back to a html string\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function unparse(parent,opts)\r\n"
"	opts=opts or {tabjoin=true}\r\n"
"\r\n"
"	local tabjoin=opts.tabjoin -- only one of these recursive calls should have this flag\r\n"
"	if tabjoin then opts.tabjoin=false end -- so disable it\r\n"
"	\r\n"
"	local out=function(s) opts.out[#opts.out+1]=s end\r\n"
"	local att=function(t)\r\n"
"		local at={}\r\n"
"		for i,v in pairs(t) do\r\n"
"			local t=type(i)\r\n"
"			if t==\"string\" then\r\n"
"				at[#at+1]=i..\"=\"..\"\\\"\"..v..\"\\\"\"\r\n"
"			end\r\n"
"		end\r\n"
"		if at[1] then\r\n"
"			return \" \"..table.concat(at,\" \")..\" \"\r\n"
"		else\r\n"
"			return \"\"\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	if not opts.out then opts.out={} end\r\n"
"\r\n"
"	for i,v in ipairs(parent) do\r\n"
"		local t=type(v)\r\n"
"		if t==\"string\" then\r\n"
"			out(v)\r\n"
"		elseif t==\"table\" then\r\n"
"			if v[0] then\r\n"
"				if v[1] then -- stuff within this tag\r\n"
"					out(\"<\"..v[0]..att(v)..\">\")\r\n"
"						unparse(v,opts)\r\n"
"					out(\"</\"..v[0]..\">\")\r\n"
"				else -- an empty tag\r\n"
"					out(\"<\"..v[0]..att(v)..\"/>\")\r\n"
"				end\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	if tabjoin then -- reenable flag before returning\r\n"
"		opts.tabjoin=true\r\n"
"		return table.concat(opts.out)\r\n"
"	else\r\n"
"		return opts\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- get/set the attr tag of the given type (deals with silly case problems)\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function attr(parent,name,set)\r\n"
"\r\n"
"	name=string.lower(name)\r\n"
"\r\n"
"	if set then parent[name]=set end\r\n"
"\r\n"
"	return parent[name]\r\n"
"--[[\r\n"
"\r\n"
"	for n,v in pairs(parent) do\r\n"
"		if type(n)==\"string\" and string.lower(n)==name then\r\n"
"			if set then parent[n]=set end\r\n"
"			return v\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	return nil\r\n"
"]]\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find the first child tag of the given type, this does not recurse\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function child(parent,name)\r\n"
"\r\n"
"	name=string.lower(name)\r\n"
"\r\n"
"	for i,v in ipairs(parent) do\r\n"
"		if type(v)==\"table\" and v[0] and string.lower(v[0])==name then return v end\r\n"
"	end\r\n"
"	\r\n"
"	return nil\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find all the children tag of the given type, this does not recurse\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function childs(parent,name)\r\n"
"\r\n"
"	name=string.lower(name)\r\n"
"	\r\n"
"	local t={}\r\n"
"	\r\n"
"	for i,v in ipairs(parent) do\r\n"
"		if type(v)==\"table\" and v[0] and string.lower(v[0])==name then t[#t+1]=v end\r\n"
"	end\r\n"
"	\r\n"
"	return t\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find the first descendent tag of the given type, this does recurse\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function descendent(parent,name)\r\n"
"\r\n"
"	name=string.lower(name)\r\n"
"\r\n"
"	for i,v in ipairs(parent) do\r\n"
"		if type(v)==\"table\" and v[0] and string.lower(v[0])==name then return v end\r\n"
"	end\r\n"
"	\r\n"
"	for i,v in ipairs(parent) do -- recurse\r\n"
"		local ret\r\n"
"		if type(v)==\"table\" then ret=descendent(v,name) end\r\n"
"		if ret then return ret end\r\n"
"	end\r\n"
"	\r\n"
"	return nil\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find **all** the descendent tags of the given type, this does recurse\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function descendents(parent,name,opts)\r\n"
"	opts=opts or {}\r\n"
"	opts.out=opts.out or {}\r\n"
"	\r\n"
"	local out=function(s) opts.out[#opts.out+1]=s end\r\n"
"	\r\n"
"	name=string.lower(name)\r\n"
"\r\n"
"	for i,v in ipairs(parent) do -- this level\r\n"
"		if type(v)==\"table\" and v[0] and string.lower(v[0])==name then out(v) end\r\n"
"	end\r\n"
"	\r\n"
"	for i,v in ipairs(parent) do -- recurse\r\n"
"		if type(v)==\"table\" then descendents(v,name,opts) end\r\n"
"	end\r\n"
"	\r\n"
"	return opts.out -- maybe an empty output\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find the first descendent tag of the given class, this does recurse\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function class(parent,name)\r\n"
"\r\n"
"	name=string.lower(name)\r\n"
"\r\n"
"	for i,v in ipairs(parent) do\r\n"
"		if type(v)==\"table\" then\r\n"
"			if attr(v,\"class\") then\r\n"
"--print( attr(v,\"class\") ..\"\\n"
"\" )\r\n"
"				if string.lower(attr(v,\"class\"))==name then return v end\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	for i,v in ipairs(parent) do -- recurse\r\n"
"		local ret\r\n"
"		if type(v)==\"table\" then ret=class(v,name) end\r\n"
"		if ret then return ret end\r\n"
"	end\r\n"
"	\r\n"
"	return nil\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find **all** the descendent tags of the given class, this does recurse\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function classes(parent,name,opts)\r\n"
"	opts=opts or {}\r\n"
"	opts.out=opts.out or {}\r\n"
"	\r\n"
"	local out=function(s) opts.out[#opts.out+1]=s end\r\n"
"	\r\n"
"	name=string.lower(name)\r\n"
"\r\n"
"	for i,v in ipairs(parent) do -- this level\r\n"
"		if type(v)==\"table\" then\r\n"
"			if attr(v,\"class\") then\r\n"
"				if string.lower(attr(v,\"class\"))==name then out(v) end\r\n"
"			end\r\n"
"		end\r\n"
"		if type(v)==\"table\" and attr(v,\"class\") and string.lower(attr(v,\"class\"))==name then out(v) end\r\n"
"	end\r\n"
"	\r\n"
"	for i,v in ipairs(parent) do -- recurse\r\n"
"		if type(v)==\"table\" then classes(v,name,opts) end\r\n"
"	end\r\n"
"	\r\n"
"	return opts.out -- maybe an empty output\r\n"
"\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.pp","--+-----------------------------------------------------------------------------------------------------------------+--\r\n"
"--\r\n"
"-- (C) Kriss Daniels 2005 http://www.XIXs.com\r\n"
"--\r\n"
"-- This file made available under the terms of The MIT License : http://www.opensource.org/licenses/mit-license.php\r\n"
"--\r\n"
"-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n"
"--\r\n"
"-- The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n"
"--\r\n"
"-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n"
"--\r\n"
"--+-----------------------------------------------------------------------------------------------------------------+--\r\n"
"\r\n"
"local up_G=_G\r\n"
"\r\n"
"local print=print\r\n"
"local io=io\r\n"
"local table=table\r\n"
"local string=string\r\n"
"local loadfile=loadfile\r\n"
"local loadstring=loadstring\r\n"
"local assert=assert\r\n"
"local pcall=pcall\r\n"
"local xpcall=xpcall\r\n"
"\r\n"
"local setmetatable=setmetatable\r\n"
"local getfenv=getfenv\r\n"
"local setfenv=setfenv\r\n"
"\r\n"
"module(\"wetgenes.pp\")\r\n"
"\r\n"
"\r\n"
"\r\n"
"--\r\n"
"--\r\n"
"-- Create a lua program from an input file.\r\n"
"--\r\n"
"-- This can then be parsed and run to produce a preprocesed outputfile\r\n"
"--\r\n"
"--\r\n"
"\r\n"
"-- #() can be used anywhere except at the start of a line to inject the text between () as a small chunk of lua\r\n"
"-- # can be used at the start of the line to inject the rest of the line as lua\r\n"
"-- #include \"fname\" is a piece of magic that injects the given file into the output\r\n"
"-- #( at the start of the line denotes the begining of a pure lua block, rest of line is ignored\r\n"
"-- #) at the start of the line denotes the end of a pure lua block, rest of line is ignored\r\n"
"-- a pure lua block is needed for multiline table definitions otherwise the line numbering system breaks things\r\n"
"--\r\n"
"-- returns a table of strings which can be table.concat into a string result\r\n"
"\r\n"
"function ppload(filename,chunk)\r\n"
"\r\n"
"local included\r\n"
"\r\n"
"local file\r\n"
"local temp\r\n"
"local line_num\r\n"
"local new_filename\r\n"
"local lua_block_insert\r\n"
"\r\n"
"\r\n"
"	lua_block_insert=false\r\n"
"\r\n"
"	if chunk then -- we are a sub build\r\n"
"\r\n"
"		included=true\r\n"
"\r\n"
"	else\r\n"
"\r\n"
"		included=false\r\n"
"\r\n"
"		chunk = {n=0}\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"\r\n"
"	file=io.open(filename,\"r\")\r\n"
"	\r\n"
"	assert(file,\"failed to load \"..filename)\r\n"
"\r\n"
"	if not included then\r\n"
"\r\n"
"		table.insert(chunk,\"-- A lua file that builds a preprocesed file as a table\\n"
"\")\r\n"
"		table.insert(chunk,\"\\n"
"\")\r\n"
"		table.insert(chunk,\"pp_output_table = {}\\n"
"\")\r\n"
"		table.insert(chunk,\"local _out_ti=table.insert\\n"
"\")\r\n"
"		table.insert(chunk,\"local _out_tt=pp_output_table\\n"
"\")\r\n"
"		table.insert(chunk,\"local _out_do=function(s)\\n"
"\")\r\n"
"		table.insert(chunk,\"	_out_ti(_out_tt,s)\\n"
"\")\r\n"
"		table.insert(chunk,\"	for i in string.gfind(s,'\\\\n"
"') do -- count outputlines\\n"
"\")\r\n"
"		table.insert(chunk,\"		_lo=_lo+1\\n"
"\")\r\n"
"		table.insert(chunk,\"		if _lo_break then -- so we can break on line\\n"
"\")\r\n"
"		table.insert(chunk,\"			assert(_lo<_lo_break,'user line break')\\n"
"\")\r\n"
"		table.insert(chunk,\"		end\\n"
"\")\r\n"
"		table.insert(chunk,\"	end\\n"
"\")\r\n"
"		table.insert(chunk,\"end\\n"
"\")\r\n"
"		table.insert(chunk,\"_lo=0\\n"
"\")\r\n"
"		table.insert(chunk,\"local _out=function(...) for i,v in ipairs({...}) do _out_do(v) end end\\n"
"\")\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	table.insert(chunk,\"\\n"
"\")\r\n"
"	table.insert(chunk,\"_file='\"..filename..\"'\\n"
"\")\r\n"
"	table.insert(chunk,\"\\n"
"\")\r\n"
"\r\n"
"	line_num=1\r\n"
"	for line in file:lines() do\r\n"
"\r\n"
"		if lua_block_insert==false then\r\n"
"		\r\n"
"			table.insert(chunk, string.format('_l=%4d; ', line_num))\r\n"
"		end\r\n"
"		\r\n"
"		\r\n"
"		if string.find(line, \"^#%(\") then\r\n"
"		\r\n"
"			lua_block_insert=true\r\n"
"			table.insert(chunk, \"\\n"
"\")\r\n"
"			\r\n"
"		elseif string.find(line, \"^#%)\") then\r\n"
"		\r\n"
"			lua_block_insert=false\r\n"
"			table.insert(chunk, \"\\n"
"\")\r\n"
"			\r\n"
"		elseif string.find(line, \"^#dofile\") then\r\n"
"\r\n"
"			_,_,new_filename=string.find(line, \"^#dofile%s\\\"([%w%p]+)\\\"\")\r\n"
"\r\n"
"			new_filename=pp_input_cd..new_filename\r\n"
"\r\n"
"			table.insert(chunk, \"--Including \"..new_filename..\"\\n"
"\")\r\n"
"			\r\n"
"			local fp=io.open(new_filename,\"r\")\r\n"
"			local d=fp:read(\"*all\")\r\n"
"			table.insert(chunk,d)\r\n"
"\r\n"
"			table.insert(chunk,\"\\n"
"\")\r\n"
"			table.insert(chunk,\"_file='\"..filename..\"'\\n"
"\")\r\n"
"			table.insert(chunk,\"\\n"
"\")\r\n"
"\r\n"
"		elseif string.find(line, \"^#include\") then\r\n"
"\r\n"
"			_,_,new_filename=string.find(line, \"^#include%s\\\"([%w%p]+)\\\"\")\r\n"
"\r\n"
"			new_filename=pp_input_cd..new_filename\r\n"
"\r\n"
"			table.insert(chunk, \"--Including \"..new_filename..\"\\n"
"\")\r\n"
"\r\n"
"			ppload(new_filename,chunk)\r\n"
"\r\n"
"			table.insert(chunk,\"\\n"
"\")\r\n"
"			table.insert(chunk,\"_file='\"..filename..\"'\\n"
"\")\r\n"
"			table.insert(chunk,\"\\n"
"\")\r\n"
"\r\n"
"		elseif string.find(line, \"^#\") then\r\n"
"\r\n"
"			table.insert(chunk, string.sub(line, 2) .. \"\\n"
"\")\r\n"
"\r\n"
"		else\r\n"
"		\r\n"
"			if lua_block_insert then\r\n"
"			\r\n"
"				table.insert(chunk, line .. \"\\n"
"\")\r\n"
"			\r\n"
"			else\r\n"
"\r\n"
"			local last = 1\r\n"
"\r\n"
"				for text, expr, index in string.gfind(line, \"(.-)#(%b())()\") do \r\n"
"\r\n"
"					last = index\r\n"
"\r\n"
"					if text ~= \"\" then\r\n"
"\r\n"
"						table.insert(chunk, string.format('_out %q ', text))\r\n"
"\r\n"
"					end\r\n"
"\r\n"
"					table.insert(chunk, string.format('_out%s ', expr))\r\n"
"\r\n"
"				end\r\n"
"\r\n"
"-- gsub to remove ugly line ends and replace with \\n"
" to make file more readable\r\n"
"temp=string.gsub(string.sub(line, last),\"\\n"
"\",\"\\\\n"
"\")\r\n"
"temp=string.gsub(temp,\"\\r\",\"\")\r\n"
"temp=string.format('_out %q\\n"
"',temp..\"\\n"
"\")\r\n"
"\r\n"
"				table.insert(chunk, temp)\r\n"
"				\r\n"
"			end\r\n"
"\r\n"
"		end\r\n"
"\r\n"
"		line_num=line_num+1\r\n"
"	end\r\n"
"\r\n"
"	file:close()\r\n"
"\r\n"
"	if not included then\r\n"
"	\r\n"
"		table.insert(chunk,\"\\n"
"return pp_output_table\\n"
"\")\r\n"
"	end\r\n"
"\r\n"
"  return chunk\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function loadsave(fname_in,fname_out)\r\n"
"\r\n"
"pp_input_cd=\"\"\r\n"
"\r\n"
"\r\n"
"pp_input_table={}\r\n"
"pp_input_string=\"\"\r\n"
"pp_input_lua=function() end\r\n"
"\r\n"
"pp_output_table={}\r\n"
"pp_output_string=\"\"\r\n"
"\r\n"
"\r\n"
"\r\n"
"print ( \"Lua pre processing \" .. fname_in .. \" into \" .. fname_out .. \"\" )\r\n"
"\r\n"
"\r\n"
"-- create input table, and its string\r\n"
"\r\n"
"pp_input_table=ppload(fname_in)\r\n"
"\r\n"
"pp_input_string=table.concat(pp_input_table)\r\n"
"\r\n"
"\r\n"
"-- output the lua program string to a file along with the output to aid with debuging,\r\n"
"-- any lua errors will hopefully be more meaningfull this way\r\n"
"\r\n"
"\r\n"
"--[[\r\n"
"local fp\r\n"
"	fp=io.open(fname_out..\".lua\",\"w\")\r\n"
"	fp:write(pp_input_string)\r\n"
"	fp:close()\r\n"
"	fp=null\r\n"
"\r\n"
"-- load that string back in and run it to produce an output table\r\n"
"pp_input_lua,_msg=loadfile(fname_out..\".lua\")\r\n"
"]]\r\n"
"\r\n"
"\r\n"
"pp_input_lua,_msg=loadstring(pp_input_string)\r\n"
"\r\n"
"\r\n"
"assert(pp_input_lua,\".\\n"
".\\n"
"\"..( _msg or \"\" )..\"\\n"
".\\n"
".\\n"
"\")\r\n"
"\r\n"
"local newfenv = {}        -- create new environment just for this file\r\n"
"setmetatable(newfenv, {__index = up_G}) -- allow global access we are not trying to sandbox\r\n"
"setfenv(pp_input_lua, newfenv)    -- change this functions environment from the global one\r\n"
"\r\n"
"\r\n"
"local ret,_msg,_ret\r\n"
"\r\n"
"\r\n"
"	_lo_break=null\r\n"
"	\r\n"
"	ret,_ret=pcall(pp_input_lua)	-- not sure about scope here...\r\n"
"			\r\n"
"\r\n"
"	if ret~=true then\r\n"
"\r\n"
"		print('.\\n"
".\\n"
"')\r\n"
"		print(string.format('%s(%d):PP file location\\n"
"',_file or \"unknown\",_l or -1))\r\n"
"		assert(null,_ret..'\\n"
".\\n"
".\\n"
"')\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"-- write that table out as a string to the destination file\r\n"
"\r\n"
"\r\n"
"pp_output_string=table.concat(_ret)\r\n"
"\r\n"
"local fp\r\n"
"	fp=io.open(fname_out,\"w\")\r\n"
"	fp:write(pp_output_string)\r\n"
"	fp:close()\r\n"
"	fp=null\r\n"
"\r\n"
"end\r\n"
"\r\n"
"",

"fenestra.widget.textedit","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"-- widget class string\r\n"
"-- a one line string buffer that can be edited\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.textedit\")\r\n"
"\r\n"
"local widget_data=require(\"fenestra.widget.data\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"\r\n"
"--	local it=widget.string\r\n"
"\r\n"
"-- call here so we can use any state changes immediatly	\r\n"
"	local ret=widget.meta.mouse(widget,act,x,y,key)\r\n"
"	\r\n"
"	if widget.master.active==widget then\r\n"
"	\r\n"
"		widget.master.focus=widget\r\n"
"		\r\n"
"		if act==\"down\" then\r\n"
"			local dx=x-((widget.pxd or 0)+(widget.text_x or 0))\r\n"
"--print(dx)\r\n"
"			if dx<0 then -- catch lessthan\r\n"
"				widget.data.str_idx=0\r\n"
"			else\r\n"
"				widget.data.str_idx=widget.master.font.which(dx,widget.data.str)\r\n"
"				if widget.data.str_idx<0 then widget.data.str_idx=#widget.data.str end -- catch morethan\r\n"
"			end\r\n"
"\r\n"
"			widget.master.throb=255\r\n"
"			widget:set_dirty()\r\n"
"\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	return ret\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"--	local it=widget.string\r\n"
"	local master=widget.master\r\n"
"	\r\n"
"	local changed=false\r\n"
"\r\n"
"--print(\"gotkey\",ascii)\r\n"
"	\r\n"
"	if act==\"down\" or act==\"repeat\" then\r\n"
"	\r\n"
"		if key==\"left\" then\r\n"
"\r\n"
"			widget.data.str_idx=widget.data.str_idx-1\r\n"
"			if widget.data.str_idx<0 then widget.data.str_idx=0 end\r\n"
"			\r\n"
"			master.throb=255\r\n"
"			changed=true\r\n"
"						\r\n"
"		elseif key==\"right\" then\r\n"
"	\r\n"
"			widget.data.str_idx=widget.data.str_idx+1\r\n"
"			if widget.data.str_idx>#widget.data.str then widget.data.str_idx=#widget.data.str end\r\n"
"			\r\n"
"			master.throb=255\r\n"
"			changed=true\r\n"
"			\r\n"
"		elseif key==\"home\" then\r\n"
"		\r\n"
"			widget.data.str_idx=0\r\n"
"			changed=true\r\n"
"		\r\n"
"		elseif key==\"end\" then\r\n"
"		\r\n"
"			widget.data.str_idx=#widget.data.str\r\n"
"			changed=true\r\n"
"		\r\n"
"		elseif key==\"backspace\" then\r\n"
"	\r\n"
"			if widget.data.str_idx >= #widget.data.str then -- at end\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(1,-2)\r\n"
"				widget.data.str_idx=#widget.data.str\r\n"
"				\r\n"
"				changed=true\r\n"
"			\r\n"
"			elseif widget.data.str_idx < 1 then -- at start\r\n"
"			\r\n"
"			elseif widget.data.str_idx == 1 then -- near start\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(2)\r\n"
"				widget.data.str_idx=widget.data.str_idx-1\r\n"
"			\r\n"
"				changed=true\r\n"
"\r\n"
"			else -- somewhere in the line\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(1,widget.data.str_idx-1) .. widget.data.str:sub(widget.data.str_idx+1)\r\n"
"				widget.data.str_idx=widget.data.str_idx-1\r\n"
"				\r\n"
"				changed=true\r\n"
"\r\n"
"			end\r\n"
"			\r\n"
"			master.throb=255\r\n"
"			\r\n"
"		elseif key==\"delete\" then\r\n"
"	\r\n"
"			if widget.data.str_idx >= #widget.data.str then -- at end\r\n"
"			\r\n"
"			elseif widget.data.str_idx < 1 then -- at start\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(2)\r\n"
"				widget.data.str_idx=0\r\n"
"			\r\n"
"				changed=true\r\n"
"\r\n"
"			else -- somewhere in the line\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(1,widget.data.str_idx) .. widget.data.str:sub(widget.data.str_idx+2)\r\n"
"				widget.data.str_idx=widget.data.str_idx\r\n"
"				\r\n"
"				changed=true\r\n"
"\r\n"
"			end\r\n"
"			\r\n"
"			master.throb=255\r\n"
"			\r\n"
"		elseif key==\"enter\" or key==\"return\" then\r\n"
"		\r\n"
"			if act==\"down\" then -- ignore repeats on enter key\r\n"
"			\r\n"
"				if widget.data.str and widget.onenter then -- callback?\r\n"
"				\r\n"
"					widget:call_hook(\"click\")\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"				changed=true\r\n"
"			end\r\n"
"			\r\n"
"--		elseif key==\"up\" then\r\n"
"--		elseif key==\"down\" then\r\n"
"		\r\n"
"		elseif ascii~=\"\" then -- not a blank string\r\n"
"			local c=string.byte(ascii)\r\n"
"			\r\n"
"			if c>=32 and c<128 then\r\n"
"			\r\n"
"				if widget.data.str_idx >= #widget.data.str then -- put at end\r\n"
"				\r\n"
"					widget.data.str=widget.data.str..ascii\r\n"
"					widget.data.str_idx=#widget.data.str\r\n"
"					\r\n"
"				elseif widget.data.str_idx < 1 then -- put at start\r\n"
"				\r\n"
"					widget.data.str=ascii..widget.data.str\r\n"
"					widget.data.str_idx=1\r\n"
"					\r\n"
"				else -- need to insert into line\r\n"
"				\r\n"
"					widget.data.str=widget.data.str:sub(1,widget.data.str_idx) .. ascii .. widget.data.str:sub(widget.data.str_idx+1)\r\n"
"					widget.data.str_idx=widget.data.str_idx+1\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"				master.throb=255\r\n"
"				\r\n"
"				changed=true\r\n"
"\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	if changed then\r\n"
"		widget.text=widget.data.str\r\n"
"		\r\n"
"		widget:call_hook(\"update\")\r\n"
"		widget:set_dirty()\r\n"
"	end\r\n"
"	\r\n"
"	return true\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"\r\n"
"	if widget.text ~= widget.data.str then\r\n"
"		widget.text = widget.data.str\r\n"
"		widget:set_dirty()\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.string=it\r\n"
"	widget.class=\"textedit\"\r\n"
"	\r\n"
"	widget.data=widget.data or widget_data.new_data({})\r\n"
"	\r\n"
"--	widget.data.str=\"\"\r\n"
"--	widget.data.str_idx=0\r\n"
"	\r\n"
"--	widget.key=key\r\n"
"	widget.update=update\r\n"
"\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"",

"swordstone","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local dbg=dbg or function()end\n"
"\n"
"\n"
"module(...)\n"
"\n"
"\n"
"local includes={\n"
"	\"swordstone.items\",\n"
"	\"swordstone.maps\",\n"
"	\"swordstone.levels\",\n"
"	\"swordstone.levels_test\",\n"
"}\n"
"\n"
"function setup()\n"
"\n"
"	for i,v in ipairs(includes) do\n"
"		require(v).setup()\n"
"	end\n"
"\n"
"end\n"
"",

"wetgenes.www.gae.fetch","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local core=require(\"wetgenes.www.gae.fetch.core\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.fetch\"]=_M\n"
"\n"
"function countzero()\n"
"	count=0\n"
"	api_time=0\n"
"end\n"
"countzero()\n"
"\n"
"local kind_props={}	-- default global props mapped to kinds\n"
"\n"
"local start_time -- handle simple api benchmarking of some calls\n"
"local function apis()\n"
"	start_time=os.time()\n"
"end\n"
"local function apie(...)\n"
"	api_time=api_time+os.time()-start_time\n"
"	return ...\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"function get(...)\n"
"	apis()\n"
"	count=count+1\n"
"	return apie(core.get(...))\n"
"end\n"
"\n"
"\n"
"\n"
"function post(...)\n"
"	apis()\n"
"	count=count+1\n"
"	return apie(core.post(...))\n"
"end\n"
"",

"yarn.fight","\n"
"-- a monter or player or any other character, really just a slightly more active item\n"
"-- these are items that need to update as time passes\n"
"\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local dbg=dbg or function()end\n"
"\n"
"\n"
"--[[\n"
"\n"
"air  evade water smother fire  burn   earth absorb  meta control\n"
"\n"
"fire burn  air   evade   earth absorb water smother meta control\n"
"\n"
"     air\n"
"     / \\\n"
"fire     earth\n"
"    |   |\n"
"meta  -  water\n"
"\n"
"\n"
"\n"
"wheel values, 0 to 1 where 0 and 1 are the same value\n"
"\n"
"these are compared and produce a relative wheel value that goes\n"
"\n"
"	0.5\n"
"	\n"
"0		1\n"
"	\n"
"	0.5\n"
"\n"
"\n"
"\n"
"earth=0.0	-- absorbs\n"
"fire =0.2	-- burns\n"
"water=0.4	-- smothers\n"
"air  =0.6   -- evades\n"
"magic=0.8   -- controls\n"
"\n"
"stone   =0.000\n"
"paper   =0.333\n"
"scissors=0.666\n"
"\n"
"so\n"
"\n"
"	\n"
"0.5 + (((a-b)*2)%1)\n"
"\n"
"kinda ish\n"
"\n"
"]]\n"
"\n"
"\n"
"\n"
"module(...)\n"
"\n"
"--\n"
"-- get the amount of damage, done by this char with their currently welded weapon\n"
"--\n"
"-- weapon will have a min-max damage amount we randoml pick an integer between these two numbers\n"
"--\n"
"function get_damage_char(c)\n"
"\n"
"	local mn,mx=get_dam(c)\n"
"	local num=0\n"
"	\n"
"	if mx<=mn then\n"
"		num=mn\n"
"	else\n"
"		num=math.random(mn,mx)\n"
"	end\n"
"	\n"
"	return math.floor(num)\n"
"end\n"
"\n"
"function get_dam(c)\n"
"\n"
"	local mn=c.is.dam_min\n"
"	local mx=c.is.dam_max\n"
"	\n"
"	if c.items then -- equipment\n"
"		for v,b in pairs(c.items) do\n"
"			if v.equiped and v.is.dam_min and v.is.dam_max then\n"
"				mn=mn+v.is.dam_min\n"
"				mx=mx+v.is.dam_max\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	return mn,mx\n"
"end\n"
"\n"
"function get_def(c)\n"
"\n"
"	local ma=c.is.def_add\n"
"	local mm=c.is.def_mul\n"
"	\n"
"	if c.items then -- equipment\n"
"		for v,b in pairs(c.items) do\n"
"			if v.equiped and v.is.def_add and v.is.def_mul then\n"
"				ma=ma+v.is.def_add\n"
"				mm=mm*v.is.def_mul\n"
"			end\n"
"		end\n"
"	end\n"
"	return ma,mm\n"
"	\n"
"end\n"
"\n"
"--\n"
"-- adjust the damage by this chars defense abilities, return the new damage number\n"
"--\n"
"function adjust_defense_char(c,damage)\n"
"\n"
"	local ma,mm=get_def(c)\n"
"\n"
"	damage=(damage+ma)*mm\n"
"	\n"
"	return math.floor(damage)\n"
"	\n"
"end\n"
"\n"
"\n"
"--\n"
"-- c1 hits c2 with the weapon in hand\n"
"--\n"
"-- adjust hitpoints trigger events etc etc\n"
"--\n"
"function hit(c1,c2)\n"
"\n"
"	local damage=get_damage_char(c1)\n"
"	\n"
"	damage=adjust_defense_char(c2,damage)\n"
"	\n"
"	local hp=c2.hp\n"
"\n"
"dbg(c2.name..\" hp : \"..c2.hp)\n"
"	\n"
"	hp=hp-damage\n"
"	\n"
"	if hp<=0 then -- dead\n"
"		\n"
"	\n"
"		if c1.is.player then\n"
"		\n"
"			c1.level.add_msg(\"You hit for \"..damage..\" damage!\")\n"
"			c1.level.add_msg(\"You killed \"..(c2.is.desc)..\".\")--\" and won \"..c2.is.score..\" points!\")\n"
"--			c1.is.score=c1.is.score+c2.is.score\n"
"			\n"
"		elseif c2.is.player then\n"
"\n"
"			c1.level.add_msg(\"You took \"..damage..\" damage from \"..(c1.is.desc)..\" and died!\")\n"
"			\n"
"		end\n"
"		\n"
"		c2.hp=0\n"
"		c2.die()\n"
"	\n"
"	else -- just hit\n"
"	\n"
"		c2.hp=hp\n"
"		\n"
"		if c1.is.player then\n"
"		\n"
"			c1.level.add_msg(\"You hit for \"..damage..\" damage!\")\n"
"			\n"
"		elseif c2.is.player then\n"
"\n"
"			c1.level.add_msg(\"You took \"..damage..\" damage from \"..(c1.is.desc)..\" and now have \"..c2.hp..\" health!\")\n"
"			\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"end\n"
"\n"
"--\n"
"-- restore some hitpoints for c1\n"
"--\n"
"-- adjust hitpoints trigger events etc etc\n"
"--\n"
"function heal(c1,n)\n"
"\n"
"	c1.hp=c1.hp+n\n"
"	\n"
"	if c1.hp>c1.is.hp then c1.hp=c1.is.hp end\n"
"	\n"
"end\n"
"",

"fenestra.wrap","\r\n"
"\r\n"
"local print=print\r\n"
"\r\n"
"local core = require(\"fenestra.core\")\r\n"
"local console = require(\"fenestra.console\")\r\n"
"local data = require(\"fenestra.data\")\r\n"
"local avatar = require(\"fenestra.avatar\")\r\n"
"local font = require(\"fenestra.font\")\r\n"
"local widget = require(\"fenestra.widget\")\r\n"
"\r\n"
"local gl=require(\"gl\")\r\n"
"\r\n"
"module(\"fenestra.wrap\")\r\n"
"\r\n"
"--\r\n"
"-- Call win to get a unique table full of functions associated\r\n"
"-- with lots of tasty up values for easy use\r\n"
"--\r\n"
"-- local win=require(\"fenestra.wrap\").win()\r\n"
"--\r\n"
"function win(opts)\r\n"
"opts=opts or {}\r\n"
"\r\n"
"local win={}\r\n"
"\r\n"
"	function win.setup(g)\r\n"
"	\r\n"
"		win._g=g -- the global table\r\n"
"		win.into_hwnd=opts.into_hwnd\r\n"
"\r\n"
"-- open window of this height		\r\n"
"		win.width=opts.width\r\n"
"		win.height=opts.height\r\n"
"\r\n"
"		win.core = core.setup(win)\r\n"
"		\r\n"
"		win.core_data = core.data.setup(win.core)\r\n"
"		\r\n"
"		win.data = data.setup(win)\r\n"
"		\r\n"
"		win.core_ogl = core.ogl.setup(win.core)\r\n"
"		\r\n"
"		win.console = console.setup(win)		\r\n"
"		win.restore_print=win.console.replace_print(g)\r\n"
"		\r\n"
"		win.avatar = avatar.setup(win)\r\n"
"		\r\n"
"		win.font_base=font.setup(win,\"base\")\r\n"
"		win.font_sans=font.setup(win,\"sans\")\r\n"
"		win.font_debug=win.font_base -- old name, do not use...\r\n"
"		\r\n"
"		win.widget=widget.setup(win,{font=win.font_sans})\r\n"
"		\r\n"
"		return win\r\n"
"	end\r\n"
"\r\n"
"	function win.clean()\r\n"
"		\r\n"
"		win.widget.clean()\r\n"
"		\r\n"
"		win.font_sans.clean()\r\n"
"		win.font_base.clean()\r\n"
"\r\n"
"		win.avatar.clean()\r\n"
"		\r\n"
"		win.restore_print()\r\n"
"		win.console.clean()\r\n"
"		\r\n"
"		core.ogl.clean(win.core_ogl)\r\n"
"		\r\n"
"		win.data.clean()\r\n"
"		\r\n"
"		core.data.clean(win.core_data)\r\n"
"		\r\n"
"		core.clean(win.core)\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	function win.xox(xox_info)\r\n"
"\r\n"
"		local core=win.xox_setup(xox_info)\r\n"
"		local xox=win.xox_get(core)\r\n"
"		xox.info=xox_info\r\n"
"		xox.core=core\r\n"
"		\r\n"
"		function xox.clean()\r\n"
"			return win.xox_clean(core)\r\n"
"		end\r\n"
"		\r\n"
"		function xox.draw()\r\n"
"			return win.xox_draw(core)\r\n"
"		end\r\n"
"\r\n"
"		function xox.set()\r\n"
"			return win.xox_set(core,xox)\r\n"
"		end\r\n"
"		\r\n"
"		return xox\r\n"
"	end\r\n"
"	\r\n"
"	function win.xsx(xsx_info)\r\n"
"\r\n"
"		local core=win.xsx_setup(xsx_info)\r\n"
"		local xsx=win.xsx_get(core)\r\n"
"		xsx.info=xsx_info\r\n"
"		xsx.core=core\r\n"
"		\r\n"
"		function xsx.clean()\r\n"
"			return win.xsx_clean(core)\r\n"
"		end\r\n"
"		\r\n"
"		function xsx.draw(f)\r\n"
"			return win.xsx_draw(core,f)\r\n"
"		end\r\n"
"		\r\n"
"		function xsx.set()\r\n"
"			return win.xsx_set(core,xsx)\r\n"
"		end\r\n"
"		\r\n"
"		return xsx\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"	function win.fbo(width,height,depth)\r\n"
"	\r\n"
"		depth=depth or 0\r\n"
"		\r\n"
"		local core=win.fbo_setup(width,height,depth)\r\n"
"		local fbo={}\r\n"
"		fbo.core=core\r\n"
"		fbo.width=width\r\n"
"		fbo.height=height\r\n"
"		fbo.depth=depth\r\n"
"		\r\n"
"		function fbo.clean(fbo)\r\n"
"			return win.fbo_clean(core)\r\n"
"		end\r\n"
"		\r\n"
"		function fbo.bind(fbo)\r\n"
"			return win.fbo_bind(core)\r\n"
"		end\r\n"
"\r\n"
"		function fbo.texture(fbo)\r\n"
"			return win.fbo_texture(core)\r\n"
"		end\r\n"
"\r\n"
"		function fbo.draw(fbo)\r\n"
"			win.fbo_texture(core)\r\n"
"			gl.Disable(gl.CULL_FACE)\r\n"
"			gl.Enable(gl.TEXTURE_2D)\r\n"
"			gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR)\r\n"
"			gl.BlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA) --fbo has premultipliedalpha\r\n"
"			gl.Begin(gl.QUADS)\r\n"
"				gl.Color({1,1,1,1})\r\n"
"				gl.TexCoord(0, 0) gl.Vertex(fbo.width*-0.5, fbo.height*-0.5)\r\n"
"				gl.TexCoord(1, 0) gl.Vertex(fbo.width* 0.5, fbo.height*-0.5)\r\n"
"				gl.TexCoord(1, 1) gl.Vertex(fbo.width* 0.5, fbo.height* 0.5)\r\n"
"				gl.TexCoord(0, 1) gl.Vertex(fbo.width*-0.5, fbo.height* 0.5)\r\n"
"			gl.End()\r\n"
"		end\r\n"
"\r\n"
"		return fbo\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	function win.tex(grd) -- this takes a texture copy of the given grd\r\n"
"	\r\n"
"		local core=win.tex_setup(grd)\r\n"
"		local tex={}\r\n"
"		tex.core=core\r\n"
"		tex.width=grd.width\r\n"
"		tex.height=grd.height\r\n"
"		tex.depth=grd.depth\r\n"
"		\r\n"
"		grd=nil -- do not keep any references\r\n"
"		\r\n"
"		function tex.clean(tex)\r\n"
"			return win.tex_clean(core)\r\n"
"		end\r\n"
"		\r\n"
"		function tex.bind(tex)\r\n"
"			return win.tex_bind(core)\r\n"
"		end\r\n"
"\r\n"
"		function tex.draw(tex)\r\n"
"			win.tex_bind(core)\r\n"
"			gl.Disable(gl.CULL_FACE)\r\n"
"			gl.Enable(gl.TEXTURE_2D)\r\n"
"			gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR)\r\n"
"			gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)\r\n"
"			gl.Begin(gl.QUADS)\r\n"
"				gl.Color({1,1,1,1})\r\n"
"				gl.TexCoord(0, 0) gl.Vertex(tex.width*-0.5, tex.height* 0.5)\r\n"
"				gl.TexCoord(1, 0) gl.Vertex(tex.width* 0.5, tex.height* 0.5)\r\n"
"				gl.TexCoord(1, 1) gl.Vertex(tex.width* 0.5, tex.height*-0.5)\r\n"
"				gl.TexCoord(0, 1) gl.Vertex(tex.width*-0.5, tex.height*-0.5)\r\n"
"			gl.End()\r\n"
"		end\r\n"
"\r\n"
"		return tex\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	\r\n"
"-- return window x,y pos transformed into the viewspace of project23d if you provided h/w to that function\r\n"
"	function win.mouse23d(w,h,x,y)\r\n"
"	\r\n"
"		local hx=win.width/2\r\n"
"		local hy=win.height/2\r\n"
"\r\n"
"		local tx,ty\r\n"
"		\r\n"
"		if win.height/(win.width or 1) > (h/w) then -- deal with new \"smart\" viewport sizeing\r\n"
"		\r\n"
"			tx=(w/ 2)*(x-hx)/hx\r\n"
"			ty=(w/-2)*(hy-y)/hx\r\n"
"			\r\n"
"		else\r\n"
"		\r\n"
"			tx=(h/ 2)*(x-hx)/hy\r\n"
"			ty=(h/-2)*(hy-y)/hy\r\n"
"\r\n"
"		end\r\n"
"\r\n"
"		return tx,ty\r\n"
"	end\r\n"
"\r\n"
"function win.choose_file(...)			return core.choose_file(				win.core,		...) end\r\n"
"\r\n"
"-- default key and mouse functions just send data to the debug console	\r\n"
"function win.keypress(...)				return win.console.keypress(							...) end\r\n"
"function win.mouse(...)					return win.console.mouse(								...) end\r\n"
"\r\n"
"function win.msg(...)					return core.msg(						win.core,		...) end\r\n"
"function win.time(...)					return core.time(						win.core,		...) end\r\n"
"\r\n"
"function win.getwin(...)				return core.getwin(						win.core,		...) end\r\n"
"function win.setwin(...)				return core.setwin(						win.core,		...) end\r\n"
"\r\n"
"function win.get(...)					return core.ogl.get(					win.core_ogl,	...) end\r\n"
"function win.set(...)					return core.ogl.set(					win.core_ogl,	...) end\r\n"
"function win.begin(...)					return core.ogl.begin(					win.core_ogl,	...) end\r\n"
"function win.clip2d(...)				return core.ogl.clip2d(					win.core_ogl,	...) end\r\n"
"function win.project23d(...)			return core.ogl.project23d(				win.core_ogl,	...) end\r\n"
"function win.swap(...)					return core.ogl.swap(					win.core_ogl,	...) end\r\n"
"\r\n"
"function win.target(...)				return core.ogl.target(					win.core_ogl,	...) end\r\n"
"function win.readpixels(...)			return core.ogl.readpixels(				win.core_ogl,	...) end\r\n"
"\r\n"
"\r\n"
"function win.debug_begin(...)			return core.ogl.debug_begin(			win.core_ogl,	...) end\r\n"
"function win.debug_end(...)				return core.ogl.debug_end(				win.core_ogl,	...) end\r\n"
"function win.debug_print(...)			return core.ogl.debug_print(			win.core_ogl,	...) end\r\n"
"function win.debug_print_alt(...)		return core.ogl.debug_print_alt(		win.core_ogl,	...) end\r\n"
"function win.debug_rect(...)			return core.ogl.debug_rect(				win.core_ogl,	...) end\r\n"
"function win.debug_polygon_begin(...)	return core.ogl.debug_polygon_begin(	win.core_ogl,	...) end\r\n"
"function win.debug_polygon_vertex(...)	return core.ogl.debug_polygon_vertex(	win.core_ogl,	...) end\r\n"
"function win.debug_polygon_end(...)		return core.ogl.debug_polygon_end(		win.core_ogl,	...) end\r\n"
"\r\n"
"\r\n"
"function win.flat_begin(...)			return core.ogl.flat_begin(				win.core_ogl,	...) end\r\n"
"function win.flat_end(...)				return core.ogl.flat_end(				win.core_ogl,	...) end\r\n"
"function win.flat_font(...)				return core.ogl.flat_font(				win.core_ogl,	...) end\r\n"
"function win.flat_print(...)			return core.ogl.flat_print(				win.core_ogl,	...) end\r\n"
"function win.flat_measure(...)			return core.ogl.flat_measure(			win.core_ogl,	...) end\r\n"
"function win.flat_which(...)			return core.ogl.flat_which(				win.core_ogl,	...) end\r\n"
"function win.flat_fits(...)				return core.ogl.flat_fits(				win.core_ogl,	...) end\r\n"
"function win.flat_rect(...)				return core.ogl.debug_rect(				win.core_ogl,	...) end\r\n"
"function win.flat_polygon_begin(...)	return core.ogl.debug_polygon_begin(	win.core_ogl,	...) end\r\n"
"function win.flat_polygon_vertex(...)	return core.ogl.debug_polygon_vertex(	win.core_ogl,	...) end\r\n"
"function win.flat_polygon_end(...)		return core.ogl.debug_polygon_end(		win.core_ogl,	...) end\r\n"
"\r\n"
"\r\n"
"function win.draw_cube(...)				return core.ogl.draw_cube(				win.core_ogl,	...) end\r\n"
"\r\n"
"function win.xox_setup(...)				return core.ogl.xox_setup(				win.core_ogl,	...) end\r\n"
"function win.xox_clean(...)				return core.ogl.xox_clean(				win.core_ogl,	...) end\r\n"
"function win.xox_draw(...)				return core.ogl.xox_draw(				win.core_ogl,	...) end\r\n"
"function win.xox_get(...)				return core.ogl.xox_get(				win.core_ogl,	...) end\r\n"
"function win.xox_set(...)				return core.ogl.xox_set(				win.core_ogl,	...) end\r\n"
"\r\n"
"function win.xsx_setup(...)				return core.ogl.xsx_setup(				win.core_ogl,	...) end\r\n"
"function win.xsx_clean(...)				return core.ogl.xsx_clean(				win.core_ogl,	...) end\r\n"
"function win.xsx_draw(...)				return core.ogl.xsx_draw(				win.core_ogl,	...) end\r\n"
"function win.xsx_get(...)				return core.ogl.xsx_get(				win.core_ogl,	...) end\r\n"
"function win.xsx_set(...)				return core.ogl.xsx_set(				win.core_ogl,	...) end\r\n"
"\r\n"
"function win.fbo_setup(...)				return core.ogl.fbo_setup(				win.core_ogl,	...) end\r\n"
"function win.fbo_clean(...)				return core.ogl.fbo_clean(				win.core_ogl,	...) end\r\n"
"function win.fbo_bind(...)				return core.ogl.fbo_bind(				win.core_ogl,	...) end\r\n"
"function win.fbo_texture(...)			return core.ogl.fbo_texture(			win.core_ogl,	...) end\r\n"
"\r\n"
"function win.tex_setup(...)				return core.ogl.tex_setup(				win.core_ogl,	...) end\r\n"
"function win.tex_clean(...)				return core.ogl.tex_clean(				win.core_ogl,	...) end\r\n"
"function win.tex_bind(...)				return core.ogl.tex_bind(				win.core_ogl,	...) end\r\n"
"\r\n"
"function win.load(...)					return core.data.load(					win.core_data,	...) end\r\n"
"	\r\n"
"	return win\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.cgilua.session","--\r\n"
"-- Mysql helper functions\r\n"
"--\r\n"
"\r\n"
"require\"cgilua.cookies\"\r\n"
"\r\n"
"local sql=require(\"wetgenes.cgilua.mysql\")\r\n"
"\r\n"
"\r\n"
"local type,ipairs=type,ipairs\r\n"
"\r\n"
"local string=string\r\n"
"\r\n"
"local wet_html=require(\"wetgenes.html\")\r\n"
"\r\n"
"local cgi = wetgenes.cgilua or require(\"wetgenes.cgilua\")\r\n"
"local cfg = cfg\r\n"
"\r\n"
"\r\n"
"local cgilua=cgilua\r\n"
"\r\n"
"local dbg=dbg or function(s) cgilua.errorlog(s) end\r\n"
"\r\n"
"module(\"wetgenes.cgilua.session\")\r\n"
"\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- log in using a session\r\n"
"-- if need is set to true then redirect to a login page as a login is needed\r\n"
"--\r\n"
"-- pass in url of current page if needed, (escaping is icky)\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function login(need)\r\n"
"\r\n"
"local sess=cgilua.cookies.get(cfg.cookie_session)\r\n"
"\r\n"
"local redirect=\"http://join.wetgenes.\"..cfg.tld..\"/?redirect=\"..wet_html.url_esc(wet_html.url_esc(cgi.url_query))\r\n"
"\r\n"
"user={}\r\n"
"\r\n"
"\r\n"
"	if sess then\r\n"
"\r\n"
"		sess=string.gsub(sess, \"[^0-9a-zA-Z]+\", \"\" )\r\n"
"\r\n"
"\r\n"
"		local info=sql.execute([[SELECT\r\n"
"				u.alias, u.posts_ppg, u.time_zone, u.sig, u.last_visit, u.last_read, u.cat_collapse_status, u.users_opt,\r\n"
"				u.ignore_list, u.buddy_list, u.id, u.group_leader_list, u.email, u.login, u.sq, u.ban_expiry\r\n"
"				, u.avatar_loc , u.referer_id , s.time_sec , s.sys_id\r\n"
"			FROM ]]..cfg.mysql_prefix_fud..[[ses s\r\n"
"				INNER JOIN ]]..cfg.mysql_prefix_fud..[[users u ON u.id=(CASE WHEN s.user_id>2000000000 THEN 1 ELSE s.user_id END)\r\n"
"			WHERE ses_id=']]..sess..[[']])\r\n"
"\r\n"
"		local tab=sql.named(info,1)\r\n"
"\r\n"
"		if tab then -- session exists\r\n"
"		\r\n"
"			if cgi.ip==tab.sys_id then -- mild security fix, session is locked to ip\r\n"
"			\r\n"
"			\r\n"
"				user.fud=tab\r\n"
"				\r\n"
"				if tab.login==\"XIX\" or tab.login==\"shi\" then -- flag admin logins\r\n"
"					tab.admin=true\r\n"
"				end\r\n"
"			\r\n"
"--	dbg(\"success\")\r\n"
"	\r\n"
"			else\r\n"
"\r\n"
"				if need then\r\n"
"					cgi.redirect(redirect)\r\n"
"				end\r\n"
"--	dbg(\"fail bad ip \"..cgi.ip..\":\"..tab.sys_id)\r\n"
"\r\n"
"			end\r\n"
"			\r\n"
"			\r\n"
"		else -- user does not exist\r\n"
"		\r\n"
"--	dbg(\"fail bad sesson\")\r\n"
"			\r\n"
"			if need then\r\n"
"				cgi.redirect(redirect)\r\n"
"			end\r\n"
"			\r\n"
"		end\r\n"
"\r\n"
"	else\r\n"
"	\r\n"
"		if need then\r\n"
"			cgi.redirect(redirect)\r\n"
"		end\r\n"
"			\r\n"
"--	dbg(\"fail no session\")\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	return user\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"",

"fenestra.buffedit","\r\n"
"\r\n"
"\r\n"
"local require=require\r\n"
"\r\n"
"-- a 1 line buffer edit, how you display it is up to you\r\n"
"-- has a simple history, just pass in key presses\r\n"
"-- this is intended for commandline style editing\r\n"
"\r\n"
"module(\"fenestra.buffedit\")\r\n"
"\r\n"
"local string=require(\"string\")\r\n"
"local table=require(\"table\")\r\n"
"\r\n"
"\r\n"
"\r\n"
"function keypress(it,ascii,key,act)\r\n"
"	\r\n"
"	if act==\"down\" or act==\"repeat\" then\r\n"
"	\r\n"
"		if key==\"left\" then\r\n"
"\r\n"
"			it.line_idx=it.line_idx-1\r\n"
"			if it.line_idx<0 then it.line_idx=0 end\r\n"
"			\r\n"
"			it.throb=255\r\n"
"						\r\n"
"		elseif key==\"right\" then\r\n"
"	\r\n"
"			it.line_idx=it.line_idx+1\r\n"
"			if it.line_idx>#it.line then it.line_idx=#it.line end\r\n"
"			\r\n"
"			it.throb=255\r\n"
"			\r\n"
"		elseif key==\"home\" then\r\n"
"		\r\n"
"			it.line_idx=0\r\n"
"		\r\n"
"		elseif key==\"end\" then\r\n"
"		\r\n"
"			it.line_idx=#it.line\r\n"
"		\r\n"
"		elseif key==\"backspace\" then\r\n"
"	\r\n"
"			if it.line_idx >= #it.line then -- at end\r\n"
"			\r\n"
"				it.line=it.line:sub(1,-2)\r\n"
"				it.line_idx=#it.line\r\n"
"			\r\n"
"			elseif it.line_idx == 0 then -- at start\r\n"
"			\r\n"
"			elseif it.line_idx == 1 then -- near start\r\n"
"			\r\n"
"				it.line=it.line:sub(2)\r\n"
"				it.line_idx=it.line_idx-1\r\n"
"			\r\n"
"			else -- somewhere in the line\r\n"
"			\r\n"
"				it.line=it.line:sub(1,it.line_idx-1) .. it.line:sub(it.line_idx+1)\r\n"
"				it.line_idx=it.line_idx-1\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"			it.throb=255\r\n"
"			\r\n"
"		elseif key==\"delete\" then\r\n"
"	\r\n"
"			if it.line_idx >= #it.line then -- at end\r\n"
"			\r\n"
"\r\n"
"			elseif it.line_idx == 0 then -- at start\r\n"
"			\r\n"
"				it.line=it.line:sub(2)\r\n"
"				it.line_idx=0\r\n"
"			\r\n"
"			else -- somewhere in the line\r\n"
"			\r\n"
"				it.line=it.line:sub(1,it.line_idx) .. it.line:sub(it.line_idx+2)\r\n"
"				it.line_idx=it.line_idx\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"			it.throb=255\r\n"
"			\r\n"
"		elseif key==\"enter\" or key==\"return\" then\r\n"
"		\r\n"
"			if act==\"down\" then -- ignore repeats on enter key\r\n"
"			\r\n"
"				local f=it.line\r\n"
"--				fenestra._g.print(\">\"..f)\r\n"
"				\r\n"
"				table.insert(it.history,it.line)\r\n"
"				\r\n"
"				while #it.history > it.history_max do\r\n"
"					table.remove(it.history,1)\r\n"
"				end\r\n"
"		\r\n"
"				it.history_idx=#it.history+1\r\n"
"			\r\n"
"				it.line=\"\"\r\n"
"				it.line_idx=0\r\n"
"				\r\n"
"				if f and it.enter then -- callback?\r\n"
"				\r\n"
"					it:enter(f)\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"		elseif key==\"up\" then\r\n"
"		\r\n"
"			it.history_idx=it.history_idx-1\r\n"
"			if it.history_idx<0 then it.history_idx=#it.history end\r\n"
"			it.line=it.history[it.history_idx] or \"\"\r\n"
"			it.line_idx=#it.line\r\n"
"		\r\n"
"		elseif key==\"down\" then\r\n"
"		\r\n"
"			it.history_idx=it.history_idx+1\r\n"
"			if it.history_idx>#it.history then it.history_idx=0 end\r\n"
"			it.line=it.history[it.history_idx] or \"\"\r\n"
"			it.line_idx=#it.line\r\n"
"			\r\n"
"		elseif ascii~=\"\" then -- not a blank string\r\n"
"			local c=string.byte(ascii)\r\n"
"			\r\n"
"			if c>=32 and c<128 then\r\n"
"			\r\n"
"				if it.line_idx >= #it.line then -- put at end\r\n"
"				\r\n"
"					it.line=it.line..ascii\r\n"
"					it.line_idx=#it.line\r\n"
"					\r\n"
"				elseif it.line_idx == 0 then -- put at start\r\n"
"				\r\n"
"					it.line=ascii..it.line\r\n"
"					it.line_idx=it.line_idx+1\r\n"
"					\r\n"
"				else -- need to insert into line\r\n"
"				\r\n"
"					it.line=it.line:sub(1,it.line_idx) .. ascii .. it.line:sub(it.line_idx+1)\r\n"
"					it.line_idx=it.line_idx+1\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"				it.throb=255\r\n"
"				\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	return true\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(it)\r\n"
"\r\n"
"	it.throb=it.throb-4\r\n"
"	if it.throb<0 then it.throb=255 end\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function create()\r\n"
"\r\n"
"local it={}\r\n"
"\r\n"
"	it.history={}\r\n"
"	it.history_idx=0\r\n"
"	it.history_max=64\r\n"
"	it.line=\"\"\r\n"
"	it.line_idx=0\r\n"
"\r\n"
"	it.throb=255\r\n"
"	\r\n"
"	it.keypress=keypress\r\n"
"	it.update=update\r\n"
"\r\n"
"	return it\r\n"
"end\r\n"
"",

"yarn.menu","\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local dbg=dbg or function()end\n"
"\n"
"module(...)\n"
"local strings=require(\"yarn.strings\")\n"
"local yarn_level=require(\"yarn.level\")\n"
"local yarn_attrs=require(\"yarn.attrs\")\n"
"\n"
"local fight=require(\"yarn.fight\")\n"
"\n"
"\n"
"function create(t,up)\n"
"\n"
"local d={}\n"
"local us=d\n"
"setfenv(1,d)\n"
"\n"
"	stack={}\n"
"\n"
"	dirty=0\n"
"	cursor=0\n"
"	\n"
"	-- set a menu to display\n"
"	function show(top)\n"
"	\n"
"		if #stack>0 then\n"
"			stack[#stack].cursor=cursor -- remember cursor position\n"
"		end\n"
"\n"
"		stack[#stack+1]=top --push\n"
"		\n"
"		if top.call then top.call(top) end -- refresh\n"
"		\n"
"		display=top.display\n"
"		cursor=top.cursor or 1\n"
"		\n"
"		dirty=1\n"
"	end\n"
"	\n"
"	-- go back to the previous menu\n"
"	function back()\n"
"\n"
"		stack[#stack]=nil -- this was us\n"
"		\n"
"		if #stack==0 then return hide() end -- clear all menus\n"
"		\n"
"		local top=stack[#stack] -- pop up a menu\n"
"		\n"
"		if top.call then top.call(top) end -- refresh\n"
"		\n"
"		display=top.display\n"
"		cursor=top.cursor or 1\n"
"		\n"
"		dirty=1\n"
"	end\n"
"	\n"
"	-- stop showing all menus and clear the stack\n"
"\n"
"	function hide()\n"
"		stack={}\n"
"		display=nil\n"
"		dirty=1\n"
"	end\n"
"\n"
"\n"
"	function keypress(ascii,key,act)\n"
"		if not display then return end\n"
"		\n"
"		dirty=1\n"
"		\n"
"		local getmenuitem=function()\n"
"			local tab=display[ cursor ]		\n"
"			if tab and tab.tab then tab=tab.tab end -- use this data\n"
"			return tab\n"
"		end\n"
"\n"
"		local tab=getmenuitem()\n"
"		\n"
"		\n"
"		if act==\"down\" then\n"
"		\n"
"			if key==\"space\" or key==\"enter\"  or key==\"return\"  or key==\"kpenter\" or key==\" \" then\n"
"			\n"
"				if tab.call then -- do this\n"
"				\n"
"					tab.call( tab )\n"
"					\n"
"				else -- just back by default\n"
"				\n"
"					back()\n"
"				\n"
"				end\n"
"			\n"
"			elseif key==\"backspace\" then\n"
"			\n"
"				hide()\n"
"			\n"
"			elseif key==\"up\" then\n"
"			\n"
"				local cacheid=getmenuitem()\n"
"				repeat\n"
"					cursor=cursor-1\n"
"				until cursor<1 or getmenuitem()~=cacheid\n"
"				\n"
"				if cursor<1 then cursor=#display end --wrap\n"
"\n"
"				local cacheid=getmenuitem() -- move to top of item\n"
"				while cursor>0 and cacheid==getmenuitem() do\n"
"					cursor=cursor-1\n"
"				end\n"
"				cursor=cursor+1\n"
"\n"
"			\n"
"			elseif key==\"down\" then\n"
"				\n"
"				local cacheid=getmenuitem()\n"
"				repeat\n"
"					cursor=cursor+1\n"
"				until cursor>#display or getmenuitem()~=cacheid\n"
"				\n"
"				if cursor>#display then cursor=1 end --wrap\n"
"			\n"
"			end\n"
"		\n"
"		end\n"
"\n"
"		\n"
"		return true\n"
"	end\n"
"\n"
"\n"
"	-- display a menu\n"
"	function update()\n"
"	\n"
"		local t=dirty\n"
"		dirty=0\n"
"		\n"
"		return t\n"
"	end\n"
"	\n"
"	-- display a menu\n"
"	function draw()\n"
"\n"
"		if not display then return end\n"
"		\n"
"		local top=stack[#stack]\n"
"\n"
"		up.asc_draw_box(0,0,40,#display+4)\n"
"--		up.asc_draw_fill(0,#display+4,40,1)\n"
"		\n"
"		if top.title then\n"
"			local title=\" \"..(top.title:upper())..\" \"\n"
"			local wo2=math.floor(#title/2)\n"
"			up.asc_print(20-wo2,0,title)\n"
"		end\n"
"		\n"
"		for i,v in ipairs(display) do\n"
"			up.asc_print(2,i+1,v.s)\n"
"		end\n"
"		\n"
"		up.asc_print(1,cursor+1,\">\")\n"
"		\n"
"	end\n"
"\n"
"	-- build a requester\n"
"	function build_request(t)\n"
"	\n"
"-- t[1++].text is the main body of text, t[1++].use is a call back function if this is\n"
"-- selectable, if there is no callback then selecting that option just hides the menu\n"
"\n"
"		local lines={}\n"
"		local pos=1\n"
"		for id=1,#t do\n"
"			local ls=strings.smart_wrap(t[id].text,40-4)\n"
"			for i=1,#ls do lines[#lines+1]={s=ls[i],id=id,tab=t[id]} end\n"
"		end\n"
"		\n"
"		return lines\n"
"	end\n"
"\n"
"\n"
"	function show_player_menu(player)\n"
"		local top={}\n"
"		\n"
"		top.title=\"look around you\"\n"
"\n"
"		top.call=function(tab)\n"
"		\n"
"			local tab={}\n"
"			\n"
"	-- add cancel option\n"
"			tab[#tab+1]={\n"
"				text=[[..]],\n"
"				call=function(it)\n"
"					back()\n"
"				end\n"
"			}\n"
"			\n"
"	-- add equiped item option\n"
"			tab[#tab+1]={\n"
"				text=[[your tools]],\n"
"				call=function(it)\n"
"					show_tool_menu(player)\n"
"				end\n"
"			}\n"
"	-- add backpack option\n"
"			tab[#tab+1]={\n"
"				text=[[your loots]],\n"
"				call=function(it)\n"
"					show_loot_menu(player)\n"
"				end\n"
"			}\n"
"			\n"
"			local items={}\n"
"			for i,v in player.cell.neighboursplus() do\n"
"				for item,b in pairs(v.items) do\n"
"					items[#items+1]=item\n"
"				end				\n"
"			end\n"
"			\n"
"			for i,v in ipairs(items) do\n"
"				if v.can.acts or v.form==\"item\"then				\n"
"					tab[#tab+1]={\n"
"						text=v.desc_text(),\n"
"						call=function(it)\n"
"							show_item_menu(v)\n"
"						end\n"
"					}\n"
"				end\n"
"			end\n"
"			\n"
"\n"
"			top.display=build_request(tab)\n"
"		end\n"
"		\n"
"		show(top)\n"
"	end\n"
"\n"
"\n"
"	function show_tool_menu(player)\n"
"		local top={}\n"
"		\n"
"		top.title=\"your tools\"\n"
"		\n"
"		top.call=function(tab)\n"
"		\n"
"			local tab={}\n"
"			\n"
"-- add cancel option\n"
"			tab[#tab+1]={\n"
"				text=[[..]],\n"
"				call=function(it)\n"
"					back()\n"
"				end\n"
"			}\n"
"			\n"
"-- add status option\n"
"			tab[#tab+1]={\n"
"				text=\"your status ( \"..player.hp..\"/\"..player.is.hp..\" hp )\",\n"
"				call=function(it)\n"
"					show_status_menu(player)\n"
"				end\n"
"			}\n"
"			\n"
"			local items={}\n"
"			for v,b in pairs(player.items or {}) do\n"
"				if v.is.equiped then\n"
"					items[#items+1]=v\n"
"				end\n"
"			end\n"
"			\n"
"			table.sort(items,function(a,b) return a.name<b.name end)\n"
"			\n"
"			for i,v in ipairs(items) do\n"
"				if v.can.acts or v.form==\"item\"then				\n"
"					tab[#tab+1]={\n"
"						text=v.desc_text(),\n"
"						call=function(it)\n"
"							show_item_menu(v)\n"
"						end\n"
"					}\n"
"				end\n"
"			end\n"
"						\n"
"			top.display=build_request(tab)\n"
"		end\n"
"		\n"
"		show(top)\n"
"	end\n"
"\n"
"	function show_loot_menu(player)\n"
"		local top={}\n"
"		\n"
"		top.title=\"your loots\"\n"
"		\n"
"		top.call=function(tab)\n"
"		\n"
"			local tab={}\n"
"			\n"
"-- add cancel option\n"
"			tab[#tab+1]={\n"
"				text=[[..]],\n"
"				call=function(it)\n"
"					back()\n"
"				end\n"
"			}\n"
"			\n"
"			local items={}\n"
"			for v,b in pairs(player.items or {}) do\n"
"				if not v.is.equiped then\n"
"					items[#items+1]=v\n"
"				end\n"
"			end\n"
"			\n"
"			table.sort(items,function(a,b) return a.name<b.name end)\n"
"			\n"
"			for i,v in ipairs(items) do\n"
"				if v.can.acts or v.form==\"item\"then				\n"
"					tab[#tab+1]={\n"
"						text=v.desc_text(),\n"
"						call=function(it)\n"
"							show_item_menu(v)\n"
"						end\n"
"					}\n"
"				end\n"
"			end\n"
"\n"
"			top.display=build_request(tab)\n"
"		end\n"
"		\n"
"		show(top)\n"
"	end\n"
"\n"
"	function show_status_menu(item)\n"
"		local top={}\n"
"\n"
"		top.title=item.desc_text()\n"
"		\n"
"\n"
"\n"
"		top.call=function(tab)\n"
"		\n"
"			local tab={}\n"
"			local player=item.level.player\n"
"			\n"
"			local dam_min,dam_max=fight.get_dam(player)\n"
"			local def_add,def_mul=fight.get_def(player)\n"
"\n"
"			local ss={}\n"
"			ss[#ss+1]=player.hp..\"/\"..player.is.hp..\" hp\"		\n"
"			if (dam_min and dam_min~=0) or (dam_max and dam_max~=0) then\n"
"				ss[#ss+1]=\"\\n"
"\"\n"
"				ss[#ss+1]=\"damage \"..math.floor(dam_min)..\" to \"..math.floor(dam_max)..\"\\n"
"\"\n"
"			end\n"
"			if (def_add and def_add~=0) or (def_mul and def_mul~=1) then\n"
"				ss[#ss+1]=\"\\n"
"\"\n"
"				ss[#ss+1]=\"protection \"..math.floor(-def_add)..\" and \"..math.floor(100*(1-def_mul))..\"% damage\\n"
"\"\n"
"			end\n"
"			local s=table.concat(ss)\n"
"\n"
"	-- add cancel option\n"
"			tab[#tab+1]={\n"
"				text=[[..]],\n"
"				call=function(it)\n"
"					back()\n"
"				end\n"
"			}\n"
"-- add status option\n"
"			tab[#tab+1]={\n"
"				text=s,\n"
"				call=function(it)\n"
"					back()\n"
"				end\n"
"			}\n"
"			\n"
"			top.display=build_request(tab)\n"
"		end\n"
"		\n"
"		show(top)\n"
"	end\n"
"	\n"
"	function show_item_menu(item)\n"
"		local top={}\n"
"\n"
"		top.title=item.desc_text()\n"
"		\n"
"		top.call=function(tab)\n"
"		\n"
"			local tab={}\n"
"			local player=item.level.player\n"
"	-- add cancel option\n"
"			tab[#tab+1]={\n"
"				text=[[..]],\n"
"				call=function(it)\n"
"					back()\n"
"				end\n"
"			}\n"
"			\n"
"\n"
"			if type(item.can.acts)==\"function\" then\n"
"				local acts=item.can.acts(item,player)\n"
"				for i,v in ipairs(acts) do\n"
"					tab[#tab+1]={\n"
"						text=v,\n"
"						call=function(it)\n"
"							if type(item.can[v])==\"function\" then\n"
"								item.can[v](item,player)\n"
"							end\n"
"						end\n"
"					}\n"
"				end\n"
"			end\n"
"\n"
"			top.display=build_request(tab)\n"
"		end\n"
"		\n"
"		show(top)\n"
"	end\n"
"\n"
"	function show_stairs_menu(it,by)\n"
"		local main=it.level.main\n"
"		local top={}\n"
"\n"
"		local goto_level=function(name,pow)\n"
"		\n"
"			main.soul.last_stairs=it.name\n"
"dbg(\"saving stairs name : \"..it.name)\n"
"\n"
"			main.save()\n"
"			main.level.player.un_cell()\n"
"			main.level=main.level.destroy()\n"
"			main.level=yarn_level.create(yarn_attrs.get(name,pow,{xh=40,yh=28}),main)\n"
"			main.menu.hide()\n"
"\n"
"-- mark this new area as visited\n"
"			main.soul.visited=main.soul.visited or {}\n"
"			main.soul.visited[name]=main.soul.visited[name] or {}\n"
"			main.soul.visited[name][pow]=true\n"
"			\n"
"\n"
"		end\n"
"		\n"
"		top.title=it.desc_text()\n"
"		\n"
"		top.call=function(tab)\n"
"		\n"
"			local tab={}\n"
"			local player=it.level.player\n"
"	-- add cancel option\n"
"			tab[#tab+1]={\n"
"				text=[[..]],\n"
"				call=function(it)\n"
"					back()\n"
"				end\n"
"			}\n"
"\n"
"			tab[#tab+1]={\n"
"				text=\"town (0)\",\n"
"				call=function()\n"
"					goto_level(\"level.town\",0)\n"
"				end\n"
"			}\n"
"			\n"
"			for i=it.stairs_min,it.stairs_max do\n"
"			\n"
"				local show=false\n"
"				local lnam=\"level.\"..it.stairs\n"
"dbg(lnam)\n"
"dbg(main.level.name)\n"
"dbg(main.level.pow)\n"
"				if  ( main.soul.visited and\n"
"					main.soul.visited[lnam] ) then\n"
"					for i,v in pairs(main.soul.visited[lnam]) do\n"
"						dbg(tostring(i)..\" : \"..tostring(v))\n"
"					end\n"
"				end\n"
"				if i<=1 then show=true end -- first level is always available\n"
"				\n"
"				if main.level.name == lnam then\n"
"					if i<=main.level.pow+1 and i>=main.level.pow-1 then\n"
"						show=true -- one up/down 1 are always available\n"
"					end\n"
"				end\n"
"\n"
"				local level_info=yarn_attrs.get(\"level.\"..it.stairs,i) -- get base info about the level\n"
"\n"
"				if  ( main.soul.visited and\n"
"					main.soul.visited[lnam] and\n"
"					main.soul.visited[lnam][i] ) or level_info.best_score then\n"
"					show=true\n"
"				end\n"
"\n"
"				\n"
"				if show then\n"
"					if level_info.best_score then\n"
"						it.level.soul.best_score=it.level.soul.best_score or {}\n"
"						level_info.best_score=it.level.soul.best_score[\"level.\"..it.stairs..\".\"..i] or level_info.best_score\n"
"					end\n"
"					local name=strings.replace(level_info.desc,level_info)\n"
"					\n"
"					tab[#tab+1]={\n"
"						text=name,\n"
"						call=function()\n"
"							goto_level(\"level.\"..it.stairs,i)\n"
"						end\n"
"					}\n"
"				end\n"
"			end\n"
"			\n"
"			top.display=build_request(tab)\n"
"		end\n"
"		\n"
"		show(top)\n"
"	end\n"
"	\n"
"	function show_talk_menu(it,by,chatname)\n"
"		chatname=chatname or \"welcome\"\n"
"		local top={}\n"
"		local chat=it.chat[chatname]\n"
"		if not chat then return hide() end\n"
"		if type(chat)==\"function\" then chat=chat(it,by,chatname) end\n"
"		\n"
"		if chat.flag then\n"
"			it.level.is[chat.flag]=true\n"
"		end\n"
"		\n"
"		top.title=strings.replace(chat.title or it.desc_text(),it)\n"
"		\n"
"		top.call=function(tab)\n"
"		\n"
"			local tab={}\n"
"			local player=it.level.player\n"
"	-- add cancel option?\n"
"\n"
"			tab[#tab+1]={\n"
"				text=strings.trim(strings.replace(chat.text,it))..\"\\n"
"\\n"
"\", -- keep one blank line at end\n"
"				call=function()\n"
"					hide()\n"
"				end\n"
"			}\n"
"\n"
"			local cursor=#tab+1\n"
"			\n"
"			for i,v in ipairs(chat.says) do\n"
"				local t=type(v)\n"
"				local text,cal\n"
"				local showsay=true\n"
"				if t==\"string\" then\n"
"					text=\"\\\"\"..strings.replace(v,it)..\"\\\"\"\n"
"					cal=function() show_talk_menu(it,by,v) end\n"
"				elseif t==\"table\" then\n"
"					text=\"\\\"\"..strings.replace(v.text,it)..\"\\\"\"\n"
"					cal=function() show_talk_menu(it,by,v.say) end\n"
"					if v.test then\n"
"						if it.level.is[v.test] then\n"
"							showsay=true\n"
"						else\n"
"							showsay=false\n"
"						end\n"
"					end\n"
"				end\n"
"				if showsay then\n"
"					tab[#tab+1]={\n"
"						text=text,\n"
"						call=cal\n"
"					}\n"
"				end\n"
"			end\n"
"			\n"
"			top.display=build_request(tab)\n"
"			for i,v in ipairs(top.display) do\n"
"				if v.id==cursor then\n"
"					top.cursor=i\n"
"					break\n"
"				end\n"
"			end\n"
"		end\n"
"		\n"
"		show(top)\n"
"	end\n"
"	\n"
"	function show_text(title,display)\n"
"		local top={}\n"
"\n"
"		local tab={}\n"
"-- add cancel option\n"
"		tab[#tab+1]={\n"
"			text=[[..]],\n"
"			call=function(it)\n"
"				back()\n"
"			end\n"
"		}\n"
"			\n"
"		tab[#tab+1]={\n"
"			text=display,\n"
"			call=function(it)\n"
"				hide()\n"
"			end\n"
"		}\n"
"\n"
"		top.title=title\n"
"		top.display=build_request(tab)\n"
"		top.cursor=2\n"
"		\n"
"		show(top)		\n"
"	end\n"
"	\n"
"	return d\n"
"	\n"
"end\n"
"",

"yarn.room","\n"
"-- a local area of cells\n"
"\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"module(...)\n"
"local yarn_attr=require(\"yarn.attr\")\n"
"\n"
"\n"
"function create(t)\n"
"\n"
"local d={}\n"
"setfenv(1,d)\n"
"\n"
"	is=yarn_attr.create(t)\n"
"	metatable={__index=is}\n"
"	setmetatable(d,metatable)\n"
"\n"
"	level=t.level\n"
"	xp=t.xp or 0\n"
"	yp=t.yp or 0\n"
"	xh=t.xh or 0\n"
"	yh=t.yh or 0\n"
"	doors={} -- a cell->room table of links to bordering rooms\n"
"	\n"
"--	cellfind={} -- find cells in his room only?\n"
"--	celllist={}\n"
"	\n"
"-- point to this room from the cells we cover, only one room pointer per cell\n"
"\n"
"	for y=yp,yp+yh-1 do\n"
"		for x=xp,xp+xh-1 do\n"
"			local cell=level.get_cell(x,y)\n"
"			cell.room=d\n"
"		end\n"
"	end\n"
"	\n"
" -- call this after adding all the rooms to the level to find all the doors\n"
" -- and mark each room as linked to its neighbours\n"
"\n"
"	function find_doors()\n"
"	\n"
"		for y=yp,yp+yh-1 do\n"
"			for x=xp,xp+xh-1 do\n"
"			\n"
"				local cell=level.get_cell(x,y)\n"
"				\n"
"				for i,v in cell.neighbours() do\n"
"				\n"
"					if v.room and cell.room and v.room~=cell.room then -- connected to a different room?\n"
"					\n"
"						doors[cell]=v.room\n"
"						cell.door=v.room\n"
"\n"
"					end\n"
"				end\n"
"			\n"
"			end\n"
"		end\n"
"	end\n"
"\n"
"\n"
"-- set this room and every cell in and around this room to visible \n"
"-- return number of cells that where revealed, this can then be used to heal\n"
"	function set_visible(v)\n"
"	local n=0\n"
"		for _,cell in level.cpairs(xp-1,yp-1,xh+2,yh+2) do\n"
"			if not cell.is.get.visible() then\n"
"				n=n+1\n"
"				cell.is.set.visible(v)\n"
"			end\n"
"		end\n"
"		is.set.visible(v)\n"
"		return n\n"
"	end\n"
"\n"
"	\n"
"	function post_create()\n"
"		for _,cell in level.cpairs(xp,yp,xh,yh) do\n"
"			cell.set.name(\"floor\")\n"
"		end\n"
"	end\n"
"\n"
"-- create a save state for this data\n"
"	function save()\n"
"		local sd={}\n"
"		\n"
"		sd=yarn_attr.save(is)\n"
"		\n"
"		sd.xp=xp\n"
"		sd.yp=yp\n"
"		sd.xh=xh\n"
"		sd.yh=yh\n"
"\n"
"		\n"
"		return sd\n"
"	end\n"
"\n"
"-- reload a saved data (create and then load)\n"
"	function load(sd)\n"
"		is=yarn_attr.load(sd)\n"
"		d.is=is\n"
"		d.metatable.__index=is\n"
"\n"
"		xp=sd.xp\n"
"		yp=sd.yp\n"
"		xh=sd.xh\n"
"		yh=sd.yh\n"
"\n"
"	end\n"
"	\n"
"	return d\n"
"	\n"
"end\n"
"\n"
"",

"yarn.attrs","\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- yes this is convoluted :)\n"
"module(...) local _M=require(...)\n"
"\n"
"local yarn=require(\"yarn\")\n"
"\n"
"require(yarn.gamename).setup()\n"
"",

"ltn12","-----------------------------------------------------------------------------\n"
"-- LTN12 - Filters, sources, sinks and pumps.\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: ltn12.lua,v 1.31 2006/04/03 04:45:42 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module\n"
"-----------------------------------------------------------------------------\n"
"local string = require(\"string\")\n"
"local table = require(\"table\")\n"
"local base = _G\n"
"module(\"ltn12\")\n"
"\n"
"filter = {}\n"
"source = {}\n"
"sink = {}\n"
"pump = {}\n"
"\n"
"-- 2048 seems to be better in windows...\n"
"BLOCKSIZE = 2048\n"
"_VERSION = \"LTN12 1.0.1\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Filter stuff\n"
"-----------------------------------------------------------------------------\n"
"-- returns a high level filter that cycles a low-level filter\n"
"function filter.cycle(low, ctx, extra)\n"
"    base.assert(low)\n"
"    return function(chunk)\n"
"        local ret\n"
"        ret, ctx = low(ctx, chunk, extra)\n"
"        return ret\n"
"    end\n"
"end\n"
"\n"
"-- chains a bunch of filters together\n"
"-- (thanks to Wim Couwenberg)\n"
"function filter.chain(...)\n"
"    local n = table.getn(arg)\n"
"    local top, index = 1, 1\n"
"    local retry = \"\"\n"
"    return function(chunk)\n"
"        retry = chunk and retry\n"
"        while true do\n"
"            if index == top then\n"
"                chunk = arg[index](chunk)\n"
"                if chunk == \"\" or top == n then return chunk\n"
"                elseif chunk then index = index + 1\n"
"                else\n"
"                    top = top+1\n"
"                    index = top\n"
"                end\n"
"            else\n"
"                chunk = arg[index](chunk or \"\")\n"
"                if chunk == \"\" then\n"
"                    index = index - 1\n"
"                    chunk = retry\n"
"                elseif chunk then\n"
"                    if index == n then return chunk\n"
"                    else index = index + 1 end\n"
"                else base.error(\"filter returned inappropriate nil\") end\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Source stuff\n"
"-----------------------------------------------------------------------------\n"
"-- create an empty source\n"
"local function empty()\n"
"    return nil\n"
"end\n"
"\n"
"function source.empty()\n"
"    return empty\n"
"end\n"
"\n"
"-- returns a source that just outputs an error\n"
"function source.error(err)\n"
"    return function()\n"
"        return nil, err\n"
"    end\n"
"end\n"
"\n"
"-- creates a file source\n"
"function source.file(handle, io_err)\n"
"    if handle then\n"
"        return function()\n"
"            local chunk = handle:read(BLOCKSIZE)\n"
"            if not chunk then handle:close() end\n"
"            return chunk\n"
"        end\n"
"    else return source.error(io_err or \"unable to open file\") end\n"
"end\n"
"\n"
"-- turns a fancy source into a simple source\n"
"function source.simplify(src)\n"
"    base.assert(src)\n"
"    return function()\n"
"        local chunk, err_or_new = src()\n"
"        src = err_or_new or src\n"
"        if not chunk then return nil, err_or_new\n"
"        else return chunk end\n"
"    end\n"
"end\n"
"\n"
"-- creates string source\n"
"function source.string(s)\n"
"    if s then\n"
"        local i = 1\n"
"        return function()\n"
"            local chunk = string.sub(s, i, i+BLOCKSIZE-1)\n"
"            i = i + BLOCKSIZE\n"
"            if chunk ~= \"\" then return chunk\n"
"            else return nil end\n"
"        end\n"
"    else return source.empty() end\n"
"end\n"
"\n"
"-- creates rewindable source\n"
"function source.rewind(src)\n"
"    base.assert(src)\n"
"    local t = {}\n"
"    return function(chunk)\n"
"        if not chunk then\n"
"            chunk = table.remove(t)\n"
"            if not chunk then return src()\n"
"            else return chunk end\n"
"        else\n"
"            table.insert(t, chunk)\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function source.chain(src, f)\n"
"    base.assert(src and f)\n"
"    local last_in, last_out = \"\", \"\"\n"
"    local state = \"feeding\"\n"
"    local err\n"
"    return function()\n"
"        if not last_out then\n"
"            base.error('source is empty!', 2)\n"
"        end\n"
"        while true do\n"
"            if state == \"feeding\" then\n"
"                last_in, err = src()\n"
"                if err then return nil, err end\n"
"                last_out = f(last_in)\n"
"                if not last_out then\n"
"                    if last_in then\n"
"                        base.error('filter returned inappropriate nil')\n"
"                    else\n"
"                        return nil\n"
"                    end\n"
"                elseif last_out ~= \"\" then\n"
"                    state = \"eating\"\n"
"                    if last_in then last_in = \"\" end\n"
"                    return last_out\n"
"                end\n"
"            else\n"
"                last_out = f(last_in)\n"
"                if last_out == \"\" then\n"
"                    if last_in == \"\" then\n"
"                        state = \"feeding\"\n"
"                    else\n"
"                        base.error('filter returned \"\"')\n"
"                    end\n"
"                elseif not last_out then\n"
"                    if last_in then\n"
"                        base.error('filter returned inappropriate nil')\n"
"                    else\n"
"                        return nil\n"
"                    end\n"
"                else\n"
"                    return last_out\n"
"                end\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-- creates a source that produces contents of several sources, one after the\n"
"-- other, as if they were concatenated\n"
"-- (thanks to Wim Couwenberg)\n"
"function source.cat(...)\n"
"    local src = table.remove(arg, 1)\n"
"    return function()\n"
"        while src do\n"
"            local chunk, err = src()\n"
"            if chunk then return chunk end\n"
"            if err then return nil, err end\n"
"            src = table.remove(arg, 1)\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Sink stuff\n"
"-----------------------------------------------------------------------------\n"
"-- creates a sink that stores into a table\n"
"function sink.table(t)\n"
"    t = t or {}\n"
"    local f = function(chunk, err)\n"
"        if chunk then table.insert(t, chunk) end\n"
"        return 1\n"
"    end\n"
"    return f, t\n"
"end\n"
"\n"
"-- turns a fancy sink into a simple sink\n"
"function sink.simplify(snk)\n"
"    base.assert(snk)\n"
"    return function(chunk, err)\n"
"        local ret, err_or_new = snk(chunk, err)\n"
"        if not ret then return nil, err_or_new end\n"
"        snk = err_or_new or snk\n"
"        return 1\n"
"    end\n"
"end\n"
"\n"
"-- creates a file sink\n"
"function sink.file(handle, io_err)\n"
"    if handle then\n"
"        return function(chunk, err)\n"
"            if not chunk then\n"
"                handle:close()\n"
"                return 1\n"
"            else return handle:write(chunk) end\n"
"        end\n"
"    else return sink.error(io_err or \"unable to open file\") end\n"
"end\n"
"\n"
"-- creates a sink that discards data\n"
"local function null()\n"
"    return 1\n"
"end\n"
"\n"
"function sink.null()\n"
"    return null\n"
"end\n"
"\n"
"-- creates a sink that just returns an error\n"
"function sink.error(err)\n"
"    return function()\n"
"        return nil, err\n"
"    end\n"
"end\n"
"\n"
"-- chains a sink with a filter\n"
"function sink.chain(f, snk)\n"
"    base.assert(f and snk)\n"
"    return function(chunk, err)\n"
"        if chunk ~= \"\" then\n"
"            local filtered = f(chunk)\n"
"            local done = chunk and \"\"\n"
"            while true do\n"
"                local ret, snkerr = snk(filtered, err)\n"
"                if not ret then return nil, snkerr end\n"
"                if filtered == done then return 1 end\n"
"                filtered = f(done)\n"
"            end\n"
"        else return 1 end\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Pump stuff\n"
"-----------------------------------------------------------------------------\n"
"-- pumps one chunk from the source to the sink\n"
"function pump.step(src, snk)\n"
"    local chunk, src_err = src()\n"
"    local ret, snk_err = snk(chunk, src_err)\n"
"    if chunk and ret then return 1\n"
"    else return nil, src_err or snk_err end\n"
"end\n"
"\n"
"-- pumps all data from a source to a sink, using a step function\n"
"function pump.all(src, snk, step)\n"
"    base.assert(src and snk)\n"
"    step = step or pump.step\n"
"    while true do\n"
"        local ret, err = step(src, snk)\n"
"        if not ret then\n"
"            if err then return nil, err\n"
"            else return 1 end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"",

"state.yarn","\r\n"
"\r\n"
"local _G=_G\r\n"
"\r\n"
"local win=win\r\n"
"\r\n"
"local table=table\r\n"
"local ipairs=ipairs\r\n"
"local string=string\r\n"
"local math=math\r\n"
"local os=os\r\n"
"\r\n"
"-- a rogue like\r\n"
"\r\n"
"local unpack=unpack\r\n"
"\r\n"
"local tostring=tostring\r\n"
"\r\n"
"local require=require\r\n"
"\r\n"
"local gl=gl\r\n"
"\r\n"
"\r\n"
"\r\n"
"local function print(...) _G.print(...) end\r\n"
"dbg=print\r\n"
"\r\n"
"\r\n"
"local _M=module(...)\r\n"
"\r\n"
"\r\n"
"yarn=require(\"yarn\")\r\n"
"\r\n"
"function setup()\r\n"
"\r\n"
"	yarn.setup()\r\n"
"	\r\n"
"	print(\"setup\")\r\n"
"\r\n"
"end\r\n"
"\r\n"
"function keypress(ascii,key,act)\r\n"
"\r\n"
"	if yarn.menu.keypress(ascii,key,act) then -- give the menu first chance to eat this keypress\r\n"
"		yarn.level.key_clear() -- stop level repeats\r\n"
"	else\r\n"
"		yarn.level.keypress(ascii,key,act)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function mouse(act,x,y,key)\r\n"
"\r\n"
"	if act==\"down\" then\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"	\r\n"
"function clean()\r\n"
"	yarn.clean()\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"function update()\r\n"
"\r\n"
"	yarn.update()\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"function draw()\r\n"
"\r\n"
"	yarn.draw()\r\n"
"\r\n"
"	win.begin()\r\n"
"	gl.ClearColor(0,0,0,0)\r\n"
"	gl.Clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT);\r\n"
"	\r\n"
"	win.project23d(480/640,1,1024)\r\n"
"	gl.MatrixMode(\"MODELVIEW\")\r\n"
"	gl.LoadIdentity()\r\n"
"					\r\n"
"local i=0\r\n"
"local t={}\r\n"
"\r\n"
"	gl.Translate(-320,240, -240)\r\n"
"		\r\n"
"	for y=0,yarn.asc_yh-1 do\r\n"
"	\r\n"
"		win.font_base.set(0,y*-16,0xff44ff44,16)\r\n"
"		\r\n"
"		for x=0,yarn.asc_xh-1 do\r\n"
"		\r\n"
"			i=1+x+y*yarn.asc_xh\r\n"
"			t[x+1]=yarn.asc[i]%256\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"		local s=string.char(unpack(t))\r\n"
"		\r\n"
"		win.font_base.draw(s)\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	\r\n"
"--	win.font_debug.set(0,0,0xffffffff,1.6)\r\n"
"--	win.font_debug.draw(\"asdasdasdsd\")\r\n"
"		\r\n"
"end\r\n"
"\r\n"
"\r\n"
"",

"wetgenes.www.ngx.fetch","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"local ngx=require(\"ngx\")\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.fetch\"]=_M\n"
"\n"
"function countzero()\n"
"	count=0\n"
"	api_time=0\n"
"end\n"
"countzero()\n"
"\n"
"local kind_props={}	-- default global props mapped to kinds\n"
"\n"
"local start_time -- handle simple api benchmarking of some calls\n"
"local function apis()\n"
"	start_time=os.time()\n"
"end\n"
"local function apie(...)\n"
"	api_time=api_time+os.time()-start_time\n"
"	return ...\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"function get(url)\n"
"	log(\"fetch.get:\")\n"
"	apis()\n"
"	count=count+1\n"
"	\n"
"	local res = ngx.location.capture(\"/@fetch/\"..url)\n"
"\n"
"	ret={}\n"
"	ret.code=res.status\n"
"	ret.headers=res.header\n"
"	ret.body=res.body\n"
"\n"
"log(wstr.serialize(ret))\n"
"	\n"
"	apie()\n"
"	return ret\n"
"end\n"
"\n"
"\n"
"\n"
"function post(url)\n"
"	log(\"fetch.post:\")\n"
"	apis()\n"
"	count=count+1\n"
"	local res = ngx.location.capture(\"/@fetch/\"..url)\n"
"	ret={}\n"
"	ret.code=res.status\n"
"	ret.headers=res.header\n"
"	ret.body=res.body\n"
"	\n"
"	apie()\n"
"	return ret\n"
"end\n"
"",

"wetgenes.bake.gamecake","\r\n"
"local require=require\r\n"
"\r\n"
"local ipairs=ipairs\r\n"
"\r\n"
"module(...)\r\n"
"\r\n"
"function build(tab)\r\n"
"\r\n"
"	local bake=require(\"wetgenes.bake\")\r\n"
"	local bakejs=require(\"wetgenes.bake.js\")\r\n"
"\r\n"
"	-- where we are building from\r\n"
"	bake.cd_base	=	bake.cd_base or bake.get_cd()\r\n"
"	-- where we are building to\r\n"
"	bake.cd_out		=	bake.cd_out or 'out'\r\n"
"\r\n"
"	bake.files_min_js=bake.files_min_js or {}\r\n"
"	bake.files_min_js[ #bake.files_min_js + 1 ]=\"gamecake\"\r\n"
"\r\n"
"	local files_gamecake={}\r\n"
"	local r=bake.findfiles{basedir=\"../../js/gamecake/src\",dir=\"\",filter=\"%.js$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		files_gamecake[#files_gamecake+1]=v\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/js/gamecake/\"..v)\r\n"
"	end\r\n"
"\r\n"
"	bake.files_pp=bake.files_pp or {}\r\n"
"	for i,v in ipairs(files_gamecake) do\r\n"
"		bake.files_pp[ #bake.files_pp +1]={ \"../../js/gamecake/src\"..v , bake.cd_out..'/js/gamecake'..v }\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\"../../js/gamecake/jslib\",dir=\"\",filter=\"%.js$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/jslib\"..v)\r\n"
"		bake.copyfile(\"../../js/gamecake/jslib\"..v,bake.cd_out..\"/jslib\"..v)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\"../../js/gamecake/art\",dir=\"\",filter=\"%.swf$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/art\"..v)\r\n"
"		bake.copyfile(\"../../js/gamecake/art\"..v,bake.cd_out..\"/art\"..v)\r\n"
"	end\r\n"
"\r\n"
"-- the main action happens here\r\n"
"	bakejs.build(tab)\r\n"
"\r\n"
"end\r\n"
"",

"yarn.strings","\n"
"--some functions for manipulating strings, copypasta rather than depend on external libs\n"
"\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"module(...)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- private replace utility function\n"
"-- look up string a inside data d and return the string we found\n"
"-- if we dont find anything then we return {a}\n"
"--\n"
"-- if we try to look up a table containing a plate field\n"
"-- then that plate name will be used to format that table content as {d.it}\n"
"-- if that table contains a [1] then it will be treated as an array of data\n"
"-- and looped over to produce a result.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local replace_lookup\n"
"replace_lookup=function(a,d) -- look up a in table d\n"
"	local t=d[a]\n"
"	if t then\n"
"		if type(t)==\"table\" then -- if a table then\n"
"			if t[1] then -- a list of stuff\n"
"				if t.plate then -- how to format\n"
"					local tt={}\n"
"					local it=d.it\n"
"					for i,v in ipairs(t) do\n"
"						d.it=v\n"
"						tt[#tt+1]=macro_replace(d[t.plate] or t.plate,d)\n"
"					end\n"
"					d.it=it\n"
"					return table.concat(tt)\n"
"				end\n"
"			else -- just one thing\n"
"				if t.plate then -- how to format\n"
"					local it=d.it\n"
"					d.it=t\n"
"					local tt=macro_replace(d[t.plate] or t.plate,d)\n"
"					d.it=it\n"
"					return tt\n"
"				end\n"
"			end\n"
"			return nil -- no not expand\n"
"		end\n"
"		return tostring(t) -- simple find, make sure we return a string\n"
"	end\n"
"	\n"
"	local a1,a2=string.find(a, \"%.\") -- try and split on first \".\"\n"
"	if not a1 then return nil end -- didnt find a dot so return nil\n"
"	\n"
"	a1=string.sub(a,1,a1-1) -- the bit before the .\n"
"	a2=string.sub(a,a2+1) -- the bit after the .\n"
"	\n"
"	local dd=d[a1] -- use the bit before the dot to find the sub table\n"
"	\n"
"	if type(dd)==\"table\" then -- check we got a table\n"
"		return replace_lookup(a2,dd) -- tail call this function\n"
"	end\n"
"	\n"
"	return nil -- couldnt find anything returnnil\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace {tags} in the string with data provided\n"
"-- allow sub table look up with a.b notation in the name\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function replace(a,d)\n"
"\n"
"return (string.gsub( a , \"{([%w%._%-]-)}\" , function(a) -- find only words and \"._-!\" tightly encased in {}\n"
"-- this means that almost all legal use of {} in javascript will not match at all.\n"
"-- Even when it does (probably as a \"{}\") then it is unlikley to accidently find anything in the d table\n"
"-- so the text will just be returned as is.\n"
"-- So it may not be safe, but it is simple to understand and perfecty fine under most use cases.\n"
"\n"
"	return replace_lookup(a,d) or (\"{\"..a..\"}\")\n"
"	\n"
"end )) -- note gsub is in brackes so we just get its first return value\n"
"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split on separator\n"
"--\n"
"-- such that a concat(seperator) on the result would return the original\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function split(text,separator)\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	\n"
"	while split_start do\n"
"		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end		-- the word\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	\n"
"	return parts\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split on transition to or from whitespace, include this white space in the table result\n"
"--\n"
"-- such that a concat on the result would be a perfect reproduction of the original\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function split_whitespace(text)\n"
"	local separator = \"%s+\"\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	\n"
"	while split_start do\n"
"		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end		-- the word\n"
"		table.insert(parts, text:sub(split_start, split_end))	-- the white space\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	\n"
"	return parts\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- trime whitespace from ends of string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function trim(s)\n"
"  return (s:gsub(\"^%s*(.-)%s*$\", \"%1\"))\n"
"end\n"
"function trim_start(s)\n"
"  return (s:gsub(\"^%s*(.-)\", \"%1\"))\n"
"end\n"
"function trim_end(s)\n"
"  return (s:gsub(\"(.-)%s*$\", \"%1\"))\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split on \\n"
", each line also includes its own \\n"
"\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function split_lines(text)\n"
"	local separator = \"\\n"
"\"\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start,true)\n"
"	\n"
"	while split_start do\n"
"		table.insert(parts, text:sub(start, split_end))\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start,true)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	\n"
"	return parts\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- wrap a string to a given width, merging all whitespace to spaces but keeping line breaks\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function smart_wrap(s,w)\n"
"	local ls=split_whitespace(s)\n"
"	local t={}\n"
"	\n"
"	local wide=0\n"
"	local line={}\n"
"	\n"
"	local function newline()\n"
"		t[#t+1]=table.concat(line,\" \") or \"\"\n"
"		wide=0\n"
"		line={}\n"
"	end\n"
"	\n"
"	for i,v in ipairs(ls) do\n"
"	\n"
"		if v:find(\"%s\") then -- just white space\n"
"		\n"
"			for i,v in string.gfind(v,\"\\n"
"\") do -- keep newlines\n"
"				newline()\n"
"			end\n"
"		\n"
"		else -- a normal word\n"
"		\n"
"			if #line>0 then wide=wide+1 end\n"
"\n"
"			if wide + #v > w then -- split\n"
"				newline()\n"
"			end\n"
"			\n"
"			line[#line+1]=v\n"
"			wide=wide+#v\n"
"			\n"
"		end\n"
"	end\n"
"	if wide~=0 then newline() end -- final newline\n"
"	\n"
"	return t\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- opposite of serialize, returns table\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function unserialize(s)\n"
"	if not s then return nil end\n"
"	\n"
"	local t\n"
"	local f,err=loadstring(s)\n"
"	if f then\n"
"		t={}\n"
"		setfenv(f,t)\n"
"		local ret,err pcall(f)\n"
"		if not ret then t=nil end -- error\n"
"	end\n"
"	return t\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- serialize a simple table to a lua string that would hopefully recreate said table if executed\n"
"--\n"
"-- returns a string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function serialize(o,fout)\n"
"\n"
"	if not fout then -- call with a function to build and return a strin	\n"
"		local ret={}\n"
"		fout=function(s)\n"
"			ret[#ret+1]=s\n"
"		end\n"
"		serialize(o,fout)		\n"
"		return table.concat(ret)\n"
"	end\n"
"\n"
"	if type(o) == \"nil\" then\n"
"	\n"
"		return fout(\"nil\")\n"
"		\n"
"	elseif type(o) == \"number\" then\n"
"	\n"
"		return fout(o)\n"
"		\n"
"	elseif type(o) == \"boolean\" then\n"
"	\n"
"		if o then return fout(\"true\") else return fout(\"false\") end\n"
"		\n"
"	elseif type(o) == \"string\" then\n"
"	\n"
"		return fout(string.format(\"%q\", o))\n"
"		\n"
"	elseif type(o) == \"table\" then\n"
"	\n"
"		fout(\"{\")\n"
"		\n"
"		local len=#o\n"
"-- do array like part first\n"
"		for i=1,len do local v=o[i]\n"
"			serialize(v,fout)\n"
"			fout(\",\")\n"
"		end\n"
"		\n"
"-- then everything out in undefined order\n"
"		for k,v in pairs(o) do\n"
"			if type(k)==\"number\" and math.floor(k)==k and k>=1 and k<=len then -- already saved\n"
"			else\n"
"				fout(\"[\")\n"
"				serialize(k,fout)\n"
"				fout(\"]=\")\n"
"				serialize(v,fout)\n"
"				fout(\",\")\n"
"			end\n"
"		end\n"
"		\n"
"		return fout(\"}\")\n"
"	else\n"
"		error(\"cannot serialize a \" .. type(o))\n"
"	end\n"
"	\n"
"end\n"
"\n"
"\n"
"",

"socket","-----------------------------------------------------------------------------\n"
"-- LuaSocket helper module\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: socket.lua,v 1.22 2005/11/22 08:33:29 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local string = require(\"string\")\n"
"local math = require(\"math\")\n"
"local socket = require(\"socket.core\")\n"
"module(\"socket\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Exported auxiliar functions\n"
"-----------------------------------------------------------------------------\n"
"function connect(address, port, laddress, lport)\n"
"    local sock, err = socket.tcp()\n"
"    if not sock then return nil, err end\n"
"    if laddress then\n"
"        local res, err = sock:bind(laddress, lport, -1)\n"
"        if not res then return nil, err end\n"
"    end\n"
"    local res, err = sock:connect(address, port)\n"
"    if not res then return nil, err end\n"
"    return sock\n"
"end\n"
"\n"
"function bind(host, port, backlog)\n"
"    local sock, err = socket.tcp()\n"
"    if not sock then return nil, err end\n"
"    sock:setoption(\"reuseaddr\", true)\n"
"    local res, err = sock:bind(host, port)\n"
"    if not res then return nil, err end\n"
"    res, err = sock:listen(backlog)\n"
"    if not res then return nil, err end\n"
"    return sock\n"
"end\n"
"\n"
"try = newtry()\n"
"\n"
"function choose(table)\n"
"    return function(name, opt1, opt2)\n"
"        if base.type(name) ~= \"string\" then\n"
"            name, opt1, opt2 = \"default\", name, opt1\n"
"        end\n"
"        local f = table[name or \"nil\"]\n"
"        if not f then base.error(\"unknown key (\".. base.tostring(name) ..\")\", 3)\n"
"        else return f(opt1, opt2) end\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Socket sources and sinks, conforming to LTN12\n"
"-----------------------------------------------------------------------------\n"
"-- create namespaces inside LuaSocket namespace\n"
"sourcet = {}\n"
"sinkt = {}\n"
"\n"
"BLOCKSIZE = 2048\n"
"\n"
"sinkt[\"close-when-done\"] = function(sock)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function(self, chunk, err)\n"
"            if not chunk then\n"
"                sock:close()\n"
"                return 1\n"
"            else return sock:send(chunk) end\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"sinkt[\"keep-open\"] = function(sock)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function(self, chunk, err)\n"
"            if chunk then return sock:send(chunk)\n"
"            else return 1 end\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"sinkt[\"default\"] = sinkt[\"keep-open\"]\n"
"\n"
"sink = choose(sinkt)\n"
"\n"
"sourcet[\"by-length\"] = function(sock, length)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function()\n"
"            if length <= 0 then return nil end\n"
"            local size = math.min(socket.BLOCKSIZE, length)\n"
"            local chunk, err = sock:receive(size)\n"
"            if err then return nil, err end\n"
"            length = length - string.len(chunk)\n"
"            return chunk\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"sourcet[\"until-closed\"] = function(sock)\n"
"    local done\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function()\n"
"            if done then return nil end\n"
"            local chunk, err, partial = sock:receive(socket.BLOCKSIZE)\n"
"            if not err then return chunk\n"
"            elseif err == \"closed\" then\n"
"                sock:close()\n"
"                done = 1\n"
"                return partial\n"
"            else return nil, err end\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"\n"
"sourcet[\"default\"] = sourcet[\"until-closed\"]\n"
"\n"
"source = choose(sourcet)\n"
"\n"
"",

"yarn","\n"
"\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"dbg=dbg or function() end\n"
"\n"
"module(...)\n"
"\n"
"gamename=\"swordstone\"\n"
"version=require(\"yarn.version\")\n"
"\n"
"\n"
"local yarn=require(\"yarn\")\n"
"local yarn_level=require(\"yarn.level\")\n"
"local yarn_menu=require(\"yarn.menu\")\n"
"local yarn_attrs=require(\"yarn.attrs\")\n"
"\n"
"local strings=require(\"yarn.strings\")\n"
"\n"
"local a_space=string.byte(\" \",1)\n"
"local a_under=string.byte(\"_\",1)\n"
"local a_star=string.byte(\"*\",1)\n"
"local a_hash=string.byte(\"#\",1)\n"
"local a_dash=string.byte(\"-\",1)\n"
"local a_dot=string.byte(\".\",1)\n"
"\n"
"asc={}\n"
"asc_xh=0\n"
"asc_yh=0	\n"
"\n"
"level={}\n"
"menu={}\n"
"\n"
"soul={}\n"
"\n"
"sdata={}\n"
"\n"
"function setup(sd,arg)\n"
"\n"
"\n"
"local i\n"
"\n"
"	asc_xh=40\n"
"	asc_yh=30\n"
"	for y=0,asc_yh-1 do\n"
"		for x=0,asc_xh-1 do\n"
"		\n"
"			i=1+x+y*asc_xh\n"
"			\n"
"			asc[i]=a_space\n"
"		end\n"
"	end\n"
"	\n"
"	menu=yarn_menu.create({},yarn)\n"
"	\n"
"	if arg and arg[1] then -- debug this level\n"
"		local pow=tonumber(arg[2] or 1) or 1\n"
"		level=yarn_level.create(yarn_attrs.get(\"level.\"..arg[1],pow,{xh=40,yh=28}),yarn)\n"
"		\n"
"	else\n"
"	\n"
"		level=yarn_level.create(yarn_attrs.get(\"level.home\",1,{xh=40,yh=28}),yarn)\n"
"	\n"
"	end\n"
"\n"
"	\n"
"	for y=0,asc_yh-1 do\n"
"		for x=0,asc_xh-1 do\n"
"			i=1+x+y*asc_xh\n"
"			local a=level.get_asc(x,y)\n"
"			if a then asc[i]=a end\n"
"		end\n"
"	end\n"
"	\n"
"--	level.draw_map(_M)\n"
"		\n"
"	local f=level.can[\"read welcome\"]\n"
"	if f then f(level) end\n"
"\n"
"end\n"
"\n"
"function keypress(ascii,key,act)\n"
"\n"
"	if menu.keypress(ascii,key,act) then -- give the menu first chance to eat this keypress\n"
"		level.key_clear() -- stop level repeats\n"
"	else\n"
"		level.keypress(ascii,key,act)\n"
"	end\n"
"end\n"
"\n"
"\n"
"function mouse(act,x,y,key)\n"
"\n"
"	if act==\"down\" then\n"
"\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"	\n"
"function clean()\n"
"end\n"
"\n"
"\n"
"\n"
"function update()\n"
"\n"
"	return level.update() + menu.update()\n"
"	\n"
"end\n"
"\n"
"function asc_print(x,y,s)\n"
"\n"
"	local id=1+x+y*asc_xh\n"
"	\n"
"	for i=1,#s do\n"
"	\n"
"		if asc[id] then\n"
"		\n"
"			asc[id]=string.byte(s,i)\n"
"		\n"
"		end\n"
"		\n"
"		id=id+1\n"
"	\n"
"	end\n"
"	\n"
"end\n"
"\n"
"function asc_draw_box(x,y,xh,yh)\n"
"\n"
"	local sc=string.rep(\"#\",xh)\n"
"	asc_print(x,y,sc)\n"
"	for i=1,yh-2 do\n"
"		local s=\"#\"..string.rep(\" \",xh-2)..\"#\"\n"
"		asc_print(x,y+i,s)\n"
"	end\n"
"	asc_print(x,y+yh-1,sc)\n"
"	\n"
"	\n"
"end\n"
"\n"
"function asc_draw_fill(x,y,xh,yh)\n"
"\n"
"	local sc=string.rep(\" \",xh)\n"
"	for i=1,yh do\n"
"		asc_print(x,y+i-1,sc)\n"
"	end\n"
"	\n"
"end\n"
"\n"
"\n"
"function draw(charwidth)\n"
"\n"
"local i=0\n"
"local t={}\n"
"\n"
"	\n"
"	for y=0,asc_yh-1 do\n"
"		for x=0,asc_xh-1 do\n"
"			i=1+x+y*asc_xh\n"
"			local a=level.get_asc(x,y)\n"
"			if a then asc[i]=a end\n"
"		end\n"
"	end\n"
"	\n"
"	function prt(y,s)\n"
"		s=tostring(s)\n"
"		asc_print(30,y,\"----------\")\n"
"		asc_print(30+math.floor((10-#s)/2),y,s)\n"
"	end\n"
"	function prt_wide(y,s)\n"
"		s=tostring(s or \"\")\n"
"		asc_print(0,y,\"                                        \")\n"
"		asc_print(math.floor((40-#s)/2),y,s)\n"
"	end\n"
"\n"
"\n"
"	local wrap=strings.smart_wrap(level.get_msg(),40)\n"
"	\n"
"	menu.draw()\n"
"	\n"
"	if #wrap<1 then\n"
"		prt_wide(29,\"\")\n"
"	elseif #wrap<2 then\n"
"		prt_wide(28,\"\")\n"
"	end\n"
"	for i=30-#wrap,29 do\n"
"		prt_wide(i,wrap[i-(29-#wrap)])\n"
"	end\n"
"	\n"
"	\n"
"	local ret={}\n"
"	for y=0,asc_yh-1 do\n"
"\n"
"		for x=0,asc_xh-1 do\n"
"		\n"
"			i=1+x+y*asc_xh\n"
"--			t[x+1]=asc[i]%256\n"
"\n"
"			if charwidth==2 then\n"
"			\n"
"				t[x*2+1]=asc[i]%256\n"
"				t[x*2+2]=32\n"
"			\n"
"			else\n"
"			\n"
"				t[x+1]=asc[i]%256\n"
"			\n"
"			end\n"
"		end\n"
"		\n"
"		local s=string.char(unpack(t))\n"
"		\n"
"		ret[#ret+1]=s\n"
"		ret[#ret+1]=\"\\n"
"\"\n"
"--print(s)\n"
"		\n"
"	end\n"
"	\n"
"	return table.concat(ret)\n"
"	\n"
"end\n"
"\n"
"\n"
"-- save the current level\n"
"-- on level change or\n"
"-- in order to dump this state to disk\n"
"\n"
"function save()\n"
"	local sd=sdata\n"
"\n"
"	local level_name=level.name\n"
"	local level_pow=level.pow\n"
"	\n"
"	soul.level_name=level_name\n"
"	soul.level_pow=level_pow\n"
"\n"
"	sd.soul=soul -- our soul, saves just as is since it does not contain complex data\n"
"\n"
"	if level.flags.clean_slate then -- special test levels\n"
"\n"
"	else\n"
"		player.un_cell()\n"
"		sd.player=player.save() -- the player is special, they contain epic loots\n"
"		player.re_cell()\n"
"		\n"
"		sd.levels=sd.levels or {}\n"
"		\n"
"		sd.levels[level_name]=sd.levels[level_name] or {}\n"
"		sd.levels[level_name][level_pow]=level.save()\n"
"	end\n"
"	\n"
"	return sd\n"
"end\n"
"\n"
"-- get any previously created saved level data if it exists\n"
"function get_level_save(level_name,level_pow)\n"
"\n"
"	local sd=sdata\n"
"\n"
"	if sd.levels and sd.levels[level_name] then\n"
"	\n"
"		return sd.levels[level_name][level_pow]\n"
"		\n"
"	end\n"
"	\n"
"end\n"
"\n"
"\n"
"-- reload a full saved data (create and then load everything)\n"
"function load(sd)\n"
"	sdata=sd\n"
"	\n"
"	soul=sd.soul\n"
"	\n"
"	player=yarn_item.create({level=level})\n"
"	player.load(sd.player)\n"
"\n"
"	level=yarn_level.create(yarn_attrs.get(soul.level_name,soul.level_pow,{xh=40,yh=28}),yarn)\n"
"	\n"
"	player.re_cell()\n"
"\n"
"end\n"
"\n"
"",

"wetgenes.www.any.stash","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"local stashdata=require(\"wetgenes.www.any.stashdata\")\n"
"\n"
"\n"
"-- a stash is a simple long term cache, it lives in data entities and survives reboots\n"
"\n"
"module(...)\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- clear all stashed data, may fail...\n"
"-- everything in the stash should be recreatable\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function clear(srv,id)\n"
"\n"
"	return false --not gonna do this yet, appengine has issues anyhow\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- delete id from stash\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function del(srv,id)\n"
"	stashdata.del(srv,id)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- put id in stash\n"
"-- data is data to store (should be json encodable)\n"
"-- opts is a table of extra options\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function put(srv,id,data,opts)\n"
"	local e=stashdata.set(srv,id,function(srv,e)\n"
"		e.cache.data=data\n"
"		if opts then\n"
"			e.cache.base=opts.base\n"
"			e.cache.func=opts.func\n"
"		end\n"
"		return e\n"
"	end)\n"
"	if e then\n"
"		return e.cache.data, e\n"
"	end	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get id from stash\n"
"-- return data,entity\n"
"-- the entity can be used for extra validity checks of the date (IE last update  time)\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function get(srv,id)\n"
"	local e=stashdata.get(srv,id)\n"
"	if e then\n"
"		return e.cache.data, e\n"
"	end\n"
"end\n"
"",

"wetgenes.diff","-----------------------------------------------------------------------------\n"
"-- Provides functions for diffing text.\n"
"--\n"
"-- (c) 2007, 2008  Yuri Takhteyev (yuri@freewisdom.org)\n"
"-- (c) 2007 Hisham Muhammad\n"
"--\n"
"-- License: MIT/X, see http://sputnik.freewisdom.org/en/License\n"
"--\n"
"-- the above was used as a base, it is no longer the same code...\n"
"--\n"
"-- this diff now returns a different slightly more compressed format\n"
"-- which is a table of numbers and strings of only the differences\n"
"-- and that format can be used to convert either string into the other string\n"
"--\n"
"-- most of the changes are actually commented and are just mild changes really\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"\n"
"local string=string\n"
"local table=table\n"
"local math=math\n"
"\n"
"local assert=assert\n"
"local setmetatable=setmetatable\n"
"local ipairs=ipairs\n"
"local type=type\n"
"\n"
"module(\"wetgenes.diff\")\n"
"\n"
"-- java version of lua, not so good at strings, so might as well use numbers for these as they are now internal only\n"
"local SAME = 0  -- token statuses\n"
"local IN   = 1\n"
"local OUT  = 2\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Split a string into tokens.  (Adapted from Gavin Kistner's split on\n"
"-- http://lua-users.org/wiki/SplitJoin.\n"
"--\n"
"-- @param text           A string to be split.\n"
"-- @param separator      [optional] the separator pattern (defaults to any\n"
"--                       white space - %s+).\n"
"-- @param skip_separator [optional] don't include the sepator in the results.     \n"
"-- @return               A list of tokens.\n"
"-----------------------------------------------------------------------------\n"
"local function split(text, separator, skip_separator)\n"
"	separator = separator or \"%s+\"\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	while split_start do\n"
"		if skip_separator then\n"
"			table.insert(parts, text:sub(start, split_start-1))\n"
"		else\n"
"			table.insert(parts, text:sub(start, split_end)) -- now includes the seperator *inside* each token\n"
"		end\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	return parts\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Derives the longest common subsequence of two strings.  This is a faster\n"
"-- implementation than one provided by stdlib.  Submitted by Hisham Muhammad. \n"
"-- The algorithm was taken from:\n"
"-- http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_subsequence\n"
"--\n"
"-- @param t1             the first string.\n"
"-- @param t2             the second string.\n"
"-- @return               the least common subsequence as a matrix.\n"
"-----------------------------------------------------------------------------\n"
"local function quick_LCS(t1, t2)\n"
"   local m = #t1\n"
"   local n = #t2\n"
"\n"
"   -- Build matrix on demand\n"
"   local C = {}\n"
"   local setmetatable = setmetatable\n"
"   local mt_tbl = {\n"
"      __index = function(t, k)\n"
"         t[k] = 0\n"
"         return 0\n"
"      end\n"
"   }\n"
"   local mt_C = {\n"
"      __index = function(t, k)\n"
"         local tbl = {}\n"
"         setmetatable(tbl, mt_tbl)\n"
"         t[k] = tbl\n"
"         return tbl\n"
"      end\n"
"   }\n"
"   setmetatable(C, mt_C)\n"
"   local max = math.max\n"
"   for i = 1, m+1 do\n"
"      local ci1 = C[i+1]\n"
"      local ci = C[i]\n"
"      for j = 1, n+1 do\n"
"         if t1[i-1] == t2[j-1] then\n"
"            ci1[j+1] = ci[j] + 1\n"
"         else\n"
"            ci1[j+1] = max(ci1[j], ci[j+1])\n"
"         end\n"
"      end\n"
"   end\n"
"   return C\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Returns a diff of two strings as a list of pairs, where the first value\n"
"-- represents a token and the second the token's status (\"same\", \"in\", \"out\").\n"
"--\n"
"-- @param old             The \"old\" text string\n"
"-- @param new             The \"new\" text string\n"
"-- @param separator      [optional] the separator pattern (defaults ot any\n"
"--                       white space).\n"
"-- @return               A list of annotated tokens.\n"
"-----------------------------------------------------------------------------\n"
"local function rev_diff(old, new, separator)\n"
"   assert(old); assert(new)\n"
"   new = split(new, separator); old = split(old, separator)\n"
"\n"
"   -- First, compare the beginnings and ends of strings to remove the common\n"
"   -- prefix and suffix.  Chances are, there is only a small number of tokens\n"
"   -- in the middle that differ, in which case  we can save ourselves a lot\n"
"   -- in terms of LCS computation.\n"
"   local prefix = \"\" -- common text in the beginning\n"
"   local suffix = \"\" -- common text in the end\n"
"   while old[1] and old[1] == new[1] do\n"
"      local token = table.remove(old, 1)\n"
"      table.remove(new, 1)\n"
"      prefix = prefix..token\n"
"   end\n"
"   while old[#old] and old[#old] == new[#new] do\n"
"      local token = table.remove(old)\n"
"      table.remove(new)\n"
"      suffix = token..suffix\n"
"   end\n"
"\n"
"   -- Setup a table that will store the diff (an upvalue for get_diff). We'll\n"
"   -- store it in the reverse order to allow for tail calls.  We'll also keep\n"
"   -- in this table functions to handle different events.\n"
"   local rev_diff = {\n"
"      put  = function(self, token, type) table.insert(self, token ) table.insert(self, type ) end, -- no sub tables, so less resources, probably\n"
"      ins  = function(self, token) self:put(token, IN) end,\n"
"      del  = function(self, token) self:put(token, OUT) end,\n"
"      same = function(self, token) if token then self:put(token, SAME) end end,\n"
"   }\n"
"\n"
"   -- Put the suffix as the first token (we are storing the diff in the\n"
"   -- reverse order)\n"
"\n"
"   rev_diff:same(suffix)\n"
"\n"
"   -- Define a function that will scan the LCS matrix backwards and build the\n"
"   -- diff output recursively.\n"
"   local function get_diff(C, old, new, i, j)\n"
"      local old_i = old[i]\n"
"      local new_j = new[j]\n"
"      if i >= 1 and j >= 1 and old_i == new_j then\n"
"         rev_diff:same(old_i)\n"
"         return get_diff(C, old, new, i-1, j-1)\n"
"      else\n"
"         local Cij1 = C[i][j-1]\n"
"         local Ci1j = C[i-1][j]\n"
"         if j >= 1 and (i == 0 or Cij1 >= Ci1j) then\n"
"            rev_diff:ins(new_j)\n"
"            return get_diff(C, old, new, i, j-1)\n"
"         elseif i >= 1 and (j == 0 or Cij1 < Ci1j) then\n"
"            rev_diff:del(old_i)\n"
"            return get_diff(C, old, new, i-1, j)\n"
"         end\n"
"      end\n"
"   end\n"
"   -- Then call it.\n"
"   get_diff(quick_LCS(old, new), old, new, #old + 1, #new + 1)\n"
"\n"
"   -- Put the prefix in at the end\n"
"   rev_diff:same(prefix)\n"
"\n"
"   return rev_diff\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Returns a diff of two strings as a list of pairs, where the first value\n"
"-- represents a token and the second the token's status (\"same\", \"in\", \"out\").\n"
"--\n"
"-- @param old             The \"old\" text string\n"
"-- @param new             The \"new\" text string\n"
"-- @param separator      [optional] the separator pattern (defaults ot any\n"
"--                       white space).\n"
"-- @return\n"
"--\n"
"-- a table containg a list of the following commands\n"
"-- if a number then the length of string that is the same and should be skipped\n"
"-- if a string then it is part of a pair of strings\n"
"-- [1] contains the old string and [2] contains the new string\n"
"-- strings are always in pairs and numbers are always seperated by two strings\n"
"-- this should be reasonably compact data\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function diff(old, new, separator)\n"
"\n"
"	local d=rev_diff(old, new, separator)\n"
"\n"
"	local t={}\n"
"	\n"
"	local same,new,old\n"
"	\n"
"	local function reset() same=0 new=\"\" old=\"\" end\n"
"	\n"
"	reset()\n"
"	\n"
"\n"
"-- scan the data from diff_base\n"
"	for i = #d , 2 , -2 do -- data comes in reversed and in pairs\n"
"	\n"
"	\n"
"	local v1=d[i] 		-- command\n"
"	local v2=d[i-1] 	-- data\n"
"	\n"
"\n"
"		if v1==SAME then\n"
"		\n"
"			if ( new~=\"\" or old~=\"\" ) then -- change state\n"
"			\n"
"				table.insert(t,old)\n"
"				table.insert(t,new)\n"
"				reset()\n"
"			end\n"
"			\n"
"			same=same+v2:len()\n"
"		\n"
"		elseif v1==OUT then \n"
"		\n"
"			if same>0 then -- change state\n"
"			\n"
"				table.insert(t,same)\n"
"				reset()\n"
"			end\n"
"			\n"
"			old=old..v2\n"
"			\n"
"		elseif v1==IN then\n"
"		\n"
"			if same>0 then -- change state\n"
"			\n"
"				table.insert(t,same)\n"
"				reset()\n"
"			end\n"
"			\n"
"			new=new..v2			\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"-- add the final chunk\n"
"	\n"
"	if same>0 then\n"
"	\n"
"		table.insert(t,same)\n"
"		\n"
"	elseif ( new~=\"\" or old~=\"\" ) then\n"
"\n"
"		table.insert(t,old)\n"
"		table.insert(t,new)\n"
"	end\n"
"\n"
"	return t\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- patch a diff against a string and return the new string\n"
"--\n"
"-- set undo to true and the patch will be applied in reverse\n"
"--\n"
"-- s1,s2\n"
"-- d=diff(s1,s2)\n"
"-- s2==patch(s1,d)\n"
"-- s1==patch(s2,d,true)\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function patch(s,t,undo)\n"
"\n"
"	local o={}\n"
"	local idx=1\n"
"\n"
"	local i=1\n"
"	local len=#t\n"
"	while i<=len do\n"
"	\n"
"		local v1,v2\n"
"		v1=t[i]\n"
"		i=i+1\n"
"		\n"
"		if type(v1)==\"string\" then\n"
"		\n"
"			v2=t[i]\n"
"			i=i+1	-- strings come in pairs so get second string\n"
"			\n"
"			if undo then\n"
"			\n"
"				table.insert(o, v1 )\n"
"				idx=idx+v2:len()\n"
"				\n"
"			else\n"
"			\n"
"				table.insert(o, v2 )\n"
"				idx=idx+v1:len()\n"
"				\n"
"			end\n"
"		else\n"
"		\n"
"			table.insert(o, s:sub(idx,idx+v1-1) )\n"
"			idx=idx+v1\n"
"			\n"
"		end\n"
"	end\n"
"	\n"
"	return table.concat(o) -- build a return string\n"
"\n"
"end\n"
"\n"
"-- a more readable way to unpatch\n"
"function unpatch(s,t) return patch(s,t,true) end\n"
"\n"
"",

"wetgenes.cgilua.mysql","\r\n"
"--\r\n"
"-- Mysql helper functions\r\n"
"--\r\n"
"\r\n"
"\r\n"
"local type,ipairs,pairs,tonumber=type,ipairs,pairs,tonumber\r\n"
"\r\n"
"local string=string\r\n"
"\r\n"
"local cgilua=cgilua\r\n"
"\r\n"
"local cfg = cfg\r\n"
"\r\n"
"\r\n"
"local luasql = require(\"luasql.mysql\")\r\n"
"local sql = luasql.mysql()\r\n"
"\r\n"
"local dbg=dbg or function(s) cgilua.errorlog(s) end\r\n"
"\r\n"
"module(\"wetgenes.cgilua.mysql\")\r\n"
"\r\n"
"query_count=0\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function setup()\r\n"
"	clean()\r\n"
"	\r\n"
"local err\r\n"
"\r\n"
"	con,err=sql:connect(cfg.mysql_database,cfg.mysql_username,cfg.mysql_password,cfg.mysql_hostname)\r\n"
"	\r\n"
"	if not con then\r\n"
"	\r\n"
"		dbg(\"\\n"
"\"..\"Failed to connect to mysql\"..(err or \"unknown\")..\"\\n"
"\") -- print error\r\n"
"		\r\n"
"		return nil\r\n"
"	end\r\n"
"	\r\n"
"	cgilua.addclosefunction( clean )\r\n"
"\r\n"
"	return _M\r\n"
"end\r\n"
"function clean()\r\n"
"	if con then con:close() end\r\n"
"	con=nil\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert a string into a hex string\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function str_to_hex(s)\r\n"
"	return string.gsub(s, \".\", function (c)\r\n"
"		return string.format(\"%02x\", string.byte(c))\r\n"
"	end)\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- escape a string for mysql, convert to a (possibly large) number in hex\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function mysql_escape(s)\r\n"
"	return \"0x\"..str_to_hex(s)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"--[[\r\n"
"+------------+----------+------+-----+---------+----------------+\r\n"
"| Field      | Type     | Null | Key | Default | Extra          |\r\n"
"+------------+----------+------+-----+---------+----------------+\r\n"
"| Id         | int(11)  | NO   | PRI | NULL    | auto_increment |\r\n"
"| Name       | char(35) | NO   |     |         |                |\r\n"
"| Country    | char(3)  | NO   | UNI |         |                |\r\n"
"| District   | char(20) | YES  | MUL |         |                |\r\n"
"| Population | int(11)  | NO   |     | 0       |                |\r\n"
"+------------+----------+------+-----+---------+----------------+\r\n"
"]]\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- mysql table creation system\r\n"
"--\r\n"
"-- check if a table exists, if it doesnt then just create it\r\n"
"--\r\n"
"-- then check each column, any column that doesnt exist but should is then added\r\n"
"--\r\n"
"-- name is the name of the table\r\n"
"-- cols, consists of the result you would expect from a SHOW COLUMNS FROM query\r\n"
"-- any descrepencies will be reported,\r\n"
"-- see above for example showing columns output\r\n"
"--\r\n"
"-- extra is other mysql key creation to put onto the end of the initial table creation\r\n"
"-- any post creation optimisation will have to happen by hand, maintaining the table columns consistency is the important bit\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function table_create(name,cols,extra)\r\n"
"\r\n"
"local cur,err\r\n"
"local q\r\n"
"\r\n"
"-- build table creation string\r\n"
"\r\n"
"	q=\"\"\r\n"
"	q=q..[[ CREATE TABLE IF NOT EXISTS `]]..name..[[` ( ]]..\"\\n"
"\"\r\n"
"	\r\n"
"	for i,v in ipairs(cols) do\r\n"
"	\r\n"
"		local l\r\n"
"		\r\n"
"		if i==1 then l=\"\" else l=\",\\n"
"\" end\r\n"
"		\r\n"
"		l=l..[[ `]]..v[1]..[[` ]]..v[2]\r\n"
"		\r\n"
"		if v[3]==\"NO\" then l=l..\" NOT NULL\" end\r\n"
"		if v[5] then l=l..\" DEFAULT \"..v[5] end\r\n"
"		if v[6] then l=l..\" \"..v[6] end\r\n"
"		\r\n"
"		q=q..l\r\n"
"	\r\n"
"	end\r\n"
"		\r\n"
"	for i,v in ipairs(cols) do -- add extra key optimizations to the table\r\n"
"	\r\n"
"		if v[4] then\r\n"
"		\r\n"
"			local l=\",\\n"
"\"\r\n"
"			\r\n"
"			if v[4]==\"PRI\" then\r\n"
"			\r\n"
"				l=l..[[ PRIMARY KEY (`]]..v[1]..[[`) ]]\r\n"
"			\r\n"
"			elseif v[4]==\"MUL\" then\r\n"
"			\r\n"
"				l=l..[[ KEY `]]..v[1]..[[` (`]]..v[1]..[[`) ]]\r\n"
"				\r\n"
"			elseif v[4]==\"UNI\" then\r\n"
"			\r\n"
"				l=l..[[ UNIQUE KEY `]]..v[1]..[[` (`]]..v[1]..[[`) ]]\r\n"
"			\r\n"
"			end\r\n"
"			\r\n"
"			q=q..l\r\n"
"			\r\n"
"		end\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	if extra then -- include extra table creation lines for keys etc\r\n"
"	\r\n"
"		q=q..\",\\n"
" \"..extra\r\n"
"	\r\n"
"	end\r\n"
"		\r\n"
"	q=q..[[ ) ]]..\"\\n"
"\"\r\n"
"\r\n"
"--dbg(\"**Preparing table \" ..name..\"\\n"
"\")\r\n"
"--dbg(q)\r\n"
"\r\n"
"	cur,err=con:execute(q)\r\n"
"	if not cur and err then dbg(\"\\n"
"\"..err..\"\\n"
"\") end\r\n"
"	\r\n"
"	cur,err=con:execute(\"SHOW COLUMNS FROM \"..name)\r\n"
"	if not cur and err then dbg(\"\\n"
"\"..err..\"\\n"
"\") end\r\n"
"	\r\n"
"	local i=1\r\n"
"	local r\r\n"
"	local tab={}\r\n"
"\r\n"
"	repeat\r\n"
"	\r\n"
"		r=cur:fetch({})\r\n"
"		tab[i]=r\r\n"
"		i=i+1\r\n"
"	\r\n"
"	until not r\r\n"
"	\r\n"
"--dbg(\"**Checking table \" ..name..\"\\n"
"\")\r\n"
"	for i,v in ipairs(tab) do\r\n"
"	\r\n"
"		local s\r\n"
"		for ii,vv in ipairs(v) do\r\n"
"			if s then s=s..\"\\t\"..vv else s=vv end\r\n"
"		end\r\n"
"	\r\n"
"--		dbg( s..\"\\n"
"\" )\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"--dbg(\"**Created table \" ..name..\"\\n"
"\")\r\n"
"\r\n"
"	if cur then cur:close() end\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- perform the sql queery\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function execute(q,flags)\r\n"
"\r\n"
"local cur,ret,err\r\n"
"local lastid,lastcur\r\n"
"\r\n"
"	\r\n"
"query_count=query_count+1\r\n"
"	cur,err=con:execute(q)\r\n"
"	\r\n"
"	if not cur and err then -- indicate failure\r\n"
"	\r\n"
"		dbg(\"\\n"
"\"..err..\"\\n"
"\") -- print error\r\n"
"		\r\n"
"		return nil\r\n"
"	end\r\n"
"	\r\n"
"	if type(cur)==\"number\" then -- a single number return value\r\n"
"	\r\n"
"		if flags==\"lastid\" and (cur~=0) then -- get last id\r\n"
"		\r\n"
"			lastcur,err=con:execute(\"SELECT LAST_INSERT_ID()\")\r\n"
"			\r\n"
"			if not lastcur and err then -- indicate failure\r\n"
"			\r\n"
"				dbg(\"\\n"
"\"..err..\"\\n"
"\") -- print error\r\n"
"				\r\n"
"				lastid=0\r\n"
"				\r\n"
"			else\r\n"
"			\r\n"
"				lastid=lastcur:fetch({})[1]\r\n"
"				\r\n"
"				lastid=tonumber(lastid)\r\n"
"				\r\n"
"				if lastcur then lastcur:close() end\r\n"
"				\r\n"
"--				dbg(\"\\n"
" LASTID = \"..lastid..\"\\n"
"\") -- print error\r\n"
"			end\r\n"
"			\r\n"
"			return lastid\r\n"
"		end\r\n"
"	\r\n"
"		return cur\r\n"
"	end\r\n"
"	\r\n"
"	ret={}\r\n"
"	\r\n"
"	ret.names=cur:getcolnames()\r\n"
"	ret.types=cur:getcoltypes()\r\n"
"	\r\n"
"	local i=1\r\n"
"	local r\r\n"
"	\r\n"
"	repeat\r\n"
"	\r\n"
"		r=cur:fetch({})\r\n"
"		ret[i]=r\r\n"
"		i=i+1\r\n"
"	\r\n"
"	until not r\r\n"
"		\r\n"
"	if cur then cur:close() end\r\n"
"	return ret\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- fill up a table with named results\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function named(tab,idx)\r\n"
"\r\n"
"	if (not tab) or (not tab[idx]) then return nil end\r\n"
"\r\n"
"local ret={}\r\n"
"\r\n"
"	for i,v in ipairs(tab.names) do\r\n"
"		ret[v]=tab[idx][i]\r\n"
"	end\r\n"
"\r\n"
"	return ret\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- insert or update data on clash, similar format to the lanes returned info\r\n"
"-- this function doesnt do anything it just builds a queery string that will\r\n"
"--\r\n"
"-- name == table name\r\n"
"-- row == data to insert\r\n"
"--\r\n"
"-- row.names == table of named columns\r\n"
"-- row[1] == table of data (strings need to have already been fixed/escaped)\r\n"
"--\r\n"
"-- this is a single insert or update, so there is only one row\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function make_set(name,row)\r\n"
"\r\n"
"local q=\"INSERT INTO \"..name..\" SET \"\r\n"
"\r\n"
"	for i,v in ipairs(row.names) do\r\n"
"	\r\n"
"		local sep=\", \\n"
"\" if i==1 then sep=\" \\n"
"\" end\r\n"
"		\r\n"
"		q=q..sep..v..\"=\"..row[1][i]..\" \"\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	q=q..\"\\n"
" ON DUPLICATE KEY UPDATE \"\r\n"
"\r\n"
"	for i,v in ipairs(row.names) do\r\n"
"	\r\n"
"		local sep=\", \\n"
"\" if i==1 then sep=\" \\n"
"\" end\r\n"
"		\r\n"
"		q=q..sep..v..\"=\"..row[1][i]..\" \"\r\n"
"	\r\n"
"	end\r\n"
"		\r\n"
"	return q\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- insert only, similar format to the lanes returned info\r\n"
"-- this function doesnt do anything it just builds a queery string that will\r\n"
"--\r\n"
"-- name == table name\r\n"
"-- row == data to insert\r\n"
"--\r\n"
"-- row.names == table of named columns\r\n"
"-- row[1] == table of data (strings need to have already been fixed/escaped)\r\n"
"--\r\n"
"-- this is a single insert or update, so there is only one row\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function make_insert(name,row)\r\n"
"\r\n"
"local q=\"INSERT INTO \"..name..\" SET \"\r\n"
"\r\n"
"	for i,v in ipairs(row.names) do\r\n"
"	\r\n"
"		local sep=\", \\n"
"\" if i==1 then sep=\" \\n"
"\" end\r\n"
"		\r\n"
"		q=q..sep..v..\"=\"..row[1][i]..\" \"\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	q=q..\"\\n"
"\"\r\n"
"		\r\n"
"	return q\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- update only, similar format to the lanes returned info\r\n"
"-- this function doesnt do anything it just builds a queery string that will\r\n"
"--\r\n"
"-- name == table name\r\n"
"-- row == data to insert\r\n"
"-- where == where to update\r\n"
"--\r\n"
"-- row.names == table of named columns\r\n"
"-- row[1] == table of data (strings need to have already been fixed/escaped)\r\n"
"--\r\n"
"-- this is a single insert or update, so there is only one row\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function make_update(name,row,where)\r\n"
"\r\n"
"local q=\"UPDATE \"..name..\" SET \"\r\n"
"\r\n"
"	for i,v in ipairs(row.names) do\r\n"
"	\r\n"
"		local sep=\", \\n"
"\" if i==1 then sep=\" \\n"
"\" end\r\n"
"		\r\n"
"		q=q..sep..v..\"=\"..row[1][i]..\" \"\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	q=q..\"\\n"
" WHERE \"..where\r\n"
"		\r\n"
"	return q\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert a table into a row set\r\n"
"--\r\n"
"-- returns row where\r\n"
"--\r\n"
"-- row.names == table of named columns\r\n"
"-- row[1] == table of data with strings fixed/escaped\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function tab_to_row(dat)\r\n"
"\r\n"
"	local idx=1\r\n"
"	local row={}\r\n"
"	row.names={}\r\n"
"	row[1]={}\r\n"
"	\r\n"
"	for n,v in pairs(dat) do -- build and fixup mysql data\r\n"
"	\r\n"
"		row.names[idx]=n\r\n"
"		\r\n"
"		if type(v)==\"string\" then\r\n"
"		\r\n"
"			if v==\"\" then\r\n"
"			\r\n"
"				row[1][idx]=\"DEFAULT\"\r\n"
"				\r\n"
"			else\r\n"
"		\r\n"
"				row[1][idx]=mysql_escape(v)\r\n"
"			\r\n"
"			end\r\n"
"			\r\n"
"		else\r\n"
"		\r\n"
"			row[1][idx]=v\r\n"
"		\r\n"
"		end\r\n"
"		\r\n"
"		idx=idx+1\r\n"
"	\r\n"
"	end\r\n"
"		\r\n"
"	return row\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- create and perform a blocking data insert or update\r\n"
"--\r\n"
"-- just pass in a tab and it will build and execute a sql query to add or change that data\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function do_set(name,tab)\r\n"
"\r\n"
"	return execute( make_set(name,tab_to_row(tab)) , \"lastid\" )\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- create and perform a blocking data insert\r\n"
"--\r\n"
"-- just pass in a tab and it will build and execute a sql query to add or change that data\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function do_insert(name,tab)\r\n"
"\r\n"
"	return execute( make_insert(name,tab_to_row(tab)) , \"lastid\" )\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- create and perform a blocking data update\r\n"
"--\r\n"
"-- just pass in a tab and it will build and execute a sql query to add or change that data\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function do_update(name,tab,where)\r\n"
"\r\n"
"	return execute( make_update(name,tab_to_row(tab),where) )\r\n"
"	\r\n"
"end\r\n"
"",

"yarn.cell","\n"
"\n"
"-- a single location\n"
"\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"module(...)\n"
"local yarn_attr=require(\"yarn.attr\")\n"
"local yarn_item=require(\"yarn.item\")\n"
"\n"
"\n"
"local a_space=string.byte(\" \",1)\n"
"local a_under=string.byte(\"_\",1)\n"
"local a_star=string.byte(\"*\",1)\n"
"local a_hash=string.byte(\"#\",1)\n"
"local a_dash=string.byte(\"-\",1)\n"
"local a_pipe=string.byte(\"|\",1)\n"
"local a_plus=string.byte(\"+\",1)\n"
"local a_dot=string.byte(\".\",1)\n"
"local a_equal=string.byte(\"=\",1)\n"
"\n"
"\n"
"function create(t,_level)\n"
"\n"
"local d={}\n"
"setfenv(1,d)\n"
"\n"
"	is=yarn_attr.create(t)\n"
"	metatable={__index=is}\n"
"	setmetatable(d,metatable)\n"
"\n"
"	level=t.level or _level\n"
"	\n"
"-- location in the map\n"
"\n"
"	level=t.level\n"
"	xp=t.xp or 0\n"
"	yp=t.yp or 0\n"
"	id=t.id or 0\n"
"		\n"
"	items={}\n"
"	\n"
"	set.name(\"wall\")\n"
"	\n"
"	function neighbours()\n"
"		local n_x_look={  0 , -1 , 1 , 0 }\n"
"		local n_y_look={ -1 ,  0 , 0 , 1 }\n"
"		return function(d,i)\n"
"			if i>4 then return nil,nil end -- no more edges\n"
"			return i+1 , level.get_cell( xp+n_x_look[i] , yp+n_y_look[i] )\n"
"		end , d , 1\n"
"	end\n"
"	\n"
"	function neighboursplus()\n"
"		local n_x_look={ 0,  0 , -1 , 1 , 0 }\n"
"		local n_y_look={ 0, -1 ,  0 , 0 , 1 }\n"
"		return function(d,i)\n"
"			if i>5 then return nil,nil end -- no more edges\n"
"			return i+1 , level.get_cell( xp+n_x_look[i] , yp+n_y_look[i] )\n"
"		end , d , 1\n"
"	end\n"
"\n"
"	function borders()\n"
"		local n_x_look={ -1 ,  0 ,  1 , -1 , 1 , -1 , 0 , 1 }\n"
"		local n_y_look={ -1 , -1 , -1 ,  0 , 0 ,  1 , 1 , 1 }\n"
"		return function(d,i)\n"
"			if i>8 then return nil,nil end -- no more edges\n"
"			return i+1 , level.get_cell( xp+n_x_look[i] , yp+n_y_look[i] )\n"
"		end , d , 1\n"
"	end\n"
"	\n"
"	function bordersplus()\n"
"		local n_x_look={ 0, -1 ,  0 ,  1 , -1 , 1 , -1 , 0 , 1 }\n"
"		local n_y_look={ 0, -1 , -1 , -1 ,  0 , 0 ,  1 , 1 , 1 }\n"
"		return function(d,i)\n"
"			if i>9 then return nil,nil end -- no more edges\n"
"			return i+1 , level.get_cell( xp+n_x_look[i] , yp+n_y_look[i] )\n"
"		end , d , 1\n"
"	end\n"
"\n"
"	function get_item() -- although there are multiple item slots, just pick one\n"
"		for v,b in pairs(items) do\n"
"			if v.form==\"item\" then return v end\n"
"		end\n"
"	end\n"
"	\n"
"	function get_char() -- find the char in the items list or nil if no char\n"
"		for v,b in pairs(items) do\n"
"			if v.form==\"char\" then return v end\n"
"		end\n"
"	end\n"
"	\n"
"	function is_empty()\n"
"		if name==\"floor\" and not get_char() then return true end\n"
"		return false\n"
"	end\n"
"	\n"
"	function asc()\n"
"		if not is.get.visible() then return a_space end\n"
"		\n"
"		local char=get_char()\n"
"		local item=get_item()\n"
"		\n"
"		if char then\n"
"			return char.asc()\n"
"		end\n"
"		\n"
"		if item then return item.asc() end\n"
"		\n"
"		if name==\"wall\" then -- some cells are just walls\n"
"			return a_hash\n"
"		else\n"
"			return a_dot\n"
"		end\n"
"			\n"
"		return a_hash\n"
"	end\n"
"\n"
"-- create a save state for this data\n"
"	function save()\n"
"		local sd={}\n"
"		sd=yarn_attr.save(is)\n"
"		\n"
"		sd.xp=nil\n"
"		sd.yp=nil\n"
"		sd.id=nil\n"
"		\n"
"		for v,b in pairs(items) do\n"
"			sd.items=sd.items or {}\n"
"			sd.items[#sd.items+1]=v.save()\n"
"		end\n"
"		\n"
"		return sd\n"
"	end\n"
"\n"
"-- reload a saved data (create and then load)\n"
"	function load(sd)\n"
"\n"
"		is=yarn_attr.load(sd)\n"
"		d.is=is\n"
"		d.metatable.__index=is\n"
"\n"
"		if sd.items then\n"
"			for i,v in pairs(sd.items) do\n"
"				local it=yarn_item.create({level=level})\n"
"				level.items[it]=true\n"
"				items[it]=true\n"
"				it.set_cell(d)\n"
"				it.load(v)\n"
"			end\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	return d\n"
"	\n"
"end\n"
"\n"
"",

"yarn.map","\n"
"-- build your own dungeon\n"
"--\n"
"-- a little bit hacky but hey, i didnt knw how i was going to do it when i started :)\n"
"\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"\n"
"module(...)\n"
"\n"
"\n"
"\n"
"local a_space=string.byte(\" \",1)\n"
"local a_under=string.byte(\"_\",1)\n"
"local a_star=string.byte(\"*\",1)\n"
"local a_hash=string.byte(\"#\",1)\n"
"local a_dash=string.byte(\"-\",1)\n"
"local a_dot=string.byte(\".\",1)\n"
"\n"
"\n"
"function create(opts)\n"
"\n"
"	local d=build_map(opts)\n"
"	\n"
"	return d\n"
"end\n"
"\n"
"\n"
"function build_map(opts)\n"
"	\n"
"local d={}\n"
"\n"
"	d.opts=opts\n"
"\n"
"local asc={}\n"
"local asc_xh=0\n"
"local asc_yh=0	\n"
"\n"
"\n"
"if opts.mode==\"town\" then\n"
"\n"
"	opts.bigroom=true\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"function d.rand_weight_change()\n"
"\n"
"local a\n"
"	d.rx={}\n"
"	d.ry={}\n"
"	\n"
"	d.ry[-1]=0\n"
"	for y=0,asc_yh-1 do\n"
"		d.ry[y]=0\n"
"		for x=0,asc_xh-1 do\n"
"			a=d.get_asc(x,y)\n"
"			if a~=a_dot then\n"
"				d.ry[y]=d.ry[y]+1\n"
"				d.ry[-1]=d.ry[-1]+1\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	d.rx[-1]=0\n"
"	for x=0,asc_xh-1 do\n"
"		d.rx[x]=0\n"
"		for y=0,asc_yh-1 do\n"
"			a=d.get_asc(x,y)\n"
"			if a~=a_dot then\n"
"				d.rx[x]=d.rx[x]+1\n"
"				d.rx[-1]=d.rx[-1]+1\n"
"			end\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"function d.rand_weight_xy()\n"
"\n"
"	local r\n"
"	\n"
"	r=d.rand(0,d.rx[-1]-1)\n"
"	for i=0,asc_xh-1 do\n"
"		r=r-d.rx[i]\n"
"		if r<=0 then\n"
"			d.x=i\n"
"			break\n"
"		end\n"
"	end\n"
"\n"
"	r=d.rand(0,d.rx[-1]-1)\n"
"	for i=0,asc_yh-1 do\n"
"		r=r-d.ry[i]\n"
"		if r<=0 then\n"
"			d.y=i\n"
"			break\n"
"		end\n"
"	end\n"
"	\n"
"end\n"
"\n"
"function d.rand_xy_door(room)\n"
"	local r=d.rand(1,4) -- pick a wall\n"
"	\n"
"	if r==1 then \n"
"		d.x=room.x-1\n"
"		d.y=d.rand(room.y+1,room.y+room.yh-2)\n"
"		d.vx=-1\n"
"		d.vy=0\n"
"	elseif r==2 then \n"
"		d.x=room.x+room.xh\n"
"		d.y=d.rand(room.y+1,room.y+room.yh-2)\n"
"		d.vx=1\n"
"		d.vy=0\n"
"	elseif r==3 then \n"
"		d.x=d.rand(room.x+1,room.x+room.xh-2)\n"
"		d.y=room.y-1\n"
"		d.vx=0\n"
"		d.vy=-1\n"
"	elseif r==4 then \n"
"		d.x=d.rand(room.x+1,room.x+room.xh-2)\n"
"		d.y=room.y+room.yh\n"
"		d.vx=0\n"
"		d.vy=1\n"
"	end\n"
"	return r\n"
"end\n"
"\n"
"function d.rand(a,b)\n"
"	if a>=b then return a end\n"
"	return math.random(a,b)\n"
"end\n"
"function d.rand_xy()\n"
"	d.x=d.rand(0,asc_xh-1)\n"
"	d.y=d.rand(0,asc_yh-1)\n"
"end\n"
"\n"
"function d.get_asc(x,y)\n"
"	if x<0 then return nil end\n"
"	if y<0 then return nil end\n"
"	if x>=asc_xh then return nil end\n"
"	if y>=asc_yh then return nil end\n"
"	return asc[1+x+y*asc_xh]\n"
"end\n"
"\n"
"function d.set_asc(x,y,a)\n"
"	if x<0 then return nil end\n"
"	if y<0 then return nil end\n"
"	if x>=asc_xh then return nil end\n"
"	if y>=asc_yh then return nil end\n"
"	asc[1+x+y*asc_xh]=a\n"
"	return true\n"
"end\n"
"\n"
"function d.room_rand()\n"
"	d.rand_weight_xy()\n"
"	d.xh=d.rand(1,4)\n"
"	d.yh=d.rand(1,4)\n"
"	d.x=d.x-d.xh\n"
"	d.y=d.y-d.yh\n"
"	d.xh=d.xh+d.rand(2,5)\n"
"	d.yh=d.yh+d.rand(2,5)\n"
"--	if d.xh==2 and d.yh==2 then d.xh=3 end -- do not allow 2x2 rooms\n"
"\n"
"	if #d.rooms < #opts.rooms then\n"
"		local r=opts.rooms[ #d.rooms+1 ]\n"
"		d.xh=r.xh\n"
"		d.yh=r.yh\n"
"		d.r=r\n"
"	else\n"
"		if opts.only_these_rooms then\n"
"			return\n"
"		end\n"
"	end\n"
"	\n"
"	if d.room_check() then d.room_dig() end\n"
"end\n"
"function d.room_check()\n"
"	if opts.bigroom then -- bigroom rooms need more space\n"
"		for y=d.y-1-2,d.y+d.yh+2 do\n"
"			for x=d.x-1-2,d.x+d.xh+2 do\n"
"				local a=d.get_asc(x,y)\n"
"				if (not a) or (a==a_dot) then return false end\n"
"			end\n"
"		end\n"
"	else\n"
"		for y=d.y-1,d.y+d.yh do\n"
"			for x=d.x-1,d.x+d.xh do\n"
"				local a=d.get_asc(x,y)\n"
"				if (not a) or (a==a_dot) then return false end\n"
"			end\n"
"		end\n"
"	end\n"
"	return true\n"
"end\n"
"function d.room_dig()\n"
"	for y=d.y,d.y+d.yh-1 do\n"
"		for x=d.x,d.x+d.xh-1 do\n"
"			d.set_asc(x,y,a_dot)\n"
"		end\n"
"	end\n"
"	d.rand_weight_change()\n"
"	local r={}\n"
"	r.x=d.x\n"
"	r.y=d.y\n"
"	r.xh=d.xh\n"
"	r.yh=d.yh\n"
"	r.doors={}\n"
"	table.insert(d.rooms,r)\n"
"	table.insert(d.rooms_groups,{r})\n"
"	if d.r then r.opts=d.r d.r=nil end -- map room opts \n"
"	return r\n"
"end\n"
"\n"
"function d.bigroom_dig()\n"
"	local r={}\n"
"	r.x=1\n"
"	r.y=1\n"
"	r.xh=asc_xh-2\n"
"	r.yh=asc_yh-2\n"
"	r.doors={}\n"
"	table.insert(d.rooms_groups,{r})\n"
"	if d.r then r.opts=d.r d.r=nil end -- map room opts \n"
"	return r\n"
"end\n"
"\n"
"function d.room_remove(r)\n"
"\n"
"	for y=r.y,r.y+r.yh-1 do\n"
"		for x=r.x,r.x+r.xh-1 do\n"
"			d.set_asc(x,y,a_dash)\n"
"		end\n"
"	end\n"
"	\n"
"	d.rand_weight_change()\n"
"	\n"
"	for i,v in ipairs(d.rooms) do\n"
"		if v==r then\n"
"			table.remove(d.rooms,i)\n"
"		end\n"
"	end\n"
"	\n"
"	for i,rg in ipairs(d.rooms_groups) do\n"
"		for i,v in ipairs(rg) do\n"
"			if v==r then\n"
"				table.remove(rg,i)\n"
"			end\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"\n"
"-- try and connect all the rooms\n"
"\n"
"function d.room_find(x,y)\n"
"\n"
"	for i,v in ipairs(d.rooms) do\n"
"		if v.x<=x and v.x+v.xh>x and v.y<=y and v.y+v.yh>y then -- hit\n"
"			return v\n"
"		end\n"
"	end\n"
"	\n"
"	if opts.bigroom then -- hit a wall, or we hit the bigroom\n"
"	\n"
"		if x==0 or x==asc_xh-1 or y==0 or y==asc_yh-1 then -- map border\n"
"			return nil\n"
"		end\n"
"\n"
"		for i,v in ipairs(d.rooms) do\n"
"			if v.xh>1 or v.yh>1 then -- ignore alleys\n"
"				if v.x-1<=x and v.x+v.xh+1>x and v.y-1<=y and v.y+v.yh+1>y then -- hit room border\n"
"					return nil\n"
"				end\n"
"			end\n"
"		end\n"
"		\n"
"-- finally we hit the bigroom by default\n"
"\n"
"		return d.bigroom\n"
"		\n"
"	end\n"
"	\n"
"	return nil\n"
"end\n"
"\n"
"function d.alleys_merge_find(r1,r2)\n"
"\n"
"local g1,g2\n"
"\n"
"	for g,v in ipairs(d.rooms_groups) do\n"
"		for r,v in ipairs(v) do\n"
"			if v==r1 then g1=g end\n"
"			if v==r2 then g2=g end\n"
"		end\n"
"	end\n"
"	\n"
"	return g1,g2\n"
"end\n"
"\n"
"function d.alleys_merge(r1,r2)\n"
"\n"
"local g1,g2=d.alleys_merge_find(r1,r2)\n"
"\n"
"--print(g1..\" - \"..g2)\n"
"	if g1~=g2 then\n"
"		for i,v in ipairs(d.rooms_groups[g2]) do -- merge groups\n"
"			table.insert(d.rooms_groups[g1],v)\n"
"		end\n"
"		table.remove(d.rooms_groups,g2) -- destroy old groups\n"
"	end\n"
"end\n"
"\n"
"function d.alleys_rand()\n"
"\n"
"	for i=1000,1,-1 do -- check quite a lot\n"
"	\n"
"--print(i..\":\"..#d.rooms_groups)\n"
"	\n"
"		if #d.rooms_groups<=1 then break end -- all connected, we will probably drop out here \n"
"			\n"
"	local r2=nil\n"
"	local g=d.rooms_groups[ 1+(i % #d.rooms_groups) ] -- simple group weighting\n"
"	local r=g[ d.rand(1,#g) ]\n"
"	local door=d.rand_xy_door(r)\n"
"	local door_hit=0\n"
"	\n"
"--		if not r.doors[door] then -- only one room per room side\n"
"		\n"
"			local fail=true\n"
"			--	print(\"start \"..d.x..\" , \"..d.y)\n"
"			if d.get_asc(d.x,d.y)==a_hash then -- can start digging\n"
"				if d.vx~=0 then\n"
"					local y=d.y\n"
"					for x=d.x,d.x+d.vx*1000 do\n"
"						local a=d.get_asc(x,y)\n"
"						if a==nil then break end -- hit edge\n"
"						if a==a_dot then -- found another alley/room\n"
"							r2=d.room_find(x,y)\n"
"							d.xh=x-d.x\n"
"							d.yh=1\n"
"							fail=false\n"
"							break\n"
"						end\n"
"						if d.get_asc(x,y-1)==a_dot then\n"
"							r2=d.room_find(x,y-1)\n"
"							break\n"
"						elseif d.get_asc(x,y+1)==a_dot then\n"
"							r2=d.room_find(x,y+1)\n"
"							break\n"
"						end\n"
"--[[\n"
"						if r2 then\n"
"							d.xh=x-d.x+1\n"
"							d.yh=1\n"
"							fail=false\n"
"							break\n"
"						end\n"
"]]\n"
"					end\n"
"				elseif d.vy~=0 then\n"
"					local x=d.x\n"
"					for y=d.y,d.y+d.vy*1000 do\n"
"						local a=d.get_asc(x,y)\n"
"						if a==nil then break end -- hit edge\n"
"						if a==a_dot then -- found another alley/room\n"
"							r2=d.room_find(x,y)\n"
"							d.yh=y-d.y\n"
"							d.xh=1\n"
"							fail=false\n"
"							break\n"
"						end\n"
"						if d.get_asc(x-1,y)==a_dot then\n"
"							r2=d.room_find(x-1,y)\n"
"							break\n"
"						elseif d.get_asc(x+1,y)==a_dot then\n"
"							r2=d.room_find(x+1,y)\n"
"							break\n"
"						end\n"
"--[[\n"
"						if r2 then\n"
"							d.yh=y-d.y+1\n"
"							d.xh=1\n"
"							fail=false\n"
"							break\n"
"						end\n"
"]]\n"
"					end\n"
"				end\n"
"			end\n"
"			\n"
"			if not fail then\n"
"			\n"
"				local g1,g2=d.alleys_merge_find(r,r2)\n"
"				\n"
"				local c1,c2\n"
"				\n"
"	if d.x==r.x or d.x==r.x+r.xh-1 or d.y==r.y or d.y==r.y+r.yh-1 then c1=true end\n"
"	if d.x+d.xh-1==r2.x or d.x+d.xh-1==r2.x+r2.xh-1 or d.y+d.yh-1==r2.y or d.y+d.yh-1==r2.y+r2.yh-1 then c2=true end\n"
"				\n"
"				if g1~=g2 and not c1 and not c2 then -- only if it connects two groups\n"
"\n"
"					local alley=d.room_dig()\n"
"					table.insert(r.doors,alley)\n"
"					table.insert(alley.doors,r)\n"
"					table.insert(r2.doors,alley)\n"
"					table.insert(alley.doors,r2)\n"
"					\n"
"					d.alleys_merge(r,alley)\n"
"					d.alleys_merge(r,r2)\n"
"					\n"
"				end\n"
"				\n"
"			end\n"
"		\n"
"--		end\n"
"	end\n"
"	\n"
"end\n"
"\n"
"-- remove all rooms that are not in the biggest connection group\n"
"function d.rooms_prune()\n"
"\n"
"	if #d.rooms_groups<=1 then return end\n"
"	\n"
"	local mx=d.rooms_groups[1]\n"
"	\n"
"	for i,v in ipairs(d.rooms_groups) do\n"
"	\n"
"		if #v > #mx then mx=v end -- biggest\n"
"		\n"
"	end\n"
"\n"
"	for i,v in ipairs(d.rooms_groups) do\n"
"	\n"
"		if v==mx then\n"
"			-- main group\n"
"		else\n"
"			for i,v in ipairs(v) do\n"
"				d.room_remove(v)\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	d.rooms_groups={mx} -- only one group remains\n"
"	\n"
"end\n"
"\n"
"\n"
"-- fill level with solid\n"
"	asc_xh=opts.xh\n"
"	asc_yh=opts.yh\n"
"	\n"
"	for y=0,asc_yh-1 do\n"
"		for x=0,asc_xh-1 do\n"
"		\n"
"			i=1+x+y*asc_xh\n"
"			asc[i]=a_hash\n"
"\n"
"		end\n"
"	end\n"
"	\n"
"	math.randomseed(os.time())\n"
"	\n"
"	d.rooms={}\n"
"	d.rooms_groups={} -- every room starts in its own group, then we try and join them all into one\n"
"\n"
"	if opts.bigroom then\n"
"		d.bigroom=d.bigroom_dig()\n"
"	end\n"
"	\n"
"	d.rand_weight_change()\n"
"	for i=1,100 do\n"
"		d.room_rand()\n"
"	end\n"
"	\n"
"	if opts.bigroom then\n"
"		for y=0,asc_yh do\n"
"			for x=0,asc_xh do\n"
"				if d.room_find(x,y)==d.bigroom then -- add the main big room\n"
"					d.set_asc(x,y,a_dot)\n"
"				end\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	d.alleys_rand()\n"
"	\n"
"	d.rooms_prune()\n"
"	\n"
"	\n"
"-- check we got all the special rooms\n"
"	local gotroom={}\n"
"	for i,v in ipairs(d.rooms) do\n"
"		if v.opts then\n"
"			gotroom[v.opts]=true\n"
"		end\n"
"	end\n"
"	for i,v in ipairs(opts.rooms) do\n"
"		if not gotroom[v] then\n"
"			return build_map(opts) -- try again\n"
"		end\n"
"	end\n"
"	\n"
"	\n"
"	return d\n"
"	\n"
"end\n"
"\n"
"",

"yarn.attr","\n"
"-- shared attributes, across cells, items and chars\n"
"-- we metamap .attr in these tables so cell.get gets attributes\n"
"\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"module(...)\n"
"local yarn_attrs=require(\"yarn.attrs\")\n"
"\n"
"-- pass in a table created by yarn_attrs.get\n"
"function create(ad)\n"
"	\n"
"local d=ad\n"
"setfenv(1,d)\n"
"\n"
"-- any state data you expect to persist must be stored in the base table\n"
"-- never change any of the sub tables, eg .can as these are\n"
"-- shared tables so any change will effect all other objects of the same class\n"
"-- all datagoes into this main table\n"
"\n"
"\n"
"	set={}\n"
"	get={}\n"
"	can=can or {} -- this may be shared data but we always need a table\n"
"\n"
"	function set.name(v)       name=v end\n"
"	function get.name() return name   end\n"
"	\n"
"	function set.visible(v)       visible=v end\n"
"	function get.visible() return visible   end\n"
"	\n"
"	\n"
"--	function get.visible() return true end -- debug\n"
"\n"
"	return d\n"
"	\n"
"end\n"
"\n"
"-- create a save state for this attr which contains enough information\n"
"-- to recreate this attr when combined with the attrdata tables\n"
"-- so this is a diff from an yarn_attrs.get\n"
"-- the result should be good to save as json\n"
"function save(it)\n"
"\n"
"	local ad=yarn_attrs.get(it.name,it.pow) -- get base data to compare\n"
"	local sd={}\n"
"	for i,v in pairs(it) do\n"
"		if ( type(ad[i])==type(v) ) and ad[i]==v then -- no change from base\n"
"		else\n"
"			if type(v)==\"table\" then --ignore tables, one deep save only\n"
"			else\n"
"				sd[i]=v -- this is something we are interested in\n"
"			end\n"
"		end\n"
"	end\n"
"-- always include these two\n"
"\n"
"	sd.name=it.name\n"
"	sd.pow=it.pow\n"
"	if sd.pow==0 then sd.pow=nil end\n"
"	\n"
"	return sd -- a table of changes to base data\n"
"end\n"
"\n"
"-- reload a saved data (use instead of create)\n"
"function load(sd)\n"
"	return create( yarn_attrs.get(sd.name,sd.pow,sd) ) -- unpack and create\n"
"end\n"
"\n"
"\n"
"-- names that have a .in them are sub classes\n"
"-- we need to be able to find them using their subclass\n"
"-- so turn a name with . into a list of possible names\n"
"-- the last part may be a number in which case it is the pow value\n"
"function keys_name_and_subnames(s)\n"
"	local splits={}\n"
"	local i=1\n"
"	repeat\n"
"		i=s:find(\".\",i,true)\n"
"		if i then\n"
"			splits[ #splits+1 ] = s:sub(1,i-1)\n"
"			i=i+1\n"
"		end\n"
"	until not i\n"
"	splits[ #splits+1 ]=s -- add all last\n"
"	return splits\n"
"end\n"
"\n"
"\n"
"",

"fenestra.widget","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"--\r\n"
"-- handle widgets\r\n"
"--\r\n"
"\r\n"
"\r\n"
"local widget_meta=require(\"fenestra.widget.meta\")\r\n"
"local widget_skin=require(\"fenestra.widget.skin\")\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget\")\r\n"
"\r\n"
"\r\n"
"--\r\n"
"-- create a master widget\r\n"
"--\r\n"
"function setup(win,def)\r\n"
"\r\n"
"	local meta={}\r\n"
"	meta.__index=meta\r\n"
"	local master={} -- the master widget, all numerical keys of a widget are the widgets children\r\n"
"	setmetatable(master,meta)\r\n"
"	master.parent=master -- we are our own parent, probably safer than setting as null\r\n"
"	master.master=master -- and our own master\r\n"
"	\r\n"
"	master.font=def.font\r\n"
"	\r\n"
"	def.master=master\r\n"
"	def.meta=meta\r\n"
"	def.win=win\r\n"
"\r\n"
"	widget_meta.setup(def)\r\n"
"	widget_skin.setup(def)\r\n"
"	\r\n"
"-- default GUI size if no other is specified\r\n"
"	def.hx=def.hx or 640\r\n"
"	def.hy=def.hy or 480\r\n"
"	def.px=def.px or 0\r\n"
"	def.py=def.py or 0\r\n"
"	def.pxd=def.pxd or 0\r\n"
"	def.pyd=def.pyd or def.hy\r\n"
"\r\n"
"	def.class=def.class or \"master\"\r\n"
"	\r\n"
"	master:setup(def)\r\n"
"	\r\n"
"	return master -- our new widget is ready\r\n"
"\r\n"
"end\r\n"
"\r\n"
"",

"coxpcall","-------------------------------------------------------------------------------\n"
"-- Coroutine safe xpcall and pcall versions\n"
"--\n"
"-- Encapsulates the protected calls with a coroutine based loop, so errors can\n"
"-- be dealed without the usual Lua 5.x pcall/xpcall issues with coroutines\n"
"-- yielding inside the call to pcall or xpcall.\n"
"--\n"
"-- Authors: Roberto Ierusalimschy and Andre Carregal \n"
"-- Contributors: Thomas Harning Jr., Ignacio Burgueo, Fbio Mascarenhas\n"
"--\n"
"-- Copyright 2005 - Kepler Project (www.keplerproject.org)\n"
"--\n"
"-- $Id: coxpcall.lua,v 1.13 2008/05/19 19:20:02 mascarenhas Exp $\n"
"-------------------------------------------------------------------------------\n"
"\n"
"-------------------------------------------------------------------------------\n"
"-- Implements xpcall with coroutines\n"
"-------------------------------------------------------------------------------\n"
"local performResume, handleReturnValue\n"
"local oldpcall, oldxpcall = pcall, xpcall\n"
"\n"
"function handleReturnValue(err, co, status, ...)\n"
"    if not status then\n"
"        return false, err(debug.traceback(co, (...)), ...)\n"
"    end\n"
"    if coroutine.status(co) == 'suspended' then\n"
"        return performResume(err, co, coroutine.yield(...))\n"
"    else\n"
"        return true, ...\n"
"    end\n"
"end\n"
"\n"
"function performResume(err, co, ...)\n"
"    return handleReturnValue(err, co, coroutine.resume(co, ...))\n"
"end    \n"
"\n"
"function coxpcall(f, err, ...)\n"
"    local res, co = oldpcall(coroutine.create, f)\n"
"    if not res then\n"
"        local params = {...}\n"
"        local newf = function() return f(unpack(params)) end\n"
"        co = coroutine.create(newf)\n"
"    end\n"
"    return performResume(err, co, ...)\n"
"end\n"
"\n"
"-------------------------------------------------------------------------------\n"
"-- Implements pcall with coroutines\n"
"-------------------------------------------------------------------------------\n"
"\n"
"local function id(trace, ...)\n"
"  return ...\n"
"end\n"
"\n"
"function copcall(f, ...)\n"
"    return coxpcall(f, id, ...)\n"
"end\n"
"",

"yarn.version","\n"
"module(...)\n"
"\n"
"name=\"Swordstone\"\n"
"number=11.951\n"
"\n"
"",

"fenestra.widget.pan","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"-- an fbo cached area, that is an area which should always be drawn to a special buffer\r\n"
"-- and then the special buffer should be displayed\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.pan\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.pan=it\r\n"
"	widget.class=\"pan\"\r\n"
"	\r\n"
"	widget.pan_px=0\r\n"
"	widget.pan_py=0\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.draw=draw\r\n"
"	\r\n"
"	widget.fbo=_G.win.fbo(0,0,0)\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"",

"yarn.item","\n"
"-- a single item\n"
"\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local dbg=dbg or function()end\n"
"\n"
"\n"
"\n"
"module(...)\n"
"local yarn_attr=require(\"yarn.attr\")\n"
"local yarn_attrs=require(\"yarn.attrs\")\n"
"local yarn_fight=require(\"yarn.fight\")\n"
"local yarn_level=require(\"yarn.level\")\n"
"\n"
"\n"
"function create(t,_level)\n"
"\n"
"	\n"
"local d={}\n"
"setfenv(1,d)\n"
"\n"
"	is=yarn_attr.create(t) -- allow attr access via item.is.wood syntax\n"
"	metatable={__index=is} -- or without the is if we do not fear nameclash\n"
"	setmetatable(d,metatable)\n"
"\n"
"	level=_level or t.level\n"
"	class=t.class\n"
"	\n"
"	time_passed=level.time_passed\n"
"	\n"
"	function del()\n"
"		if cell then -- remove link from old cell\n"
"			cell.items[d]=nil\n"
"		end\n"
"	end\n"
"\n"
"-- remove from cell but remember which cell\n"
"	function un_cell()\n"
"		local c=cell\n"
"		if c then -- remove link from old cell but remember where it was in item attrs\n"
"			is.cell_xp=c.xp\n"
"			is.cell_yp=c.yp\n"
"			c.items[d]=nil\n"
"		end\n"
"		cell=nil\n"
"		return c\n"
"	end\n"
"--put back in the cell it wasremoved from\n"
"	function re_cell()\n"
"		local c=level.get_cell(is.cell_xp,is.cell_yp)\n"
"		is.cell_xp=nil\n"
"		is.cell_yp=nil\n"
"		set_cell(c)\n"
"		return c\n"
"	end\n"
"	\n"
"\n"
"\n"
"	function set_cell(c)\n"
"	\n"
"		if cell then -- remove link from old cell\n"
"			cell.items[d]=nil\n"
"		end\n"
"		\n"
"		cell=c\n"
"		if not cell.items then cell.items={} end -- make space in non cells\n"
"		cell.items[d]=true\n"
"		\n"
"		if can.make_room_visible then -- this item makes the room visible (ie its the player)\n"
"			if cell.room then\n"
"				for i,v in cell.neighboursplus() do -- apply to neighbours and self\n"
"					if v.room and ( not v.room.get.visible() ) then -- if room is not visible\n"
"--dbg(\"setting room visible\")\n"
"						local n=v.room.set_visible(true)\n"
"						if n>0 then\n"
"							yarn_fight.heal(d,n) -- restore when we explore\n"
"						end\n"
"					end\n"
"				end\n"
"			end\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	function asc()\n"
"		return is.asc\n"
"	end\n"
"	\n"
"	function view_text()\n"
"		return \"You see \"..(is.desc or \"something\")..\".\"\n"
"	end\n"
"\n"
"	function look_text()\n"
"		local ss={}\n"
"		ss[#ss+1]=is.longdesc or is.desc\n"
"		ss[#ss+1]=\"\\n"
"\"\n"
"		\n"
"		if is.pow>0 then\n"
"			ss[#ss+1]=\"+\"..(pow)..\"\\n"
"\"\n"
"		elseif is.pow<0 then\n"
"			ss[#ss+1]=\"-\"..(-pow)..\"\\n"
"\"\n"
"		end\n"
"		\n"
"		if (dam_min and dam_min~=0) or (dam_max and dam_max~=0) then\n"
"			ss[#ss+1]=\"\\n"
"\"\n"
"			ss[#ss+1]=\"damage \"..math.floor(dam_min)..\" to \"..math.floor(dam_max)..\"\\n"
"\"\n"
"		end\n"
"\n"
"		if (def_add and def_add~=0) or (def_mul and def_mul~=1) then\n"
"			ss[#ss+1]=\"\\n"
"\"\n"
"			ss[#ss+1]=\"protection \"..math.floor(-def_add)..\" and \"..math.floor(100*(1-def_mul))..\"% damage\\n"
"\"\n"
"		end	\n"
"	\n"
"		return table.concat(ss)\n"
"	end\n"
"\n"
"	function desc_text()\n"
"		local s=is.desc\n"
"		if is.pow>0 then\n"
"			s=s..\"+\"..pow\n"
"		elseif is.pow<0 then\n"
"			s=s..\"-\"..(-pow)\n"
"		end\n"
"		return s\n"
"	end\n"
"\n"
"	function move(vx,vy)\n"
"		local x=cell.xp+vx\n"
"		local y=cell.yp+vy\n"
"		local c=level.get_cell(x,y)\n"
"		\n"
"		if c and c.name==\"floor\" then -- its a cell we can move into\n"
"		\n"
"			local char=c.get_char()\n"
"\n"
"			if char then -- interact with another char?\n"
"				if char.can.use and can.operate then\n"
"\n"
"					local usename=char.can.use\n"
"					\n"
"					if char.can[usename] then\n"
"						char.can[usename](char , d )\n"
"					elseif usename==\"menu\" then\n"
"						if char.can.menu then\n"
"							char.can.menu(char,d)\n"
"						else\n"
"							level.main.menu.show_item_menu(char)\n"
"						end\n"
"					end\n"
"					\n"
"				elseif char.can.fight and can.fight then\n"
"				\n"
"					if char.is.player or is.player then -- do not fight amongst selfs				\n"
"						yarn_fight.hit(d,char)\n"
"						return 1\n"
"					end\n"
"					\n"
"				end\n"
"			else -- just move\n"
"				set_cell(c)\n"
"				return 1 -- time taken to move\n"
"			end\n"
"			\n"
"		end\n"
"		return 0\n"
"	end\n"
"\n"
"	function die()\n"
"		if is.player then -- we deaded\n"
"			local main=level.main\n"
"			main.soul.last_stairs=nil\n"
"			main.save()\n"
"			main.level=main.level.destroy()\n"
"\n"
"			hp=is.hp -- regen\n"
"			\n"
"			main.level=yarn_level.create(yarn_attrs.get(\"level.home\",1,{xh=40,yh=28}),main)\n"
"			local level=main.level\n"
"			main.menu.hide()\n"
"			\n"
"			-- setup cyro stuff again\n"
"			local v\n"
"			v=level.find_item(\"cryo_door\") v.can.set_close(v)\n"
"			v=level.find_item(\"cryo_bed\") v.can.set_open(v)\n"
"			\n"
"			-- reposition next to the bed\n"
"			v=level.find_item(\"cryo_bed\")\n"
"			for i,v in v.cell.neighbours() do\n"
"				if v.is_empty() then --empty so place palyer here\n"
"					level.player.set_cell( v )\n"
"					break\n"
"				end\n"
"			end\n"
"\n"
"\n"
"\n"
"			\n"
"			main.level.add_msg(\"You feel dead...\")\n"
"\n"
"		else\n"
"		\n"
"			local p=level.new_item( name..\"_corpse\" )\n"
"			p.set_cell( cell )\n"
"			\n"
"			if loot then\n"
"				for n,p in pairs(loot) do\n"
"					if math.random() < p then\n"
"						local l=level.new_item( n )\n"
"						l.set_cell( cell )\n"
"					end\n"
"				end\n"
"			end\n"
"\n"
"			level.del_item(d)\n"
"		end\n"
"	end\n"
"\n"
"	function update()\n"
"	\n"
"		if can.roam==\"random\" then\n"
"		\n"
"			if 	time_passed<level.time_passed then\n"
"		\n"
"				local vs={ {1,0} , {-1,0} , {0,1} , {0,-1} }\n"
"				\n"
"				vs=vs[level.rand(1,4)]\n"
"				\n"
"				move(vs[1],vs[2])\n"
"				\n"
"				time_passed=time_passed+1\n"
"			end\n"
"			\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"-- create a save state for this data\n"
"	function save()\n"
"		local sd={}\n"
"		\n"
"		sd=yarn_attr.save(is)\n"
"		\n"
"		return sd\n"
"	end\n"
"\n"
"-- reload a saved data (create and then load)\n"
"	function load(sd)\n"
"		is=yarn_attr.load(sd)\n"
"		d.is=is\n"
"		d.metatable.__index=is\n"
"		\n"
"		for _,n in ipairs(yarn_attr.keys_name_and_subnames(is.name)) do\n"
"		\n"
"			d.level.cellfind[n]=d.cell -- last generated cell of this type\n"
"			\n"
"			local l=d.level.celllist[n] or {} -- all generated cells of this type\n"
"			l[#l+1]=d.cell\n"
"			d.level.celllist[n]=l\n"
"			\n"
"		end\n"
"	end\n"
"\n"
"	return d\n"
"	\n"
"end\n"
"\n"
"",

"worker","\n"
"-- moved the worker thread to own file so we cant pick up any out of thread upvalues by mistake\n"
"\n"
"local require=require -- darnation, upvalues are a problem, currently lanes is disabled but this will break it later\n"
"\n"
"module(...)\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get url content\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function lanes_url_worker(msg)\n"
"\n"
"local http=require(\"socket.http\")\n"
"\n"
"local body, headers, code = http.request(msg.url)\n"
"\n"
"local ret={}\n"
"\n"
"	ret.body=body\n"
"	ret.headers=headers\n"
"	ret.code=code\n"
"	\n"
"	return ret\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- the generic worker thread function\n"
"--\n"
"-- used to create new worker threads\n"
"--\n"
"-- pass in a linda and an id to use on that linda for coms\n"
"--\n"
"-- this function needs to require and setup the things it neads as otherwise it has nothing\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function lanes_worker(linda,idx)\n"
"\n"
"package.cpath=apps.cpath -- and set paths so we can find things\n"
"package.path=apps.path\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- return a msg from a worker\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function lanes_return(linda,msg,ret)\n"
"	\n"
"	if work_lanes_disable then\n"
"	\n"
"		return ret\n"
"	\n"
"	else\n"
"\n"
"		linda:send(nil,0,{ cmd=\"ret\" , id=msg.id , ret=ret })\n"
"	\n"
"	end\n"
"	\n"
"	return nil\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- perform the end in the worker\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function lanes_end_worker(linda,msg)\n"
"\n"
"local kay=math.floor(collectgarbage(\"count\"))\n"
"	print(\"lua thread was using \"..kay..\"k\\n"
"\")\n"
"					\n"
"	linda:send(nil,0,{ cmd=\"end\" , id=msg.id })\n"
"\n"
"end\n"
"\n"
"\n"
"local loop=true\n"
"\n"
"	while loop do\n"
"\n"
"	local msg= linda:receive( nil, idx )\n"
"\n"
"--print(idx,\" : \",msg.cmd,\"\\n"
"\")\n"
"	\n"
"		if msg then\n"
"		\n"
"			if msg.cmd==\"end\" then\n"
"\n"
"				lanes_end_worker(linda,msg)\n"
"				\n"
"				return -- finish since we where told to\n"
"					\n"
"			elseif msg.cmd==\"url\" then\n"
"			\n"
"				local ret=lanes_url_worker(msg)\n"
"				lanes_return(linda,msg,ret)\n"
"			\n"
"			end\n"
"			\n"
"-- requests can be large hits on memory, so\n"
"-- perform a full garbage collect after every request?\n"
"--			collectgarbage(\"collect\")\n"
"			\n"
"		end\n"
"	end\n"
"\n"
"end\n"
"",

"wetgenes.bake.ngx","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"local lfs=require(\"lfs\")\r\n"
"\r\n"
"module(...)\r\n"
"\r\n"
"function build(tab)\r\n"
"\r\n"
"	local bake=require(\"wetgenes.bake\")\r\n"
"	\r\n"
"	-- where we are building from\r\n"
"	bake.cd_base	=	bake.cd_base or bake.get_cd()\r\n"
"	-- where we are building to\r\n"
"	bake.cd_out		=	bake.cd_out or '.ngx'\r\n"
"	-- where we are building from\r\n"
"	bake.cd_root	=	bake.cd_base .. \"/../..\"\r\n"
"\r\n"
"-- we need this one\r\n"
"	lfs.mkdir(bake.cd_out)\r\n"
"-- and these\r\n"
"	lfs.mkdir(bake.cd_out..\"/conf\")\r\n"
"	lfs.mkdir(bake.cd_out..\"/logs\")\r\n"
"	lfs.mkdir(bake.cd_out..\"/sqlite\")\r\n"
"\r\n"
"\r\n"
"-- combine all possible lua files into one lua dir in the .ngx output dir\r\n"
"\r\n"
"	local opts={basedir=bake.cd_root..\"/bin\",dir=\"lua\",filter=\"\"}\r\n"
"	local r=bake.findfiles(opts)\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		local fname=bake.cd_out..\"/\"..v\r\n"
"		bake.create_dir_for_file(fname)\r\n"
"		bake.copyfile(opts.basedir..\"/\"..v,fname)\r\n"
"	end\r\n"
"\r\n"
"	local opts={basedir=bake.cd_base..\"/html\",dir=\"lua\",filter=\"\"}\r\n"
"	local r=bake.findfiles(opts)\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		local fname=bake.cd_out..\"/\"..v\r\n"
"		bake.create_dir_for_file(fname)\r\n"
"		bake.copyfile(opts.basedir..\"/\"..v,fname)\r\n"
"	end\r\n"
"\r\n"
"	local opts={basedir=bake.cd_base,dir=\"lua\",filter=\"\"}\r\n"
"	local r=bake.findfiles(opts)\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		local fname=bake.cd_out..\"/\"..v\r\n"
"		bake.create_dir_for_file(fname)\r\n"
"		bake.copyfile(opts.basedir..\"/\"..v,fname)\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"-- now do the same with the modules datas\r\n"
"\r\n"
"	local modnames={\r\n"
"		\"admin\",\r\n"
"		\"base\",\r\n"
"		\"blog\",\r\n"
"		\"chan\",\r\n"
"		\"comic\",\r\n"
"		\"console\",\r\n"
"		\"data\",\r\n"
"		\"dice\",\r\n"
"		\"dimeload\",\r\n"
"		\"dumid\",\r\n"
"		\"forum\",\r\n"
"		\"mirror\",\r\n"
"		\"note\",\r\n"
"		\"port\",\r\n"
"		\"profile\",\r\n"
"		\"score\",\r\n"
"		\"shoop\",\r\n"
"		\"thumbcache\",\r\n"
"		\"todo\",\r\n"
"		\"waka\",\r\n"
"	}\r\n"
"	for i,n in ipairs(modnames) do\r\n"
"		for i,s in ipairs{\"art\",\"css\",\"js\"} do\r\n"
"			local opts={basedir=bake.cd_root..\"/mods/\"..n..\"/\"..s,dir=\"\",filter=\"\"}\r\n"
"			local r=bake.findfiles(opts)\r\n"
"			for i,v in ipairs(r.ret) do\r\n"
"				local fname=bake.cd_out..\"/html/\"..s..\"/\"..n..\"/\"..v\r\n"
"				bake.create_dir_for_file(fname)\r\n"
"				bake.copyfile(opts.basedir..\"/\"..v,fname)\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"		local opts={basedir=bake.cd_root..\"/mods/\"..n..\"/lua\",dir=\"\",filter=\"\"}\r\n"
"		local r=bake.findfiles(opts)\r\n"
"		for i,v in ipairs(r.ret) do\r\n"
"			local fname=bake.cd_out..\"/lua/\"..n..\"/\"..v\r\n"
"			bake.create_dir_for_file(fname)\r\n"
"			bake.copyfile(opts.basedir..\"/\"..v,fname)\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	local opts={basedir=bake.cd_base,dir=\"html\",filter=\"\"}\r\n"
"	local r=bake.findfiles(opts)\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		local fname=bake.cd_out..\"/\"..v\r\n"
"		bake.create_dir_for_file(fname)\r\n"
"		bake.copyfile(opts.basedir..\"/\"..v,fname)\r\n"
"	end\r\n"
"\r\n"
"local ngx_config=[[\r\n"
"\r\n"
"#This forces us to have only one lua state, which can make some nginx speed hacks possible\r\n"
"#Since we can leave values lying around for future use.\r\n"
"#I figure we can just use lanes to offload big cpu tasks onto other threads...\r\n"
"\r\n"
"worker_processes  1;\r\n"
"\r\n"
"\r\n"
"\r\n"
"events {\r\n"
"    worker_connections  512;\r\n"
"}\r\n"
"\r\n"
"http {\r\n"
"\r\n"
"# do not merge slashes fool\r\n"
"merge_slashes off ;\r\n"
"\r\n"
"types {\r\n"
"    text/html                             html htm shtml;\r\n"
"    text/css                              css;\r\n"
"    text/xml                              xml;\r\n"
"    image/gif                             gif;\r\n"
"    image/jpeg                            jpeg jpg;\r\n"
"    application/x-javascript              js;\r\n"
"    application/atom+xml                  atom;\r\n"
"    application/rss+xml                   rss;\r\n"
"\r\n"
"    text/mathml                           mml;\r\n"
"    text/plain                            txt;\r\n"
"    text/vnd.sun.j2me.app-descriptor      jad;\r\n"
"    text/vnd.wap.wml                      wml;\r\n"
"    text/x-component                      htc;\r\n"
"\r\n"
"    image/png                             png;\r\n"
"    image/tiff                            tif tiff;\r\n"
"    image/vnd.wap.wbmp                    wbmp;\r\n"
"    image/x-icon                          ico;\r\n"
"    image/x-jng                           jng;\r\n"
"    image/x-ms-bmp                        bmp;\r\n"
"    image/svg+xml                         svg svgz;\r\n"
"    image/webp                            webp;\r\n"
"\r\n"
"    application/java-archive              jar war ear;\r\n"
"    application/mac-binhex40              hqx;\r\n"
"    application/msword                    doc;\r\n"
"    application/pdf                       pdf;\r\n"
"    application/postscript                ps eps ai;\r\n"
"    application/rtf                       rtf;\r\n"
"    application/vnd.ms-excel              xls;\r\n"
"    application/vnd.ms-powerpoint         ppt;\r\n"
"    application/vnd.wap.wmlc              wmlc;\r\n"
"    application/vnd.google-earth.kml+xml  kml;\r\n"
"    application/vnd.google-earth.kmz      kmz;\r\n"
"    application/x-7z-compressed           7z;\r\n"
"    application/x-cocoa                   cco;\r\n"
"    application/x-java-archive-diff       jardiff;\r\n"
"    application/x-java-jnlp-file          jnlp;\r\n"
"    application/x-makeself                run;\r\n"
"    application/x-perl                    pl pm;\r\n"
"    application/x-pilot                   prc pdb;\r\n"
"    application/x-rar-compressed          rar;\r\n"
"    application/x-redhat-package-manager  rpm;\r\n"
"    application/x-sea                     sea;\r\n"
"    application/x-shockwave-flash         swf;\r\n"
"    application/x-stuffit                 sit;\r\n"
"    application/x-tcl                     tcl tk;\r\n"
"    application/x-x509-ca-cert            der pem crt;\r\n"
"    application/x-xpinstall               xpi;\r\n"
"    application/xhtml+xml                 xhtml;\r\n"
"    application/zip                       zip;\r\n"
"\r\n"
"    application/octet-stream              bin exe dll;\r\n"
"    application/octet-stream              deb;\r\n"
"    application/octet-stream              dmg;\r\n"
"    application/octet-stream              eot;\r\n"
"    application/octet-stream              iso img;\r\n"
"    application/octet-stream              msi msp msm;\r\n"
"\r\n"
"    audio/midi                            mid midi kar;\r\n"
"    audio/mpeg                            mp3;\r\n"
"    audio/ogg                             ogg;\r\n"
"    audio/x-m4a                           m4a;\r\n"
"    audio/x-realaudio                     ra;\r\n"
"\r\n"
"    video/3gpp                            3gpp 3gp;\r\n"
"    video/mp4                             mp4;\r\n"
"    video/mpeg                            mpeg mpg;\r\n"
"    video/quicktime                       mov;\r\n"
"    video/webm                            webm;\r\n"
"    video/x-flv                           flv;\r\n"
"    video/x-m4v                           m4v;\r\n"
"    video/x-mng                           mng;\r\n"
"    video/x-ms-asf                        asx asf;\r\n"
"    video/x-ms-wmv                        wmv;\r\n"
"    video/x-msvideo                       avi;\r\n"
"}\r\n"
"\r\n"
"lua_package_path  './lua/?.lua;./lua/?/init.lua;;';\r\n"
"lua_package_cpath ';;';\r\n"
"\r\n"
"  server {\r\n"
"\r\n"
"      access_log  logs/access.log;\r\n"
"      error_log   logs/error.log debug;\r\n"
"      listen      127.0.0.1:8888;\r\n"
"      root        html;\r\n"
"      server_name host.local;\r\n"
"\r\n"
"#do the fetch work?\r\n"
"	location ~ /@fetch/(.*)$ {\r\n"
"		internal;\r\n"
"		set $a $1;\r\n"
"		resolver 8.8.8.8;\r\n"
"		rewrite (.*) $a break;\r\n"
"		proxy_pass_request_headers off;\r\n"
"		proxy_pass '$a?$args';\r\n"
"	}\r\n"
"\r\n"
"\r\n"
"#try existing files\r\n"
"	location  / {\r\n"
"		try_files $uri @serv;\r\n"
"	}\r\n"
"	\r\n"
"#call into lua to handle anything else	\r\n"
"	location  @serv {\r\n"
"		content_by_lua \"require(\\\"wetgenes.www.ngx.serv\\\").serv()\";\r\n"
"	}\r\n"
"	\r\n"
"  }\r\n"
"}\r\n"
"]]\r\n"
"	local fname=bake.cd_out..\"/conf/nginx.conf\"\r\n"
"	bake.writefile(fname,ngx_config)\r\n"
"\r\n"
"	if (tab.arg[1] or \"\")==\"serv\" then\r\n"
"	\r\n"
"		print(\"Starting anlua on nginx\\n"
"\\n"
"\")\r\n"
"		\r\n"
"		bake.execute(bake.cd_out,\"../../../bin/exe/nginx\",\"-p. -sstop\")\r\n"
"		bake.execute(bake.cd_out,\"../../../bin/exe/nginx\",\"-p.\")\r\n"
"--		bake.execute(bake.cd_out,\"tail\",\"-n0 -f logs/error.log\")\r\n"
"		\r\n"
"		local fp=io.popen(\"tail -n0 -f logs/error.log\",\"r\") -- should probably just open the file myself...\r\n"
"		local finished\r\n"
"		while true do\r\n"
"			local l=fp:read(\"*l\")\r\n"
"			if l then\r\n"
"				local s=l\r\n"
"				s=s:gsub(\", client: .*$\",\" .\")\r\n"
"				s=s:gsub(\"^.*: %*%d* \",\". \")\r\n"
"				print(s)\r\n"
"			else break end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"end\r\n"
"",

"wetgenes.string","\n"
"local string=string\n"
"local table=table\n"
"local math=math\n"
"\n"
"local type=type\n"
"local pairs=pairs\n"
"local ipairs=ipairs\n"
"local tostring=tostring\n"
"local setmetatable=setmetatable\n"
"local error=error\n"
"local tonumber=tonumber\n"
"\n"
"local log=print\n"
"\n"
"--\n"
"-- Some ueful string functions.\n"
"--\n"
"\n"
"module(\"wetgenes.string\")\n"
"\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split a string into a table, flag enables pattern match on true\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function str_split(div,str,flag)\n"
"\n"
"	if (str=='') then return {\"\"} end\n"
"	\n"
"	if (div=='') or not div then error(\"div expected\", 2) end\n"
"	if (str=='') or not str then error(\"str expected\", 2) end\n"
"\n"
"	local pos,arr = 0,{}\n"
"\n"
"	-- for each divider found\n"
"	for st,sp in function() return string.find(str,div,pos,not flag) end do\n"
"		table.insert(arr,string.sub(str,pos,st-1)) -- Attach chars left of current divider\n"
"		pos = sp + 1 -- Jump past current divider\n"
"	end\n"
"\n"
"	if pos~=0 then\n"
"		table.insert(arr,string.sub(str,pos)) -- Attach chars right of last divider\n"
"	else\n"
"		table.insert(arr,str) -- return entire string\n"
"	end\n"
"\n"
"\n"
"	return arr\n"
"end\n"
"--  yeah the above is bad and should be turned into this\n"
"function split(str,div,flag) return str_split(div,str,flag) end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- serialize a simple table to a lua string that would hopefully recreate said table if executed\n"
"--\n"
"-- returns a string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function serialize(o,opts)\n"
"opts=opts or {}\n"
"opts.done=opts.done or {} -- only do tables once\n"
"\n"
"opts.indent=opts.indent or \"\"\n"
"opts.newline=opts.newline or ( opts.compact and \"\" or \"\\n"
"\" )\n"
"\n"
"local fout=opts.fout\n"
"\n"
"	if not fout then -- call with a new function to build and return a string\n"
"		local ret={}\n"
"		opts.fout=function(...)\n"
"			for i,v in ipairs({...}) do ret[#ret+1]=v end\n"
"		end\n"
"		serialize(o,opts)		\n"
"		return table.concat(ret)\n"
"	end\n"
"\n"
"	if type(o) == \"number\" then\n"
"	\n"
"		return fout(o)\n"
"		\n"
"	elseif type(o) == \"boolean\" then\n"
"	\n"
"		if o then return fout(\"true\") else return fout(\"false\") end\n"
"		\n"
"	elseif type(o) == \"string\" then\n"
"	\n"
"		return fout(string.format(\"%q\", o))\n"
"		\n"
"	elseif type(o) == \"table\" then\n"
"	\n"
"		\n"
"		if opts.done[o] and opts.no_duplicates then\n"
"			fout(opts.indent,\"\\n"
"\",opts.indent,\"{--[[DUPLICATE]]}\",opts.newline)\n"
"			return\n"
"		else\n"
"		\n"
"			fout(opts.newline,opts.indent,\"{\",opts.newline)\n"
"\n"
"			if opts.pretty then\n"
"				opts.indent=opts.indent..\" \"\n"
"			end\n"
"			\n"
"			opts.done[o]=true\n"
"			\n"
"			local maxi=0\n"
"			\n"
"			for k,v in ipairs(o) do -- dump number keys in order\n"
"				fout(opts.indent)\n"
"				serialize(v,opts)\n"
"				fout(\",\",opts.newline)\n"
"				maxi=k -- remember top\n"
"			end\n"
"			\n"
"			for k,v in pairs(o) do\n"
"				if (type(k)~=\"number\") or (k<1) or (k>maxi) or (math.floor(k)~=k) then -- skip what we already dumped\n"
"					fout(opts.indent,\"[\")\n"
"					serialize(k,opts)\n"
"					fout(\"]=\")\n"
"					serialize(v,opts)\n"
"					fout(\",\",opts.newline)\n"
"				end\n"
"			end\n"
"			\n"
"			if opts.pretty then\n"
"				opts.indent=opts.indent:sub(1,-2)\n"
"			end\n"
"			fout(opts.indent,\"}\",opts.newline)\n"
"			return\n"
"		end\n"
"	elseif type(o) == \"nil\" then	\n"
"		return fout(\"nil\")\n"
"	else\n"
"		error(\"cannot serialize a \" .. type(o))\n"
"	end\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- dump a table to a lua string for debuging output, \n"
"--\n"
"-- returns a string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function dump(o,opts)\n"
"opts=opts or {}\n"
"opts.done=opts.done or {} -- only do tables once\n"
"opts.names=opts.names or {\"this\"}\n"
"\n"
"opts.indent=opts.indent or \"\"\n"
"opts.newline=opts.newline or ( opts.compact and \"\" or \"\\n"
"\" )\n"
"\n"
"local fout=opts.fout\n"
"\n"
"	if not fout then -- call with a new function to build and return a string\n"
"		local ret={}\n"
"		opts.fout=function(...)\n"
"			for i,v in ipairs({...}) do ret[#ret+1]=v end\n"
"		end\n"
"		dump(o,opts)		\n"
"		return table.concat(ret)\n"
"	end\n"
"\n"
"	if type(o) == \"number\" then\n"
"	\n"
"		return fout(o)\n"
"		\n"
"	elseif type(o) == \"boolean\" then\n"
"	\n"
"		if o then return fout(\"true\") else return fout(\"false\") end\n"
"		\n"
"	elseif type(o) == \"string\" then\n"
"	\n"
"		return fout(string.format(\"%q\", o))\n"
"		\n"
"	elseif type(o) == \"table\" then\n"
"	\n"
"		\n"
"		if opts.done[o] then\n"
"			fout(\"(\",opts.done[o],\")\")\n"
"			return\n"
"		else\n"
"		\n"
"			fout(opts.newline,opts.indent,\"{\",opts.newline)\n"
"\n"
"			opts.indent=opts.indent..\" \"\n"
"			\n"
"			opts.done[o]=table.concat(opts.names,\".\")\n"
"			\n"
"			local maxi=0\n"
"			\n"
"			for k,v in ipairs(o) do -- dump number keys in order\n"
"				table.insert(opts.names,tostring(k))\n"
"				fout(opts.indent)\n"
"				dump(v,opts)\n"
"				fout(\",\",opts.newline)\n"
"				maxi=k -- remember top\n"
"				table.remove(opts.names)\n"
"			end\n"
"			\n"
"			for k,v in pairs(o) do\n"
"				if (type(k)~=\"number\") or (k<1) or (k>maxi) or (math.floor(k)~=k) then -- skip what we already dumped\n"
"					table.insert(opts.names,tostring(k))\n"
"					fout(opts.indent,\"[\")\n"
"					dump(k,opts)\n"
"					fout(\"]=\")\n"
"					dump(v,opts)\n"
"					fout(\",\",opts.newline)\n"
"					table.remove(opts.names)\n"
"				end\n"
"			end\n"
"			\n"
"			opts.indent=opts.indent:sub(1,-2)\n"
"			\n"
"			fout(opts.indent,\"}\",opts.newline)\n"
"			return\n"
"		end\n"
"	elseif type(o) == \"nil\" then	\n"
"		return fout(\"nil\")\n"
"	else\n"
"		return fout(\"function(\"..type(o)..\")end\")\n"
"	end\n"
"	\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- join a table of things into an english list with commas and an \"and\" at the end\n"
"-- returns nil if the table is empty\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function str_join_english_list(t)\n"
"\n"
"local s\n"
"\n"
"	for i,v in ipairs(t) do\n"
"	\n"
"		if not s then -- first\n"
"		\n"
"			s=v\n"
"			\n"
"		elseif t[i+1]==nil then -- last\n"
"		\n"
"			s=s..\" and \"..v\n"
"			\n"
"		else -- middle\n"
"		\n"
"			s=s..\", \"..v\n"
"			\n"
"		end\n"
"	\n"
"	end\n"
"\n"
"	return s\n"
"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert a string into a hex string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function str_to_hex(s)\n"
"	return string.gsub(s, \".\", function (c)\n"
"		return string.format(\"%02x\", string.byte(c))\n"
"	end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace any %xx with the intended char, eg \"%20\" becomes a \" \"\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_decode(str)\n"
"    return string.gsub(str, \"%%(%x%x)\", function(hex)\n"
"        return string.char(tonumber(hex, 16))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace % , & , # , ' , \" and = chars with %xx codes\n"
"-- this is the bare minimum we need to escape so as not to confuse things\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_encode(str)\n"
"    return string.gsub(str, \"([&=%%#'\\\"])\", function(c)\n"
"        return string.format(\"%%%02X\", string.byte(c))\n"
"    end)\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- trime whitespace from ends of string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function trim(s)\n"
"  return (s:gsub(\"^%s*(.-)%s*$\", \"%1\"))\n"
"end\n"
"function trim_start(s)\n"
"  return (s:gsub(\"^%s*(.-)\", \"%1\"))\n"
"end\n"
"function trim_end(s)\n"
"  return (s:gsub(\"(.-)%s*$\", \"%1\"))\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split on \\n"
", each line also includes its own \\n"
"\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function split_lines(text)\n"
"	local separator = \"\\n"
"\"\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start,true)\n"
"	\n"
"	while split_start do\n"
"		table.insert(parts, text:sub(start, split_end))\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start,true)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	\n"
"	return parts\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split on whitespace, throw away all whitespace return only the words\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function split_words(text,split)\n"
"	local separator = split or \"%s+\"\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	\n"
"	while split_start do\n"
"		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	\n"
"	return parts\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split on transition to or from whitespace, include this white space in the table result\n"
"--\n"
"-- such that a concat on the result would be a perfect reproduction of the original\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function split_whitespace(text)\n"
"	local separator = \"%s+\"\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	\n"
"	while split_start do\n"
"		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end		-- the word\n"
"		table.insert(parts, text:sub(split_start, split_end))	-- the white space\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	\n"
"	return parts\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split a string in two on first = \n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function split_equal(text)\n"
"	local separator = \"=\"\n"
"	\n"
"	local parts = {}\n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start,true)\n"
"	\n"
"	if split_start and split_start>1 and split_end<#text then -- data either side of seperator\n"
"	\n"
"		return text:sub(1,split_start-1) , text:sub(split_end+1)\n"
"		\n"
"	end\n"
"	\n"
"	return nil\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- private replace utility function\n"
"-- look up string a inside data d and return the string we found\n"
"-- if we dont find anything then we return {a}\n"
"--\n"
"-- if we try to look up a table containing a plate field\n"
"-- then that plate name will be used to format that table content as {d.it}\n"
"-- if that table contains a [1] then it will be treated as an array of data\n"
"-- and looped over to produce a result.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local replace_lookup\n"
"replace_lookup=function(a,d) -- look up a in table d\n"
"	local t=d[a]\n"
"	if t then\n"
"		if type(t)==\"table\" then -- if a table then\n"
"			if t[1] then -- a list of stuff\n"
"				if t.plate then -- how to format\n"
"					local tt={}\n"
"					local it=d.it\n"
"					for i,v in ipairs(t) do\n"
"						d.it=v\n"
"						tt[#tt+1]=macro_replace(d[t.plate] or t.plate,d)\n"
"					end\n"
"					d.it=it\n"
"					return table.concat(tt)\n"
"				end\n"
"			else -- just one thing\n"
"				if t.plate then -- how to format\n"
"					local it=d.it\n"
"					d.it=t\n"
"					local tt=macro_replace(d[t.plate] or t.plate,d)\n"
"					d.it=it\n"
"					return tt\n"
"				end\n"
"			end\n"
"			return nil -- no not expand\n"
"		end\n"
"		return tostring(t) -- simple find, make sure we return a string\n"
"	end\n"
"	\n"
"	local a1,a2=string.find(a, \"%.\") -- try and split on first \".\"\n"
"	if not a1 then return nil end -- didnt find a dot so return nil\n"
"	\n"
"	a1=string.sub(a,1,a1-1) -- the bit before the .\n"
"	a2=string.sub(a,a2+1) -- the bit after the .\n"
"	\n"
"	local dd=d[a1] -- use the bit before the dot to find the sub table\n"
"	\n"
"	if type(dd)==\"table\" then -- check we got a table\n"
"		return replace_lookup(a2,dd) -- tail call this function\n"
"	end\n"
"	\n"
"	return nil -- couldnt find anything returnnil\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace {tags} in the string with data provided\n"
"-- allow sub table look up with a.b notation in the name\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function replace(a,d)\n"
"\n"
"return (string.gsub( a , \"{([%w%._%-]-)}\" , function(a) -- find only words and \"._-!\" tightly encased in {}\n"
"-- this means that almost all legal use of {} in javascript will not match at all.\n"
"-- Even when it does (probably as a \"{}\") then it is unlikley to accidently find anything in the d table\n"
"-- so the text will just be returned as is.\n"
"-- So it may not be safe, but it is simple to understand and perfecty fine under most use cases.\n"
"\n"
"	return replace_lookup(a,d) or (\"{\"..a..\"}\")\n"
"	\n"
"end )) -- note gsub is in brackes so we just get its first return value\n"
"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- like replace but allows for simple creation of temporary substitutions\n"
"-- this enables very simple macro expansion\n"
"-- so {var=}value{=var} would set var to value\n"
"-- and that value would last for the rest of the chunk\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function macro_replace_once(text,old_d,opts)\n"
"	opts=opts or {}\n"
"	local opts_clean=opts.clean\n"
"	local opts_htmldbg=opts.dbg_html_comments\n"
"\n"
"	local d={} -- we can store temporary vars in here\n"
"	if old_d then setmetatable(d,{__index=old_d})	end -- wrap original d to protect it\n"
"	\n"
"	\n"
"	local ret={}\n"
"	\n"
"	local separator = \"{[%w%._%-=]-}\"\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	\n"
"	while split_start do\n"
"		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end		-- part1\n"
"		table.insert(parts, text:sub(split_start, split_end))	-- part2\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"\n"
"	local count=0\n"
"	local capt=nil\n"
"	\n"
"\n"
"-- step through	\n"
"	for i=1,#parts do local v=parts[i]\n"
"		local tag=nil\n"
"		local dat=nil\n"
"		local skip_capt=nil\n"
"		if string.len(v)>=3 then -- must be at least this long\n"
"			local fc=v:sub(1,1) -- first char\n"
"			local lc=v:sub(-1) -- last char\n"
"			if fc==\"{\" and lc==\"}\" then -- special part\n"
"				tag=v:sub(2,#v-1)\n"
"				local fc=tag:sub(1,1) -- first char\n"
"				local lc=tag:sub(-1) -- last char\n"
"				\n"
"				if lc==\"=\" then -- start of capture\n"
"					if capt==nil then\n"
"						capt=tag:sub(1,-2)\n"
"						d[capt]=\"\"\n"
"						skip_capt=true\n"
"						if opts_clean then\n"
"							dat=\"\"\n"
"						end\n"
"					end\n"
"				elseif fc==\"=\" then -- end of capture\n"
"					if capt==tag:sub(2) then -- must match\n"
"						capt=nil\n"
"						if opts_clean then dat=\"\" end\n"
"					end\n"
"				else -- normal lookup\n"
"					dat=replace_lookup(tag,d)\n"
"				end\n"
"			end\n"
"		end\n"
"		local s\n"
"		if dat then\n"
"			count=count+1\n"
"			if opts_htmldbg and tag then\n"
"				s=\"<!--{ \"..tag..\" }-->\\n"
"\"..dat\n"
"			else\n"
"				s=dat\n"
"			end\n"
"		else\n"
"			s=v\n"
"		end\n"
"		\n"
"		if not skip_capt then\n"
"			if capt then -- record capture\n"
"				d[capt]=d[capt]..s\n"
"				if opts_clean then s=\"\" end\n"
"			end\n"
"		end\n"
"		\n"
"		ret[#ret+1]=s\n"
"	end\n"
"\n"
"	return table.concat(ret,\"\"),count\n"
"end\n"
"\n"
"function macro_replace(a,d,opts)\n"
"\n"
"local opts=opts or {} --{dbg_html_comments=true} to include html dbg, this will break some macro use inside javascript or html attributes so is off by default turn on to dbg\n"
"	\n"
"	local ret=a\n"
"	local count=0\n"
"\n"
"	opts.clean=false\n"
"	for i=1,100 do -- maximum recursion\n"
"	\n"
"		ret,count=macro_replace_once(ret,d,opts)\n"
"		\n"
"		if count==0 then break end -- nothing left to replace\n"
"		\n"
"	end\n"
"	opts.clean=true\n"
"	ret=macro_replace_once(ret,{},opts) -- finally remove temporary chunks\n"
"	return ret\n"
"end\n"
"",

"fenestra.console","\r\n"
"\r\n"
"local hex=function(str) return tonumber(str,16) end\r\n"
"\r\n"
"local string=string\r\n"
"local table=table\r\n"
"local ipairs=ipairs\r\n"
"local math=math\r\n"
"local loadstring=loadstring\r\n"
"local pcall=pcall\r\n"
"\r\n"
"-- imported global functions\r\n"
"local sub = string.sub\r\n"
"local match = string.match\r\n"
"local find = string.find\r\n"
"local push = table.insert\r\n"
"local pop = table.remove\r\n"
"local append = table.insert\r\n"
"local concat = table.concat\r\n"
"local floor = math.floor\r\n"
"local write = io.write\r\n"
"local read = io.read\r\n"
"local type = type\r\n"
"local setfenv = setfenv\r\n"
"local tostring=tostring\r\n"
"local pairs=pairs\r\n"
"local ipairs=ipairs\r\n"
"local unpack=unpack\r\n"
"local require=require\r\n"
"\r\n"
"local _G = _G\r\n"
"\r\n"
"module(\"fenestra.console\")\r\n"
"local fenestra_buffedit=require(\"fenestra.buffedit\")\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- split a string into a table\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"local function split(div,str)\r\n"
"\r\n"
"  if (div=='') or not div then error(\"div expected\", 2) end\r\n"
"  if (str=='') or not str then error(\"str expected\", 2) end\r\n"
"  \r\n"
"  local pos,arr = 0,{}\r\n"
"  \r\n"
"  -- for each divider found\r\n"
"  for st,sp in function() return string.find(str,div,pos,false) end do\r\n"
"	table.insert(arr,sub(str,pos,st-1)) -- Attach chars left of current divider\r\n"
"	pos = sp + 1 -- Jump past current divider\r\n"
"  end\r\n"
"  \r\n"
"  if pos~=0 then\r\n"
"	table.insert(arr,sub(str,pos)) -- Attach chars right of last divider\r\n"
"  else\r\n"
"	table.insert(arr,str) -- return entire string\r\n"
"  end\r\n"
"  \r\n"
"  \r\n"
"  return arr\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"function setup(fenestra)\r\n"
"\r\n"
"	local function print(...)\r\n"
"		fenestra._g.print(...)\r\n"
"	end\r\n"
"\r\n"
"	local ogl=fenestra.ogl\r\n"
"\r\n"
"	local it={}\r\n"
"	\r\n"
"	it.buff=fenestra_buffedit.create() -- create buff edit\r\n"
"	it.buff.enter=function(_,line) it.dump_eval(line) end\r\n"
"	\r\n"
"	it.lines={}\r\n"
"	it.lines_display={}\r\n"
"	\r\n"
"	it.x=0\r\n"
"	it.y=0\r\n"
"	it.y_show=8*8\r\n"
"	\r\n"
"	it.show=false\r\n"
"\r\n"
"	function it.clean()\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"	-- print out lua data in a somewhat sensible way, returns a string\r\n"
"	it.dump_limit = 20\r\n"
"	it.dump_depth = 7\r\n"
"	it.dump_stack = {}\r\n"
"\r\n"
"	it.call = {} -- name -> function : functions that should be easily to call on the console command line\r\n"
"	\r\n"
"	it.call.help=function()\r\n"
"		local t={}\r\n"
"		for n,f in pairs(it.call) do\r\n"
"			t[#t+1]=n\r\n"
"		end\r\n"
"		return table.concat(t,\" \")\r\n"
"	end\r\n"
"	\r\n"
"	function it.dump_table(tbl,delim)\r\n"
"		local n = #tbl\r\n"
"		local res = ''\r\n"
"		local k = 0\r\n"
"		-- very important to avoid disgracing ourselves with circular referencs...\r\n"
"		if #it.dump_stack > it.dump_depth then\r\n"
"			return \"...\"\r\n"
"		end\r\n"
"		for i,t in ipairs(it.dump_stack) do\r\n"
"			if tbl == t then\r\n"
"				return \"<self>\"\r\n"
"			end\r\n"
"		end\r\n"
"		push(it.dump_stack,tbl)\r\n"
"		\r\n"
"		for key,v in pairs(tbl) do\r\n"
"			if type(key) == 'number' then\r\n"
"				key = '['..tostring(key)..']'\r\n"
"			else\r\n"
"				key = tostring(key)\r\n"
"			end\r\n"
"			res = res..delim..key..'='..it.dump_string(v)\r\n"
"			k = k + 1\r\n"
"			if k > it.dump_limit then\r\n"
"				res = res..\" ... \"\r\n"
"				break\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"		pop(it.dump_stack)\r\n"
"		return sub(res,2)\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"\r\n"
"	function it.dump_string(val)\r\n"
"		local tp = type(val)\r\n"
"		if tp == 'function' then\r\n"
"			return tostring(val)\r\n"
"		elseif tp == 'table' then\r\n"
"			if val.__tostring  then\r\n"
"				return tostring(val)\r\n"
"			else\r\n"
"				return '{'..it.dump_table(val,',\\n"
"')..'}'\r\n"
"			end\r\n"
"		elseif tp == 'string' then\r\n"
"			return val--\"'\"..val..\"'\"\r\n"
"		elseif tp == 'number' then\r\n"
"			return tostring(val)\r\n"
"		else\r\n"
"			return tostring(val)\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"-- based on ilua.lua\r\n"
"	function it.dump_eval(line)\r\n"
"	\r\n"
"		local function compile(line)\r\n"
"			local f,err = loadstring(line,'local')\r\n"
"			return err,f\r\n"
"		end\r\n"
"		\r\n"
"		\r\n"
"		local err,chunk\r\n"
"		local ret={}\r\n"
"		local args={}\r\n"
"		\r\n"
"		\r\n"
"		if line~=\"\" then args=split(\"%s\",line) end -- split input on whitespace\r\n"
"		\r\n"
"		if args[1] then\r\n"
"		\r\n"
"			function lookup(tab,name)\r\n"
"				local names=split(\"%.\",name)\r\n"
"				for i,v in ipairs(names) do\r\n"
"--				print(i..\" \"..v)\r\n"
"					if type(tab)==\"table\" then\r\n"
"						tab=tab[v]\r\n"
"					else\r\n"
"						tab=nil\r\n"
"					end\r\n"
"				end\r\n"
"				return tab\r\n"
"			end\r\n"
"			\r\n"
"			chunk=lookup(it.call,args[1]) -- check special console functions\r\n"
"			\r\n"
"			if chunk and type(chunk)==\"function\" then -- must be a function\r\n"
"			\r\n"
"				table.remove(args,1) -- remove the function name\r\n"
"			\r\n"
"				setfenv(chunk,fenestra._g) -- call with master environment?\r\n"
"			else\r\n"
"			\r\n"
"				chunk=lookup(fenestra._g,args[1]) -- check for functions in master environment\r\n"
"				\r\n"
"				if chunk and type(chunk)==\"function\" then -- must be a function\r\n"
"				\r\n"
"					table.remove(args,1) -- remove the function name\r\n"
"				\r\n"
"				else\r\n"
"					chunk=nil\r\n"
"				end\r\n"
"				\r\n"
"				-- do not try and change the fenv of a function in the main envronment...\r\n"
"			\r\n"
"			end\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"		if not chunk then\r\n"
"		\r\n"
"			args={} -- no arguments\r\n"
"			\r\n"
"			-- is it an expression?\r\n"
"			err,chunk = compile('print('..line..')')\r\n"
"			if err then\r\n"
"				-- otherwise, a statement?\r\n"
"				err,chunk = compile(line)\r\n"
"			end\r\n"
"			\r\n"
"			if chunk then\r\n"
"				setfenv(chunk,fenestra._g) -- compile in master environment will have an overloaded print\r\n"
"			end\r\n"
"		end\r\n"
"\r\n"
"		-- if compiled ok, then evaluate the chunk\r\n"
"		if not err and chunk then\r\n"
"		\r\n"
"			ret = { pcall(chunk,unpack(args)) }\r\n"
"			\r\n"
"			if not ret[1] then\r\n"
"				err=ret[2]\r\n"
"				ret={}\r\n"
"			else\r\n"
"				table.remove(ret,1)\r\n"
"			end\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"		-- if there was any error, print it out\r\n"
"		if err then\r\n"
"			fenestra._g.print(err)\r\n"
"		else\r\n"
"			for i,v in ipairs(ret) do\r\n"
"				fenestra._g.print(v)\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	function it.update()\r\n"
"	\r\n"
"		it.buff:update()\r\n"
"		\r\n"
"		if it.show then\r\n"
"			if it.y~=it.y_show then\r\n"
"			\r\n"
"				local d=(it.y_show-it.y)/4\r\n"
"				if d>0 then d=math.ceil(d) else d=math.floor(d) end\r\n"
"				it.y= math.floor( it.y + d )\r\n"
"			\r\n"
"			end\r\n"
"		else\r\n"
"			if it.y~=0 then\r\n"
"			\r\n"
"				local d=(0-it.y)/4\r\n"
"				if d>0 then d=math.ceil(d) else d=math.floor(d) end\r\n"
"				it.y= math.floor( it.y + d )\r\n"
"			\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	function it.draw()\r\n"
"	\r\n"
"		fenestra.debug_begin()\r\n"
"		\r\n"
"		local w=fenestra.get(\"width\")\r\n"
"		local h=it.y\r\n"
"		fenestra.debug_polygon_begin()\r\n"
"		fenestra.debug_polygon_vertex(0,0,hex\"ee00cc00\")\r\n"
"		fenestra.debug_polygon_vertex(w,0,hex\"ee00cc00\")\r\n"
"		fenestra.debug_polygon_vertex(w,h,hex\"ee004400\")\r\n"
"		fenestra.debug_polygon_vertex(0,h,hex\"ee004400\")\r\n"
"		fenestra.debug_polygon_end()\r\n"
"		\r\n"
"--		fenestra.debug_rect(0,0,fenestra.get(\"width\"),it.y,hex\"8800ff00\")\r\n"
"		\r\n"
"		local i=#it.lines\r\n"
"		local y=it.y-16\r\n"
"		while y>-8 and i>0 do\r\n"
"		\r\n"
"			fenestra.debug_print({x=0,y=y,size=8,color=hex\"ff00ff00\",s=it.lines[i]})\r\n"
"			\r\n"
"			y=y-8\r\n"
"			i=i-1\r\n"
"		end\r\n"
"		\r\n"
"		if it.show_hud then\r\n"
"			for i,v in ipairs(it.lines_display) do\r\n"
"			\r\n"
"				fenestra.debug_print({x=0,y=it.y+i*8-8,size=8,color=hex\"ffffffff\",s=v})\r\n"
"			\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"		fenestra.debug_print({x=0,y=it.y-8,size=8,color=hex\"ff00ff00\",s=\">\"..it.buff.line})\r\n"
"\r\n"
"		fenestra.debug_rect((it.buff.line_idx+1)*8,it.y-8,(it.buff.line_idx+2)*8,it.y,hex\"00ff00\"+it.buff.throb*256*256*256)\r\n"
"\r\n"
"		fenestra.debug_end()\r\n"
"\r\n"
"		it.lines_display={}\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"	function it.print(s)\r\n"
"	\r\n"
"		s=it.dump_string(s)\r\n"
"	\r\n"
"		table.insert(it.lines,s)\r\n"
"		\r\n"
"		while #it.lines > 64 do\r\n"
"		\r\n"
"			table.remove(it.lines,1)\r\n"
"		\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	function it.display(s)\r\n"
"	\r\n"
"		s=it.dump_string(s)\r\n"
"		\r\n"
"		table.insert(it.lines_display,s)\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	function it.mouse(act,x,y,key)\r\n"
"--		print(act..\" \"..x..\",\"..y..\" \"..key)\r\n"
"	end\r\n"
"	\r\n"
"	function it.keypress(ascii,key,act)\r\n"
"\r\n"
"		if act==\"down\" then\r\n"
"--			fenestra._g.print(ascii..\" \"..(key or \"\"))\r\n"
"		end\r\n"
"\r\n"
"		if act==\"down\" and ascii==\"`\" then\r\n"
"		\r\n"
"			if it.show then\r\n"
"			\r\n"
"				it.show=false\r\n"
"				it.show_hud=false\r\n"
"				\r\n"
"			elseif it.show_hud then\r\n"
"			\r\n"
"				it.show=true			\r\n"
"				throb=255\r\n"
"			else\r\n"
"				it.show_hud=true\r\n"
"			end\r\n"
"\r\n"
"			return true\r\n"
"		end\r\n"
"			\r\n"
"		if it.show then\r\n"
"		\r\n"
"			if act==\"down\" or act==\"repeat\" then\r\n"
"					\r\n"
"				if key==\"page up\" or key==\"prior\" then\r\n"
"				\r\n"
"					it.y_show=it.y_show-8\r\n"
"				\r\n"
"				elseif key==\"page down\" or key==\"next\" then\r\n"
"				\r\n"
"					it.y_show=it.y_show+8\r\n"
"\r\n"
"				end\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"			return it.buff:keypress(ascii,key,act)\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"-- overload print function in the given (global) tab\r\n"
"-- returns a function to undo this act (however this function may fail...)\r\n"
"	function it.replace_print(g)\r\n"
"	\r\n"
"		local print_old=g.print\r\n"
"		it.print_old=g.print\r\n"
"		local print_new=function(...)\r\n"
"		\r\n"
"			local t={}\r\n"
"			for i,v in ipairs({...}) do\r\n"
"				table.insert(t, it.dump_string(v) )\r\n"
"			end\r\n"
"			if not t[1] then t[1]=\"nil\" end\r\n"
"			\r\n"
"			it.print( unpack(t) )\r\n"
"			if print_old then\r\n"
"				print_old( unpack(t) )\r\n"
"			end\r\n"
"		end\r\n"
"		g.print=print_new\r\n"
"		\r\n"
"		return function()\r\n"
"			if g.print==print_new then -- only change back if noone else changed it\r\n"
"				g.print=print_old\r\n"
"				return true\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	\r\n"
"	return it\r\n"
"end\r\n"
"",

"savedata","{[\"soul\"]={[\"level_name\"]=\"level.test\",[\"level_pow\"]=0,},[\"player\"]={[\"cell_xp\"]=30,[\"cell_yp\"]=13,[\"name\"]=\"player\",},[\"levels\"]={[\"level.test\"]={[0]={[\"xh\"]=40,[\"yh\"]=28,[\"name\"]=\"level.test\",[\"cells\"]={{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"name\"]=\"floor\",},{[\"items\"]={{[\"name\"]=\"stairs.dump\",},},[\"name\"]=\"floor\",},{[\"items\"]={{[\"name\"]=\"sensei.dump\",},},[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"name\"]=\"floor\",},nil,nil,nil,{[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"items\"]={{[\"name\"]=\"stairs.home\",},},[\"name\"]=\"floor\",},nil,{[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"name\"]=\"floor\",},nil,nil,nil,{[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",[\"items\"]={{[\"name\"]=\"stairs.test\",},},},{[\"visible\"]=true,[\"name\"]=\"floor\",[\"items\"]={{[\"name\"]=\"sensei.test\",},},},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"name\"]=\"floor\",},{[\"items\"]={{[\"name\"]=\"sensei.twin1\",},},[\"name\"]=\"floor\",},{[\"items\"]={{[\"name\"]=\"sensei.twin2\",},},[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"floor\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},{[\"visible\"]=true,[\"name\"]=\"wall\",},},[\"rooms\"]={{[\"xh\"]=5,[\"yh\"]=5,[\"name\"]=\"room\",[\"xp\"]=8,[\"yp\"]=9,},{[\"xh\"]=4,[\"yh\"]=3,[\"name\"]=\"room\",[\"xp\"]=16,[\"yp\"]=3,},{[\"xh\"]=4,[\"yh\"]=3,[\"name\"]=\"room\",[\"visible\"]=true,[\"xp\"]=29,[\"yp\"]=13,},{[\"xh\"]=4,[\"yh\"]=3,[\"name\"]=\"room\",[\"xp\"]=22,[\"yp\"]=21,},{[\"xh\"]=1,[\"yh\"]=1,[\"name\"]=\"room\",[\"xp\"]=30,[\"yp\"]=16,},{[\"xh\"]=1,[\"yh\"]=1,[\"name\"]=\"room\",[\"xp\"]=17,[\"yp\"]=6,},{[\"xh\"]=1,[\"yh\"]=1,[\"name\"]=\"room\",[\"xp\"]=13,[\"yp\"]=11,},{[\"xh\"]=1,[\"yh\"]=1,[\"name\"]=\"room\",[\"xp\"]=23,[\"yp\"]=24,},},},},},}",

"yarnlove","\r\n"
"dbg=print\r\n"
"dbg(os.date())\r\n"
"\r\n"
"local yarn=require(\"yarn\")\r\n"
"local yarn_strings=require(\"yarn.strings\")\r\n"
"\r\n"
"function love.load()\r\n"
"\r\n"
"	for i,s in ipairs{\r\n"
"		\"data/fonts/VeraMono.ttf\",\r\n"
"		\"../mods/data/fonts/VeraMono.ttf\",\r\n"
"		\"yarn/mods/data/fonts/VeraMono.ttf\",\r\n"
"		} do\r\n"
"		if love.filesystem.exists(s) then -- use this file\r\n"
"\r\n"
"			love.graphics.setFont(s, 16)\r\n"
"			break\r\n"
"\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	yarn.setup()\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function love.update()\r\n"
"	yarn.update()\r\n"
"end\r\n"
"\r\n"
"function love.draw()\r\n"
"	local s=yarn.draw(2)\r\n"
"    love.graphics.print(s, 0, 0)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function love.keypressed(key, unicode)\r\n"
"--print(\"down\",key,unicode)\r\n"
"	yarn.keypress(key,key,\"down\")\r\n"
"end\r\n"
"\r\n"
"function love.keyreleased(key, unicode)\r\n"
"--print(\"up\",key,unicode)\r\n"
"	yarn.keypress(key,key,\"up\")\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function love.quit()\r\n"
"end\r\n"
"",

"webcache","\n"
"local io=io\n"
"local table=table\n"
"local coroutine=coroutine\n"
"\n"
"local ipairs=ipairs\n"
"local math=math\n"
"local string=string\n"
"local print=print\n"
"local require=require\n"
"local loadstring=loadstring\n"
"local setfenv=setfenv\n"
"\n"
"local work=require(\"work\")\n"
"local wetstr=require(\"wetgenes.string\")\n"
"\n"
"local apps=apps\n"
"\n"
"module(...)\n"
"\n"
"cache={}\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- escape a url so it can be used as a filename\n"
"-- this is a oneway function, you cannot get the url back from the filename.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function esc_url(str)\n"
"    return string.lower( string.gsub(str, \"([\\128-\\255/\\\\:])\", function(c)\n"
"        return \"_\"\n"
"    end) )\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get a url, use lua cache or disk cache or read from the web\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function get_url(url)\n"
"\n"
"	local ret=cache[url] -- first try for memory cache\n"
"	\n"
"	if not ret then -- then try for disk cache\n"
"	\n"
"		local erl=esc_url(url)\n"
"		local fname=apps.dir..\"local/cache/\"..erl..\".lua\"\n"
"		local fp=io.open(fname,\"rb\")\n"
"		\n"
"		if fp then -- got some cache\n"
"		\n"
"			local s=fp:read(\"*all\")\n"
"			fp:close()\n"
"			local f=loadstring(\"return (\"..s..\")\")\n"
"			setfenv(f,{})\n"
"			ret=f()\n"
"			\n"
"		else -- finally hit the web server\n"
"		\n"
"			ret=work.get_url(url)\n"
"			\n"
"			local fp=io.open(fname,\"wb\")	-- and save into the disk cache\n"
"			if fp then\n"
"				fp:write( wetstr.serialize(ret) )\n"
"				fp:close()\n"
"			end\n"
"			\n"
"		end\n"
"		cache[url]=ret\n"
"	end\n"
"	return ret\n"
"end\n"
"",

"yarnterm","package.path=package.path..\";./?/init.lua\"\r\n"
"\r\n"
"\r\n"
"dbg=function(...)\r\n"
"	local fp=io.open(\"yarn.dbg\",\"a\")\r\n"
"	if fp then\r\n"
"		for i,v in ipairs{...} do\r\n"
"			fp:write(v)\r\n"
"		end\r\n"
"		fp:write(\"\\n"
"\")\r\n"
"		io.close(fp)\r\n"
"	end\r\n"
"end\r\n"
"dbg(os.date())\r\n"
"\r\n"
"local yarn=require(\"yarn\")\r\n"
"local yarn_strings=require(\"yarn.strings\")\r\n"
"\r\n"
"local function keycode(code)\r\n"
"\r\n"
"--print(code)\r\n"
"\r\n"
"	if code==65  then return \"up\" end\r\n"
"	if code==66  then return \"down\" end\r\n"
"	if code==68  then return \"left\" end\r\n"
"	if code==67  then return \"right\" end\r\n"
"	if code==32  then return \"space\" end\r\n"
"	if code==127 then return \"backspace\" end\r\n"
"	if code==27  then return \"esc\" end\r\n"
"	if code==10  then return \"enter\" end\r\n"
"\r\n"
"	return \"\"\r\n"
"end\r\n"
"\r\n"
"local aesc=string.char(27) .. '['\r\n"
"\r\n"
"local fp=io.open(\"savedata.lua\",\"r\")\r\n"
"local sd\r\n"
"if fp then\r\n"
"	sd=yarn_strings.unserialize(fp:read())\r\n"
"	fp:close()\r\n"
"end\r\n"
"\r\n"
"yarn.setup(sd,arg)\r\n"
"yarn.update()\r\n"
"print( aesc..\"2J\"..aesc..\"0;0H\"..yarn.draw(2) )\r\n"
"\r\n"
"local exit=false\r\n"
"while not exit do\r\n"
"\r\n"
"	local key_str=io.stdin:read(1)\r\n"
"	\r\n"
"	local key=keycode( key_str:byte() )\r\n"
"	\r\n"
"	if key_str==\"q\" then exit=true end\r\n"
"\r\n"
"	yarn.keypress(key_str,key,\"down\")\r\n"
"	yarn.keypress(key_str,key,\"up\")\r\n"
"	yarn.update()\r\n"
"	print( aesc..\"0;0H\"..yarn.draw(2) )\r\n"
"\r\n"
"end\r\n"
"\r\n"
"local sd=yarn.save()\r\n"
"local fp=io.open(\"savedata.lua\",\"w\")\r\n"
"fp:write(yarn_strings.serialize(sd))\r\n"
"fp:close()\r\n"
"\r\n"
"",

"wetgenes.www.any.stashdata","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"\n"
"\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"local wdata=require(\"wetgenes.www.any.data\")\n"
"\n"
"default_props=\n"
"{\n"
"}\n"
"\n"
"default_cache=\n"
"{\n"
"	base=nil,  --\n"
"	func=nil,  -- require(base).func(srv,id) to rebuild this stash\n"
"	data={},  -- the data we stashed\n"
"}\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- allways this kind\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function kind(srv)\n"
"	return \"stash\"\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- check that entity has initial data and set any missing defaults\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function check(srv,ent)\n"
"\n"
"	local c=ent.cache\n"
"		\n"
"	return ent\n"
"end\n"
"\n"
"\n"
"\n"
"wdata.set_defs(_M) -- create basic data handling funcs\n"
"\n"
"wdata.setup_db(_M) -- make sure DB exists and is ready\n"
"\n"
"\n"
"",

"wetgenes.gamecake.canvas","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"wetgenes.gamecake.canvas\")\r\n"
"\r\n"
"local wgrd=require(\"wetgenes.grd\")\r\n"
"\r\n"
"\r\n"
"base={}\r\n"
"meta={}\r\n"
"meta.__index=base\r\n"
"\r\n"
"function create(opts)\r\n"
"\r\n"
"	local canvas={}\r\n"
"	setmetatable(canvas,meta)\r\n"
"	\r\n"
"	canvas.cake=opts.cake\r\n"
"	\r\n"
"	canvas.grd=wgrd.create(canvas.cake.grd_fmt,\r\n"
"		opts.width or 320,\r\n"
"		opts.height or 240,\r\n"
"		1)\r\n"
"\r\n"
"	return canvas\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.cgilua.mysqljson","\r\n"
"-- handle mostly opaque data stored in a mysql database\r\n"
"-- json is the easy/suported data format across various \"web\" languages i use ( as2/as3/jscript/lua/php )\r\n"
"-- so the data is serialised in json format\r\n"
"\r\n"
"local tonumber=tonumber\r\n"
"\r\n"
"\r\n"
"local sql=require(\"wetgenes.cgilua.mysql\")\r\n"
"local json=require(\"wetgenes.json\")\r\n"
"\r\n"
"\r\n"
"local cgi = wetgenes.cgilua or require(\"wetgenes.cgilua\")\r\n"
"local cfg = cfg\r\n"
"\r\n"
"\r\n"
"local cgilua=cgilua\r\n"
"\r\n"
"local os=os\r\n"
"\r\n"
"\r\n"
"\r\n"
"local dbg=dbg or function(s) cgilua.errorlog(s) end\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"wetgenes.cgilua.mysqljson\")\r\n"
"\r\n"
"\r\n"
"base_sqltable={\r\n"
"	--	name		type			NULL	KEY,	default		extra\r\n"
"	{	\"id\",		\"bigint(20)\",	\"NO\",	\"PRI\",	nil,		\"auto_increment\"	}, -- unique object ID\r\n"
"	{	\"last\",		\"bigint(20)\",	\"NO\",	\"MUL\",	nil,		nil					}, -- last updated time\r\n"
"	{	\"latch\",	\"int(11)\",		\"NO\",	\"MUL\",	nil,		nil					}, -- a \"lock\" counter\r\n"
"	{	\"json\",		\"text\",			\"NO\",	nil,	nil,		nil					}, -- serialised data\r\n"
"}\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- create a data table\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function create_table(tabname)\r\n"
"\r\n"
"	sql.table_create(tabname,base_sqltable)\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- create a new item, you will need to call put, before it is actually created in the database\r\n"
"-- and of course the put may fail\r\n"
"-- set the id to 0 if you want to get an auto inc id\r\n"
"-- you may also create an item with a user id and perform a get rather than a put\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function create(tabname,id)\r\n"
"\r\n"
"local it={}\r\n"
"\r\n"
"	it.tabname=tabname\r\n"
"	it.id=id or 0\r\n"
"	it.last=os.time()\r\n"
"	it.latch=0\r\n"
"	it.data={}\r\n"
"	it.dirty=false\r\n"
"	it.json=json.Encode(it.data)\r\n"
"	\r\n"
"	return it\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- write data to database\r\n"
"-- this function may FAIL :)\r\n"
"-- need to take apropriate action if it does\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function put(it)\r\n"
"\r\n"
"	it.json=json.Encode(it.data) -- encode data, ready for send\r\n"
"	\r\n"
"	if it.id==0 or it.latch==0 then -- first write, so create a new ID\r\n"
"	\r\n"
"		local tab={}\r\n"
"		local t=os.time()\r\n"
"		local l=1\r\n"
"		\r\n"
"		tab.last=t\r\n"
"		tab.latch=l\r\n"
"		tab.json=it.json\r\n"
"		\r\n"
"		if it.id==0 then -- do not care about id\r\n"
"		\r\n"
"			local ret=sql.do_insert(it.tabname,tab)\r\n"
"			\r\n"
"			if ret==0 then return false end\r\n"
"			\r\n"
"			it.id=ret\r\n"
"		\r\n"
"		else -- we wish to create a fixed id\r\n"
"		\r\n"
"			tab.id=it.id\r\n"
"			local ret=sql.do_insert(it.tabname,tab)\r\n"
"			\r\n"
"			if ret~=1 then return false end\r\n"
"		end\r\n"
"	\r\n"
"		return true\r\n"
"			\r\n"
"	else -- update an existing item\r\n"
"	\r\n"
"		local tab={}\r\n"
"		local t=os.time()\r\n"
"		local l=it.latch+1\r\n"
"		\r\n"
"		tab.last=t\r\n"
"		tab.latch=l\r\n"
"		tab.json=it.json\r\n"
"		\r\n"
"		local ret=sql.do_update(it.tabname,tab,\" id=\"..it.id..\" AND latch=\"..it.latch)\r\n"
"		\r\n"
"		if ret==1 then -- updated OK\r\n"
"		\r\n"
"			it.latch=l\r\n"
"			it.last=t\r\n"
"		\r\n"
"			return true\r\n"
"		else\r\n"
"		\r\n"
"			it.dirty=true -- flag data as dirty\r\n"
"		\r\n"
"			return false\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	return false\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- get data from database using id\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function get(it)\r\n"
"\r\n"
"	local res=sql.execute([[\r\n"
"			SELECT *\r\n"
"			FROM ]]..it.tabname..[[\r\n"
"			WHERE id=]]..it.id..[[ ]])\r\n"
"			\r\n"
"	local tab=sql.named(res,1)\r\n"
"	\r\n"
"	if not tab then return false end\r\n"
"	\r\n"
"	it.last=tonumber(tab.last)\r\n"
"	it.latch=tonumber(tab.latch)\r\n"
"	it.json=tab.json\r\n"
"	\r\n"
"	it.data=json.Decode(it.json) or {} -- decode data so we may edit it\r\n"
"	\r\n"
"	it.dirty=false\r\n"
"	\r\n"
"	return true\r\n"
"\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.cgilua.misc","\r\n"
"local assert,error,getfenv,getmetatable,ipairs,loadstring,next,pairs,pcall,print,rawget,rawset,setfenv,setmetatable,tonumber,tostring,type,unpack,xpcall = assert,error,getfenv,getmetatable,ipairs,loadstring,next,pairs,pcall,print,rawget,rawset,setfenv,setmetatable,tonumber,tostring,type,unpack,xpcall\r\n"
"\r\n"
"local string,table=string,table\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"wetgenes.cgilua.misc\")\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert an ipstr \"a.b.c.d\" to a number\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function ipstr_to_number(str)\r\n"
"\r\n"
"local num=0\r\n"
"\r\n"
"	for word in string.gmatch(str, \"[^.]+\") do num=num*256+tonumber(word) end\r\n"
"	\r\n"
"	return num\r\n"
"\r\n"
"end\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert a number to an ipstr \"a.b.c.d\"\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function number_to_ipstr(num)\r\n"
"\r\n"
"local h,s\r\n"
"\r\n"
"	h=string.format(\"%08x\",num)\r\n"
"\r\n"
"	s=tonumber( string.sub(h,1,2) , 16 ) .. \".\" ..\r\n"
"	  tonumber( string.sub(h,3,4) , 16 ) .. \".\" ..\r\n"
"	  tonumber( string.sub(h,5,6) , 16 ) .. \".\" ..\r\n"
"	  tonumber( string.sub(h,7,8) , 16 ) \r\n"
"\r\n"
"	return s\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- split a string into a table\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function str_split(div,str)\r\n"
"\r\n"
"  if (div=='') or not div then error(\"div expected\", 2) end\r\n"
"  if not str then error(\"str expected\", 2) end\r\n"
"  if str==\"\" then return {\"\"} end\r\n"
"  \r\n"
"  local pos,arr = 0,{}\r\n"
"  \r\n"
"  -- for each divider found\r\n"
"  for st,sp in function() return string.find(str,div,pos,true) end do\r\n"
"	table.insert(arr,string.sub(str,pos,st-1)) -- Attach chars left of current divider\r\n"
"	pos = sp + 1 -- Jump past current divider\r\n"
"  end\r\n"
"  \r\n"
"  if pos~=0 then\r\n"
"	table.insert(arr,string.sub(str,pos)) -- Attach chars right of last divider\r\n"
"  else\r\n"
"	table.insert(arr,str) -- return entire string\r\n"
"  end\r\n"
"  \r\n"
"  \r\n"
"  return arr\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- join a table of things into an english list with commas and an \"and\" at the end\r\n"
"-- returns nil if the table is empty\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function str_join_english_list(t)\r\n"
"\r\n"
"local s\r\n"
"\r\n"
"	for i,v in ipairs(t) do\r\n"
"	\r\n"
"		if not s then -- first\r\n"
"		\r\n"
"			s=v\r\n"
"			\r\n"
"		elseif t[i+1]==nil then -- last\r\n"
"		\r\n"
"			s=s..\" and \"..v\r\n"
"			\r\n"
"		else -- middle\r\n"
"		\r\n"
"			s=s..\", \"..v\r\n"
"			\r\n"
"		end\r\n"
"	\r\n"
"	end\r\n"
"\r\n"
"	return s\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert a string into a hex string\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function str_to_hex(s)\r\n"
"	return string.gsub(s, \".\", function (c)\r\n"
"		return string.format(\"%02x\", string.byte(c))\r\n"
"	end)\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- escape a string for mysql, convert to a (possibly large) number in hex\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function mysql_escape(s)\r\n"
"	return \"0x\"..str_to_hex(s)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- replace any %xx with the intended char, eg \"%20\" becomes a \" \"\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function url_decode(str)\r\n"
"    return string.gsub(str, \"%%(%x%x)\", function(hex)\r\n"
"        return string.char(tonumber(hex, 16))\r\n"
"    end)\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- replace % , & and = chars with %xx codes\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function url_encode(str)\r\n"
"    return string.gsub(str, \"([&=%%])\", function(c)\r\n"
"        return string.format(\"%%%02x\", string.byte(c))\r\n"
"    end)\r\n"
"--  return str\r\n"
"end\r\n"
"",

"wetgenes.cgilua","--\r\n"
"-- Some cgilua helper functions\r\n"
"--\r\n"
"\r\n"
"local cgi\r\n"
"local cgilua=cgilua\r\n"
"\r\n"
"local string=string\r\n"
"local table=table\r\n"
"local math=math\r\n"
"\r\n"
"local type=type\r\n"
"local pairs=pairs\r\n"
"local setfenv=setfenv\r\n"
"\r\n"
"local socket=require(\"socket\")\r\n"
"local misc=require(\"wetgenes.cgilua.misc\")\r\n"
"\r\n"
"module(\"wetgenes.cgilua\")\r\n"
"cgi=_M -- cgi should point to this module\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- print a debug string somewhere useful\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"dbg=function(s)\r\n"
"	cgilua.errorlog(s)\r\n"
"	if not headers_sent then \r\n"
"		contentheader(\"text\", \"html\")\r\n"
"	end\r\n"
"	cgilua.put(s)\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- just a copy of some cgilua put\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"put=function(s)\r\n"
"	cgilua.put(s)\r\n"
"end\r\n"
"header=function(a,b)\r\n"
"	cgilua.header(a,b)\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- Set content type and remember headers have been sent\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function contentheader(type, subtype)\r\n"
"\r\n"
"	if headers_sent then return end -- so this is safe to call multiple times\r\n"
"	\r\n"
"	headers_sent=true -- flag\r\n"
"	\r\n"
"	cgilua.contentheader(type, subtype)\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- redirect\r\n"
"-- either with headers or throw out some javascript if that is too late\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function redirect(url)\r\n"
"\r\n"
"	if headers_sent then\r\n"
"\r\n"
"		cgilua.put([[<script type=\"text/javascript\"> window.location = ]]..string.format(\"%q\",url)..[[; </script>]])\r\n"
"\r\n"
"	else\r\n"
"\r\n"
"		cgilua.redirect(url)\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- Build some always useful information about this request\r\n"
"-- into this module\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function setup() -- call setup once to set global values for this request?\r\n"
"\r\n"
"	start_time=socket.gettime()\r\n"
"	query_count=0\r\n"
"	\r\n"
"	math.randomseed( math.floor(start_time*1000) )\r\n"
"	math.random()\r\n"
"\r\n"
"	headers_sent=false\r\n"
"\r\n"
"	path=cgilua.servervariable(\"SCRIPT_NAME\")..cgilua.servervariable(\"PATH_INFO\")\r\n"
"\r\n"
"	server=cgilua.servervariable(\"SERVER_NAME\")\r\n"
"\r\n"
"	query=cgilua.servervariable(\"QUERY_STRING\")\r\n"
"\r\n"
"	ip=cgilua.servervariable(\"REMOTE_ADDR\")\r\n"
"	ipnum=misc.ipstr_to_number(ip)\r\n"
"\r\n"
"	url=\"http://\"..server..path\r\n"
"	url_query=url\r\n"
"\r\n"
"	if query and query~=\"\" then url_query=url..\"?\"..query end\r\n"
"	-- url_query is now probably full if we need to redirect to ourselves (which we often do)\r\n"
"	\r\n"
"	slash=misc.str_split(\"/\",url) --  a normally useful array\r\n"
"\r\n"
"	-- the lua query/post are dangerous as they may contain tables...\r\n"
"	-- this creates safe copies that are only strings\r\n"
"\r\n"
"	gets={}\r\n"
"	for i,v in pairs(cgilua.QUERY) do\r\n"
"		if type(i)==\"string\" and type(v)==\"string\" then -- do not allow tables to break simple code\r\n"
"			gets[i]=v\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	posts={}\r\n"
"	for i,v in pairs(cgilua.POST) do\r\n"
"		if type(i)==\"string\" and type(v)==\"string\" then -- do not allow tables to break simple code\r\n"
"			posts[i]=v\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	json=nil\r\n"
"	if gets.fmt==\"json\" or posts.fmt==\"json\" then -- a special json request, start building the return\r\n"
"		json={}\r\n"
"		json.doups={}\r\n"
"	end\r\n"
"	\r\n"
"	return _M\r\n"
"end\r\n"
"",

"wetgenes.gamecake","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"-- gamecake lua is a simple CPU only 2D game framework that renders to a bitmap.\r\n"
"-- It bears a passing resemblence to gamecake js.\r\n"
"\r\n"
"\r\n"
"\r\n"
"local win=win\r\n"
"\r\n"
"module(\"wetgenes.gamecake\")\r\n"
"\r\n"
"local wcanvas=require(\"wetgenes.gamecake.canvas\")\r\n"
"\r\n"
"\r\n"
"base={}\r\n"
"meta={}\r\n"
"meta.__index=base\r\n"
"\r\n"
"function create(opts)\r\n"
"\r\n"
"	local cake={}\r\n"
"	setmetatable(cake,meta)\r\n"
"	\r\n"
"	opts.cake=cake -- insert cake into opts\r\n"
"	\r\n"
"	cake.grd_fmt=\"GRD_FMT_U8_BGRA\"\r\n"
"	\r\n"
"	\r\n"
"	cake.canvas=wcanvas.create(opts) -- we will need a canvas to draw too, use same opts\r\n"
"\r\n"
"	return cake\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-- draw using win and opengl functions\r\n"
"-- do not call if you do not have fenestra and a global win setup.\r\n"
"base.draw = function(cake)\r\n"
"	local t=win.tex( cake.canvas.grd )\r\n"
"	t:draw()\r\n"
"	t:clean()\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"",

"work","\n"
"local work_lanes_version=16 -- bump this version number to live update running threads\n"
"local work_lanes_disable=true -- do not use lanes if set, block the main thread for easier debuging\n"
"\n"
"\n"
"\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local math=math\n"
"local string=string\n"
"local print=print\n"
"local coroutine=coroutine\n"
"local require=require\n"
"\n"
"local lanes\n"
"if not work_lanes_disable then lanes=require(\"lanes\") end\n"
"\n"
"local worker=require(\"worker\")\n"
"\n"
"local wetlua=wetlua\n"
"\n"
"module(...)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- create data.lanes table and threads if it isnt already setup\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function lanes_setup()\n"
"\n"
"	msgid=msgid or 1 -- msg id, use and inc on each send\n"
"	rets=rets or {} -- table of return values, slot filed is msgid, just busy wait for results\n"
"	threads=threads or {} -- our threads\n"
"	\n"
"	local need_new_workers=false\n"
"	\n"
"	if work_lanes_disable then -- stop here, we are not using lanes\n"
"		state=\"working\"\n"
"		return\n"
"	end\n"
"\n"
"	\n"
"local function create_new_thread(i)\n"
"	threads[i]={}\n"
"	threads[i].linda=lanes.linda()\n"
"	threads[i].version=work_lanes_version\n"
"	local worker=lanes.gen(\"*\",{[\"globals\"]={apps=apps}}, worker.lanes_worker )\n"
"	threads[i].worker=worker(threads[i].linda,i)\n"
"\n"
"end\n"
"	\n"
"	for i=1,1 do\n"
"	\n"
"		if not threads[i] then -- create new\n"
"		\n"
"			create_new_thread(i)\n"
"		\n"
"		else -- check old\n"
"				\n"
"			if	threads[i].worker.status~=\"done\" and \n"
"				threads[i].worker.status~=\"error\" and \n"
"				threads[i].worker.status~=\"cancelled\" then\n"
"						\n"
"				if threads[i].version~=work_lanes_version then -- this old running thread is a bad version\n"
"				\n"
"					need_new_workers=true\n"
"					\n"
"				end\n"
"			\n"
"			else -- replace dead thread\n"
"			\n"
"				create_new_thread(i)\n"
"			\n"
"			end\n"
"		end\n"
"		\n"
"	end\n"
"		\n"
"--	update=lanes_update\n"
"	\n"
"	if need_new_workers then -- kill all old threads and start new threads\n"
"	\n"
"		lanes_refresh()\n"
"			\n"
"	else\n"
"	\n"
"		state=\"working\"\n"
"	\n"
"	end\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- tell worker threads to shutdown and start again\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function lanes_refresh()\n"
"\n"
"		lanes_clean()		\n"
"		state=\"refreshing\"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- tell worker threads to shutdown\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function lanes_clean()\n"
"\n"
"	state=\"cleaning\"\n"
"\n"
"	if not work_lanes_disable then\n"
"	\n"
"		for i,v in ipairs(threads) do\n"
"		\n"
"			lanes_send({cmd=\"end\"},i)\n"
"			\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get a uniqueish msg id for comms\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function lanes_get_new_msgid()\n"
"\n"
"	msgid=msgid+1\n"
"	if msgid > 65535 then msgid=0 end -- do not let numbers spiral out of control\n"
"	rets[msgid]=nil -- maybe something got stuck\n"
"	\n"
"	return msgid\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- send a msg to a worker\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function lanes_send(msg,idx)\n"
"\n"
"	msg.id=lanes_get_new_msgid() -- where to store a reply, \n"
"	\n"
"	if not work_lanes_disable then\n"
"		threads[idx].linda:send(nil,idx,msg)\n"
"	\n"
"	end\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- check the state of workers\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function lanes_update()\n"
"\n"
"--dbg(\"searching for msg\\n"
"\")\n"
"	if state==\"working\" then\n"
"		local msg\n"
"		\n"
"		if not work_lanes_disable then\n"
"\n"
"			for i,v in ipairs(threads) do -- we shouldnt share lindas amongst worker threads, it seems to confuse things, a bug no doubt\n"
"			\n"
"				repeat\n"
"				\n"
"					msg=threads[i].linda:receive( 0 , 0 ) -- check for returned msgs, but do not block\n"
"					\n"
"					if msg then\n"
"						rets[msg.id]=msg -- store msg in rets table, there are polling waits on these\n"
"					end\n"
"					\n"
"				until not msg\n"
"				\n"
"			end\n"
"		\n"
"		end\n"
"	\n"
"	elseif state==\"cleaning\" or state==\"refreshing\" then\n"
"	\n"
"-- check threads for ending\n"
"\n"
"	local finished=true\n"
"\n"
"		if not work_lanes_disable then\n"
"		\n"
"			for i,v in ipairs(threads) do\n"
"			\n"
"				if	v.worker.status~=\"done\" and \n"
"					v.worker.status~=\"error\" and \n"
"					v.worker.status~=\"cancelled\" then\n"
"				\n"
"					finished=false\n"
"				\n"
"				end\n"
"			\n"
"			end\n"
"		\n"
"		end\n"
"		\n"
"		if finished then\n"
"		\n"
"			if state==\"cleaning\" then -- just shutting down\n"
"			\n"
"				state=\"cleaned\"\n"
"				\n"
"			elseif state==\"refreshing\" then -- reloading\n"
"			\n"
"				state=\"cleaned\"\n"
"				\n"
"				lanes_setup()\n"
"			end\n"
"			\n"
"		end\n"
"	\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- send a url request to a worker thread and return the result\n"
"-- use yield to wait and poll, this should probably be upgraded to use a wakeup signal\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function get_url(url)\n"
"\n"
"local msg={}\n"
"local ret\n"
"\n"
"	msg.cmd=\"url\"\n"
"	msg.url=url\n"
"	if work_lanes_disable then\n"
"		return worker.lanes_url_worker(msg)\n"
"	\n"
"	else	\n"
"	\n"
"		lanes_send(msg,1)\n"
"		\n"
"--print(\"waiting for \"..msg.id..\"\\n"
"\")\n"
"		repeat coroutine.yield() until rets[msg.id] -- poll wait for return value\n"
"--print(\"got \"..msg.id..\"\\n"
"\")\n"
"\n"
"		ret=rets[msg.id]\n"
"		rets[msg.id]=nil\n"
"	\n"
"		return ret.ret\n"
"	end\n"
"	\n"
"	\n"
"end\n"
"",

"wetgenes.www.ngx.srv","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local ngx=require(\"ngx\")\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.srv\"]=_M\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- build a new srv structure for this request\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function new()\n"
"	srv={}\n"
"	\n"
"	srv.put=function(...)\n"
"		ngx.print(...)\n"
"	end\n"
"	\n"
"	srv.exit=function(n)\n"
"		ngx.exit(n)\n"
"		return n\n"
"	end\n"
"	\n"
"	srv.set_header=function(n,v)\n"
"--		log(\"srv.set_header:\",n,\"=\",v)\n"
"		ngx.header[n] = v;\n"
"	end\n"
"	\n"
"	srv.set_mimetype=function(v)	\n"
"		srv.set_header(\"content_type\",v)\n"
"--		log(\"srv.set_mimetype:\",v)\n"
"	end\n"
"	\n"
"	srv.set_cookie=function(t)\n"
"--		log(\"srv.set_cookie:\",t.name,\"=\",t.value)		\n"
"		ngx.header[\"Set-Cookie\"]=t.name..\"=\"..t.value..\"; Domain=\"..t.domain..\"; Path=\"..t.path..\";  Expires=\"..ngx.cookie_time(t.live)\n"
"	end\n"
"\n"
"	srv.redirect=function(url)\n"
"--		log(\"srv.redirect:\",url)\n"
"		return ngx.redirect(url)\n"
"	end\n"
"\n"
"	srv.reloadcache=function(...)\n"
"		log(\"srv.reloadcache:\",...)\n"
"	end\n"
"\n"
"	srv.cache={} -- a very local cache\n"
"	\n"
"	srv.method=ngx.var.request_method -- probably GET or POST\n"
"	\n"
"	srv.ip=ngx.var.remote_addr -- users IP\n"
"	\n"
"\n"
"\n"
"	local scheme=ngx.var.scheme			-- http or https\n"
"	local domain=ngx.var.server_name\n"
"	local port=ngx.var.server_port\n"
"	local uri=ngx.var.uri				-- begins with /\n"
"	\n"
"	if port and port~=\"80\" then\n"
"	\n"
"		srv.url=scheme..\"://\"..domain..\":\"..port..uri -- the url requested (not including any query string)\n"
"\n"
"	else\n"
"\n"
"		srv.url=scheme..\"://\"..domain..uri -- the url requested (not including any query string)\n"
"\n"
"	end\n"
"	\n"
"	srv.query=ngx.var.args -- the query string\n"
"--log(srv.query)\n"
"	\n"
"	\n"
"	srv.headers=ngx.req.get_headers()\n"
"	\n"
"	srv.cookies={}\n"
"	local cs\n"
"	if type(srv.headers.Cookie==\"string\") then\n"
"		cs=wstr.split(srv.headers.Cookie,\";\")\n"
"	else\n"
"		cs=srv.headers.Cookie\n"
"	end\n"
"	log(srv.headers.Cookie)\n"
"	for i,s in ipairs(cs or {}) do\n"
"		local n,v=wstr.split_equal(wstr.trim(s))\n"
"		srv.cookies[n]=v\n"
"	end\n"
"\n"
"	ngx.req.read_body()\n"
"	srv.posts=ngx.req.get_post_args()\n"
"\n"
"	srv.uploads={}\n"
"\n"
"	srv.gets=ngx.req.get_uri_args()\n"
"\n"
"	srv.vars={}\n"
"	for key, val in pairs( srv.posts ) do\n"
"		srv.vars[key]=val\n"
"	end\n"
"	for key, val in pairs( srv.gets ) do\n"
"		srv.vars[key]=val\n"
"	end\n"
"\n"
"	return srv\n"
"end\n"
"",

"wetgenes.bake.js","\r\n"
"local require=require\r\n"
"local loadfile=loadfile\r\n"
"local setfenv=setfenv\r\n"
"local pcall=pcall\r\n"
"local print=print\r\n"
"local pairs=pairs\r\n"
"local ipairs=ipairs\r\n"
"local type=type\r\n"
"\r\n"
"local string=string\r\n"
"local table=table\r\n"
"local io=io\r\n"
"local os=os\r\n"
"\r\n"
"module(...)\r\n"
"\r\n"
"function build(tab)\r\n"
"\r\n"
"local bake=require(\"wetgenes.bake\")\r\n"
"\r\n"
"local pp=require(\"wetgenes.pp\")\r\n"
"local lfs=require(\"lfs\")\r\n"
"\r\n"
"local no_art=false\r\n"
"\r\n"
"local opts=tab.opts or {} -- can pass in an opts of default options\r\n"
"\r\n"
"local opts_changed=false\r\n"
"local func\r\n"
"\r\n"
"	opts.VERSION_NUMBER=opts.VERSION_NUMBER or 0\r\n"
"\r\n"
"	func=loadfile(\"src/opts.lua\")\r\n"
"	if func then\r\n"
"		setfenv(func,opts)\r\n"
"		pcall(func)\r\n"
"	else\r\n"
"		opts_changed=true\r\n"
"	end\r\n"
"		\r\n"
"	for i=1,#tab.arg do\r\n"
"		\r\n"
"		if tab.arg[i]==\"bump\" then\r\n"
"		\r\n"
"			opts.VERSION_NUMBER=opts.VERSION_NUMBER+0.001\r\n"
"		\r\n"
"			opts_changed=true\r\n"
"		end\r\n"
"		\r\n"
"		if tab.arg[i]==\"debug\" then\r\n"
"		\r\n"
"			opts.VERSION_BUILD=\"debug\"\r\n"
"		\r\n"
"			opts_changed=true\r\n"
"		end\r\n"
"		\r\n"
"		if tab.arg[i]==\"release\" then\r\n"
"		\r\n"
"			opts.VERSION_BUILD=\"release\"\r\n"
"		\r\n"
"			opts_changed=true\r\n"
"		end\r\n"
"		\r\n"
"		if tab.arg[i]==\"noart\" then\r\n"
"			no_art=true\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	if opts_changed then -- write out changed file\r\n"
"		local fp=io.open(\"src/opts.lua\",\"w\")\r\n"
"		for i,v in pairs(opts) do\r\n"
"		\r\n"
"			if type(v)==\"number\" then\r\n"
"				fp:write(i..\"=\"..v..\"\\n"
"\")\r\n"
"			elseif type(v)==\"string\" then\r\n"
"				fp:write(i..\"=\"..string.format(\"%q\",v)..\"\\n"
"\")\r\n"
"			end\r\n"
"		end\r\n"
"		fp:close()\r\n"
"	end\r\n"
"	\r\n"
"	\r\n"
"	\r\n"
"	\r\n"
"-- where we are building from\r\n"
"bake.cd_base	=	bake.cd_base or bake.get_cd()\r\n"
"\r\n"
"-- where we are building to\r\n"
"bake.cd_out		=	bake.cd_out or 'out'\r\n"
"\r\n"
"lfs.mkdir(bake.cd_out)\r\n"
"lfs.mkdir(bake.cd_out..'/art')\r\n"
"lfs.mkdir(bake.cd_out..'/cache')\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"-- go up a dir from base cd and remember as main CD for building commands\r\n"
"\r\n"
"bake.set_cd(bake.get_cd()..'/..')\r\n"
"bake.cd=bake.get_cd()\r\n"
"\r\n"
"print('cd','=',bake.cd)\r\n"
"\r\n"
"\r\n"
"bake.cmd.java=\"java\" -- needed for minifier\r\n"
"bake.cmd.zip=\"zip\" -- needed to zip stuffs\r\n"
"\r\n"
"bake.cmd.lua		=	bake.path_clean_exe( bake.cd , '/exe/lua' )\r\n"
"\r\n"
"if bake.osflavour==\"nix\" then -- expected to be installed...\r\n"
"--	bake.cmd.mtasc=\"mtasc\"\r\n"
"--	bake.cmd.swfmill=\"swfmill\"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"bake.set_cd(bake.cd_base)\r\n"
"\r\n"
"bake.files_min_js=bake.files_min_js or {}\r\n"
"bake.files_min_js[ #bake.files_min_js + 1 ]=tab.name\r\n"
"\r\n"
"bake.files_js={}\r\n"
"for v in lfs.dir(\"src\") do -- add all .js files in the src dir\r\n"
"	if string.find(v,\"%.js$\") then\r\n"
"		v=string.gsub( v , \"%.js$\" , \"\")\r\n"
"		table.insert(bake.files_js,v)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"bake.files_css={}\r\n"
"for v in lfs.dir(\"src\") do -- add all .css files in the src dir\r\n"
"	if string.find(v,\"%.css$\") then\r\n"
"		v=string.gsub( v , \"%.css$\" , \"\")\r\n"
"		table.insert(bake.files_css,v)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"bake.files_html={}\r\n"
"for v in lfs.dir(\"src\") do -- and all .html files in the src dir\r\n"
"	if string.find(v,\"%.html$\") then\r\n"
"		v=string.gsub( v , \"%.html$\" , \"\")\r\n"
"		table.insert(bake.files_html,v)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"for i,v in ipairs(bake.files_js) do\r\n"
"	pp.loadsave( 'src/'..v..'.js' , bake.cd_out..'/'..v..'.js' )\r\n"
"end\r\n"
"for i,v in ipairs(bake.files_css) do\r\n"
"	pp.loadsave( 'src/'..v..'.css' , bake.cd_out..'/'..v..'.css' )\r\n"
"end\r\n"
"\r\n"
"for i,v in ipairs(bake.files_html) do\r\n"
"	pp.loadsave( 'src/'..v..'.html' , bake.cd_out..'/'..v..'.html' )\r\n"
"end\r\n"
"\r\n"
"-- generic pp of files,full paths from -> to\r\n"
"bake.files_pp=bake.files_pp or {}\r\n"
"for i,v in ipairs(bake.files_pp) do\r\n"
"	pp.loadsave( v[1] , v[2] )\r\n"
"end\r\n"
"\r\n"
"\r\n"
"io.flush()\r\n"
"\r\n"
"if no_art then\r\n"
"print('****')\r\n"
"print('**SKIPPING**ART**BUILD**STEP**')\r\n"
"print('****')\r\n"
"else\r\n"
"\r\n"
"\r\n"
"for i,v in ipairs(bake.files_min_js) do\r\n"
"print('compressing '..v)\r\n"
"	bake.execute( bake.cd_base , bake.cmd.java ,\r\n"
"\"-jar ../../js/class/compiler.jar --js_output_file \"..bake.cd_out..\"/\"..v..\".min.js --js \"..bake.cd_out..\"/\"..v..\".js\")\r\n"
"\r\n"
"end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.png$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.jpg$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.swf$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.css$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.mp3$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.ogg$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.wav$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"jslib\",filter=\"%.js$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"	\r\n"
"-- build an application cache\r\n"
"\r\n"
"	for i,v in ipairs(tab.cache_files or {}) do\r\n"
"		local v1,v2\r\n"
"		if type(v)==\"table\" then\r\n"
"			v1=v[1]\r\n"
"			v2=v[2]\r\n"
"		else\r\n"
"			v1=v\r\n"
"			v2=v\r\n"
"		end\r\n"
"print('caching out/'..v1..\" as \"..v2)\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/cache/\"..v2)\r\n"
"		bake.copyfile(\"out/\"..v1,bake.cd_out..\"/cache/\"..v2)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=bake.cd_out..\"/cache\",dir=\".\",filter=\"\"}\r\n"
"	local mc=table.concat(r.ret,\"\\n"
"\")..\"\\n"
"\"\r\n"
"	local fp=io.open(bake.cd_out..\"/cache/cache.manifest\",\"w\")\r\n"
"	fp:write(\"CACHE MANIFEST\\n"
"\")\r\n"
"	fp:write(\"#Updated on \"..os.date()..\"\\n"
"\")\r\n"
"	fp:write(mc)\r\n"
"	fp:close()\r\n"
"	\r\n"
"-- zip everything in the cache, this is our distribution package\r\n"
"	bake.execute(bake.cd_out..\"/cache\",bake.cmd.zip,\"../\"..tab.name..\".zip * -r\")\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"",

"wetquire","\n"
"local oldmodule=module\n"
"local oldrequire=require\n"
"\n"
"-- unhappy modules, do not use this code with them\n"
"local cruft_list={\n"
"	[\"lanes\"]=true,\n"
"	[\"socket\"]=true,\n"
"}\n"
"\n"
"local os=os\n"
"\n"
"-- a small attempt to replace the module function and to impliment live reloading of lua code\n"
"-- on demand without restarting a lua state, this is dodgy but rather useful for testing\n"
"-- and live server situations where downtime is to be avoided. Small changes can be pushed\n"
"-- to a live server seamlessly with a little care.\n"
"\n"
"--\n"
"-- This monkey patches module and require when you call overload and is best applied to the master environment\n"
"-- as early as possible.\n"
"--\n"
"\n"
"-- define functions as local here so they can call each other\n"
"local _overload\n"
"local _rerequire\n"
"local _remodule\n"
"local _require\n"
"local _module\n"
"\n"
"\n"
"-- modules loaded before this time whould be reloaded when required\n"
"-- defaults to 0, just set to os.time() then rerequire your main module\n"
"-- and it should reload every lua module that supports reloading\n"
"local reload_time=0\n"
"\n"
"--\n"
"-- we are about to use this new module function in this file so it needs to be\n"
"-- defined here\n"
"--\n"
"function _remodule(name)\n"
"--print(name)\n"
"--print(package.loaded[name])\n"
"	local mod = package.loaded[name] -- reuse old environment on a reload\n"
"	if mod~=\"table\" then --  or make a new one\n"
"		mod={}\n"
"	end\n"
"	\n"
"-- push some extra data into the module, this flags the module as being a remodule\n"
"-- and provides what I need to reload it from disk\n"
"-- if _MOD_FILENAME is not going to work then do not use this version of module\n"
"-- if you are expecting side effects from the normal module function then again\n"
"-- do not use this version :)\n"
"	mod._MOD_NAME=name\n"
"	mod._MOD_FILENAME=debug.getinfo(2).short_src -- where to reload from\n"
"	mod._MOD_LOADTIME=os.time() -- the time that we where loaded \n"
"\n"
"-- dbg\n"
"--	print(\"Loaded module : \".. mod._MOD_FILENAME)\n"
"\n"
"	package.loaded[name] = mod\n"
"	if setfenv then setfenv(2, mod) end -- setfenv may not exist in lua 5.2\n"
"\n"
"	return mod\n"
"end\n"
"\n"
"\n"
"--\n"
"-- A require function that can reload the lua source when told to do so\n"
"--\n"
"function _rerequire(s)\n"
"	if cruft_list[s] then return _require(s) end -- use old require and module functions\n"
"\n"
"	local oldstate=_overload(false)\n"
"\n"
"	local mod=oldrequire(s)\n"
"\n"
"	if type(mod)==\"table\" and mod._MOD_LOADTIME and ( mod._MOD_LOADTIME < reload_time ) then -- force reload\n"
"\n"
"		if mod._MOD_FILENAME then\n"
"			if not mod._MOD_DISABLE_RELOAD then\n"
"				local f,err=loadfile(mod._MOD_FILENAME)\n"
"				if f then\n"
"					f()\n"
"				else\n"
"					print(err) -- treat as warning\n"
"				end\n"
"			end\n"
"		end\n"
"	\n"
"	end\n"
"\n"
"	_overload(oldstate)\n"
"	return mod\n"
"end\n"
"\n"
"function _require(s)\n"
"	local oldstate=_overload(true)\n"
"	local mod=oldrequire(s)\n"
"	_overload(oldstate)\n"
"	return mod\n"
"end\n"
"\n"
"_module=oldmodule\n"
"\n"
"--\n"
"-- replace global functions, or restore (restore=true)\n"
"-- returns true if they where the original functions\n"
"--\n"
"function _overload(restore)\n"
"\n"
"	\n"
"	local oldstate\n"
"	\n"
"	oldstate=(require==oldrequire) -- true if functions are not replaced\n"
"	\n"
"	if restore then -- restore\n"
"\n"
"		require=oldrequire\n"
"		module=oldmodule\n"
"		\n"
"	else -- replace\n"
"	\n"
"		require=_rerequire\n"
"		module=_remodule\n"
"		\n"
"	end\n"
"\n"
"	return oldstate\n"
"end\n"
"\n"
"\n"
"--use all the above locals to create this module\n"
"\n"
"_remodule(\"wetquire\")\n"
"\n"
"_MOD_DISABLE_RELOAD=true -- disable reload of this module\n"
"\n"
"module=_module\n"
"require=_require\n"
"\n"
"remodule=_remodule\n"
"rerequire=_rerequire\n"
"\n"
"overload=_overload\n"
"--overload=function() return true end -- disable\n"
"\n"
"function set_reload_time(t)\n"
"	reload_time=t or os.time() -- mark all modules loaded before now as requiring a reload\n"
"end\n"
"",

"wetgenes.www.ngx.sys","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"local ngx=require(\"ngx\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.sys\"]=_M\n"
"\n"
"\n"
"function sleep(...)\n"
"	log(\"sys.sleep:\")\n"
"\n"
"--	return core.sleep(...)\n"
"\n"
"end\n"
"\n"
"function file_read(filename)\n"
"	local d\n"
"	local fp=io.open(\"html/\"..filename,\"r\")\n"
"	if fp then\n"
"		d=fp:read(\"*a\")\n"
"		fp:close()\n"
"	end\n"
"	return d\n"
"--	return core.file_read(filename)\n"
"end\n"
"\n"
"function bytes_split(bytes,size)\n"
"	log(\"sys.bytes_split:\")\n"
"	\n"
"	local t={}\n"
"	for i=1,#bytes,size do\n"
"		t[#t+1]=bytes:sub(i,i+size-1)\n"
"	end\n"
"	return t\n"
"end\n"
"\n"
"function bytes_join(tab)\n"
"	return table.concat(tab)\n"
"end\n"
"\n"
"function bytes_to_string(bytes)\n"
"	return bytes\n"
"end\n"
"\n"
"function bin_encode(enc,s)\n"
"	log(\"sys.bin_encode:\")\n"
"\n"
"	if enc==\"hex\" then\n"
"		r=str_to_hex(s)\n"
"	elseif enc==\"base64\" then\n"
"		r=b64_enc(s)\n"
"	else\n"
"		r=s\n"
"	end\n"
"	\n"
"	return r \n"
"--	return core.bin_encode(t,b)\n"
"end\n"
"\n"
"function md5(s,t)\n"
"	log(\"sys.md5:\")\n"
"	if f==\"bin\" then return ngx.md5_bin(s) end\n"
"	return ngx.md5(s)\n"
"end\n"
"function sha1(s,f)\n"
"	log(\"sys.sha1:\")\n"
"--	if f==\"bin\" then return ngx.sha1_bin(s) end\n"
"--	return ngx.sha1(s)\n"
"--	return core.sha1(s,f)\n"
"end\n"
"function hmac_sha1(k,s,f)\n"
"	log(\"sys.hmac_sha1:\")\n"
"	if f==\"bin\" then return ngx.hmac_sha1(k,s) end\n"
"	return ngx.hmac_sha1(k,s)\n"
"end\n"
"\n"
"function zip_list(z)\n"
"	log(\"sys.zip_list:\")\n"
"--	return core.zip_list(z)\n"
"end\n"
"function zip_read(z,n)\n"
"	log(\"sys.sleep:\")\n"
"--	return core.zip_read(z,n)\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert a string into a hex string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function str_to_hex(s)\n"
"	return string.gsub(s, \".\", function (c)\n"
"		return string.format(\"%02x\", string.byte(c))\n"
"	end)\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- check if the given file exists\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function file_exists(filename)\n"
"\n"
"	local f=io.open(\"html/\"..filename,\"r\")\n"
"	if f then\n"
"		f:close()\n"
"		return true\n"
"	end\n"
"\n"
"	return false\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- find a given lua file, within the lua path\n"
"-- do not pass in the .lua extension\n"
"-- returns a path to a file you can then open\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function file_find_lua(name)\n"
"\n"
"	return \"../lua/\"..name..\".lua\"\n"
"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function redirect(srv,url)\n"
"\n"
"	if not srv.redirect(url) then -- header write failed, spit out some java script instead?\n"
"	\n"
"		srv.put([[<script type=\"text/javascript\" >window.location = \"]]..url..[[\";</script>]])\n"
"		\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"-- character table string\n"
"local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n"
"\n"
"-- encoding\n"
"function b64_enc(data)\n"
"    return ((data:gsub('.', function(x) \n"
"        local r,b='',x:byte()\n"
"        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\n"
"        return r;\n"
"    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\n"
"        if (#x < 6) then return '' end\n"
"        local c=0\n"
"        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\n"
"        return b:sub(c+1,c+1)\n"
"    end)..({ '', '==', '=' })[#data%3+1])\n"
"end\n"
"\n"
"-- decoding\n"
"function b64_dec(data)\n"
"    data = string.gsub(data, '[^'..b..'=]', '')\n"
"    return (data:gsub('.', function(x)\n"
"        if (x == '=') then return '' end\n"
"        local r,f='',(b:find(x)-1)\n"
"        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end\n"
"        return r;\n"
"    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)\n"
"        if (#x ~= 8) then return '' end\n"
"        local c=0\n"
"        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end\n"
"        return string.char(c)\n"
"    end))\n"
"end\n"
"",

"wetgenes.bake","--+-----------------------------------------------------------------------------------------------------------------+--\r\n"
"--\r\n"
"-- (C) Kriss Daniels 2005 http://www.XIXs.com\r\n"
"--\r\n"
"-- This file made available under the terms of The MIT License : http://www.opensource.org/licenses/mit-license.php\r\n"
"--\r\n"
"-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n"
"--\r\n"
"-- The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n"
"--\r\n"
"-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n"
"--\r\n"
"--+-----------------------------------------------------------------------------------------------------------------+--\r\n"
"\r\n"
"\r\n"
"--\r\n"
"-- A thrown together build toool, well some useful lua functions for making a build.\r\n"
"--\r\n"
"-- The intent is to optimise a fullbuild rather than a partial build,\r\n"
"--\r\n"
"-- it is the times you have to rebuild everything that causes you to go make a cup of tea, after all.\r\n"
"--\r\n"
"-- This is exceptionally true of windows where process creation has a huge overhead\r\n"
"--\r\n"
"-- Hopefully things are kept shrinkwrapped enough here to enable an easy unixy port when I need it (theywoz)\r\n"
"--\r\n"
"\r\n"
"local lfs=require(\"lfs\")\r\n"
"local table=table\r\n"
"local string=string\r\n"
"local os=os\r\n"
"local io=io\r\n"
"local print=print\r\n"
"\r\n"
"local ipairs=ipairs\r\n"
"local assert=assert\r\n"
"\r\n"
"module(\"wetgenes.bake\")\r\n"
"\r\n"
"osflavour=\"win\"\r\n"
"	\r\n"
"local os_shell=os.getenv(\"SHELL\")\r\n"
"if os_shell and string.sub(os_shell,1,5)== \"/bin/\" then\r\n"
"	osflavour=\"nix\"\r\n"
"end\r\n"
"\r\n"
"-- fullpaths to usefull commands\r\n"
"\r\n"
"cmd={}\r\n"
"\r\n"
"\r\n"
"-- place to store options\r\n"
"\r\n"
"opt={}\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"--\r\n"
"-- get/set current dir\r\n"
"--\r\n"
"get_cd=function()\r\n"
"\r\n"
"	return string.gsub(lfs.currentdir(),'\\\\','/')\r\n"
"\r\n"
"end\r\n"
"set_cd=function(str)\r\n"
"\r\n"
"	lfs.chdir(str)\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"--\r\n"
"-- combine strings and resolve . or .. and cancel out multiple // and switch \\ to /\r\n"
"-- so we should end up with a valid clean path\r\n"
"--\r\n"
"path_clean=function(...)\r\n"
"\r\n"
"local str\r\n"
"\r\n"
"	str=table.concat({...})\r\n"
"	str=string.gsub(str,'\\\\','/')\r\n"
"\r\n"
"	return(str)\r\n"
"\r\n"
"end\r\n"
"\r\n"
"--\r\n"
"-- as path_clean but add .exe (so we can easily not do this later if under unix)\r\n"
"--\r\n"
"path_clean_exe=function(...)\r\n"
"\n"
"if osflavour==\"nix\" then\n"
"	return(path_clean(...))\r\n"
"else\r\n"
"	return(path_clean(...)..'.exe')\r\n"
"end\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"--\r\n"
"-- return the substring after the last .\r\n"
"--\r\n"
"path_ext=function(str)\r\n"
"\r\n"
"	return(str)\r\n"
"\r\n"
"end\r\n"
"\r\n"
"--\r\n"
"-- perform some substitutions and then execute the command from the given cwd\r\n"
"--\r\n"
"execute=function(cwd,cmd,arg)\r\n"
"\r\n"
"	if cwd then\r\n"
"	\r\n"
"		lfs.chdir(cwd)\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	if arg then\r\n"
"	\r\n"
"		os.execute(cmd..' '..arg)\r\n"
"		\r\n"
"	else\r\n"
"	\r\n"
"		os.execute(cmd)\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"end\r\n"
"\n"
"\r\n"
"\r\n"
"--\r\n"
"-- given a filename make sure that its containing directory exists\r\n"
"--\r\n"
"create_dir_for_file=function(n)\r\n"
"	local t={}\r\n"
"	for w in string.gmatch(n, \"[^/]+\") do t[#t+1]=w end\r\n"
"	local s=\"\"\r\n"
"	t[#t]=nil -- remove the filename\r\n"
"	for i,v in ipairs(t) do\r\n"
"		s=s..v\r\n"
"		lfs.mkdir(s)\r\n"
"		s=s..\"/\"\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"--\r\n"
"-- get the filenames (relative to the basedir) of all files matching the filter\r\n"
"--\r\n"
"findfiles=function(opts)\r\n"
"if not opts then return end\r\n"
"if not opts.basedir then return end\r\n"
"if not opts.dir then return end\r\n"
"if not opts.filter then return end\r\n"
"opts.ret=opts.ret or {}\r\n"
"\r\n"
"	local subdirs={}\r\n"
"	local d=opts.basedir..\"/\"..opts.dir\r\n"
"	if lfs.attributes(d) then -- only if dir exists\r\n"
"		for v in lfs.dir(d) do\r\n"
"			local a=lfs.attributes(d..\"/\"..v)\r\n"
"	--print(\"test\",v,a.mode)\r\n"
"			if a.mode==\"file\" then\r\n"
"				if string.find(v,opts.filter) then\r\n"
"	--print(\"found\",v)\r\n"
"					opts.ret[#opts.ret+1]=opts.dir..\"/\"..v\r\n"
"				end\r\n"
"			end\r\n"
"			if a.mode==\"directory\" then\r\n"
"				if v:sub(1,1)~=\".\" then\r\n"
"					subdirs[#subdirs+1]=v\r\n"
"				end\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"-- recurse\r\n"
"	local dir=opts.dir\r\n"
"	for i,v in ipairs(subdirs) do\r\n"
"		opts.dir=dir..\"/\"..v\r\n"
"		findfiles(opts)\r\n"
"	end\r\n"
"\r\n"
"	return opts\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"readfile=function(name)\r\n"
"	local fp=assert(io.open(name,\"r\"))\r\n"
"	local d=fp:read(\"*all\")\r\n"
"	fp:close()\r\n"
"	return d\r\n"
"end\r\n"
"\r\n"
"file_exists=function(name)\r\n"
"	local fp=(io.open(name,\"r\"))\r\n"
"--print(fp)\r\n"
"	if fp then fp:close() return true end\r\n"
"	return false\r\n"
"end\r\n"
"\r\n"
"writefile=function(name,data)\r\n"
"	local fp=assert(io.open(name,\"w\"))\r\n"
"	fp:write(data)\r\n"
"	fp:close()\r\n"
"end\r\n"
"\r\n"
"copyfile=function(frm,too)\r\n"
"	local text=readfile(frm)\r\n"
"	writefile(too,text)\r\n"
"end\r\n"
"\r\n"
"",

"simpxml","\r\n"
"local table=table\r\n"
"local string=string\r\n"
"\r\n"
"local pairs=pairs\r\n"
"local ipairs=ipairs\r\n"
"\r\n"
"local type=type\r\n"
"\r\n"
"local tostring=tostring\r\n"
"local print=print\r\n"
"\r\n"
"module(...)\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- some old simple xml parsing code, found here and fixed up a little :)\r\n"
"--\r\n"
"-- http://lua-users.org/lists/lua-l/2002-06/msg00040.html\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- auxiliar function to parse tag attributes\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function parse_args(s,label)\r\n"
"  local arg = {}\r\n"
"  arg[0]=string.lower(label or \"?\")\r\n"
"  string.gsub(s, \"([%w_]+)%s*=%s*([\\\"'])(.-)%2\", function (w, _, a)\r\n"
"    arg[string.lower(w)] = a\r\n"
"  end)\r\n"
"  return arg\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- string \"s\" is a string with XML marks. This function parses the string\r\n"
"-- and returns the resulting tree.\r\n"
"--\r\n"
"-- simple but will parse small data xml files just fine and thats what im using it for\r\n"
"--\r\n"
"-- it is very easy to produce a valid xml file that will break this\r\n"
"-- however as long as you are just using tags/data and especially if you control the creation\r\n"
"-- everything will be peachy\r\n"
"--\r\n"
"-- by putting the tag name in [0] we can use the string namespace for all attributes\r\n"
"--\r\n"
"-- [0] == tag name (lowercase)\r\n"
"-- [1++] == contained strings or tables (sub tags)\r\n"
"-- [string] == attributes (indexe strings will be converted to lowercase)\r\n"
"--\r\n"
"-- all string keys are attributes associated with the tag\r\n"
"-- all numerical keys are sub tags/strings except [0] which is the tag name\r\n"
"--\r\n"
"-- see the other functions here for how to simply step through this tree\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function parse(s)\r\n"
"  local stack = {}\r\n"
"  local top = {}\r\n"
"  table.insert(stack, top)\r\n"
"  local i = 1\r\n"
"  local ni,j,c,label,args, empty = string.find(s, \"<%?(%/?)([%w_]+)(.-)(%/?)%?>\")\r\n"
"  \r\n"
"  while ni do\r\n"
"    local text = string.sub(s, i, ni-1)\r\n"
"    if not string.find(text, \"^%s*$\") then\r\n"
"      table.insert(top, text)\r\n"
"    end\r\n"
"    if empty == \"/\" then  -- empty element tag\r\n"
"      table.insert(top, parse_args(args,label) )\r\n"
"    elseif c == \"\" then   -- start tag\r\n"
"      top = parse_args(args,label)\r\n"
"      table.insert(stack, top)   -- new level\r\n"
"    else  -- end tag\r\n"
"      local toclose = table.remove(stack)  -- remove top\r\n"
"      top = stack[#stack]\r\n"
"      if #stack < 1 then\r\n"
"        assert(false,\"Tag <\"..label..\"> not matched \")\r\n"
"      end\r\n"
"      if toclose[0] ~= label then\r\n"
"	    assert(false,\"Tag <\"..(toclose[0] or \"?\")..\"> doesnt match <\"..(label or \"?\")..\">.\")\r\n"
"      end\r\n"
"      table.insert(top, toclose)\r\n"
"    end \r\n"
"    i = j+1\r\n"
"    ni,j,c,label,args, empty = string.find(s, \"<(%/?)([%w_]+)(.-)(%/?)>\", j)\r\n"
"  end\r\n"
"  local text = string.sub(s, i)\r\n"
"  if not string.find(text, \"^%s*$\") then\r\n"
"    table.insert(stack[#stack], text)\r\n"
"  end\r\n"
"  return stack[2]\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find the first child tag of the given type\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function child(parent,name)\r\n"
"\r\n"
"	if type(name)==\"table\" then -- sub sub sub lookup\r\n"
"	\r\n"
"		local ret=parent\r\n"
"		for i,v in ipairs(name) do\r\n"
"			if not ret then return nil end\r\n"
"			ret=child(ret,v)\r\n"
"		end\r\n"
"		return ret\r\n"
"		\r\n"
"	else\r\n"
"		name=string.lower(name)\r\n"
"\r\n"
"		for i,v in ipairs(parent) do\r\n"
"			if type(v)==\"table\" and v[0] and string.lower(v[0])==name then return v end\r\n"
"		end\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"	return nil\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert an xml tree to an xml string that could then be output to a file\r\n"
"--\r\n"
"-- again, best used with small data sets only please :)\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function tree_to_string(tree)\r\n"
"\r\n"
"	local t={}\r\n"
"	function out(s) t[#t+1]=tostring(s) end\r\n"
"	local indent=-1\r\n"
"	\r\n"
"	local function dosub(l)\r\n"
"		indent=indent+1\r\n"
"	\r\n"
"		local tabs=\"\"\r\n"
"		if indent>0 then tabs=string.rep(\" \",indent) end\r\n"
"	\r\n"
"		out(tabs)\r\n"
"		out(\"<\"..l[0])\r\n"
"		local ns={}\r\n"
"		for i,v in pairs(l) do\r\n"
"			if type(i)==\"string\" then --find attributes\r\n"
"				ns[#ns+1]=i\r\n"
"			end\r\n"
"		end\r\n"
"		table.sort(ns) -- ascii sort attributes\r\n"
"		for i=1,#ns do\r\n"
"			out(\" \"..ns[i]..\"=\\\"\"..l[ ns[i] ]..\"\\\"\")\r\n"
"		end\r\n"
"		if not l[1] then -- no children\r\n"
"			out(\" />\\n"
"\")\r\n"
"		else\r\n"
"			out(\">\\n"
"\")\r\n"
"			\r\n"
"			for i=1,#l do\r\n"
"				if type(l[i])==\"table\" then\r\n"
"					dosub(l[i])\r\n"
"				else\r\n"
"					out(l[i])\r\n"
"				end\r\n"
"			end\r\n"
"			\r\n"
"			out(tabs)\r\n"
"			out(\"</\"..l[0]..\">\\n"
"\")\r\n"
"		end\r\n"
"\r\n"
"		indent=indent-1\r\n"
"	end\r\n"
"-- the top chunk is an xml version string and possibly some text\r\n"
"-- skip that bit, just output its chunks with this standard xml header\r\n"
"	out([[<?xml version=\"1.0\" standalone=\"no\" ?>]])\r\n"
"	out(\"\\n"
"\")\r\n"
"	for i=1,#tree do\r\n"
"		if type(tree[i])==\"table\" then\r\n"
"			dosub(tree[i])\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	return table.concat(t)\r\n"
"end\r\n"
"",

"fenestra.data","\r\n"
"\r\n"
"local hex=function(str) return tonumber(str,16) end\r\n"
"\r\n"
"local io=io\r\n"
"local string=string\r\n"
"local table=table\r\n"
"local ipairs=ipairs\r\n"
"local math=math\r\n"
"local loadstring=loadstring\r\n"
"local pcall=pcall\r\n"
"\r\n"
"-- imported global functions\r\n"
"local sub = string.sub\r\n"
"local match = string.match\r\n"
"local find = string.find\r\n"
"local push = table.insert\r\n"
"local pop = table.remove\r\n"
"local append = table.insert\r\n"
"local concat = table.concat\r\n"
"local floor = math.floor\r\n"
"local write = io.write\r\n"
"local read = io.read\r\n"
"local type = type\r\n"
"local setfenv = setfenv\r\n"
"local tostring=tostring\r\n"
"local pairs=pairs\r\n"
"local ipairs=ipairs\r\n"
"local unpack=unpack\r\n"
"\r\n"
"local _G = _G\r\n"
"\r\n"
"local apps=apps\r\n"
"local wldir=apps.dir or \"\"\r\n"
"\r\n"
"module(\"fenestra.data\")\r\n"
"\r\n"
"\r\n"
"\r\n"
"function setup(fenestra)\r\n"
"\r\n"
"	local print=fenestra._g.print\r\n"
"	\r\n"
"	local it={}\r\n"
"	\r\n"
"	function it.clean()\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"	function it.load(fname)\r\n"
"\r\n"
"		local fp=io.open(wldir..fname,\"rb\")\r\n"
"		local dat=fp:read(\"*all\")\r\n"
"		fp:close();\r\n"
"		\r\n"
"		\r\n"
"		return fenestra.load(dat)\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"	return it\r\n"
"end\r\n"
"",

"wetgenes.www.any.users","if ngx then\n"
"	return require(\"wetgenes.www.ngx.users\")\n"
"else\n"
"	return require(\"wetgenes.www.gae.users\")\n"
"end\n"
"",

"wetgenes.www.ngx.mail","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.mail\"]=_M\n"
"\n"
"\n"
"function send(...)\n"
"	log(\"mail.send:\")\n"
"--	return core.send(...)\n"
"end\n"
"",

"wetgenes.www.any.log","if ngx then\r	return require(\"wetgenes.www.ngx.log\")\relse\r	return require(\"wetgenes.www.gae.log\")\rend\r",

"wetgenes.www.gae.users","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local core=require(\"wetgenes.www.gae.users.core\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.users\"]=_M\n"
"\n"
"function login_url(a)\n"
"\n"
"	return core.login_url(a)\n"
"\n"
"end\n"
"\n"
"\n"
"function logout_url(a)\n"
"\n"
"	return core.logout_url(a)\n"
"\n"
"end\n"
"\n"
"function get_google_user()\n"
"\n"
"	return core.get_google_user()\n"
"\n"
"end\n"
"",

"wetgenes.www.gae.mail","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local core=require(\"wetgenes.www.gae.mail.core\")\n"
"\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.mail\"]=_M\n"
"\n"
"\n"
"function send(...)\n"
"	return core.send(...)\n"
"end\n"
"",

"socket.smtp","-----------------------------------------------------------------------------\n"
"-- SMTP client support for the Lua language.\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: smtp.lua,v 1.46 2007/03/12 04:08:40 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local coroutine = require(\"coroutine\")\n"
"local string = require(\"string\")\n"
"local math = require(\"math\")\n"
"local os = require(\"os\")\n"
"local socket = require(\"socket\")\n"
"local tp = require(\"socket.tp\")\n"
"local ltn12 = require(\"ltn12\")\n"
"local mime = require(\"mime\")\n"
"module(\"socket.smtp\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Program constants\n"
"-----------------------------------------------------------------------------\n"
"-- timeout for connection\n"
"TIMEOUT = 60\n"
"-- default server used to send e-mails\n"
"SERVER = \"localhost\"\n"
"-- default port\n"
"PORT = 25\n"
"-- domain used in HELO command and default sendmail\n"
"-- If we are under a CGI, try to get from environment\n"
"DOMAIN = os.getenv(\"SERVER_NAME\") or \"localhost\"\n"
"-- default time zone (means we don't know)\n"
"ZONE = \"-0000\"\n"
"\n"
"---------------------------------------------------------------------------\n"
"-- Low level SMTP API\n"
"-----------------------------------------------------------------------------\n"
"local metat = { __index = {} }\n"
"\n"
"function metat.__index:greet(domain)\n"
"    self.try(self.tp:check(\"2..\"))\n"
"    self.try(self.tp:command(\"EHLO\", domain or DOMAIN))\n"
"    return socket.skip(1, self.try(self.tp:check(\"2..\")))\n"
"end\n"
"\n"
"function metat.__index:mail(from)\n"
"    self.try(self.tp:command(\"MAIL\", \"FROM:\" .. from))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:rcpt(to)\n"
"    self.try(self.tp:command(\"RCPT\", \"TO:\" .. to))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:data(src, step)\n"
"    self.try(self.tp:command(\"DATA\"))\n"
"    self.try(self.tp:check(\"3..\"))\n"
"    self.try(self.tp:source(src, step))\n"
"    self.try(self.tp:send(\"\\r\\n"
".\\r\\n"
"\"))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:quit()\n"
"    self.try(self.tp:command(\"QUIT\"))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:close()\n"
"    return self.tp:close()\n"
"end\n"
"\n"
"function metat.__index:login(user, password)\n"
"    self.try(self.tp:command(\"AUTH\", \"LOGIN\"))\n"
"    self.try(self.tp:check(\"3..\"))\n"
"    self.try(self.tp:command(mime.b64(user)))\n"
"    self.try(self.tp:check(\"3..\"))\n"
"    self.try(self.tp:command(mime.b64(password)))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:plain(user, password)\n"
"    local auth = \"PLAIN \" .. mime.b64(\"\\0\" .. user .. \"\\0\" .. password)\n"
"    self.try(self.tp:command(\"AUTH\", auth))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:auth(user, password, ext)\n"
"    if not user or not password then return 1 end\n"
"    if string.find(ext, \"AUTH[^\\n"
"]+LOGIN\") then\n"
"        return self:login(user, password)\n"
"    elseif string.find(ext, \"AUTH[^\\n"
"]+PLAIN\") then\n"
"        return self:plain(user, password)\n"
"    else\n"
"        self.try(nil, \"authentication not supported\")\n"
"    end\n"
"end\n"
"\n"
"-- send message or throw an exception\n"
"function metat.__index:send(mailt)\n"
"    self:mail(mailt.from)\n"
"    if base.type(mailt.rcpt) == \"table\" then\n"
"        for i,v in base.ipairs(mailt.rcpt) do\n"
"            self:rcpt(v)\n"
"        end\n"
"    else\n"
"        self:rcpt(mailt.rcpt)\n"
"    end\n"
"    self:data(ltn12.source.chain(mailt.source, mime.stuff()), mailt.step)\n"
"end\n"
"\n"
"function open(server, port, create)\n"
"    local tp = socket.try(tp.connect(server or SERVER, port or PORT,\n"
"        TIMEOUT, create))\n"
"    local s = base.setmetatable({tp = tp}, metat)\n"
"    -- make sure tp is closed if we get an exception\n"
"    s.try = socket.newtry(function()\n"
"        s:close()\n"
"    end)\n"
"    return s\n"
"end\n"
"\n"
"-- convert headers to lowercase\n"
"local function lower_headers(headers)\n"
"    local lower = {}\n"
"    for i,v in base.pairs(headers or lower) do\n"
"        lower[string.lower(i)] = v\n"
"    end\n"
"    return lower\n"
"end\n"
"\n"
"---------------------------------------------------------------------------\n"
"-- Multipart message source\n"
"-----------------------------------------------------------------------------\n"
"-- returns a hopefully unique mime boundary\n"
"local seqno = 0\n"
"local function newboundary()\n"
"    seqno = seqno + 1\n"
"    return string.format('%s%05d==%05u', os.date('%d%m%Y%H%M%S'),\n"
"        math.random(0, 99999), seqno)\n"
"end\n"
"\n"
"-- send_message forward declaration\n"
"local send_message\n"
"\n"
"-- yield the headers all at once, it's faster\n"
"local function send_headers(headers)\n"
"    local h = \"\\r\\n"
"\"\n"
"    for i,v in base.pairs(headers) do\n"
"        h = i .. ': ' .. v .. \"\\r\\n"
"\" .. h\n"
"    end\n"
"    coroutine.yield(h)\n"
"end\n"
"\n"
"-- yield multipart message body from a multipart message table\n"
"local function send_multipart(mesgt)\n"
"    -- make sure we have our boundary and send headers\n"
"    local bd = newboundary()\n"
"    local headers = lower_headers(mesgt.headers or {})\n"
"    headers['content-type'] = headers['content-type'] or 'multipart/mixed'\n"
"    headers['content-type'] = headers['content-type'] ..\n"
"        '; boundary=\"' ..  bd .. '\"'\n"
"    send_headers(headers)\n"
"    -- send preamble\n"
"    if mesgt.body.preamble then\n"
"        coroutine.yield(mesgt.body.preamble)\n"
"        coroutine.yield(\"\\r\\n"
"\")\n"
"    end\n"
"    -- send each part separated by a boundary\n"
"    for i, m in base.ipairs(mesgt.body) do\n"
"        coroutine.yield(\"\\r\\n"
"--\" .. bd .. \"\\r\\n"
"\")\n"
"        send_message(m)\n"
"    end\n"
"    -- send last boundary\n"
"    coroutine.yield(\"\\r\\n"
"--\" .. bd .. \"--\\r\\n"
"\\r\\n"
"\")\n"
"    -- send epilogue\n"
"    if mesgt.body.epilogue then\n"
"        coroutine.yield(mesgt.body.epilogue)\n"
"        coroutine.yield(\"\\r\\n"
"\")\n"
"    end\n"
"end\n"
"\n"
"-- yield message body from a source\n"
"local function send_source(mesgt)\n"
"    -- make sure we have a content-type\n"
"    local headers = lower_headers(mesgt.headers or {})\n"
"    headers['content-type'] = headers['content-type'] or\n"
"        'text/plain; charset=\"iso-8859-1\"'\n"
"    send_headers(headers)\n"
"    -- send body from source\n"
"    while true do\n"
"        local chunk, err = mesgt.body()\n"
"        if err then coroutine.yield(nil, err)\n"
"        elseif chunk then coroutine.yield(chunk)\n"
"        else break end\n"
"    end\n"
"end\n"
"\n"
"-- yield message body from a string\n"
"local function send_string(mesgt)\n"
"    -- make sure we have a content-type\n"
"    local headers = lower_headers(mesgt.headers or {})\n"
"    headers['content-type'] = headers['content-type'] or\n"
"        'text/plain; charset=\"iso-8859-1\"'\n"
"    send_headers(headers)\n"
"    -- send body from string\n"
"    coroutine.yield(mesgt.body)\n"
"end\n"
"\n"
"-- message source\n"
"function send_message(mesgt)\n"
"    if base.type(mesgt.body) == \"table\" then send_multipart(mesgt)\n"
"    elseif base.type(mesgt.body) == \"function\" then send_source(mesgt)\n"
"    else send_string(mesgt) end\n"
"end\n"
"\n"
"-- set defaul headers\n"
"local function adjust_headers(mesgt)\n"
"    local lower = lower_headers(mesgt.headers)\n"
"    lower[\"date\"] = lower[\"date\"] or\n"
"        os.date(\"!%a, %d %b %Y %H:%M:%S \") .. (mesgt.zone or ZONE)\n"
"    lower[\"x-mailer\"] = lower[\"x-mailer\"] or socket._VERSION\n"
"    -- this can't be overriden\n"
"    lower[\"mime-version\"] = \"1.0\"\n"
"    return lower\n"
"end\n"
"\n"
"function message(mesgt)\n"
"    mesgt.headers = adjust_headers(mesgt)\n"
"    -- create and return message source\n"
"    local co = coroutine.create(function() send_message(mesgt) end)\n"
"    return function()\n"
"        local ret, a, b = coroutine.resume(co)\n"
"        if ret then return a, b\n"
"        else return nil, a end\n"
"    end\n"
"end\n"
"\n"
"---------------------------------------------------------------------------\n"
"-- High level SMTP API\n"
"-----------------------------------------------------------------------------\n"
"send = socket.protect(function(mailt)\n"
"    local s = open(mailt.server, mailt.port, mailt.create)\n"
"    local ext = s:greet(mailt.domain)\n"
"    s:auth(mailt.user, mailt.password, ext)\n"
"    s:send(mailt)\n"
"    s:quit()\n"
"    return s:close()\n"
"end)\n"
"",

"wetgenes.www.ngx.serv","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.ngx.log\").log\n"
"local debug=require(\"debug\")\n"
"\n"
"\n"
"local ngx=require(\"ngx\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.serv\"]=_M\n"
"\n"
"function serv()\n"
"	xpcall(serv2,function(msg,lev)\n"
"		log( msg )\n"
"		log( debug.traceback() )\n"
"	end)\n"
"end\n"
"\n"
"function serv2()\n"
"\n"
"	local basic=require(\"base.basic\")\n"
"\n"
"	-- shove this basic functions into the global name space\n"
"	-- they will work with the opts to serv this app as needed\n"
"\n"
"	basic.serv(require(\"wetgenes.www.ngx.srv\").new())\n"
"\n"
"end\n"
"",

"fenestra.widget.text","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.text\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"\r\n"
"	if widget.data then\r\n"
"		widget.text=widget.data:get_string()\r\n"
"	end\r\n"
"\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.button=it\r\n"
"	widget.class=\"text\"\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.draw=draw\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"",

"wetgenes.www.any.data","if ngx then\n"
"	return require(\"wetgenes.www.sqlite.data\")\n"
"else\n"
"	return require(\"wetgenes.www.gae.data\")\n"
"end\n"
"",

"wetgenes.www.gae.log","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local core=require(\"wetgenes.www.gae.log.core\")\n"
"\n"
"\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.log\"]=_M\n"
"\n"
"\n"
"function log(a,b)\n"
"\n"
"	return core.log(a,b)\n"
"\n"
"end\n"
"",

"wetgenes.sandbox","\n"
"local string=string\n"
"local table=table\n"
"\n"
"local type=type\n"
"local pairs=pairs\n"
"local ipairs=ipairs\n"
"local tostring=tostring\n"
"local setmetatable=setmetatable\n"
"\n"
"--\n"
"-- Simple sandboxing of lua functions\n"
"--\n"
"\n"
"\n"
"-- make a table to be used as a reasonably \"safe\" environment\n"
"-- code can still lock up in loops or allocate too much memory\n"
"-- but it doesnt get to jump out of its sandbox\n"
"\n"
"local function local_make_env_safe()\n"
"local env={\n"
"	assert=assert,\n"
"	error=error,\n"
"	ipairs=ipairs,\n"
"	pairs=pairs,\n"
"	next=next,\n"
"	pcall=pcall,\n"
"	select=select,\n"
"	tonumber=tonumber,\n"
"	tostring=tostring,\n"
"	type=type,\n"
"	unpack=unpack,\n"
"	xpcall=xpcall,\n"
"	coroutine={\n"
"		create=coroutine.create,\n"
"		resume=coroutine.resume,\n"
"		running=coroutine.running,\n"
"		status=coroutine.status,\n"
"		wrap=coroutine.wrap,\n"
"		yield=coroutine.yield,\n"
"	},\n"
"	table={\n"
"		concat=table.concat,\n"
"		insert=table.insert,\n"
"		maxn=table.maxn,\n"
"		remove=table.remove,\n"
"		sort=table.sort,\n"
"	},\n"
"	string={\n"
"		byte=string.byte,\n"
"		char=string.char,\n"
"		find=string.find,\n"
"		format=string.format,\n"
"		gmatch=string.gmatch,\n"
"		gsub=string.gsub,\n"
"		len=string.len,\n"
"		lower=string.lower,\n"
"		match=string.match,\n"
"		rep=string.rep,\n"
"		reverse=string.reverse,\n"
"		sub=string.sub,\n"
"		upper=string.upper,\n"
"	},\n"
"	math={\n"
"		abs=math.abs,\n"
"		acos=math.acos,\n"
"		asin=math.asin,\n"
"		atan=math.atan,\n"
"		atan2=math.atan2,\n"
"		ceil=math.ceil,\n"
"		cos=math.cos,\n"
"		cosh=math.cosh,\n"
"		deg=math.deg,\n"
"		exp=math.exp,\n"
"		floor=math.floor,\n"
"		fmod=math.fmod,\n"
"		frexp=math.frexp,\n"
"		huge=math.huge,\n"
"		ldexp=math.ldexp,\n"
"		log=math.log,\n"
"		log10=math.log10,\n"
"		max=math.max,\n"
"		min=math.min,\n"
"		modf=math.modf,\n"
"		pi=math.pi,\n"
"		pow=math.pow,\n"
"		rad=math.rad,\n"
"		random=math.random, -- should replace with sandboxed versions\n"
"		randomseed=math.randomseed, -- should replace with sandboxed versions\n"
"		sin=math.sin,\n"
"		sinh=math.sinh,\n"
"		sqrt=math.sqrt,\n"
"		tan=math.tan,\n"
"		tanh=math.tanh,\n"
"	},\n"
"	os={\n"
"		clock=os.clock,\n"
"		date=os.date, -- this can go boom in some situations?\n"
"		difftime=os.difftime,\n"
"		time=os.time,\n"
"	},\n"
"}\n"
"\n"
"-- a modified loadstring that can set its function environment\n"
"-- setfenv is probably quite dangerous to expose, too much opportunity for\n"
"-- mischief on any function the sandbox code is given access to\n"
"-- it is however safe in this use since its your function that was just\n"
"-- loadstringed\n"
"	env.loadstring=function(s,newenv)\n"
"		local f,e=loadstring(s)\n"
"		if f then setfenv(f,newenv or env) end\n"
"		return f,e\n"
"	end\n"
"\n"
"	return env\n"
"end\n"
"\n"
"\n"
"\n"
"module(\"wetgenes.sandbox\")\n"
"\n"
"--\n"
"-- get a functional environment full of useful but \"safe\" functions\n"
"--\n"
"function make_env(opts)\n"
"\n"
"local env=local_make_env_safe()\n"
"\n"
"	return env\n"
"end\n"
"\n"
"",

"fenestra.widget.button","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.button\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"\r\n"
"	if widget.data then\r\n"
"		widget.text=widget.data:get_string()\r\n"
"	end\r\n"
"\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.button=it\r\n"
"	widget.class=\"button\"\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.draw=draw\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"",

"socket.http","-----------------------------------------------------------------------------\n"
"-- HTTP/1.1 client support for the Lua language.\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: http.lua,v 1.70 2007/03/12 04:08:40 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-------------------------------------------------------------------------------\n"
"local socket = require(\"socket\")\n"
"local url = require(\"socket.url\")\n"
"local ltn12 = require(\"ltn12\")\n"
"local mime = require(\"mime\")\n"
"local string = require(\"string\")\n"
"local base = _G\n"
"local table = require(\"table\")\n"
"module(\"socket.http\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Program constants\n"
"-----------------------------------------------------------------------------\n"
"-- connection timeout in seconds\n"
"TIMEOUT = 60\n"
"-- default port for document retrieval\n"
"PORT = 80\n"
"-- user agent field sent in request\n"
"USERAGENT = socket._VERSION\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Reads MIME headers from a connection, unfolding where needed\n"
"-----------------------------------------------------------------------------\n"
"local function receiveheaders(sock, headers)\n"
"    local line, name, value, err\n"
"    headers = headers or {}\n"
"    -- get first line\n"
"    line, err = sock:receive()\n"
"    if err then return nil, err end\n"
"    -- headers go until a blank line is found\n"
"    while line ~= \"\" do\n"
"        -- get field-name and value\n"
"        name, value = socket.skip(2, string.find(line, \"^(.-):%s*(.*)\"))\n"
"        if not (name and value) then return nil, \"malformed reponse headers\" end\n"
"        name = string.lower(name)\n"
"        -- get next line (value might be folded)\n"
"        line, err  = sock:receive()\n"
"        if err then return nil, err end\n"
"        -- unfold any folded values\n"
"        while string.find(line, \"^%s\") do\n"
"            value = value .. line\n"
"            line = sock:receive()\n"
"            if err then return nil, err end\n"
"        end\n"
"        -- save pair in table\n"
"        if headers[name] then headers[name] = headers[name] .. \", \" .. value\n"
"        else headers[name] = value end\n"
"    end\n"
"    return headers\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Extra sources and sinks\n"
"-----------------------------------------------------------------------------\n"
"socket.sourcet[\"http-chunked\"] = function(sock, headers)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function()\n"
"            -- get chunk size, skip extention\n"
"            local line, err = sock:receive()\n"
"            if err then return nil, err end\n"
"            local size = base.tonumber(string.gsub(line, \";.*\", \"\"), 16)\n"
"            if not size then return nil, \"invalid chunk size\" end\n"
"            -- was it the last chunk?\n"
"            if size > 0 then\n"
"                -- if not, get chunk and skip terminating CRLF\n"
"                local chunk, err, part = sock:receive(size)\n"
"                if chunk then sock:receive() end\n"
"                return chunk, err\n"
"            else\n"
"                -- if it was, read trailers into headers table\n"
"                headers, err = receiveheaders(sock, headers)\n"
"                if not headers then return nil, err end\n"
"            end\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"socket.sinkt[\"http-chunked\"] = function(sock)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function(self, chunk, err)\n"
"            if not chunk then return sock:send(\"0\\r\\n"
"\\r\\n"
"\") end\n"
"            local size = string.format(\"%X\\r\\n"
"\", string.len(chunk))\n"
"            return sock:send(size ..  chunk .. \"\\r\\n"
"\")\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Low level HTTP API\n"
"-----------------------------------------------------------------------------\n"
"local metat = { __index = {} }\n"
"\n"
"function open(host, port, create)\n"
"    -- create socket with user connect function, or with default\n"
"    local c = socket.try((create or socket.tcp)())\n"
"    local h = base.setmetatable({ c = c }, metat)\n"
"    -- create finalized try\n"
"    h.try = socket.newtry(function() h:close() end)\n"
"    -- set timeout before connecting\n"
"    h.try(c:settimeout(TIMEOUT))\n"
"    h.try(c:connect(host, port or PORT))\n"
"    -- here everything worked\n"
"    return h\n"
"end\n"
"\n"
"function metat.__index:sendrequestline(method, uri)\n"
"    local reqline = string.format(\"%s %s HTTP/1.1\\r\\n"
"\", method or \"GET\", uri)\n"
"    return self.try(self.c:send(reqline))\n"
"end\n"
"\n"
"function metat.__index:sendheaders(headers)\n"
"    local h = \"\\r\\n"
"\"\n"
"    for i, v in base.pairs(headers) do\n"
"        h = i .. \": \" .. v .. \"\\r\\n"
"\" .. h\n"
"    end\n"
"    self.try(self.c:send(h))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:sendbody(headers, source, step)\n"
"    source = source or ltn12.source.empty()\n"
"    step = step or ltn12.pump.step\n"
"    -- if we don't know the size in advance, send chunked and hope for the best\n"
"    local mode = \"http-chunked\"\n"
"    if headers[\"content-length\"] then mode = \"keep-open\" end\n"
"    return self.try(ltn12.pump.all(source, socket.sink(mode, self.c), step))\n"
"end\n"
"\n"
"function metat.__index:receivestatusline()\n"
"    local status = self.try(self.c:receive())\n"
"    local code = socket.skip(2, string.find(status, \"HTTP/%d*%.%d* (%d%d%d)\"))\n"
"    return self.try(base.tonumber(code), status)\n"
"end\n"
"\n"
"function metat.__index:receiveheaders()\n"
"    return self.try(receiveheaders(self.c))\n"
"end\n"
"\n"
"function metat.__index:receivebody(headers, sink, step)\n"
"    sink = sink or ltn12.sink.null()\n"
"    step = step or ltn12.pump.step\n"
"    local length = base.tonumber(headers[\"content-length\"])\n"
"    local t = headers[\"transfer-encoding\"] -- shortcut\n"
"    local mode = \"default\" -- connection close\n"
"    if t and t ~= \"identity\" then mode = \"http-chunked\"\n"
"    elseif base.tonumber(headers[\"content-length\"]) then mode = \"by-length\" end\n"
"    return self.try(ltn12.pump.all(socket.source(mode, self.c, length),\n"
"        sink, step))\n"
"end\n"
"\n"
"function metat.__index:close()\n"
"    return self.c:close()\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- High level HTTP API\n"
"-----------------------------------------------------------------------------\n"
"local function adjusturi(reqt)\n"
"    local u = reqt\n"
"    -- if there is a proxy, we need the full url. otherwise, just a part.\n"
"    if not reqt.proxy and not PROXY then\n"
"        u = {\n"
"           path = socket.try(reqt.path, \"invalid path 'nil'\"),\n"
"           params = reqt.params,\n"
"           query = reqt.query,\n"
"           fragment = reqt.fragment\n"
"        }\n"
"    end\n"
"    return url.build(u)\n"
"end\n"
"\n"
"local function adjustproxy(reqt)\n"
"    local proxy = reqt.proxy or PROXY\n"
"    if proxy then\n"
"        proxy = url.parse(proxy)\n"
"        return proxy.host, proxy.port or 3128\n"
"    else\n"
"        return reqt.host, reqt.port\n"
"    end\n"
"end\n"
"\n"
"local function adjustheaders(reqt)\n"
"    -- default headers\n"
"    local lower = {\n"
"        [\"user-agent\"] = USERAGENT,\n"
"        [\"host\"] = reqt.host,\n"
"        [\"connection\"] = \"close, TE\",\n"
"        [\"te\"] = \"trailers\"\n"
"    }\n"
"    -- if we have authentication information, pass it along\n"
"    if reqt.user and reqt.password then\n"
"        lower[\"authorization\"] = \n"
"            \"Basic \" ..  (mime.b64(reqt.user .. \":\" .. reqt.password))\n"
"    end\n"
"    -- override with user headers\n"
"    for i,v in base.pairs(reqt.headers or lower) do\n"
"        lower[string.lower(i)] = v\n"
"    end\n"
"    return lower\n"
"end\n"
"\n"
"-- default url parts\n"
"local default = {\n"
"    host = \"\",\n"
"    port = PORT,\n"
"    path =\"/\",\n"
"    scheme = \"http\"\n"
"}\n"
"\n"
"local function adjustrequest(reqt)\n"
"    -- parse url if provided\n"
"    local nreqt = reqt.url and url.parse(reqt.url, default) or {}\n"
"    -- explicit components override url\n"
"    for i,v in base.pairs(reqt) do nreqt[i] = v end\n"
"    if nreqt.port == \"\" then nreqt.port = 80 end\n"
"    socket.try(nreqt.host and nreqt.host ~= \"\", \n"
"        \"invalid host '\" .. base.tostring(nreqt.host) .. \"'\")\n"
"    -- compute uri if user hasn't overriden\n"
"    nreqt.uri = reqt.uri or adjusturi(nreqt)\n"
"    -- ajust host and port if there is a proxy\n"
"    nreqt.host, nreqt.port = adjustproxy(nreqt)\n"
"    -- adjust headers in request\n"
"    nreqt.headers = adjustheaders(nreqt)\n"
"    return nreqt\n"
"end\n"
"\n"
"local function shouldredirect(reqt, code, headers)\n"
"    return headers.location and\n"
"           string.gsub(headers.location, \"%s\", \"\") ~= \"\" and\n"
"           (reqt.redirect ~= false) and\n"
"           (code == 301 or code == 302) and\n"
"           (not reqt.method or reqt.method == \"GET\" or reqt.method == \"HEAD\")\n"
"           and (not reqt.nredirects or reqt.nredirects < 5)\n"
"end\n"
"\n"
"local function shouldreceivebody(reqt, code)\n"
"    if reqt.method == \"HEAD\" then return nil end\n"
"    if code == 204 or code == 304 then return nil end\n"
"    if code >= 100 and code < 200 then return nil end\n"
"    return 1\n"
"end\n"
"\n"
"-- forward declarations\n"
"local trequest, tredirect\n"
"\n"
"function tredirect(reqt, location)\n"
"    local result, code, headers, status = trequest {\n"
"        -- the RFC says the redirect URL has to be absolute, but some\n"
"        -- servers do not respect that\n"
"        url = url.absolute(reqt.url, location),\n"
"        source = reqt.source,\n"
"        sink = reqt.sink,\n"
"        headers = reqt.headers,\n"
"        proxy = reqt.proxy, \n"
"        nredirects = (reqt.nredirects or 0) + 1,\n"
"        create = reqt.create\n"
"    }   \n"
"    -- pass location header back as a hint we redirected\n"
"    headers.location = headers.location or location\n"
"    return result, code, headers, status\n"
"end\n"
"\n"
"function trequest(reqt)\n"
"    -- we loop until we get what we want, or\n"
"    -- until we are sure there is no way to get it\n"
"    local nreqt = adjustrequest(reqt)\n"
"    local h = open(nreqt.host, nreqt.port, nreqt.create)\n"
"    -- send request line and headers\n"
"    h:sendrequestline(nreqt.method, nreqt.uri)\n"
"    h:sendheaders(nreqt.headers)\n"
"    local code = 100 \n"
"    local headers, status\n"
"    -- if there is a body, check for server status\n"
"    if nreqt.source then\n"
"        h:sendbody(nreqt.headers, nreqt.source, nreqt.step) \n"
"    end\n"
"    -- ignore any 100-continue messages\n"
"    while code == 100 do \n"
"        code, status = h:receivestatusline()\n"
"        headers = h:receiveheaders()\n"
"    end\n"
"    -- at this point we should have a honest reply from the server\n"
"    -- we can't redirect if we already used the source, so we report the error \n"
"    if shouldredirect(nreqt, code, headers) and not nreqt.source then\n"
"        h:close()\n"
"        return tredirect(reqt, headers.location)\n"
"    end\n"
"    -- here we are finally done\n"
"    if shouldreceivebody(nreqt, code) then\n"
"        h:receivebody(headers, nreqt.sink, nreqt.step)\n"
"    end\n"
"    h:close()\n"
"    return 1, code, headers, status\n"
"end\n"
"\n"
"local function srequest(u, b)\n"
"    local t = {}\n"
"    local reqt = {\n"
"        url = u,\n"
"        sink = ltn12.sink.table(t)\n"
"    }\n"
"    if b then\n"
"        reqt.source = ltn12.source.string(b)\n"
"        reqt.headers = {\n"
"            [\"content-length\"] = string.len(b),\n"
"            [\"content-type\"] = \"application/x-www-form-urlencoded\"\n"
"        }\n"
"        reqt.method = \"POST\"\n"
"    end\n"
"    local code, headers, status = socket.skip(1, trequest(reqt))\n"
"    return table.concat(t), code, headers, status\n"
"end\n"
"\n"
"request = socket.protect(function(reqt, body)\n"
"    if base.type(reqt) == \"string\" then return srequest(reqt, body)\n"
"    else return trequest(reqt) end\n"
"end)\n"
"",

"yarn.level","\n"
"-- a collection of everything\n"
"\n"
"\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local dbg=dbg\n"
"\n"
"module(...)\n"
"local yarn_map=require(\"yarn.map\")\n"
"local yarn_room=require(\"yarn.room\")\n"
"local yarn_cell=require(\"yarn.cell\")\n"
"local yarn_item=require(\"yarn.item\")\n"
"local yarn_attr=require(\"yarn.attr\")\n"
"\n"
"local yarn_attrs=require(\"yarn.attrs\")\n"
"\n"
"\n"
"function create(t,up)\n"
"\n"
"local d={}\n"
"setfenv(1,d)\n"
"\n"
"	is=yarn_attr.create(t)\n"
"	metatable={__index=is}\n"
"	setmetatable(d,metatable)\n"
"\n"
"	level=d -- we are the level, so level.level==level\n"
"	main=up\n"
"	menu=up.menu\n"
"	soul=up.soul\n"
"\n"
"	time_passed=0\n"
"	time_update=0\n"
"	\n"
"	xh=t.xh or 30\n"
"	yh=t.yh or 30\n"
"\n"
"	rooms={}\n"
"	items={}\n"
"	flags={}\n"
"		\n"
"	cells={}\n"
"	cellfind={}\n"
"	celllist={}\n"
"	\n"
"	can=can or {}\n"
"\n"
"-- create default blank cells\n"
"	for y=0,yh-1 do\n"
"		for x=0,xh-1 do\n"
"			local i=x+y*xh\n"
"			cells[i]=yarn_cell.create(yarn_attrs.get(\"cell\",0,{ level=d, xp=x, yp=y, id=i }))\n"
"		end\n"
"	end\n"
"\n"
"\n"
"\n"
"\n"
"	\n"
"\n"
"--	function draw_map(m) map.draw_map(m) end\n"
"	function get_asc(x,y)\n"
"		local cell=get_cell(x,y)\n"
"		return (cell and cell.asc())\n"
"	end\n"
"\n"
"-- use to find a unique named item in this level\n"
"	function find_item(name)\n"
"		for v,b in pairs(items) do\n"
"			if v.name==name then\n"
"				return v\n"
"			end\n"
"		end\n"
"	end\n"
"\n"
"\n"
"-- use all items of a given name\n"
"	function find_items(name)\n"
"		local ret={}\n"
"		for v,b in pairs(items) do\n"
"			if v.name==name then\n"
"				ret[#ret+1]=v\n"
"			end\n"
"		end\n"
"		return ret\n"
"	end\n"
"	\n"
"	function get_cell(x,y)\n"
"		if x<0 then return nil end\n"
"		if x>=xh then return nil end\n"
"		if y<0 then return nil end\n"
"		if y>=yh then return nil end\n"
"		return cells[ x+y*xh ]\n"
"	end\n"
"\n"
"-- iterate an area of cells	\n"
"	function cpairs(x,y,w,h)\n"
"		return function(a,i)\n"
"			local px=i%w\n"
"			local py=(i-px)/w\n"
"			if py>=h then return end\n"
"			return i+1,get_cell(x+px,y+py)\n"
"		end, cells, 0\n"
"	end\n"
"	\n"
"	function new_item(n,l)\n"
"		local at\n"
"		if type(n)==\"string\" then\n"
"			at=yarn_attrs.get(n,l)\n"
"		else\n"
"			at=n\n"
"			n=at.name\n"
"		end\n"
"		local it=yarn_item.create( at ,d)\n"
"		items[it]=true -- everything lives in items list\n"
"		\n"
"		for i,v in pairs(it.can) do -- every item puts its can functions in the levels can table\n"
"			d.can[i]=v\n"
"		end\n"
"		-- this means we can easily add uniquely named can functions to a level using any item\n"
"\n"
"		return it\n"
"	end\n"
"	function del_item(it)\n"
"		items[it]=nil\n"
"		it.del()\n"
"	end\n"
"	\n"
"	function rand(a,b)\n"
"		if a>=b then return a end\n"
"		return math.random(a,b)\n"
"	end\n"
"\n"
"-- get a random room	\n"
"	function rand_room(t)\n"
"		local n=0\n"
"		for i,v in ipairs(rooms) do if v.xh>1 and v.yh>1 then n=n+1 end end -- count rooms\n"
"		n=rand(1,n)\n"
"		for i,v in ipairs(rooms) do\n"
"			if v.xh>1 and v.yh>1 then\n"
"				n=n-1\n"
"				if n<1 then return v end -- found it\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"-- get a random cell in the given range\n"
"	function rand_cell(t)\n"
"		local x=rand(t.xp,t.xp+t.xh-1)\n"
"		local y=rand(t.yp,t.yp+t.yh-1)\n"
"		return get_cell(x,y)\n"
"	end\n"
"\n"
"-- get a random cell in a random room\n"
"\n"
"	function rand_room_cell(t)\n"
"		return rand_cell(rand_room(t))\n"
"	end\n"
"\n"
"	\n"
"	key_repeat=nil\n"
"	key_repeat_count=0\n"
"	\n"
"	function key_clear()\n"
"		key_repeat=nil\n"
"	end\n"
"	\n"
"	function key_check()\n"
"		key_repeat_count=key_repeat_count+1\n"
"		if key_repeat_count>=10 then\n"
"			key_do(key_repeat)\n"
"		end\n"
"	end\n"
"	\n"
"	function key_do(key)\n"
"	\n"
"		if key==\"space\" or key==\"enter\"  or key==\"return\"  or key==\"kpenter\" or key==\" \" then\n"
"		\n"
"			up.menu.show_player_menu(player)\n"
"			\n"
"		end\n"
"		\n"
"		key_repeat_count=0 -- always zero the repeat counter\n"
"	\n"
"		local vx=0\n"
"		local vy=0\n"
"		\n"
"		if key==\"up\" then\n"
"			vx=0\n"
"			vy=-1\n"
"		elseif key==\"down\" then\n"
"			vx=0\n"
"			vy=1\n"
"		elseif key==\"left\" then\n"
"			vx=-1\n"
"			vy=0\n"
"		elseif key==\"right\" then\n"
"			vx=1\n"
"			vy=0\n"
"		end\n"
"		\n"
"		if vx~=0 or vy~=0 then\n"
"			time_update=time_update+player.move(vx,vy)\n"
"			return true\n"
"		end\n"
"	end\n"
"	\n"
"	function step(t,it)\n"
"		if it then t=t end -- advance level time relative to actor..\n"
"		time_update=time_update+t\n"
"	end\n"
"	\n"
"	function keypress(ascii,key,act)\n"
"	\n"
"		if act==\"down\" then\n"
"		\n"
"			key_repeat=key\n"
"			key_repeat_count=0\n"
"			\n"
"			key_do(key_repeat)\n"
"			\n"
"		elseif act==\"up\" then -- an up key cancels all repeats\n"
"		\n"
"			if key_repeat==key then\n"
"				key_repeat=nil\n"
"			end\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	function update()\n"
"		key_check()\n"
"		\n"
"		if time_update==0 then return 0 end\n"
"		\n"
"		is.time_total=(is.time_total or 0)+time_update\n"
"		\n"
"--print(time_passed)\n"
"\n"
"-- regen health?\n"
"--		player.attr.hp=math.floor(player.attr.hp+time_update)\n"
"--		if player.attr.hp > player.attr.hpmax then player.attr.hp = player.attr.hpmax end\n"
"		\n"
"		for v,b in pairs(items) do\n"
"			v.update()\n"
"		end\n"
"		\n"
"		if display_msg_time<time_passed then -- report your most important stats in msg form\n"
"		\n"
"			local item=player.cell.get_item()\n"
"			\n"
"			if item then -- standing on an item\n"
"				set_msg(item.view_text())\n"
"			else\n"
"				set_msg(\"Your health is \".. player.hp ..\"/\".. player.is.hp )\n"
"			end\n"
"		end\n"
"\n"
"		local t=time_update\n"
"		time_passed=time_passed+time_update\n"
"		time_update=0\n"
"		return t\n"
"	end\n"
"	\n"
"	display_msg=nil\n"
"	display_msg_time=0\n"
"	function set_msg(a)\n"
"		display_msg=a\n"
"		display_msg_time=time_passed\n"
"	end\n"
"	function add_msg(a)\n"
"		if display_msg_time<time_passed then display_msg=nil end -- do not add to previously displayed msgs\n"
"		if display_msg then display_msg=display_msg..\" \" else display_msg=\"\" end\n"
"		display_msg=display_msg..a\n"
"		display_msg_time=time_passed\n"
"	end\n"
"	function get_msg()\n"
"		return display_msg or \"\"\n"
"	end\n"
"\n"
"	function destroy()\n"
"	end\n"
"\n"
"-- create a save state for this data\n"
"	function save()\n"
"		local sd={}\n"
"		\n"
"		local p=player\n"
"		p.un_cell() -- remove from map as player will be saved seperately\n"
"		\n"
"		sd=yarn_attr.save(is)\n"
"		\n"
"--		sd.player=p.save()\n"
"		sd.rooms={}\n"
"		sd.cells={}\n"
"		\n"
"		for i,v in ipairs(cells) do -- cells contain all items so they get saved here\n"
"			sd.cells[i]=v.save()\n"
"			if sd.cells[i].name==\"wall\" then\n"
"				if not sd.cells[i].visible then\n"
"					if not sd.cells[i].items then\n"
"						sd.cells[i]=nil				-- do not need to save cell as it is in default state\n"
"					end\n"
"				end\n"
"			end\n"
"		end\n"
"		\n"
"		for i,v in ipairs(rooms) do -- rooms are just areas of cells\n"
"			sd.rooms[i]=v.save()\n"
"		end\n"
"		\n"
"		p.re_cell() -- put playerback in map\n"
"		return sd\n"
"	end\n"
"\n"
"-- reload a saved data (create and then load)\n"
"	function load(sd)\n"
"\n"
"		for i,v in pairs(sd.rooms) do -- create rooms\n"
"			rooms[i]=yarn_room.create(yarn_attrs.get(\"room\",0,{ level=d , xp=v.xp, yp=v.yp, xh=v.xh, yh=v.yh, } ))\n"
"			rooms[i].load(v)\n"
"		end\n"
"\n"
"		for i,v in pairs(cells) do -- modify cells from default state here, placing items and so on\n"
"			if sd.cells[i] then v.load(sd.cells[i]) end\n"
"		end\n"
"		\n"
"		is=yarn_attr.load(sd)\n"
"		d.is=is\n"
"		d.metatable.__index=is\n"
"\n"
"--auto gen\n"
"		for i,v in ipairs(rooms) do v.find_doors() end\n"
"		\n"
"	end\n"
"	\n"
"\n"
"-- setup stuff below\n"
"\n"
"\n"
"	\n"
"	local sd=main.get_level_save(is.name,is.pow)\n"
"	\n"
"if sd then\n"
"dbg(\"found level savedata for -> \",is.name,\" : \",is.pow)	\n"
"\n"
"	load(sd)\n"
"	\n"
"	yarn_attrs.generate_player_bystairs(d)\n"
"\n"
"else\n"
"dbg(\"creating new level for -> \",is.name,\" : \",is.pow)	\n"
"\n"
"\n"
"-- set opts using rooms,this is where most of the brainwork happens	\n"
"	opts=yarn_attrs.get_map(d.name,d.pow)\n"
"	level.flags=opts.flags -- these are importatn level state and should be saved\n"
"	opts.xh=d.xh\n"
"	opts.yh=d.yh\n"
"	map=yarn_map.create(opts) -- create an empty map, this is only a room layout\n"
"	\n"
"-- now turn that generated map into real rooms we can put stuff in\n"
"	for i,v in ipairs(map.rooms) do\n"
"		rooms[i]=yarn_room.create(yarn_attrs.get(\"room\",0,\n"
"			{ level=d, xp=v.x, yp=v.y, xh=v.xh, yh=v.yh, }) )\n"
"		rooms[i].opts=v.opts\n"
"	end\n"
"	for i,v in ipairs(rooms) do\n"
"		v.post_create()\n"
"	end\n"
"\n"
"-- find link door locations	\n"
"	for i,v in ipairs(rooms) do v.find_doors() end\n"
"		\n"
"	\n"
"	for i,r in ipairs(rooms) do\n"
"		if r.opts then -- special?\n"
"			local cs=r.opts.cells\n"
"			for y=1,#cs do\n"
"				local v=cs[y]\n"
"				for x=1,#v do\n"
"					local n=v[x]\n"
"					\n"
"					if n==\"space\" then -- do nothing\n"
"					else\n"
"						local c=get_cell(r.xp+x-1,r.yp+y-1)\n"
"						if r.opts.callback then\n"
"							r.opts.callback({call=\"cell\",cell=c,name=n,level=d,room=r})\n"
"						end\n"
"					end\n"
"				end\n"
"			end\n"
"			if r.opts.callback then\n"
"				r.opts.callback({call=\"room\",level=d,room=r})\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	\n"
"	if opts.bigroom then\n"
"\n"
"--		rooms[#rooms+1]=yarn_room.create(yarn_attrs.get(\"room\",0,\n"
"--			{ level=d, xp=1, yp=1, xh=xh-2, yh=yh-2, }) )\n"
"\n"
"		for y=0,yh-1 do\n"
"			for x=0,xh-1 do\n"
"				local i=x+y*xh\n"
"				local cell=cells[i]\n"
"				if map.room_find(x,y)==map.bigroom then\n"
"					cell.set.name(\"floor\")\n"
"					cell.is.set.visible(true)\n"
"				end\n"
"				if y==0 or y==yh-1 or x==0 or x==xh-1 then\n"
"					cell.is.set.visible(true)\n"
"				end\n"
"			end\n"
"		end\n"
"		for i,r in ipairs(rooms) do\n"
"			if r.xh>1 and r.yh>1 then -- not corridors\n"
"				for x=r.xp-1,r.xp+r.xh do\n"
"					for y=r.yp-1,r.yp+r.yh do\n"
"						if x==r.xp-1 or x==r.xp+r.xh or y==r.yp-1 or y==r.yp+r.yh then\n"
"							local cell=get_cell(x,y)\n"
"							cell.is.set.visible(true)\n"
"						end\n"
"					end\n"
"				end\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	if opts.generate then opts.generate(level) end\n"
"\n"
"end\n"
"\n"
"\n"
"	return d\n"
"	\n"
"end\n"
"\n"
"",

"fenestra.widget.meta","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- generic default widget functions\n"
"\n"
"\n"
"module(\"fenestra.widget.meta\")\n"
"\n"
"-- available widget classes\n"
"classes={\n"
"\n"
"-- base classes\n"
"\n"
"	[\"master\"]=require(\"fenestra.widget.master\"),\n"
"	[\"button\"]=require(\"fenestra.widget.button\"),\n"
"	[\"drag\"]=require(\"fenestra.widget.drag\"),\n"
"	[\"text\"]=require(\"fenestra.widget.text\"),\n"
"	[\"textedit\"]=require(\"fenestra.widget.textedit\"),\n"
"\n"
"--classes built out of the base classes\n"
"\n"
"	[\"pan\"]=require(\"fenestra.widget.pan\"),\n"
"	[\"slide\"]=require(\"fenestra.widget.slide\"),\n"
"\n"
"	[\"scroll\"]=require(\"fenestra.widget.scroll\"),\n"
"\n"
"}\n"
"\n"
"--\n"
"-- add meta functions\n"
"--\n"
"function setup(def)\n"
"\n"
"--	local master=def.master\n"
"	local meta=def.meta\n"
"	local win=def.win\n"
"\n"
"-- set a dirty flag on this and all parents, this has a smart break, as if a child is dirty\n"
"-- then its parent must also be\n"
"-- the dirty flag is cleared on draw\n"
"	function meta.set_dirty(widget)\n"
"		widget.dirty=true\n"
"		while (widget.parent ~= widget) and not widget.parent.dirty do\n"
"			widget=widget.parent\n"
"			widget.dirty=true\n"
"		end\n"
"	end\n"
"\n"
"	function meta.call_hook(widget,hook,dat)\n"
"		local hooks=widget.hooks or widget.master.hooks\n"
"		local type_hooks=type(hooks)\n"
"		if type_hooks==\"function\" then -- master function\n"
"			hooks(hook,widget,dat)\n"
"		elseif type_hooks==\"table\" and hooks[hook] then -- or table of functions\n"
"			hooks[hook](widget,dat)\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- add a new widget as a child to this one\n"
"--\n"
"	function meta.add(parent,def)\n"
"		\n"
"		local widget={}\n"
"		setmetatable(widget,meta)\n"
"		table.insert(parent,widget)\n"
"		widget.parent=parent\n"
"		widget.master=parent.master\n"
"		widget:setup(def)\n"
"		widget.meta=meta		\n"
"		return widget\n"
"	end\n"
"	\n"
"--\n"
"-- remove from parent\n"
"--\n"
"	function meta.remove(widget)\n"
"	\n"
"		if widget.parent then\n"
"			for i,v in ipairs(widget.parent) do\n"
"				if v==widget then\n"
"					table.remove(widget.parent,i)\n"
"				end\n"
"			end\n"
"			widget.parent=nil\n"
"		end\n"
"		\n"
"	end	\n"
"--\n"
"-- add a previosuly created widget as a child to this widget\n"
"-- the widget will be forcibly removed...\n"
"--\n"
"	function meta.insert(parent,widget)\n"
"	\n"
"		meta.remove(widget) -- make sure we dont end up in two parents\n"
"		\n"
"		table.insert(parent,widget)\n"
"		widget.parent=parent\n"
"		widget.master=parent.master\n"
"		\n"
"		return widget\n"
"	end\n"
"\n"
"--\n"
"-- initial setup\n"
"--def\n"
"	function meta.setup(widget,def)\n"
"	\n"
"		widget.state=\"none\"\n"
"		\n"
"		widget.meta=meta\n"
"		\n"
"		widget.data=def.data -- this widget is synced with this data\n"
"		\n"
"		widget.class=def.class\n"
"		widget.highlight=def.highlight\n"
"		\n"
"		widget.id=def.id\n"
"		widget.user=def.user\n"
"		widget.hooks=def.hooks\n"
"		\n"
"		widget.sx=def.sx or def.hx or 1 -- (ratio)size for layout code\n"
"		widget.sy=def.sy or def.hy or 1 -- use hx and hy if its provided\n"
"		\n"
"		widget.mx=def.mx or 0 -- max (ratio)size for layout code\n"
"		widget.my=def.my or 0\n"
"		\n"
"\n"
"		\n"
"		-- if set these will generate rx,ry\n"
"		widget.pxf=def.pxf      -- local position, for sliders etc, goes from 0-1 \n"
"		widget.pyf=def.pyf      -- fractional position within container\n"
"\n"
"		widget.px=def.px or 0 -- relative pixel position (may generate)\n"
"		widget.py=def.py or 0\n"
"		\n"
"		widget.pxd=def.pxd or 0 -- absolute pixel position (very probably generated)\n"
"		widget.pyd=def.pyd or 0\n"
"		\n"
"		widget.pa=def.pa or 0 -- display rotation angle, possibly\n"
"\n"
"		\n"
"		-- if set these will generate hx,hy\n"
"		widget.hxf=def.hxf	  -- optional relative local size of container, possibly best not to use\n"
"		widget.hyf=def.hyf	  -- it does not have a default so may not be set\n"
"		\n"
"		widget.hx=def.hx or 0 -- absolute pixel size (may generate)\n"
"		widget.hy=def.hy or 0\n"
"		\n"
"		widget.hx_max=def.hx_max -- clip maximum layout size\n"
"		widget.hy_max=def.hy_max		\n"
"				\n"
"		widget.hx_fill=def.hx_fill -- if we wish to stretch this layout then this widget can fill up\n"
"		widget.hy_fill=def.hy_fill -- this much extra space where 1 is all of the avilable extra space\n"
"\n"
"		widget.color=def.color\n"
"		widget.text_color=def.text_color or widget.master.text_color or 0xff000000 -- black text\n"
"		widget.text_size=def.text_size or widget.master.text_size or 16 -- quite chunky text by default\n"
"		\n"
"		widget.text_color_over=def.text_color_over -- if set, switch text color on hover\n"
"		widget.text_align=def.text_align -- default is center\n"
"		\n"
"		widget.text=def.text -- display this text on the button\n"
"		\n"
"		if widget.color or widget.text then widget.solid=true end\n"
"		widget.solid=widget.solid or def.solid\n"
"		\n"
"		if widget.class and classes[widget.class] then -- got a class, call its setup, its setup can override other functions\n"
"			classes[widget.class].setup(widget,def)\n"
"		end\n"
"		\n"
"		if widget.master.ids and widget.id then widget.master.ids[widget.id]=widget end -- lookup by id\n"
"		\n"
"		widget:set_dirty()\n"
"		\n"
"		return widget\n"
"	end\n"
"--\n"
"-- and final cleanup\n"
"--\n"
"	function meta.clean(widget)\n"
"		widget:set_dirty()\n"
"		if widget.master.ids and widget.id then widget.master.ids[widget.id]=nil end -- remove id lookup\n"
"		if widget.fbo then widget.fbo:clean() end\n"
"		return widget\n"
"	end\n"
"--\n"
"-- live adjustment\n"
"--\n"
"	function meta.get(widget,val,...)\n"
"	\n"
"		if val==\"slide\" then\n"
"		\n"
"			local x=(widget.pxd-widget.parent.pxd) / (widget.parent.hx-widget.hx)\n"
"			local y=(widget.pyd-widget.parent.pyd) / (widget.parent.hy-widget.hy)\n"
"			\n"
"			\n"
"			return x,y\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	function meta.set(widget,val,...)\n"
"	local t={...}\n"
"	\n"
"		if val==\"slide\" then\n"
"			for i,v in ipairs(widget) do\n"
"			\n"
"				if type(t[1])==\"table\" then\n"
"					v.pxf=t[1][1] or v.pxf or 0\n"
"					v.pyf=t[1][2] or v.pyf or 0\n"
"				else\n"
"					v.pxf=t[1] or v.pxf or 0\n"
"					v.pyf=t[2] or v.pyf or 0\n"
"				end\n"
"				\n"
"--print(\"SET\",v.pxf,v.pyf)\n"
"\n"
"				v.px=(widget.hx-v.hx)*v.pxf -- local position relative to parents size\n"
"				v.py=(widget.hy-v.hy)*v.pyf\n"
"				\n"
"				v.pxd=widget.pxd+v.px -- absolute\n"
"				v.pyd=widget.pyd-v.py\n"
"				\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"--\n"
"-- initial layout of widgets, to put them into reasonable positions\n"
"--\n"
"	function meta.layout(widget)\n"
"--print(widget.class)\n"
"		if widget.class==\"flow\" or widget.class==\"hx\" then -- hx will be removed\n"
"			meta.layout_flow(widget)\n"
"		elseif widget.class==\"fill\" or widget.class==\"pan\" then\n"
"			meta.layout_fill(widget)\n"
"		elseif widget.class==\"slide\" or widget.class==\"pad\" then\n"
"			meta.layout_padding(widget)\n"
"		elseif widget.class==\"master\" or widget.class==\"abs\" then\n"
"			meta.layout_base(widget)\n"
"		else\n"
"			meta.layout_base(widget)\n"
"		end\n"
"	end\n"
"	\n"
"	function meta.layout_none(widget)\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"	function meta.layout_padding(widget)\n"
"		for i,v in ipairs(widget) do\n"
"\n"
"			if v.hxf then v.hx=widget.hx*v.hxf end -- generate size as a fraction of parent\n"
"			if v.hyf then v.hy=widget.hy*v.hyf end\n"
"			\n"
"			v.px=(widget.hx-v.hx)*v.pxf -- local position relative to parents size\n"
"			v.py=(widget.hy-v.hy)*v.pyf\n"
"\n"
"			v.pxd=widget.pxd+v.px -- local absolute position\n"
"			v.pyd=widget.pyd-v.py\n"
"\n"
"		end\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"\n"
"	function meta.layout_base(widget)\n"
"		for i,v in ipairs(widget) do\n"
"		\n"
"			if v.hxf then v.hx=widget.hx*v.hxf end -- generate size as a fraction of parent\n"
"			if v.hyf then v.hy=widget.hy*v.hyf end\n"
"			\n"
"			if v.pxf then v.px=(widget.hx)*v.pxf end -- local position relative to parents size\n"
"			if v.pyf then v.py=(widget.hy)*v.pyf end\n"
"\n"
"			v.pxd=widget.pxd+v.px -- absolute position\n"
"			v.pyd=widget.pyd-v.py\n"
"			\n"
"		end\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"\n"
"-- this is a fixed layout that works kind of like text\n"
"-- we do not adjust the hx,hy size of sub widgets\n"
"-- we just place them left to right top to bottom\n"
"-- finally we resize this widget to fit its content\n"
"-- the widgets sx,sy is used as default hx,hy for layout\n"
"	function meta.layout_fill(widget)\n"
"		\n"
"		local hx,hy=0,0\n"
"		local my=0\n"
"		local mhx,mhy=0,0\n"
"		function addone(w)\n"
"			w.px=hx\n"
"			w.py=hy\n"
"			hx=hx+w.hx\n"
"			if hx > mhx then mhx=hx end -- max x total size\n"
"			if w.hy > my then my=w.hy end -- max y size for this line\n"
"--print(w.id or \"?\",w.px,w.py,w.hx,w.hy)\n"
"		end\n"
"		\n"
"		function endoflines()\n"
"			widget.hx=mhx\n"
"			widget.hy=mhy\n"
"		end\n"
"		\n"
"		function endofline()\n"
"			hx=0\n"
"			hy=hy+my\n"
"			my=0\n"
"			mhy=hy\n"
"		end\n"
"		\n"
"		if #widget>0 then\n"
"		\n"
"			widget.hx=widget.sx -- use sx,sy as the base fill size\n"
"			widget.hy=widget.sy\n"
"		\n"
"			for i,w in ipairs(widget) do\n"
"			\n"
"				if hx+w.hx>widget.hx then\n"
"					if hx==0 then -- need one item per line so add it anyway\n"
"						addone(w)\n"
"						endofline()\n"
"					else -- skip this one, push it onto nextline\n"
"						endofline()\n"
"						addone(w)\n"
"					end\n"
"				else -- it fits so just add\n"
"					addone(w)\n"
"				end\n"
"			end\n"
"\n"
"			if hx>0 then endofline() end -- final end of line\n"
"			\n"
"			endoflines()\n"
"			\n"
"		end\n"
"		\n"
"		for i,v in ipairs(widget) do\n"
"			v.pxd=widget.pxd+v.px\n"
"			v.pyd=widget.pyd-v.py\n"
"		end\n"
"\n"
"-- layout sub sub widgets	\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"-- this is the magical layout that works like text\n"
"-- except things expand to fit the area\n"
"-- use sx,sy and mx,my to control what ends up where\n"
"	function meta.layout_flow(widget)\n"
"		local sx,sy=0,0\n"
"		local my=0\n"
"		local line=1\n"
"		\n"
"		function endoflines()\n"
"			local y=0\n"
"			for i,v in ipairs(widget) do\n"
"				v.hy=v.sy*widget.hy/sy\n"
"				if v.hy_max and v.hy > v.hy_max then v.hy = v.hy_max end\n"
"				v.py=y\n"
"				if v.endofline then y=y+v.hy end\n"
"--print(v.px..\",\"..v.py..\" - \"..v.hx..\",\"..v.hy)\n"
"			end\n"
"		end\n"
"		\n"
"		function endofline(i)\n"
"			local x=0\n"
"			for i=line,i do -- final line layout\n"
"				local v=widget[i]\n"
"				v.sy=my\n"
"				v.hx=v.sx*widget.hx/sx\n"
"				if v.hx_max and v.hx > v.hx_max then v.hx = v.hx_max end\n"
"				v.px=x\n"
"				x=x+v.hx\n"
"			end\n"
"			widget[i].endofline=true\n"
"			sx=0\n"
"			sy=sy+my\n"
"			my=0\n"
"			line=i+1\n"
"		end\n"
"		\n"
"		if #widget>0 then\n"
"			for i,v in ipairs(widget) do\n"
"			\n"
"				v.endofline=false\n"
"				if sx+v.sx>widget.mx then\n"
"					if sx==0 then -- only one on line\n"
"						if v.sy>my then my=v.sy end\n"
"						sx=sx+v.sx				\n"
"						endofline(i)\n"
"					else -- skip this one, push onto nextline\n"
"						endofline(i-1)\n"
"						if v.sy>my then my=v.sy end\n"
"						sx=sx+v.sx				\n"
"					end\n"
"				else\n"
"					if v.sy>my then my=v.sy end\n"
"					sx=sx+v.sx				\n"
"				end\n"
"			end\n"
"\n"
"			endofline(#widget)\n"
"			endoflines()\n"
"		end\n"
"		\n"
"		for i,v in ipairs(widget) do\n"
"			v.pxd=widget.pxd+v.px\n"
"			v.pyd=widget.pyd-v.py\n"
"		end\n"
"\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"--\n"
"-- handle key input\n"
"--\n"
"	function meta.key(widget,ascii,key,act)\n"
"	end\n"
"	\n"
"--\n"
"-- handle mouse input\n"
"--\n"
"	function meta.mouse(widget,act,x,y,key)\n"
"	\n"
"--print(x..\",\"..y..\" : \"..widget.px..\",\"..widget.py)\n"
"\n"
"		if widget.pan_px then x=x-widget.pan_px end\n"
"		if widget.pan_py then y=y-widget.pan_py end\n"
"\n"
"		if widget.solid and x>=widget.pxd and x<widget.pxd+widget.hx and y<=widget.pyd and y>widget.pyd-widget.hy then\n"
"		\n"
"			if act==\"down\" then\n"
"-- only set if null or our parent...\n"
"				if not widget.master.active or widget.master.active==widget.parent then\n"
"					widget.master.active=widget\n"
"					widget.master.active_x=x-widget.pxd\n"
"					widget.master.active_y=y-widget.pyd\n"
"				end\n"
"			end\n"
"			if act==\"up\" then\n"
"				if widget.master.active and widget.master.active==widget then -- widget clicked\n"
"					widget:call_hook(\"click\")\n"
"				end\n"
"			end\n"
"\n"
"			if not widget.master.active or widget.master.active==widget then -- over widget\n"
"				widget.master.over=widget\n"
"			end\n"
"		else\n"
"		\n"
"			if widget.master.over==widget then\n"
"				widget.master.over=nil\n"
"			end\n"
"		end\n"
"	\n"
"		for i,v in ipairs(widget) do\n"
"			v:mouse(act,x,y,key)\n"
"		end\n"
"	end\n"
"	\n"
"--\n"
"-- update this widget and its sub widgets\n"
"--\n"
"	function meta.update(widget)\n"
"	\n"
"		for i,v in ipairs(widget) do\n"
"			v:update()\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- remove all children of this widget\n"
"--\n"
"	function meta.remove_all(widget)\n"
"	\n"
"		local len=#widget\n"
"		for i=1,len do\n"
"			widget[i]=nil\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- clean and remove all children of this widget\n"
"--\n"
"	function meta.clean_all(widget)\n"
"	\n"
"		for i,v in ipairs(widget) do\n"
"			v:clean_all()\n"
"		end\n"
"		\n"
"		local len=#widget\n"
"		for i=1,len do\n"
"			widget[i]:clean()\n"
"			widget[i]=nil\n"
"		end\n"
"	end\n"
"\n"
"end\n"
"",

"wetgenes.www.gae.img","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local core=require(\"wetgenes.www.gae.img.core\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.img\"]=_M\n"
"\n"
"\n"
"function get(...)\n"
"\n"
"	return core.get(...)\n"
"\n"
"end\n"
"\n"
"function resize(...)\n"
"\n"
"	return core.resize(...)\n"
"\n"
"end\n"
"\n"
"function composite(...)\n"
"\n"
"	return core.composite(...)\n"
"\n"
"end\n"
"",

"wetgenes.www.any.mail","if ngx then\r	return require(\"wetgenes.www.ngx.mail\")\relse\r	return require(\"wetgenes.www.gae.mail\")\rend\r\r",

"spew.util","\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"local string=string\n"
"local math=math\n"
"local os=os\n"
"local print=print\n"
"local tonumber=tonumber\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"--\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"module(\"spew.util\")\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split a string into a table\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function str_split(div,str,enable_special_chars)\n"
"\n"
"  if (div=='') or not div then error(\"div expected\", 2) end\n"
"  if (str=='') or not str then error(\"str expected\", 2) end\n"
"  \n"
"  local pos,arr = 0,{}\n"
"  \n"
"  -- for each divider found\n"
"  for st,sp in function() return string.find(str,div,pos,not enable_special_chars) end do\n"
"	table.insert(arr,string.sub(str,pos,st-1)) -- Attach chars left of current divider\n"
"	pos = sp + 1 -- Jump past current divider\n"
"  end\n"
"  \n"
"  if pos~=0 then\n"
"	table.insert(arr,string.sub(str,pos)) -- Attach chars right of last divider\n"
"  else\n"
"	table.insert(arr,str) -- return entire string\n"
"  end\n"
"  \n"
"  \n"
"  return arr\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace any %xx with the intended char, eg \"%20\" becomes a \" \"\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_decode(str)\n"
"    return string.gsub(str, \"%%(%x%x)\", function(hex)\n"
"        return string.char(tonumber(hex, 16))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace % , & and = chars with %xx codes\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_encode(str)\n"
"    return string.gsub(str, \"([&=%%])\", function(c)\n"
"        return string.format(\"%%%02x\", string.byte(c))\n"
"    end)\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- decode a string into a msg\n"
"-- if last is passed in then this table is adjusted rather than a new table being created\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function str_to_msg(str,last)\n"
"local msg=last or {}\n"
"local arr\n"
"local set\n"
"\n"
"	arr=str_split(\"&\",str)\n"
"	\n"
"	for i,v in ipairs(arr) do\n"
"	\n"
"		if v~=\"\" then\n"
"		\n"
"			set=str_split(\"=\",v)\n"
"			\n"
"			if set[1] and set[2] then\n"
"			\n"
"				msg[ set[1] ]=url_decode(set[2])\n"
"			end\n"
"			\n"
"		end\n"
"	end\n"
"\n"
"	return msg\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- encode a msg into a string\n"
"-- if last is available then only *changes* from msg to last are encoded, last is also updated with these changes\n"
"-- this gives a very simple delta compression\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function msg_to_str(msg,last)\n"
"local str\n"
"local line=\"&\"\n"
"\n"
"	for i,v in pairs(msg) do\n"
"	\n"
"		if (not last) or (last[i]~=v) then -- only store changes in string\n"
"		\n"
"			line=line.. i ..\"=\".. url_encode(v) ..\"&\"\n"
"			\n"
"			if last then last[i]=v end\n"
"			\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	return line\n"
"end\n"
"\n"
"",

"wetgenes.www.gae.sys","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local core=require(\"wetgenes.www.gae.sys.core\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.sys\"]=_M\n"
"\n"
"\n"
"function sleep(...)\n"
"\n"
"	return core.sleep(...)\n"
"\n"
"end\n"
"\n"
"function file_read(filename)\n"
"\n"
"	return core.file_read(filename)\n"
"end\n"
"\n"
"function bytes_split(bytes,size)\n"
"	return core.bytes_split(bytes,size)\n"
"end\n"
"function bytes_join(tab)\n"
"	return core.bytes_join(tab)\n"
"end\n"
"\n"
"function bytes_to_string(bytes)\n"
"	return core.bytes_to_string(bytes)\n"
"end\n"
"\n"
"function bin_encode(t,b)\n"
"	return core.bin_encode(t,b)\n"
"end\n"
"\n"
"function md5(s,f)\n"
"	return core.md5(s,f)\n"
"end\n"
"function sha1(s,f)\n"
"	return core.sha1(s,f)\n"
"end\n"
"function hmac_sha1(k,s,f)\n"
"	return core.hmac_sha1(k,s,f)\n"
"end\n"
"\n"
"function zip_list(z)\n"
"	return core.zip_list(z)\n"
"end\n"
"function zip_read(z,n)\n"
"	return core.zip_read(z,n)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- check if the given file exists\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function file_exists(filename)\n"
"\n"
"--[[\n"
"	local f=io.open(filename,\"r\")\n"
"	if f then\n"
"		f:close()\n"
"		return true\n"
"	end\n"
"\n"
"	return false\n"
"]]\n"
"\n"
"	return core.file_exists(filename)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- find a given lua file, within the lua path\n"
"-- do not pass in the .lua extension\n"
"-- returns a path to a file you can then open\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function file_find_lua(name)\n"
"\n"
"	return \"lua/\"..name..\".lua\"\n"
"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function redirect(srv,url)\n"
"\n"
"--	if not srv.redirect(url) then -- header write failed, spit out some java script instead?\n"
"	\n"
"		srv.put([[<script type=\"text/javascript\" >window.location = \"]]..url..[[\";</script>]])\n"
"		\n"
"--	end\n"
"\n"
"end\n"
"\n"
"",

"swordstone.maps","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local dbg=dbg or function()end\n"
"\n"
"\n"
"module(...)\n"
"\n"
"local strings=require(\"yarn.strings\")\n"
"\n"
"\n"
"function setup()\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"strings=strings or {}\n"
"keys=keys or {}\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- add new room data\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function add_room(name,map,key)\n"
"	if map then\n"
"		strings[name]=map\n"
"	end\n"
"	if key then\n"
"		keys[name]=key\n"
"	end\n"
"end\n"
"local room=add_room\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- build room info from an ascii map and a key\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function string_to_room(s,key)\n"
"\n"
"	if not key then key=keys.base end\n"
"\n"
"	local r={}\n"
"\n"
"	local lines=strings.split_lines(s)\n"
"	for i,v in ipairs(lines) do lines[i]=strings.trim(v)..\" \" end -- trim, but add space back on end\n"
"	\n"
"	local xh=0\n"
"	for i,v in ipairs(lines) do if #v>xh then xh=#v end end -- find maximum line length\n"
"\n"
"	local ls={}\n"
"	for i,v in ipairs(lines) do if #v==xh then ls[#ls+1]=v end end -- only keep lines of this length\n"
"	local yh=#ls\n"
"	xh=math.floor(xh/2) -- 2 chars to one cell\n"
"	\n"
"	xh=xh-2\n"
"	yh=yh-2\n"
"	\n"
"	if xh<0 then xh=0 end\n"
"	if yh<0 then yh=0 end\n"
"	\n"
"	r.xh=xh\n"
"	r.yh=yh\n"
"	\n"
"	r.name=\"unnnamed\"\n"
"	\n"
"	r.cells={}\n"
"	for n=2,#ls-1 do -- skip top/bottom line\n"
"		local l=ls[n]\n"
"		local t={}\n"
"		r.cells[ #r.cells+1 ]=t\n"
"		for i=1+2,#l-2,2 do -- skip left/right chars\n"
"			local ab=l:sub(i,i+1)\n"
"			t[#t+1]=key[ab] or keys.base[ab] or \"space\"\n"
"		end\n"
"	end\n"
"	return r\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get room info by name\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function get_room(name)\n"
"\n"
"	local r\n"
"\n"
"	if strings[name] then	\n"
"		r=string_to_room( strings[name] , keys[name] )\n"
"	end\n"
"\n"
"	return r\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"-- basic key, every map string uses this by default and then adds more or overides\n"
"keys.base={\n"
"	[\"# \"]=\"wall\",\n"
"	[\". \"]=\"space\",\n"
"	[\"- \"]=\"item_spawn\",\n"
"	[\"= \"]=\"bigitem_spawn\",\n"
"	[\"@ \"]=\"player_spawn\",\n"
"	[\"< \"]=\"stairs\",\n"
"}\n"
"\n"
"\n"
"room(\"bigroom\",[[\n"
"# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n"
"# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n"
"]])\n"
"\n"
"room(\"pub\",[[\n"
"# # # # # # # #\n"
"# . . . . . . #\n"
"# . = = = = . #\n"
"# . = = = = . #\n"
"# . . . . . . #\n"
"# # # # # # # #\n"
"]])\n"
"\n"
"room(\"bank\",[[\n"
"# # # # # #\n"
"# . . . . #\n"
"# . = = . #\n"
"# . = = . #\n"
"# . . . . #\n"
"# # # # # #\n"
"]])\n"
"\n"
"room(\"shop\",[[\n"
"# # # # # #\n"
"# . . . . #\n"
"# . = = . #\n"
"# . = = . #\n"
"# . = = . #\n"
"# . = = . #\n"
"# . . . . #\n"
"# # # # # #\n"
"]])\n"
"\n"
"room(\"hotel\",[[\n"
"# # # # # # #\n"
"# . . . . . #\n"
"# . = = = . #\n"
"# . = = = . #\n"
"# . = = = . #\n"
"# . . . . . #\n"
"# # # # # # #\n"
"]])\n"
"\n"
"\n"
"room(\"home_bedroom\",[[\n"
"# # # # # # # # # #\n"
"# . . . . . . . . #\n"
"# . # # # # # # . #\n"
"# . # =1@ . . =2. #\n"
"# . # # # # # # . #\n"
"# . . . . . . . . #\n"
"# # # # # # # # # #\n"
"]],{\n"
"	[\"=1\"]=\"cryo_bed\",\n"
"	[\"=2\"]=\"cryo_door\",\n"
"})\n"
"\n"
"room(\"home_mainroom\",[[\n"
"# # # # # # # # # #\n"
"# . . . . . . . . #\n"
"# . = = . . = = . #\n"
"# . = = . . = = . #\n"
"# . = = . . = = . #\n"
"# . = = . . = = . #\n"
"# . . . . . . . . #\n"
"# # # # # # # # # #\n"
"]])\n"
"\n"
"room(\"home_stairs\",[[\n"
"# # # # # # #\n"
"# . . . . . #\n"
"# . # # # . #\n"
"# . . < # . #\n"
"# . # # # . #\n"
"# . . . . . #\n"
"# # # # # # #\n"
"]],{\n"
"	[\"< \"]=\"stairs.home\",\n"
"})\n"
"\n"
"room(\"dump_stairs\",[[\n"
"# # # # # #\n"
"# . . . . #\n"
"# . < @1. #\n"
"# . . . . #\n"
"# # # # # #\n"
"]],{   \n"
"	[\"< \"]=\"stairs.dump\",\n"
"	[\"@1\"]=\"sensei.dump\",\n"
"})\n"
"\n"
"\n"
"\n"
"room(\"stairs\",[[\n"
"# # # # #\n"
"# . . . #\n"
"# . < . #\n"
"# . . . #\n"
"# # # # #\n"
"]],{\n"
"	[\"< \"]=\"stairs\",\n"
"})\n"
"\n"
"room(\"redroom\",[[\n"
"# # # # # #\n"
"# . . . . #\n"
"# . @1@2. #\n"
"# . . . . #\n"
"# # # # # #\n"
"]],{\n"
"	[\"@1\"]=\"sensei.twin1\",\n"
"	[\"@2\"]=\"sensei.twin2\",\n"
"})\n"
"",

"fenestra.widget.master","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"-- widget class master\n"
"-- the master widget\n"
"\n"
"\n"
"\n"
"local gl=require('gl')\n"
"\n"
"module(\"fenestra.widget.master\")\n"
"\n"
"--\n"
"-- add meta functions\n"
"--\n"
"function setup(widget,def)\n"
"\n"
"	local master=widget\n"
"	local meta=widget.meta\n"
"--	local win=def.win\n"
"\n"
"	master.throb=0\n"
"	master.fbo=_G.win.fbo(0,0,0) -- use an fbo\n"
"\n"
"-- the master gets some special overloaded functions to do a few more things\n"
"	function master.update(widget)\n"
"	\n"
"		local throb=(widget.throb<128)\n"
"		\n"
"		widget.throb=widget.throb-4\n"
"		if widget.throb<0 then widget.throb=255 end\n"
"		\n"
"		if throb ~= (widget.throb<128) then -- dirty throb...\n"
"			if widget.focus then\n"
"				if widget.focus.class==\"textedit\" then\n"
"					widget.focus:set_dirty()\n"
"				end\n"
"			end\n"
"		end\n"
"\n"
"		meta.update(widget)\n"
"	end\n"
"	\n"
"	function master.layout(widget)\n"
"		meta.layout(widget)\n"
"		master.remouse(widget)\n"
"	end\n"
"\n"
"	local dirty_fbos={}\n"
"	local find_dirty_fbos\n"
"	find_dirty_fbos=function(widget)\n"
"		if widget.fbo and widget.dirty then\n"
"			dirty_fbos[ #dirty_fbos+1 ]=widget\n"
"		end\n"
"		for i,v in ipairs(widget) do\n"
"			find_dirty_fbos(v)\n"
"		end\n"
"	end\n"
"	\n"
"	function master.draw(widget)\n"
"		dirty_fbos={}\n"
"		find_dirty_fbos(widget)\n"
"	\n"
"		gl.Disable(gl.CULL_FACE)\n"
"		gl.Disable(gl.LIGHTING)\n"
"		gl.Disable(gl.DEPTH_TEST)\n"
"		gl.PushMatrix()\n"
"		\n"
"		if #dirty_fbos>0 then\n"
"			for i=#dirty_fbos,1,-1 do -- call in reverse so sub fbos can work\n"
"				meta.draw(dirty_fbos[i]) -- dirty, so this only builds the fbo\n"
"			end\n"
"		end\n"
"		\n"
"		meta.draw(widget)\n"
"		\n"
"		gl.PopMatrix()\n"
"--		gl.Enable(\"DEPTH_TEST\")\n"
"--		gl.Enable(\"LIGHTING\")\n"
"	end\n"
"	\n"
"--\n"
"-- handle key input\n"
"--\n"
"	function master.key(widget,ascii,key,act)\n"
"\n"
"		if master.focus then -- key focus\n"
"		\n"
"			master.focus:key(ascii,key,act)\n"
"		end\n"
"\n"
"	end\n"
"\n"
"--\n"
"-- set the mouse position to its last position\n"
"-- call this after adding/removing widgets to make sure they highlight properly\n"
"--	\n"
"	function master.remouse(widget)\n"
"		local p=widget.last_mouse_position or {0,0}\n"
"		widget.mouse(widget,nil,p[1],p[2],nil)\n"
"	end\n"
"--\n"
"-- handle mouse input\n"
"--	\n"
"	function master.mouse(widget,act,x,y,key)\n"
"	\n"
"		master.last_mouse_position={x,y}\n"
"	\n"
"--		if widget.state==\"ready\" then\n"
"		\n"
"			if master.active and (master.active.parent.class==\"slide\" or master.active.parent.class==\"oldslide\") then -- slide :)\n"
"			\n"
"				local w=master.active\n"
"				local p=master.active.parent\n"
"				\n"
"				local minx=p.pxd\n"
"				local miny=p.pyd-p.hy+w.hy\n"
"				local maxx=p.pxd+p.hx-w.hx\n"
"				local maxy=p.pyd\n"
"				\n"
"				w.pxd=x-master.active_x\n"
"				w.pyd=y-master.active_y\n"
"				\n"
"				if w.pxd<minx then w.pxd=minx end\n"
"				if w.pxd>maxx then w.pxd=maxx end\n"
"				if w.pyd<miny then w.pyd=miny end\n"
"				if w.pyd>maxy then w.pyd=maxy end\n"
"				\n"
"				w.px=w.pxd-p.pxd\n"
"				w.py=p.pyd-w.pyd\n"
"			\n"
"				w:call_hook(\"slide\")\n"
"				\n"
"				w:set_dirty()\n"
"\n"
"			end\n"
"			\n"
"			local old_active=master.active\n"
"			local old_over=master.over\n"
"			for i,v in ipairs(widget) do\n"
"				meta.mouse(v,act,x,y,key)\n"
"			end\n"
"			\n"
"			if act==\"up\" then\n"
"				master.active=nil\n"
"			end\n"
"			\n"
"--mark as dirty\n"
"			if master.active~=old_active then\n"
"				if master.active then master.active:set_dirty() end\n"
"				if old_active then old_active:set_dirty() end\n"
"			end\n"
"			if master.over~=old_over then\n"
"				if master.over then master.over:set_dirty() end\n"
"				if old_over then old_over:set_dirty() end\n"
"			end\n"
"			\n"
"--		end\n"
"	end\n"
"--\n"
"end\n"
"",

"wetgenes.www.sqlite","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=print\n"
"\n"
"if ngx then\n"
"	log=require(\"wetgenes.www.any.log\").log\n"
"end\n"
"\n"
"local sql=require(\"sqlite\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"local function fixkind(kind) return kind:gsub(\"%p\",\"_\") end\n"
"\n"
"module(...)\n"
"\n"
"dbs={} -- tooglobal?pass in this or your own to the funcs anyhow\n"
"\n"
"function open(dbs,prefix,kind,postfix) -- multiple opens are ok and get you the same db\n"
"\n"
"	kind=fixkind(kind)\n"
"\n"
"	local db=dbs[kind]\n"
"	\n"
"	if db then return db end -- already open\n"
"	\n"
"	db=assert(sql.open(prefix..kind..postfix))\n"
"\n"
"	set_pragmas(db) -- always run this\n"
"\n"
"\n"
"	dbs[kind]=db -- remember\n"
"	return db\n"
"	\n"
"end\n"
"\n"
"function close(dbs,kind)\n"
"\n"
"	kind=fixkind(kind)\n"
"\n"
"	local db=dbs[kind]\n"
"	\n"
"	if db then\n"
"		sb:close()\n"
"		dbs[kind]=nil\n"
"	end\n"
"end\n"
"\n"
"-- setup pragmas, should run this after opening a db\n"
"function set_pragmas(db)\n"
"exec(db,[[\n"
"PRAGMA synchronous = 0 ;\n"
"PRAGMA encoding = \"UTF-8\" ;\n"
"]])\n"
"\n"
"-- tunrning sync off is dangerous, but so is life\n"
"-- technically its only dangerous if you lose power whilst writing to disk\n"
"-- this is perhaps less likely than file coruption on a failing disk\n"
"\n"
"end\n"
"\n"
"-- wrap db:exec with an error checker\n"
"function exec(db,s,f,d)\n"
"--log(s)\n"
"	if 	db:exec(s,f,d)~=sql.OK then error(db:errmsg()) end\n"
"end\n"
"\n"
"-- get all rows the sql requests\n"
"function rows(db,s)\n"
"\n"
"	local d={}\n"
"--	local f=function(d,count,v,n)\n"
"--		local dd={}\n"
"--		d[#d+1]=dd\n"
"--		for i=1,count do dd[ n[i] ]=v[i] end\n"
"--		return 0\n"
"--	end\n"
"	\n"
"	for r in db:nrows(s) do\n"
"		d[#d+1]=r\n"
"	end\n"
"\n"
"--	if 	db:exec(s,f,d)~=sql.OK then error(db:errmsg()) end\n"
"\n"
"	return d\n"
"end\n"
"\n"
"-- get first row the sql requests\n"
"function row(db,s)\n"
"	return rows(db,s)[1]\n"
"end\n"
"\n"
"-- get info about a table, this can only work if WE created the table\n"
"function get_info(db,kind)\n"
"\n"
"	kind=fixkind(kind)\n"
"\n"
"--[[\n"
"	local d=rows(db,\"PRAGMA table_info('\"..name..\"')\");\n"
"	print(wstr.serialize(d))\n"
"]]\n"
"\n"
"	local d=rows(db,\"select sql from sqlite_master where name = '\"..kind..\"';\")\n"
"	\n"
"	if not d[1] then return end -- no table of the given kind exists\n"
"	\n"
"-- grab the bit in brackets\n"
"	local _,_,s=string.find(d[1].sql,\"%((.*)%)\")\n"
"--print(s)\n"
"-- and split it by commas\n"
"	local a=wstr.split(s,\",\")\n"
"	\n"
"	tab={}\n"
"	\n"
"	local flags={\"NOT\",\"NULL\",\"INTEGER\",\"REAL\",\"TEXT\",\"BLOB\",\"PRIMARY\",\"FOREIGN\",\"KEY\",\"COLLATE\",\"BINARY\",\"NOCASE\",\"RTRIM\",\"UNIQUE\",\"CHECK\",\"DEFAULT\"}\n"
"	for i,v in ipairs(flags) do flags[v]=0 end -- set as this next word\n"
"	flags.DEFAULT=1 -- set as the next word\n"
"	\n"
"	for i,v in ipairs(a) do\n"
"		local c=wstr.split_words(v)\n"
"--		print(wstr.serialize(c))\n"
"		local d={}\n"
"		for i,v in ipairs(c) do d[v]=flags[v] and c[i+flags[v]] end -- set flags only if we recognise them\n"
"		local cmd=false\n"
"		for i,v in ipairs(flags) do if c[1]:sub(1,#v)==v then cmd=v end end\n"
"		if cmd then\n"
"			d.cmd=c[1] -- set the command\n"
"		else -- a named column\n"
"			d.name=c[1] -- set the name\n"
"			if d.name:sub(1,1)==\"'\" then d.name=d.name:sub(2,-2) end -- strip quotes\n"
"		end\n"
"\n"
"		tab[i]=d\n"
"	end\n"
"	\n"
"--	print(wstr.serialize(tab))\n"
"	return tab\n"
"end\n"
"\n"
"-- create or update a table, this can only update if *we* created the table using this function\n"
"-- info is the same as when returned from info function\n"
"-- the two arecompared and the table updated with any missing columns\n"
"-- so you may not get a a table in the exact order specified or it may have extra cruft etc\n"
"--\n"
"-- in general it should be safe to add columns to the end of the info and call this again\n"
"-- so we can modify existing tabs\n"
"function set_info(db,kind,info)\n"
"\n"
"	kind=fixkind(kind)\n"
"\n"
"--	print(wstr.serialize(info))\n"
"\n"
"	old=get_info(db,kind)\n"
"\n"
"-- build the sql string we need to run	\n"
"	local t={}\n"
"	local p=function(...) for i,v in ipairs{...} do t[#t+1]=tostring(v) end end\n"
"\n"
"-- add a column\n"
"	local function pdef(t)\n"
"		if t.name then\n"
"			p(\"'\"..t.name..\"'\")\n"
"			if t.INTEGER then\n"
"				p(\" INTEGER\")\n"
"			elseif t.REAL then\n"
"				p(\" REAL\")\n"
"			elseif t.TEXT then\n"
"				p(\" TEXT\")\n"
"			elseif t.BLOB then\n"
"				p(\" BLOB\")\n"
"			end\n"
"			if t.PRIMARY then\n"
"				p(\" PRIMARY KEY\")\n"
"			elseif t.UNIQUE then\n"
"				p(\" UNIQUE\")\n"
"			end\n"
"			if t.DEFAULT then\n"
"				p(\" DEFAULT \",t.DEFAULT) --- Only numbers? ...dont want defaults anyhow...\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"--check if is already added\n"
"	local function in_table(tab,name)\n"
"		for i,v in ipairs(tab) do\n"
"			if v.name==name then return true end\n"
"		end\n"
"	end\n"
"	\n"
"	if not old then -- create new\n"
"	\n"
"		p(\"CREATE TABLE \"..kind..\"( \")\n"
"		for i,v in ipairs(info) do\n"
"			if i>1 then p(\" , \") end\n"
"			pdef(v)\n"
"		end\n"
"		p(\" );\")\n"
"	\n"
"	else -- adjust\n"
"	\n"
"		local ch -- if set then we need to add these columns\n"
"		for i,v in ipairs(info) do\n"
"			if not in_table(old,v.name) then\n"
"				ch=ch or {}\n"
"				ch[#ch+1]=v\n"
"			end\n"
"		end\n"
"\n"
"		if ch then\n"
"			for i,v in ipairs(ch) do\n"
"				p(\"ALTER TABLE \"..kind..\" ADD COLUMN \")\n"
"				pdef(v)\n"
"				p(\" ;\")\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	if t[1] then -- something to do\n"
"--		print(table.concat(t))\n"
"		exec(db,table.concat(t))\n"
"	end\n"
"	\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- escape a string for sqlite use\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function escape(s)\n"
"	return \"'\"..s:gsub(\"'\",\"''\")..\"'\"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- turn a table into a string of values\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_values(tab)\n"
"\n"
"	local ns={}\n"
"	local ds={}\n"
"	for n,d in pairs(tab) do\n"
"		if type(d)==\"string\" then d=escape(d) end\n"
"		ns[#ns+1]=\"'\"..n..\"'\"\n"
"		ds[#ds+1]=d\n"
"	end\n"
"\n"
"	return \"(\"..table.concat(ns,\",\")..\")\"..\" VALUES (\"..table.concat(ds,\",\")..\")\"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- turn a table into a string of sets\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_valueset(tab)\n"
"\n"
"	local ss={}\n"
"	for n,d in pairs(tab) do\n"
"		if type(d)==\"string\" then d=escape(d) end\n"
"		ss[#ss+1]=\"'\"..n..\"'=\"..d\n"
"	end\n"
"\n"
"	return table.concat(ss,\",\")\n"
"end\n"
"\n"
"function fixvalue(v)\n"
"	if type(v)==\"string\" then\n"
"		return escape(v)\n"
"	else\n"
"		return tonumber(v)\n"
"	end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- insert or update data on clash, similar format to the lanes returned info\n"
"-- this function doesnt do anything it just builds a queery string that will\n"
"--\n"
"-- name == table name\n"
"-- tab == data to insert\n"
"--\n"
"-- this is a single insert or update, so there is only one row\n"
"--\n"
"-- any previous values not in the tab be lost, use update to only change some values\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_replace(name,tab)\n"
"	return \"REPLACE INTO \"..name..\" \"..make_values(tab)..\";\"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- insert only, similar format to the lanes returned info\n"
"-- this function doesnt do anything it just builds a queery string that will\n"
"--\n"
"-- name == table name\n"
"-- tab == data to insert\n"
"--\n"
"-- this is a single insert or update, so there is only one row\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_insert(name,tab)\n"
"	return \"INSERT INTO \"..name..\" \"..make_values(tab)..\";\"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- update only, similar format to the lanes returned info\n"
"-- this function doesnt do anything it just builds a queery string that will\n"
"--\n"
"-- name == table name\n"
"-- tab == data to insert\n"
"-- where == where to update (sql string)\n"
"--\n"
"-- this is a single insert or update, so there is only one row\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_update(name,tab,where)\n"
"\n"
"	return \"UPDATE \"..name..\" SET \"..make_valueset(tab)..\" WHERE \"..where..\";\"\n"
"end\n"
"\n"
"\n"
"\n"
"",

"wetgenes.www.any.fetch","if ngx then\r	return require(\"wetgenes.www.ngx.fetch\")\relse\r	return require(\"wetgenes.www.gae.fetch\")\rend\r",

"wetgenes.www.any.oauth","\n"
"\n"
"local wet_html=require(\"wetgenes.html\")\n"
"\n"
"local sys=require(\"wetgenes.www.any.sys\")\n"
"\n"
"local json=require(\"wetgenes.json\")\n"
"local dat=require(\"wetgenes.www.any.data\")\n"
"\n"
"local users=require(\"wetgenes.www.any.users\")\n"
"\n"
"local fetch=require(\"wetgenes.www.any.fetch\")\n"
"\n"
"local img=require(\"wetgenes.www.any.img\")\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log -- grab the func from the package\n"
"\n"
"local wet_string=require(\"wetgenes.string\")\n"
"local str_split=wet_string.str_split\n"
"local serialize=wet_string.serialize\n"
"\n"
"\n"
"local math=math\n"
"local string=string\n"
"local table=table\n"
"local os=os\n"
"\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"local tostring=tostring\n"
"local tonumber=tonumber\n"
"local type=type\n"
"local pcall=pcall\n"
"local loadstring=loadstring\n"
"\n"
"\n"
"module(...)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- The escape function for oauth must be exactly this, RFC3986\n"
"-- it would be nice if / was not escaped since base64 is also used all over the place\n"
"-- but that is not the case.\n"
"--\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function esc(s)\n"
"	return string.gsub(s,'[^0-9A-Za-z%-._~]', -- RFC3986 happy chars\n"
"		function(c) return ( string.format(\"%%%02X\", string.byte(c)) ) end )\n"
"end\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- unesc performs the oposite of esc\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function unesc(str)\n"
"    return string.gsub(str, \"%%(%x%x)\", function(hex)\n"
"        return string.char(tonumber(hex, 16))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- perform a hmac_sha1 that is oauth friendly, key is an RFC3986 string, result is a base64 hash\n"
"--\n"
"-- this uses some java crypto functions exposed in sys for dealing with hmac and sha1\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function hmac_sha1(key,str)\n"
"	local bin=sys.hmac_sha1(key,str,\"bin\") -- key gets used as is, (string is 7bit safe).\n"
"	local b64=sys.bin_encode(\"base64\",bin) -- we need to convert the resuilt to base64\n"
"	return b64\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get the current time and build a nonce for it using a passed in key value\n"
"-- which i do not think has to be terribly secret, we reuse hmac_sha1\n"
"-- just to keep the number of strange functions used low, really this could generate anything\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function time_nonce(key) -- pass in a secret key\n"
"	local t=math.floor(os.time())\n"
"	local n=sys.bin_encode(\"hex\",sys.hmac_sha1(key,tostring(t)..\"&aelua.dumid.oauth\",\"bin\"))\n"
"	return t,n -- returns time,nonce\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- vars contains the variables we intend to send to the oauth server\n"
"-- opts contains extra options:\n"
"--  post should be set to GET if we do not intend to use POST\n"
"--  url should be the oauth server url for this request\n"
"--  secret should be the token secret provided by the oauth server or nil for initial signin\n"
"--  api_secret should be your special api/consumer secret\n"
"-- these opts are used to build a request string from the vars and sign it so that\n"
"-- the oauth server will be happy with it\n"
"-- it returns a base64 signature , request string\n"
"-- the request string could be used in the body of a POST (default)\n"
"-- or if you set opts.post=\"GET\" then you could the use it in a GET request\n"
"--\n"
"-- aparently it is better to put this stuff in the header, Authorization:\n"
"-- but I have my doubts\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function build(vars,opts)\n"
"\n"
"	local post      =opts.post       or \"POST\" \n"
"	local url       =opts.url        or \"\"\n"
"	local tok_secret=opts.tok_secret or \"\"\n"
"	local api_secret=opts.api_secret or \"\"\n"
"\n"
"	local vals={}\n"
"\n"
"-- esc and shove all oauth vars into vals\n"
"	for i,v in pairs(vars) do\n"
"		vals[#vals+1]={esc(i),esc(v)} -- record a simple table , i==[1] v==[2]\n"
"	end\n"
"\n"
"	table.sort(vals, function(a,b)\n"
"			if a[1]==b[1] then return a[2]<b[2] end -- sort by [2] if [1] is the same\n"
"			return a[1]<b[1] -- other wise sort by [1]\n"
"		end)\n"
"		\n"
"-- now they are in the right order, build the query string\n"
"\n"
"	for i=1,#vals do local v=vals[i]\n"
"		vals[i]=v[1]..\"=\"..v[2]\n"
"	end\n"
"	local query=table.concat(vals,\"&\")\n"
"	local base=post..\"&\"..esc(url)..\"&\"..esc(query) -- everything always gets escaped\n"
"	local key=esc(api_secret)..\"&\"..esc(tok_secret) -- the key is built from these strings\n"
"	local sign=hmac_sha1(key,base)\n"
"	\n"
"	return sign , query..\"&oauth_signature=\"..esc(sign) -- sign it\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- turns a responce string into a table of values, this is the oposite of build\n"
"-- and intended to deal with the results\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function decode(s)\n"
"	local ret={}\n"
"	local aa=str_split(\"&\",s) -- first split on &\n"
"	for i=1,#aa do local v=aa[i]\n"
"		local a,b = wet_string.split_equal(v)\n"
"--log(\"decode : \"..v..\" : \"..type(a)..\" : \"..type(b))		\n"
"		ret[unesc(a)]=unesc(b) -- unescape both sides\n"
"	end\n"
"	return ret -- return a lookup table, which may be empty\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"",

"socket.ftp","-----------------------------------------------------------------------------\n"
"-- FTP support for the Lua language\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: ftp.lua,v 1.45 2007/07/11 19:25:47 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local table = require(\"table\")\n"
"local string = require(\"string\")\n"
"local math = require(\"math\")\n"
"local socket = require(\"socket\")\n"
"local url = require(\"socket.url\")\n"
"local tp = require(\"socket.tp\")\n"
"local ltn12 = require(\"ltn12\")\n"
"module(\"socket.ftp\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Program constants\n"
"-----------------------------------------------------------------------------\n"
"-- timeout in seconds before the program gives up on a connection\n"
"TIMEOUT = 60\n"
"-- default port for ftp service\n"
"PORT = 21\n"
"-- this is the default anonymous password. used when no password is\n"
"-- provided in url. should be changed to your e-mail.\n"
"USER = \"ftp\"\n"
"PASSWORD = \"anonymous@anonymous.org\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Low level FTP API\n"
"-----------------------------------------------------------------------------\n"
"local metat = { __index = {} }\n"
"\n"
"function open(server, port, create)\n"
"    local tp = socket.try(tp.connect(server, port or PORT, TIMEOUT, create))\n"
"    local f = base.setmetatable({ tp = tp }, metat)\n"
"    -- make sure everything gets closed in an exception\n"
"    f.try = socket.newtry(function() f:close() end)\n"
"    return f\n"
"end\n"
"\n"
"function metat.__index:portconnect()\n"
"    self.try(self.server:settimeout(TIMEOUT))\n"
"    self.data = self.try(self.server:accept())\n"
"    self.try(self.data:settimeout(TIMEOUT))\n"
"end\n"
"\n"
"function metat.__index:pasvconnect()\n"
"    self.data = self.try(socket.tcp())\n"
"    self.try(self.data:settimeout(TIMEOUT))\n"
"    self.try(self.data:connect(self.pasvt.ip, self.pasvt.port))\n"
"end\n"
"\n"
"function metat.__index:login(user, password)\n"
"    self.try(self.tp:command(\"user\", user or USER))\n"
"    local code, reply = self.try(self.tp:check{\"2..\", 331})\n"
"    if code == 331 then\n"
"        self.try(self.tp:command(\"pass\", password or PASSWORD))\n"
"        self.try(self.tp:check(\"2..\"))\n"
"    end\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:pasv()\n"
"    self.try(self.tp:command(\"pasv\"))\n"
"    local code, reply = self.try(self.tp:check(\"2..\"))\n"
"    local pattern = \"(%d+)%D(%d+)%D(%d+)%D(%d+)%D(%d+)%D(%d+)\"\n"
"    local a, b, c, d, p1, p2 = socket.skip(2, string.find(reply, pattern))\n"
"    self.try(a and b and c and d and p1 and p2, reply)\n"
"    self.pasvt = {\n"
"        ip = string.format(\"%d.%d.%d.%d\", a, b, c, d),\n"
"        port = p1*256 + p2\n"
"    }\n"
"    if self.server then\n"
"        self.server:close()\n"
"        self.server = nil\n"
"    end\n"
"    return self.pasvt.ip, self.pasvt.port\n"
"end\n"
"\n"
"function metat.__index:port(ip, port)\n"
"    self.pasvt = nil\n"
"    if not ip then\n"
"        ip, port = self.try(self.tp:getcontrol():getsockname())\n"
"        self.server = self.try(socket.bind(ip, 0))\n"
"        ip, port = self.try(self.server:getsockname())\n"
"        self.try(self.server:settimeout(TIMEOUT))\n"
"    end\n"
"    local pl = math.mod(port, 256)\n"
"    local ph = (port - pl)/256\n"
"    local arg = string.gsub(string.format(\"%s,%d,%d\", ip, ph, pl), \"%.\", \",\")\n"
"    self.try(self.tp:command(\"port\", arg))\n"
"    self.try(self.tp:check(\"2..\"))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:send(sendt)\n"
"    self.try(self.pasvt or self.server, \"need port or pasv first\")\n"
"    -- if there is a pasvt table, we already sent a PASV command\n"
"    -- we just get the data connection into self.data\n"
"    if self.pasvt then self:pasvconnect() end\n"
"    -- get the transfer argument and command\n"
"    local argument = sendt.argument or\n"
"        url.unescape(string.gsub(sendt.path or \"\", \"^[/\\\\]\", \"\"))\n"
"    if argument == \"\" then argument = nil end\n"
"    local command = sendt.command or \"stor\"\n"
"    -- send the transfer command and check the reply\n"
"    self.try(self.tp:command(command, argument))\n"
"    local code, reply = self.try(self.tp:check{\"2..\", \"1..\"})\n"
"    -- if there is not a a pasvt table, then there is a server\n"
"    -- and we already sent a PORT command\n"
"    if not self.pasvt then self:portconnect() end\n"
"    -- get the sink, source and step for the transfer\n"
"    local step = sendt.step or ltn12.pump.step\n"
"    local readt = {self.tp.c}\n"
"    local checkstep = function(src, snk)\n"
"        -- check status in control connection while downloading\n"
"        local readyt = socket.select(readt, nil, 0)\n"
"        if readyt[tp] then code = self.try(self.tp:check(\"2..\")) end\n"
"        return step(src, snk)\n"
"    end\n"
"    local sink = socket.sink(\"close-when-done\", self.data)\n"
"    -- transfer all data and check error\n"
"    self.try(ltn12.pump.all(sendt.source, sink, checkstep))\n"
"    if string.find(code, \"1..\") then self.try(self.tp:check(\"2..\")) end\n"
"    -- done with data connection\n"
"    self.data:close()\n"
"    -- find out how many bytes were sent\n"
"    local sent = socket.skip(1, self.data:getstats())\n"
"    self.data = nil\n"
"    return sent\n"
"end\n"
"\n"
"function metat.__index:receive(recvt)\n"
"    self.try(self.pasvt or self.server, \"need port or pasv first\")\n"
"    if self.pasvt then self:pasvconnect() end\n"
"    local argument = recvt.argument or\n"
"        url.unescape(string.gsub(recvt.path or \"\", \"^[/\\\\]\", \"\"))\n"
"    if argument == \"\" then argument = nil end\n"
"    local command = recvt.command or \"retr\"\n"
"    self.try(self.tp:command(command, argument))\n"
"    local code = self.try(self.tp:check{\"1..\", \"2..\"})\n"
"    if not self.pasvt then self:portconnect() end\n"
"    local source = socket.source(\"until-closed\", self.data)\n"
"    local step = recvt.step or ltn12.pump.step\n"
"    self.try(ltn12.pump.all(source, recvt.sink, step))\n"
"    if string.find(code, \"1..\") then self.try(self.tp:check(\"2..\")) end\n"
"    self.data:close()\n"
"    self.data = nil\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:cwd(dir)\n"
"    self.try(self.tp:command(\"cwd\", dir))\n"
"    self.try(self.tp:check(250))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:type(type)\n"
"    self.try(self.tp:command(\"type\", type))\n"
"    self.try(self.tp:check(200))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:greet()\n"
"    local code = self.try(self.tp:check{\"1..\", \"2..\"})\n"
"    if string.find(code, \"1..\") then self.try(self.tp:check(\"2..\")) end\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:quit()\n"
"    self.try(self.tp:command(\"quit\"))\n"
"    self.try(self.tp:check(\"2..\"))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:close()\n"
"    if self.data then self.data:close() end\n"
"    if self.server then self.server:close() end\n"
"    return self.tp:close()\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- High level FTP API\n"
"-----------------------------------------------------------------------------\n"
"local function override(t)\n"
"    if t.url then\n"
"        local u = url.parse(t.url)\n"
"        for i,v in base.pairs(t) do\n"
"            u[i] = v\n"
"        end\n"
"        return u\n"
"    else return t end\n"
"end\n"
"\n"
"local function tput(putt)\n"
"    putt = override(putt)\n"
"    socket.try(putt.host, \"missing hostname\")\n"
"    local f = open(putt.host, putt.port, putt.create)\n"
"    f:greet()\n"
"    f:login(putt.user, putt.password)\n"
"    if putt.type then f:type(putt.type) end\n"
"    f:pasv()\n"
"    local sent = f:send(putt)\n"
"    f:quit()\n"
"    f:close()\n"
"    return sent\n"
"end\n"
"\n"
"local default = {\n"
"	path = \"/\",\n"
"	scheme = \"ftp\"\n"
"}\n"
"\n"
"local function parse(u)\n"
"    local t = socket.try(url.parse(u, default))\n"
"    socket.try(t.scheme == \"ftp\", \"wrong scheme '\" .. t.scheme .. \"'\")\n"
"    socket.try(t.host, \"missing hostname\")\n"
"    local pat = \"^type=(.)$\"\n"
"    if t.params then\n"
"        t.type = socket.skip(2, string.find(t.params, pat))\n"
"        socket.try(t.type == \"a\" or t.type == \"i\",\n"
"            \"invalid type '\" .. t.type .. \"'\")\n"
"    end\n"
"    return t\n"
"end\n"
"\n"
"local function sput(u, body)\n"
"    local putt = parse(u)\n"
"    putt.source = ltn12.source.string(body)\n"
"    return tput(putt)\n"
"end\n"
"\n"
"put = socket.protect(function(putt, body)\n"
"    if base.type(putt) == \"string\" then return sput(putt, body)\n"
"    else return tput(putt) end\n"
"end)\n"
"\n"
"local function tget(gett)\n"
"    gett = override(gett)\n"
"    socket.try(gett.host, \"missing hostname\")\n"
"    local f = open(gett.host, gett.port, gett.create)\n"
"    f:greet()\n"
"    f:login(gett.user, gett.password)\n"
"    if gett.type then f:type(gett.type) end\n"
"    f:pasv()\n"
"    f:receive(gett)\n"
"    f:quit()\n"
"    return f:close()\n"
"end\n"
"\n"
"local function sget(u)\n"
"    local gett = parse(u)\n"
"    local t = {}\n"
"    gett.sink = ltn12.sink.table(t)\n"
"    tget(gett)\n"
"    return table.concat(t)\n"
"end\n"
"\n"
"command = socket.protect(function(cmdt)\n"
"    cmdt = override(cmdt)\n"
"    socket.try(cmdt.host, \"missing hostname\")\n"
"    socket.try(cmdt.command, \"missing command\")\n"
"    local f = open(cmdt.host, cmdt.port, cmdt.create)\n"
"    f:greet()\n"
"    f:login(cmdt.user, cmdt.password)\n"
"    f.try(f.tp:command(cmdt.command, cmdt.argument))\n"
"    if cmdt.check then f.try(f.tp:check(cmdt.check)) end\n"
"    f:quit()\n"
"    return f:close()\n"
"end)\n"
"\n"
"get = socket.protect(function(gett)\n"
"    if base.type(gett) == \"string\" then return sget(gett)\n"
"    else return tget(gett) end\n"
"end)\n"
"\n"
"",

"socket.tp","-----------------------------------------------------------------------------\n"
"-- Unified SMTP/FTP subsystem\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: tp.lua,v 1.22 2006/03/14 09:04:15 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local string = require(\"string\")\n"
"local socket = require(\"socket\")\n"
"local ltn12 = require(\"ltn12\")\n"
"module(\"socket.tp\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Program constants\n"
"-----------------------------------------------------------------------------\n"
"TIMEOUT = 60\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Implementation\n"
"-----------------------------------------------------------------------------\n"
"-- gets server reply (works for SMTP and FTP)\n"
"local function get_reply(c)\n"
"    local code, current, sep\n"
"    local line, err = c:receive()\n"
"    local reply = line\n"
"    if err then return nil, err end\n"
"    code, sep = socket.skip(2, string.find(line, \"^(%d%d%d)(.?)\"))\n"
"    if not code then return nil, \"invalid server reply\" end\n"
"    if sep == \"-\" then -- reply is multiline\n"
"        repeat\n"
"            line, err = c:receive()\n"
"            if err then return nil, err end\n"
"            current, sep = socket.skip(2, string.find(line, \"^(%d%d%d)(.?)\"))\n"
"            reply = reply .. \"\\n"
"\" .. line\n"
"        -- reply ends with same code\n"
"        until code == current and sep == \" \"\n"
"    end\n"
"    return code, reply\n"
"end\n"
"\n"
"-- metatable for sock object\n"
"local metat = { __index = {} }\n"
"\n"
"function metat.__index:check(ok)\n"
"    local code, reply = get_reply(self.c)\n"
"    if not code then return nil, reply end\n"
"    if base.type(ok) ~= \"function\" then\n"
"        if base.type(ok) == \"table\" then\n"
"            for i, v in base.ipairs(ok) do\n"
"                if string.find(code, v) then\n"
"                    return base.tonumber(code), reply\n"
"                end\n"
"            end\n"
"            return nil, reply\n"
"        else\n"
"            if string.find(code, ok) then return base.tonumber(code), reply\n"
"            else return nil, reply end\n"
"        end\n"
"    else return ok(base.tonumber(code), reply) end\n"
"end\n"
"\n"
"function metat.__index:command(cmd, arg)\n"
"    if arg then\n"
"        return self.c:send(cmd .. \" \" .. arg.. \"\\r\\n"
"\")\n"
"    else\n"
"        return self.c:send(cmd .. \"\\r\\n"
"\")\n"
"    end\n"
"end\n"
"\n"
"function metat.__index:sink(snk, pat)\n"
"    local chunk, err = c:receive(pat)\n"
"    return snk(chunk, err)\n"
"end\n"
"\n"
"function metat.__index:send(data)\n"
"    return self.c:send(data)\n"
"end\n"
"\n"
"function metat.__index:receive(pat)\n"
"    return self.c:receive(pat)\n"
"end\n"
"\n"
"function metat.__index:getfd()\n"
"    return self.c:getfd()\n"
"end\n"
"\n"
"function metat.__index:dirty()\n"
"    return self.c:dirty()\n"
"end\n"
"\n"
"function metat.__index:getcontrol()\n"
"    return self.c\n"
"end\n"
"\n"
"function metat.__index:source(source, step)\n"
"    local sink = socket.sink(\"keep-open\", self.c)\n"
"    local ret, err = ltn12.pump.all(source, sink, step or ltn12.pump.step)\n"
"    return ret, err\n"
"end\n"
"\n"
"-- closes the underlying c\n"
"function metat.__index:close()\n"
"    self.c:close()\n"
"	return 1\n"
"end\n"
"\n"
"-- connect with server and return c object\n"
"function connect(host, port, timeout, create)\n"
"    local c, e = (create or socket.tcp)()\n"
"    if not c then return nil, e end\n"
"    c:settimeout(timeout or TIMEOUT)\n"
"    local r, e = c:connect(host, port)\n"
"    if not r then\n"
"        c:close()\n"
"        return nil, e\n"
"    end\n"
"    return base.setmetatable({c = c}, metat)\n"
"end\n"
"\n"
"",

"fenestra.widget.file","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"-- a scrolling area, the widget is biger than display area but scroll bars allow you to see it all\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.file\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"	widget.class=\"file\"\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.draw=draw\r\n"
"\r\n"
"-- auto add the draging button as a child\r\n"
"--[[\r\n"
"	local ss=16\r\n"
"	if widget.hx<ss*2 then ss=widget.hx/2 end\r\n"
"	if widget.hy<ss*2 then ss=widget.hy/2 end\r\n"
"	\r\n"
"	widget.pan=		widget:add({class=\"pan\",	hx=widget.hx-ss,	hy=widget.hy-ss,	})\r\n"
"	widget.slidey=	widget:add({class=\"slide\",	hx=ss,				hy=widget.hy-ss,	px=widget.hx-ss,	py=0,\r\n"
"		datx={max=0},daty={max=1},color=0xffffffff})\r\n"
"	widget.slidex=	widget:add({class=\"slide\",	hx=widget.hx-ss,	hy=ss,           	px=0,           	py=widget.hy-ss,\r\n"
"		datx={max=1},daty={max=0},color=0xffffffff})\r\n"
"]]\r\n"
"	return widget\r\n"
"end\r\n"
"",

"wetgenes.www.gae.cache","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local core=require(\"wetgenes.www.gae.cache.core\")\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.cache\"]=_M\n"
"\n"
"function countzero()\n"
"	count=0\n"
"	count_got=0\n"
"	api_time=0\n"
"\n"
"end\n"
"countzero()\n"
"\n"
"local start_time -- handle simple api benchmarking of some calls\n"
"local function apis()\n"
"	start_time=os.time()\n"
"end\n"
"local function apie(...)\n"
"	api_time=api_time+os.time()-start_time\n"
"	return ...\n"
"end\n"
"\n"
"\n"
"function clear(srv)\n"
"	apis()\n"
"	return apie(core.clear())\n"
"\n"
"end\n"
"\n"
"\n"
"function del(srv,id)\n"
"	if srv then srv.cache[id]=nil end\n"
"	apis()\n"
"	return apie(core.del(id))\n"
"\n"
"end\n"
"\n"
"function put(srv,id,tab,ttl)\n"
"	if srv then srv.cache[id]=tab end -- this local cache only lasts as long as a request\n"
"	apis()\n"
"--if( type(tab)~=\"string\" ) then log(type(tab)..\" \"..tostring(tab)) end -- it seems to be only safe to cache strings\n"
"	return apie(core.put(id,tab,ttl))\n"
"\n"
"end\n"
"\n"
"function get(srv,id)\n"
"	if srv and type(srv.cache[id])~=\"nil\" then return srv.cache[id] end -- very fast retry for multiple gets\n"
"	\n"
"	apis()\n"
"	count=count+1\n"
"\n"
"	local r=apie(core.get(id))\n"
"\n"
"	if type(r)~=\"nil\" then count_got=count_got+1 end -- a false is still a good result\n"
"\n"
"	return r\n"
"end\n"
"\n"
"function inc(srv,id,num,start)\n"
"	apis()\n"
"	local r=apie(core.inc(id,num,start))\n"
"	\n"
"	if srv then srv.cache[id]=r end -- so we can fast get it later in this request\n"
"\n"
"	return r\n"
"end\n"
"\n"
"",

"fenestra.test","\r\n"
"\r\n"
"local bit=require('bit')\r\n"
"local gl=require('gl')\r\n"
"\r\n"
"win=require('fenestra.wrap').win()\r\n"
"\r\n"
"\r\n"
"\r\n"
"win.setup(_G) -- create and associate with this global table, eg _G.print gets replaced\r\n"
"\r\n"
"win.width=win.get(\"width\")\r\n"
"win.height=win.get(\"height\")\r\n"
"\r\n"
"\r\n"
"local moddat,t=win.data.load(\"data/objects/xox/aball.xox\")\r\n"
"local xox=win.xox(moddat)\r\n"
"\r\n"
"\r\n"
"local xsx_dat,t=win.data.load(\"data/avatar/xsx/cycle_walk.xsx\")\r\n"
"local xsx=win.xsx(xsx_dat)\r\n"
"local soul=win.avatar.load_soul(\"local/avatar/soul/default.cthulhu.xml\")\r\n"
"\r\n"
"\r\n"
"local items={}\r\n"
"\r\n"
"world=require(\"box2d.wrap\").world({gravity={0,-10}})\r\n"
"\r\n"
"local ground = world.body{}\r\n"
"ground.shape{box={width=64,height=10},density=1,friction=0.3}\r\n"
"ground.set{x=0,y=-24-10,a=0}\r\n"
"\r\n"
"\r\n"
"function new_item(x,y,a)\r\n"
"\r\n"
"	local it={}\r\n"
"\r\n"
"	it.text=\"hello\"\r\n"
"	it.ts=1.6\r\n"
"	it.tc=0xff00ff00\r\n"
"	\r\n"
"	it.tx,it.ty=win.font_debug.size(it.text,it.ts)\r\n"
"	\r\n"
"	it.tx=-(it.tx/2)\r\n"
"	it.ty= (it.ty/2)\r\n"
"\r\n"
"	it.body=world.body{}\r\n"
"	it.body.shape{box={width=-it.tx,height=it.ty,center={0,0}},density=1,friction=0.3,restitution=0.25}\r\n"
"	it.body.set{mass=\"shapes\",x=x,y=y,a=a} -- calculate from shapes\r\n"
"	\r\n"
"	return it\r\n"
"end\r\n"
"\r\n"
"table.insert(items, new_item(0,10,0) )\r\n"
"\r\n"
"\r\n"
"function win.mouse(act,x,y,key)\r\n"
"\r\n"
"\r\n"
"	local hx=win.width/2\r\n"
"	local hy=win.height/2\r\n"
"\r\n"
"	local tx,ty\r\n"
"	\r\n"
"	if win.height/(win.width or 1) > (3/4) then -- deal with new viewport sizeing\r\n"
"	\r\n"
"		tx=(4/3)*(x-hx)/hx\r\n"
"		ty=(4/3)*(hy-y)/hx\r\n"
"		\r\n"
"	else\r\n"
"	\r\n"
"		tx=(x-hx)/hy\r\n"
"		ty=(hy-y)/hy\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"		\r\n"
"	win.widget.mouse(win.widget,act,320+tx*240,240+ty*240,key)\r\n"
"\r\n"
"	if act==\"down\" then\r\n"
"	\r\n"
"\r\n"
"		table.insert(items, new_item(tx*24,ty*24,0) )\r\n"
"	\r\n"
"	end\r\n"
"\r\n"
"end\r\n"
"	\r\n"
"--print(xsx)\r\n"
"--	xsx.set(t)\r\n"
"\r\n"
"	win.avatar.map_xsx(xsx,soul)\r\n"
"\r\n"
"\r\n"
"function modl(name)\r\n"
"\r\n"
"	moddat,t=win.data.load(\"data/avatar/xox/\"..name..\".xox\")\r\n"
"	\r\n"
"	if moddat then\r\n"
"	\r\n"
"		xox.clean()\r\n"
"		xox=win.xox(moddat)\r\n"
"		\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"local rx,ry,rz=0,0,0\r\n"
"local frame=0\r\n"
"\r\n"
"local last=win.time()\r\n"
"local frame_last=last\r\n"
"local frame_count=0\r\n"
"local fps=0\r\n"
"\r\n"
"local times={}\r\n"
"\r\n"
"local function times_setup()\r\n"
"	local t={}\r\n"
"	t.time=0\r\n"
"	t.time_live=0\r\n"
"	\r\n"
"	t.hash=0\r\n"
"	t.hash_live=0\r\n"
"	\r\n"
"	t.started=0\r\n"
"	\r\n"
"	function t.start()\r\n"
"		t.started=win.time()\r\n"
"	end\r\n"
"	\r\n"
"	function t.stop()\r\n"
"		local ended=win.time()\r\n"
"		\r\n"
"		t.time_live=t.time_live + ended-t.started\r\n"
"		t.hash_live=t.hash_live + 1\r\n"
"	end\r\n"
"	\r\n"
"	function t.done()\r\n"
"		t.time=t.time_live\r\n"
"		t.hash=t.hash_live\r\n"
"		t.time_live=0\r\n"
"		t.hash_live=0\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	return t\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"times.update=times_setup()\r\n"
"times.draw=times_setup()\r\n"
"times.swap=times_setup()\r\n"
"\r\n"
"win.update=function()\r\n"
"\r\n"
"	win.width=win.get(\"width\")\r\n"
"	win.height=win.get(\"height\")\r\n"
"	\r\n"
"	\r\n"
"	local t=win.time()\r\n"
"	local d=t-last\r\n"
"	local d_orig=d\r\n"
"\r\n"
"-- count frames	\r\n"
"	if t-frame_last >= 1 then\r\n"
"	\r\n"
"		fps=frame_count\r\n"
"		frame_count=0\r\n"
"		frame_last=t\r\n"
"	\r\n"
"		times.update.done()\r\n"
"		times.draw.done()\r\n"
"		times.swap.done()\r\n"
"	end\r\n"
"	\r\n"
"-- update\r\n"
"\r\n"
"	local do_draw=false\r\n"
"	while d >= 0.020 do\r\n"
"	\r\n"
"		times.update.start()\r\n"
"		\r\n"
"		world.step(1/50,2)\r\n"
"		\r\n"
"		rx=(rx+1)%360\r\n"
"		ry=(ry+1)%360\r\n"
"		rz=(rz+1)%360\r\n"
"		\r\n"
"		frame=(frame+0.020)\r\n"
"		if frame>xsx.length then frame=frame-xsx.length end \r\n"
"		\r\n"
"		win.widget:update()\r\n"
"		\r\n"
"		win.console.update()\r\n"
"		\r\n"
"		times.update.stop()\r\n"
"		\r\n"
"		if d>1 then -- reset when very out of sync\r\n"
"			last=t\r\n"
"			d=0\r\n"
"		else\r\n"
"			last=last+0.020\r\n"
"			d=d-0.020\r\n"
"		end\r\n"
"		\r\n"
"		do_draw=true\r\n"
"	end\r\n"
"\r\n"
"-- draw\r\n"
"\r\n"
"\r\n"
"	if do_draw then\r\n"
"\r\n"
"		times.draw.start()\r\n"
"		win.begin()\r\n"
"		\r\n"
"		gl.MatrixMode(\"MODELVIEW\")\r\n"
"		gl.LoadIdentity()\r\n"
"		\r\n"
"\r\n"
"		\r\n"
"\r\n"
"--		for x=-10,10,10 do\r\n"
"--			for y=-10,10,10 do\r\n"
"\r\n"
"		local x,y=0,0\r\n"
"			\r\n"
"				gl.PushMatrix()\r\n"
"				\r\n"
"				gl.Translate(x/2,y/2, 0)\r\n"
"				\r\n"
"		gl.Translate(0,0, -32)\r\n"
"		gl.Scale(8,8,8)\r\n"
"		gl.Rotate(rz,0,0,1);\r\n"
"		gl.Rotate(ry,0,1,0);\r\n"
"		gl.Rotate(rx,1,0,0);\r\n"
"		\r\n"
"--				win.draw_cube(0.5)\r\n"
"--				xox.draw()\r\n"
"				xsx.draw(frame);\r\n"
"				\r\n"
"				gl.PopMatrix()\r\n"
"				\r\n"
"--			end\r\n"
"--		end\r\n"
"\r\n"
"\r\n"
"		for i,v in ipairs(items) do\r\n"
"		\r\n"
"			\r\n"
"			v.body.get()\r\n"
"			gl.PushMatrix()\r\n"
"			\r\n"
"			gl.Translate(v.body.x,v.body.y, -24)\r\n"
"			gl.Rotate(v.body.a,0,0,1);\r\n"
"--[[\r\n"
"			gl.Rotate(90,0,1,0);\r\n"
"			xsx.draw(frame);\r\n"
"			gl.Rotate(-90,0,1,0);\r\n"
"]]			\r\n"
"			win.font_debug.set(v.tx,v.ty,v.tc,v.ts)\r\n"
"			win.font_debug.draw(v.text)\r\n"
"\r\n"
"		\r\n"
"			gl.PopMatrix()\r\n"
"		end\r\n"
"		\r\n"
"		\r\n"
"		gl.PushMatrix()\r\n"
"		gl.Translate(-320,-240, -240*1.0)\r\n"
"		win.widget:draw()\r\n"
"		gl.PopMatrix()\r\n"
"		\r\n"
"		win.console.draw()\r\n"
"		\r\n"
"--		win.debug_rect(0,0,640,480,0x44000000)\r\n"
"	\r\n"
"		win.swap()\r\n"
"		times.draw.stop()\r\n"
"		\r\n"
"		frame_count=frame_count+1\r\n"
"		\r\n"
"		local gci=gcinfo()\r\n"
"		win.console.display(string.format(\"fps=%02.0f t=%03.0f u=%03.0f d=%03.0f gc=%0.0fk\",fps,math.floor(0.5+(10000/fps)),math.floor(0.5+times.update.time*10000),math.floor(0.5+times.draw.time*10000/times.draw.hash),math.floor(gci) ))\r\n"
"		\r\n"
"	end\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"while win.msg(\"wait\") do\r\n"
"\r\n"
"	win.update()\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"win.clean()\r\n"
"\r\n"
"",

"app","-- This file exists to flag the basedir of the INSERTFILENAMEHERE app\n"
"-- it may also contain some lua code that should be run\n"
"\n"
"\n"
"local function start_func(arg1)\n"
"\n"
"\n"
"local wetquire=require(\"wetquire\")\n"
"wetquire.overload() -- replace require and module\n"
"\n"
"--\n"
"-- Wet test main start code\n"
"--\n"
"-- arg[...] is set to the commandline as this program is invoked\n"
"--\n"
"-- need to setup windows etc and run whatever app or state is requested\n"
"--\n"
"-- print will also output to the debug console under windows as no console may be available\n"
"--\n"
"\n"
"print(\"start\\n"
"\")\n"
"\n"
"main_next=main_next or arg1\n"
"\n"
"print( \"next->\" .. (main_next or \"\") ) -- start state\n"
"\n"
"--[[\n"
"print( arg[1] or \"\" ) -- app\n"
"print( arg[2] or \"\" ) -- state\n"
"print( arg[3] or \"\" ) -- command\n"
"print( arg[4] or \"\" ) -- hwnd\n"
"]]\n"
"\n"
"--print( main.test() or \"\" )\n"
"\n"
"\n"
"\n"
"--lanes=require(\"lanes\")\n"
"\n"
"local f=function()\n"
"\n"
"-- special datas for state to use...\n"
"\n"
"wet_setup_comandline=nil--arg[3]\n"
"wet_setup_hwnd=nil--arg[4]\n"
"\n"
"	local f=loadfile(apps.dir..\"lua/state/init.lua\")\n"
"	f(\"state\")\n"
"	\n"
"end\n"
"\n"
"--[[\n"
"\n"
"thread={}\n"
"	thread.linda=lanes.linda()\n"
"	thread.worker=lanes.gen(\"*\",{[\"globals\"]={\n"
"		arg=arg,\n"
"		oldmain=main,\n"
"		main_next=main_next,\n"
"		apps=apps\n"
"	}},f)(thread.linda,1)\n"
"\n"
"-- wait for thread? not if this is running under moz...\n"
"--	if not arg[2] then \n"
"		local t=thread.worker[1]\n"
"--	end\n"
"	\n"
"\n"
"-- no lanes?\n"
"--]]\n"
"\n"
"f()\n"
"\n"
"\n"
"\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"module(...)\n"
"\n"
"start=start_func\n"
"\n"
"\n"
"",

"wetgenes.www.ngx.users","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.users\"]=_M\n"
"\n"
"function login_url(a)\n"
"\n"
"	log(\"users.login_url:\")\n"
"--	return core.login_url(a)\n"
"\n"
"end\n"
"\n"
"\n"
"function logout_url(a)\n"
"\n"
"	log(\"users.logout_url:\")\n"
"--	return core.logout_url(a)\n"
"\n"
"end\n"
"\n"
"function get_google_user()\n"
"\n"
"	log(\"users.get_google_user:\")\n"
"--	return core.get_google_user()\n"
"\n"
"end\n"
"",

"wetgenes.www.sqlite.data","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"\n"
"local sql=require(\"sqlite\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"local wsql=require(\"wetgenes.www.sqlite\")\n"
"\n"
"local json=require(\"wetgenes.json\")\n"
"\n"
"local fixvalue=wsql.fixvalue\n"
"\n"
"module(...)\n"
"local wdata=require(...) -- this is us\n"
"package.loaded[\"wetgenes.www.any.data\"]=wdata\n"
"\n"
"local cache=require(\"wetgenes.www.any.cache\")\n"
"local wdatadef=require(\"wetgenes.www.any.datadef\")\n"
"\n"
"\n"
"function countzero()\n"
"	count=0\n"
"	api_time=0\n"
"end\n"
"countzero()\n"
"\n"
"local kind_props={}	-- default global props mapped to kinds\n"
"\n"
"local start_time -- handle simple api benchmarking of some calls\n"
"local function apis()\n"
"	start_time=os.time()\n"
"end\n"
"local function apie(...)\n"
"	api_time=api_time+os.time()-start_time\n"
"	return ...\n"
"end\n"
"\n"
"\n"
"local function fixkind(kind) return kind:gsub(\"%p\",\"_\") end\n"
"\n"
"-- can over ride this function to open dbs from other places\n"
"function getdb(kind)\n"
"\n"
"local prefix=\"sqlite/\"\n"
"local postfix=\".sqlite\"\n"
"\n"
"-- at this point we can choose to return a single database no matter what the kind\n"
"-- or open a seperate one for each kind which might make more sense\n"
"\n"
"--	db=wsql.open(wsql.dbs,prefix,fixkind(kind),postfix)\n"
"\n"
"	db=wsql.open(wsql.dbs,prefix,\"data\",postfix)\n"
"	return db\n"
"end\n"
"\n"
"function keyinfo(keystr)\n"
"	local t=wstr.split(keystr,\"/\")	\n"
"	return {kind=t[1],id=tonumber(t[2]) or t[2] }\n"
"end\n"
"\n"
"function keystr(kind,id,parent)\n"
"	return kind..\"/\"..id\n"
"end\n"
"\n"
"\n"
"\n"
"function del(ent,t)\n"
"	local kind=fixkind(ent and ent.key and ent.key.kind)\n"
"	local id=ent and ent.key and ent.key.id\n"
"	local ret\n"
"--	log(wstr.serialize(ent))\n"
"	log(\"data.del:\",kind)\n"
"	apis()\n"
"	\n"
"	count=count+0.5\n"
"	\n"
"	local db=getdb(kind)\n"
"\n"
"	local s\n"
"	if type(id)==\"number\" then\n"
"		s=\"DELETE FROM \"..kind..\" WHERE ROWID=\"..fixvalue(id)..\";\"\n"
"	else\n"
"		s=\"DELETE FROM \"..kind..\" WHERE id=\"..fixvalue(id)..\";\"\n"
"	end\n"
"log(s)\n"
"	ret=wsql.exec(db,s)\n"
"	apie()\n"
"	return true\n"
"end\n"
"\n"
"function put(ent,t)\n"
"	local kind=fixkind(ent and ent.key and ent.key.kind)\n"
"	local id=ent and ent.key and ent.key.id\n"
"	local ret\n"
"--	log(wstr.serialize(ent))\n"
"	log(\"data.put:\",kind)\n"
"	apis()\n"
"	count=count+0.5\n"
"\n"
"	local db=getdb(kind)\n"
"	\n"
"	local s=wsql.make_replace(kind,ent.props)\n"
"	\n"
"log(s)\n"
"	ret=wsql.exec(db,s)\n"
"	id=id or db:last_insert_rowid() -- get the new id, unless we forced it\n"
"	\n"
"	ent.key.id=id -- fix id\n"
"	ent.cache.id=id -- fix id\n"
"	\n"
"	apie()\n"
"	return keystr(kind,id)\n"
"end\n"
"\n"
"function get(ent,t)\n"
"	local kind=fixkind(ent and ent.key and ent.key.kind)\n"
"	local id=ent and ent.key and ent.key.id\n"
"	local ret\n"
"--	log(wstr.serialize(ent))\n"
"	log(\"data.get:\",kind)\n"
"	apis()\n"
"	count=count+0.5\n"
"\n"
"	local db=getdb(kind)\n"
"\n"
"	local s\n"
"	if type(id)==\"number\" then\n"
"		s=\"SELECT * FROM \"..kind..\" WHERE ROWID=\"..fixvalue(id)..\";\"\n"
"	else\n"
"		s=\"SELECT * FROM \"..kind..\" WHERE id=\"..fixvalue(id)..\";\"\n"
"	end\n"
"\n"
"log(s)\n"
"	ent.props=wsql.row(db,s)\n"
"	\n"
"if ent.props then\n"
"--	log(wstr.serialize(ent.props))\n"
"end\n"
"\n"
"	apie()\n"
"	return ent.props and ent\n"
"end\n"
"\n"
"function query(q)\n"
"	local kind=fixkind(q and q.kind)\n"
"	local ret\n"
"	log(\"data.query:\")\n"
"	apis()\n"
"	count=count+1\n"
"--log(tostring(q))	\n"
"\n"
"	local db=getdb(kind)\n"
"\n"
"	apie()\n"
"	return {list={}}\n"
"end\n"
"\n"
"function rollback(t)\n"
"end\n"
"function commit(t)\n"
"	return true\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- Begin a transaction, use the functions inside the returned table\n"
"-- to perform actions within this transaction\n"
"--\n"
"-- the basic code flow is that you should begin one transaction per entity(parent)\n"
"-- and then rollback all when one fails. the first del/put/get locks the entity\n"
"-- we are dealing with in this transaction\n"
"--\n"
"-- after the t.fail flag gets set on a put/del then everything apart from rollback just returns nil\n"
"-- and commit is turned into an auto rollback\n"
"--\n"
"-- so this is OK transaction code, just remember that puts may not auto generate a key\n"
"-- and there may be other reasons for fails\n"
"--\n"
"-- for _=1,10 do -- try a few times\n"
"--     t=begin()\n"
"--     if t.get(e) then e.props.data=e.props.data..\"new data\" end\n"
"--     t.put(e)\n"
"--     if t.commit() then break end -- success\n"
"-- end\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function begin()\n"
"	log(\"data.begin:\")\n"
"\n"
"	local t={}\n"
"--	t.core=core.begin()\n"
"	\n"
"	t.fail=false -- this will be set to true when a transaction action fails and you should rollback and retry\n"
"	t.done=false -- set to true on commit or rollback to disable all methods\n"
"	\n"
" -- these methods are the same as the global ones but operate on this transaction\n"
" 	t.del=function(ent)	if t.fail or t.done then return nil end return del(ent,t) end\n"
"	t.put=function(ent)	if t.fail or t.done then return nil end return put(ent,t) end\n"
"	t.get=function(ent)	if t.fail or t.done then return nil end return get(ent,t) end\n"
"	t.query=function(q)	if t.fail or t.done then return nil end return query(q,t) end\n"
"	\n"
"	t.rollback=function() -- returns false to imply that nothing was commited\n"
"		if t.done then return false end -- safe to rollback repeatedly\n"
"		t.done=true\n"
"		t.fail=not rollback(t) -- we always set fail and return false\n"
"		return not t.fail\n"
"	end	\n"
"	\n"
"	t.commit=function() -- returns true if commited, false if not\n"
"		if t.done then return false end -- safe to rollback repeatedly\n"
"		if t.fail then -- rollback rather than commit\n"
"			return rollback(t)\n"
"		end\n"
"		t.done=true\n"
"		apis()\n"
"		t.fail=not commit(t)\n"
"		return not t.fail\n"
"	end\n"
"\n"
"	return t\n"
"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- build cache which is a mixture of decoded json vars (this may contain sub tables)\n"
"-- overiden by database props which do not contain tables but are mildly searchable\n"
"-- props.json should contain this json data string on input\n"
"-- cache will be a filled in table to be used instead of props\n"
"--\n"
"-- Not sure if this is more compact than just creating many real key/value pairs\n"
"-- but it feels like a better way to organize. :)\n"
"--\n"
"-- At least it is a bit more implicit about what can and cannot be searched for.\n"
"--\n"
"-- the idea is everything we need is copied into the cache, you can edit it there\n"
"-- and then build_props will do the reverse in preperation for a put\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function build_cache(e)\n"
"\n"
"	if e.props.json then -- expand the json data\n"
"	\n"
"		e.cache=json.decode(e.props.json)\n"
"		\n"
"	else\n"
"	\n"
"		e.cache={}\n"
"	\n"
"	end\n"
"\n"
"	for i,v in pairs(e.props) do -- override cache by props\n"
"		e.cache[i]=v\n"
"	end\n"
"	\n"
"	e.cache.json=nil -- not the json prop\n"
"	\n"
"	if e.key then -- copy the key data\n"
"		e.cache.parent=e.key.parent\n"
"		e.cache.kind=e.key.kind\n"
"		e.cache.id=e.props.id or e.key.id -- use string or ROWID?\n"
"	end\n"
"	\n"
"	return e\n"
"\n"
"end\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- a simplistic reverse of build cache\n"
"-- any props of the same name will get updated from this cache\n"
"-- rather than encoded into props.json\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function build_props(e)\n"
"\n"
"	local t={}\n"
"	local ignore={kind=true,id=true,parent=true,json=true,} -- special names to ignore\n"
"	\n"
"	for i,v in pairs(e.cache) do\n"
"		if ignore[i] then -- ignore these special names\n"
"		elseif e.props[i] then\n"
"			e.props[i]=v -- if it exists as a prop then the prop is updated\n"
"		else\n"
"			t[i]=v -- else it just goes into the json prop\n"
"		end\n"
"	end\n"
"	e.props.json=json.encode(t)\n"
"\n"
"	if e.key.id then\n"
"		if type(e.key.id)==\"number\" then\n"
"			e.props.ROWID=e.key.id -- use number id from key\n"
"		else\n"
"			e.props.id=e.key.id -- use string id from key\n"
"		end\n"
"	end\n"
"	\n"
"	return e\n"
"	\n"
"end\n"
"\n"
"\n"
"function set_defs(env)\n"
"	return wdatadef.set_defs(env)\n"
"end\n"
"\n"
"\n"
"function setup_db(env,srv)\n"
"\n"
"-- make sure database exists and is setup\n"
"\n"
"	local kind=env.kind()\n"
"\n"
"	log(\"data.setup_db:\",kind)\n"
"\n"
"\n"
"	local db=getdb(kind)\n"
"\n"
"-- all data has these fields	\n"
"	local info={\n"
"		{name=\"id\",TEXT=true,UNIQUE=true},\n"
"		{name=\"created\",REAL=true},\n"
"		{name=\"updated\",REAL=true},\n"
"		{name=\"json\",TEXT=true},\n"
"	}\n"
"	\n"
"--check if is already added\n"
"	local function in_table(tab,name)\n"
"		for i,v in ipairs(tab) do\n"
"			if v.name==name then return true end\n"
"		end\n"
"	end\n"
"	\n"
"		\n"
"	for n,v in pairs(env.default_props) do\n"
"		if not in_table(info,n) then -- add to table, simple check for dupes just in case.\n"
"			local t={name=n}\n"
"			local tp=type(v)\n"
"			if tp==\"number\" then -- only have numbers or strings and numbers are real\n"
"				t.REAL=true\n"
"			else\n"
"				t.TEXT=true\n"
"			end\n"
"			info[#info+1]=t\n"
"		end\n"
"	end\n"
"	\n"
"\n"
"-- check or update database\n"
"	wsql.set_info(db,kind,info)\n"
"	\n"
"end\n"
"",

"wetgenes.www.any.img","if ngx then\r	return require(\"wetgenes.www.ngx.img\")\relse\r	return require(\"wetgenes.www.gae.img\")\rend\r",

"wetgenes.www.any.datadef","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"local json=require(\"wetgenes.json\")\n"
"\n"
"\n"
"module(\"wetgenes.www.any.datadef\")\n"
"\n"
"local wdata=require(\"wetgenes.www.any.data\")\n"
"local cache=require(\"wetgenes.www.any.cache\")\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- Create a new local entity filled with initial data\n"
"-- the id can be and often is nil\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_create(env,srv,id)\n"
"\n"
"	local ent={}\n"
"	\n"
"	ent.key={kind=env.kind(srv),id=id,notsaved=true} -- we will not know the key id until after we save\n"
"	ent.props={}\n"
"	\n"
"	local p=ent.props\n"
"	\n"
"	p.created=(srv and srv.time) or os.time()\n"
"	p.updated=(srv and srv.time) or p.created\n"
"	\n"
"	for i,v in pairs(env.default_props or {}) do\n"
"		p[i]=v\n"
"	end\n"
"\n"
"	wdata.build_cache(ent) -- this just copies the props across\n"
"	\n"
"-- these are json only vars\n"
"	local c=ent.cache\n"
"	\n"
"	for i,v in pairs(env.default_cache or {}) do\n"
"		c[i]=v\n"
"	end\n"
"\n"
"	return env.check(srv,ent)\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- Save to database\n"
"-- this calls check before putting and does not put if check says it is invalid\n"
"-- build_props is called so code should always be updating the cache values\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_put(env,srv,ent,tt)\n"
"	t=tt or wdata -- use transaction?\n"
"\n"
"	if not env.check(srv,ent) then return nil end -- check that this is valid to put\n"
"\n"
"	wdata.build_props(ent)\n"
"	local ks=t.put(ent)\n"
"	\n"
"	if ks then\n"
"		ent.key=wdata.keyinfo( ks ) -- update key with new id\n"
"		wdata.build_cache(ent)\n"
"		\n"
"		if not tt then env.cache_fix(srv,env.cache_what(srv,ent)) end -- destroy any cache if not in transaction\n"
"	end\n"
"\n"
"	return ks -- return the keystring which is an absolute name\n"
"end\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- Load from database, pass in id or entity\n"
"-- the props will be copied into the cache\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_get(env,srv,id,tt)\n"
"\n"
"	local ent=id\n"
"	\n"
"	if type(ent)~=\"table\" then -- get by id\n"
"		ent=env.create(srv)\n"
"		ent.key.id=id\n"
"	end\n"
"	\n"
"	local ck=env.cache_key(srv,ent.key.id)\n"
"	if not tt and ck then -- can try for cached value outside of transactions\n"
"		local ent=cache.get(srv,ck)\n"
"		if ent then return env.check(srv,json.decode(ent)) end -- Yay, we got a cached value\n"
"	end\n"
"	\n"
"	local t=tt or wdata -- use transaction?\n"
"	\n"
"	if not t.get(ent) then\n"
"		if not tt and ck then -- kill auto cache\n"
"			cache.del(srv,ck)\n"
"		end\n"
"		return nil\n"
"	end\n"
"	\n"
"	wdata.build_cache(ent)\n"
"	\n"
"	if not tt and ck then -- auto cache ent for one hour\n"
"		cache.put(srv,ck,json.encode(ent),60*60)\n"
"	end\n"
"	\n"
"	return env.check(srv,ent)\n"
"end\n"
"\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- get - update - put\n"
"--\n"
"-- f must be a function that changes the entity and returns true on success\n"
"-- id can be an id or an entity from which we will get the id\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_update(env,srv,id,f)\n"
"\n"
"	if type(id)==\"table\" then id=id.key.id end -- can turn an entity into an id\n"
"		\n"
"	for retry=1,10 do\n"
"		local mc={}\n"
"		local t=wdata.begin()\n"
"		local e=env.get(srv,id,t) -- must exist\n"
"		if e then\n"
"			env.cache_what(srv,e,mc) -- the original values\n"
"			if not e.key.notsaved then -- not a newly created entity\n"
"				if e.cache.updated>srv.time then -- stop any updates that time travel backwards\n"
"					t.rollback()\n"
"					log(\"DATA UPDATE FAILED TIMETRAVEL:\"..env.kind(srv)..\":\"..id)\n"
"					return false\n"
"				end\n"
"			end\n"
"			e.cache.updated=srv.time -- the function can change this change if it wishes\n"
"			if not f(srv,e) then -- hard fail\n"
"				t.rollback()\n"
"				log(\"DATA UPDATE FAILED FUNCTION:\"..env.kind(srv)..\":\"..id)\n"
"				return false\n"
"			end\n"
"			env.check(srv,e) -- keep consistant\n"
"			if env.put(srv,e,t) then -- entity put ok\n"
"				if t.commit() then -- success\n"
"					env.cache_what(srv,e,mc) -- the new values\n"
"					env.cache_fix(srv,mc) -- change any memcached values we just adjusted\n"
"					return e -- return the adjusted entity\n"
"				end\n"
"			end\n"
"		else\n"
"			t.rollback()\n"
"			log(\"DATA UPDATE FAILED MISSING:\"..env.kind(srv)..\":\"..id)\n"
"			return false\n"
"		end\n"
"		t.rollback() -- undo everything ready to try again\n"
"	end\n"
"	log(\"DATA UPDATE FAILED:\"..env.kind(srv)..\":\"..id)\n"
"end\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- this is like update, except entity will manifest if it does not exist\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_set(env,srv,id,f)\n"
"\n"
"	if type(id)==\"table\" then id=id.key.id end -- can turn an entity into an id\n"
"\n"
"	for retry=1,10 do\n"
"		local mc={}\n"
"		local t=wdata.begin()\n"
"		local e=env.get(srv,id,t) -- may or may not exist\n"
"		if not e then -- manifest\n"
"			e=env.create(srv,id)\n"
"		end\n"
"\n"
"		env.cache_what(srv,e,mc) -- the original values\n"
"		if not e.key.notsaved then -- not a newly created entity\n"
"			if e.cache.updated>srv.time then -- stop any updates that time travel backwards\n"
"				t.rollback()\n"
"				log(\"DATA SET FAILED TIMETRAVEL:\"..env.kind(srv)..\":\"..id)\n"
"				return false\n"
"			end\n"
"		end\n"
"		e.cache.updated=srv.time -- the function can change this change if it wishes\n"
"		if not f(srv,e) then -- hard fail\n"
"			t.rollback()\n"
"			log(\"DATA SET FAILED FUNCTION:\"..env.kind(srv)..\":\"..id)\n"
"			return false\n"
"		end\n"
"		env.check(srv,e) -- keep consistant\n"
"		if env.put(srv,e,t) then -- entity put ok\n"
"			if t.commit() then -- success\n"
"				env.cache_what(srv,e,mc) -- the new values\n"
"				env.cache_fix(srv,mc) -- change any memcached values we just adjusted\n"
"				return e -- return the adjusted entity\n"
"			end\n"
"		end\n"
"		t.rollback() -- undo everything ready to try again\n"
"	end\n"
"	log(\"DATA SET FAILED:\"..env.kind(srv)..\":\"..id)\n"
"	return false\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- get or create but does not put\n"
"--\n"
"-- use the check function to fill with any special defaults\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_manifest(env,srv,id)\n"
"\n"
"	if type(id)==\"table\" then id=id.key.id end -- can turn an entity into an id\n"
"\n"
"	local e=env.get(srv,id) -- may or may not exist\n"
"\n"
"	if e then\n"
"		return e\n"
"	else\n"
"		e=env.create(srv,id)\n"
"		return e\n"
"	end\n"
"	\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- what key name should we use to cache an entity?\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_cache_key(env,srv,id)\n"
"	if type(id)==\"table\" then id=id.key.id end -- can turn an entity into an id\n"
"	return \"ent=\"..env.kind(srv)..\"&id=\"..id\n"
"end\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- given an entity return or update a list of memcache keys we should recalculate\n"
"-- this list is a name->bool lookup\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_cache_what(env,srv,ent,mc)\n"
"	local mc=mc or {} -- can supply your own result table for merges	\n"
"	\n"
"	local ck=env.cache_key(srv,ent.key.id)\n"
"	if ck then\n"
"		mc[ ck ] = true\n"
"	end\n"
"	return mc\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- fix the memcache items previously produced by what_memcache\n"
"-- probably best just to delete them so they will automatically get rebuilt\n"
"-- but we could do more complicated things\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_cache_fix(env,srv,mc)\n"
"	for n,b in pairs(mc) do\n"
"		cache.del(srv,n)\n"
"	end\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- set these default functions into the given environment\n"
"-- these are functions that handle basic data management\n"
"--\n"
"-- you must also provide\n"
"--\n"
"-- a kind function\n"
"-- a check function\n"
"-- a table of default cache values\n"
"-- a table of default props values\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function set_defs(env)\n"
"\n"
"	env.create     = function(srv,id)     return def_create(env,srv,id)         end\n"
"	env.manifest   = function(srv,id)     return def_manifest(env,srv,id)       end\n"
"	env.put        = function(srv,ent,t)  return def_put(env,srv,ent,t)         end\n"
"	env.get        = function(srv,id,t)   return def_get(env,srv,id,t)          end\n"
"	env.set        = function(srv,id,f)   return def_set(env,srv,id,f)	 	    end\n"
"	env.update     = function(srv,id,f)   return def_update(env,srv,id,f)       end\n"
"	env.cache_key  = function(srv,id)     return def_cache_key(env,srv,id)      end\n"
"	env.cache_what = function(srv,ent,mc) return def_cache_what(env,srv,ent,mc) end\n"
"	env.cache_fix  = function(srv,mc)     return def_cache_fix(env,srv,mc)      end\n"
"\n"
"	return env\n"
"end\n"
"\n"
"",

"wetgenes.www.ngx.log","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local ngx=require(\"ngx\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.log\"]=_M\n"
"\n"
"\n"
"function log(...)\n"
"\n"
"-- only error seems to work?\n"
"\n"
"	if (...) then\n"
"		return ngx.log(ngx.NOTICE,...)\n"
"	end\n"
"--	return core.log(a,b)\n"
"\n"
"end\n"
"",

"wetgenes.www.any.sys","if ngx then\r	return require(\"wetgenes.www.ngx.sys\")\relse\r	return require(\"wetgenes.www.gae.sys\")\rend\r",

"wetgenes.www.any","\rmodule(...)\r",

"wetgenes.www.any.iplog","\n"
"-- manage simple rate limiting by ip, this will stop run away scripts from taking the piss\n"
"-- these structures are stored only in memcache so are very fuzzy/lazy and not to be trusted\n"
"-- but should mostly work, for now this is just rate limiting but a callback to handle extras\n"
"-- will be added when I work out what these extras might be\n"
"\n"
"local cache=require(\"wetgenes.www.any.cache\")\n"
"local json=require(\"wetgenes.json\")\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log -- grab the func from the package\n"
"\n"
"\n"
"local tostring=tostring\n"
"local math=math\n"
"local os=os\n"
"\n"
"module(\"wetgenes.www.any.iplog\")\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- turn a time in seconds into\n"
"--\n"
"-- time in : minutes , hours , days\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function get_mhd(s)\n"
"	return math.floor(s/(60)) , math.floor(s/(60*60)) , math.floor(s/(60*60*24))\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- Create a new struct\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function create(ip)\n"
"	local it={}\n"
"	it.ip=ip\n"
"	it.mhd=	{ -- arrays for simple json tables\n"
"				{0,0,0}, -- count : minutes , hours , days\n"
"				{get_mhd(os.time())}, -- stamps : minutes , hours , days\n"
"			}\n"
"	return check(it)\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- check data structure, count zero any old data as it goes out of date\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function check(it)\n"
"	local mhd={get_mhd(os.time())}\n"
"	if it.mhd[2][1]~=mhd[1] then it.mhd[1][1]=0 it.mhd[2][1]=mhd[1] end\n"
"	if it.mhd[2][2]~=mhd[2] then it.mhd[1][2]=0 it.mhd[2][2]=mhd[2] end\n"
"	if it.mhd[2][3]~=mhd[3] then it.mhd[1][3]=0 it.mhd[2][3]=mhd[3] end\n"
"	return it\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- get or create if doesnt exist\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function manifest(ip)\n"
"	return get(ip) or create(ip)\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- get by ip\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function get(ip)\n"
"	local d=cache.get(nil,\"iplog=\"..ip)\n"
"	if d then\n"
"		return check(json.decode(d))\n"
"	end\n"
"	return nil\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- put\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function put(it)\n"
"	cache.put(nil,\"iplog=\"..it.ip , json.encode(it) , 60*60*24 )\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- increment the current use by one\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function inc(it)\n"
"	it.mhd[1][1]=it.mhd[1][1]+1\n"
"	it.mhd[1][2]=it.mhd[1][2]+1\n"
"	it.mhd[1][3]=it.mhd[1][3]+1\n"
"	return it\n"
"end\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- this is the main ratelimit function you want, given an IP (string) mark up another access\n"
"-- and decide if we should bail on the request at this point, returns true if\n"
"-- it is ok to procede false if it isnt. The iplog structure is also in its second\n"
"-- return value for later inspection.\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function ratelimit(ip)\n"
"	local it=manifest(ip)\n"
"	inc(it)\n"
"	put(it) -- we do not care about overwrites, numbers are fuzzy\n"
"	if it.admin then return true,it end -- admin flag means it is always ok\n"
"	if it.mhd[1][1] > 100   then return false,it end -- max requests per minute\n"
"	if it.mhd[1][2] > 1000  then return false,it end -- max requests per hour\n"
"	if it.mhd[1][3] > 10000 then return false,it end -- max requests per day\n"
"	return true,it\n"
"end\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- mark this ip as admin so it is never rate limited\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function mark_as_admin(ip)\n"
"	local it=manifest(ip)\n"
"	if not it.admin then -- switch on flag\n"
"		it.admin=true\n"
"		put(it) -- we do not care about overwrites, numbers are fuzzy\n"
"	end\n"
"end\n"
"",

"wetgenes.www.any.opts","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local dat=require(\"wetgenes.www.any.data\")\n"
"local cache=require(\"wetgenes.www.any.cache\")\n"
"\n"
"\n"
"-- a place to keep options such as passwords that\n"
"-- the server needs to know about but are different per app\n"
"-- and obviously should not be included in code\n"
"\n"
"-- data is kept in the datastore and also cached in the memcache (todo)\n"
"\n"
"module(\"wetgenes.www.any.opts\")\n"
"local _M=require(...)\n"
"\n"
"default_props=\n"
"{\n"
"}\n"
"\n"
"default_cache=\n"
"{\n"
"}\n"
"\n"
"function kind()\n"
"	return \"opts\"\n"
"end\n"
"\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- check that entity has initial data and set any missing defaults\n"
"-- the second return value is false if this is not a valid entity\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function check(srv,ent)\n"
"\n"
"	local c=ent.cache\n"
"		\n"
"	return ent\n"
"end\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- read a string\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function get_dat(id)\n"
"	local e=get(nil,id,t)\n"
"	if e then return e.cache.dat end\n"
"	return nil\n"
"end\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- write a string\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function put_dat(id,dat)\n"
"	local e=create(nil)\n"
"	e.key.id=id\n"
"	e.cache.dat=dat\n"
"	local r=put(nil,e)\n"
"	\n"
"	return r\n"
"end\n"
"\n"
"\n"
"\n"
"dat.set_defs(_M) -- create basic data handling funcs\n"
"\n"
"dat.setup_db(_M) -- make sure DB exists and is ready\n"
"",

"lanes","--\n"
"-- LANES.LUA\n"
"--\n"
"-- Multithreading and -core support for Lua\n"
"--\n"
"-- Author: Asko Kauppi <akauppi@gmail.com>\n"
"--\n"
"-- History:\n"
"--    Jun-08 AKa: major revise\n"
"--    15-May-07 AKa: pthread_join():less version, some speedup & ability to\n"
"--                   handle more threads (~ 8000-9000, up from ~ 5000)\n"
"--    26-Feb-07 AKa: serialization working (C side)\n"
"--    17-Sep-06 AKa: started the module (serialization)\n"
"--\n"
"--[[\n"
"===============================================================================\n"
"\n"
"Copyright (C) 2007-08 Asko Kauppi <akauppi@gmail.com>\n"
"\n"
"Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"of this software and associated documentation files (the \"Software\"), to deal\n"
"in the Software without restriction, including without limitation the rights\n"
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"copies of the Software, and to permit persons to whom the Software is\n"
"furnished to do so, subject to the following conditions:\n"
"\n"
"The above copyright notice and this permission notice shall be included in\n"
"all copies or substantial portions of the Software.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n"
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
"THE SOFTWARE.\n"
"\n"
"===============================================================================\n"
"]]--\n"
"\n"
"module( \"lanes\", package.seeall )\n"
"\n"
"require \"lua51-lanes\"\n"
"assert( type(lanes)==\"table\" )\n"
"\n"
"local mm= lanes\n"
"\n"
"local linda_id=    assert( mm.linda_id )\n"
"\n"
"local thread_new=   assert(mm.thread_new)\n"
"local thread_status= assert(mm.thread_status)\n"
"local thread_wait=  assert(mm.thread_wait)\n"
"local thread_cancel= assert(mm.thread_cancel)\n"
"\n"
"local _single= assert(mm._single)\n"
"local _version= assert(mm._version)\n"
"\n"
"local _deep_userdata= assert(mm._deep_userdata)\n"
"\n"
"local now_secs= assert( mm.now_secs )\n"
"local wakeup_conv= assert( mm.wakeup_conv )\n"
"local timer_gateway= assert( mm.timer_gateway )\n"
"\n"
"local max_prio= assert( mm.max_prio )\n"
"\n"
"\n"
"ABOUT= \n"
"{\n"
"    author= \"Asko Kauppi <akauppi@gmail.com>\",\n"
"    description= \"Running multiple Lua states in parallel\",\n"
"    license= \"MIT/X11\",\n"
"    copyright= \"Copyright (c) 2007-08, Asko Kauppi\",\n"
"    version= _version,\n"
"}\n"
"\n"
"\n"
"-- Making copies of necessary system libs will pass them on as upvalues;\n"
"-- only the first state doing \"require 'lanes'\" will need to have 'string'\n"
"-- and 'table' visible.\n"
"--\n"
"local string_gmatch= assert( string.gmatch )\n"
"\n"
"local function WR(str)\n"
"    io.stderr:write( str..\"\\n"
"\" )\n"
"end\n"
"\n"
"local function DUMP( tbl )\n"
"    if not tbl then return end\n"
"    local str=\"\"\n"
"    for k,v in pairs(tbl) do\n"
"        str= str..k..\"=\"..tostring(v)..\"\\n"
"\"\n"
"    end\n"
"    WR(str)\n"
"end\n"
"\n"
"\n"
"---=== Laning ===---\n"
"\n"
"-- lane_h[1..n]: lane results, same as via 'lanes_h:join()'\n"
"-- lane_h[0]:    can be read to make sure a thread has finished (always gives 'true')\n"
"-- lane_h[-1]:   error message, without propagating the error\n"
"--\n"
"--      Reading a Lane result (or [0]) propagates a possible error in the lane\n"
"--      (and execution does not return). Cancelled lanes give 'nil' values.\n"
"--\n"
"-- lane_h.state: \"pending\"/\"running\"/\"waiting\"/\"done\"/\"error\"/\"cancelled\"\n"
"--\n"
"local lane_mt= {\n"
"    __index= function( me, k )\n"
"                if type(k) == \"number\" then\n"
"                    -- 'me[0]=true' marks we've already taken in the results\n"
"                    --\n"
"                    if not rawget( me, 0 ) then\n"
"                        -- Wait indefinately; either propagates an error or\n"
"                        -- returns the return values\n"
"                        --\n"
"                        me[0]= true  -- marker, even on errors\n"
"\n"
"                        local t= { thread_wait(me._ud,-1) }   -- wait indefinate\n"
"\n"
"                        -- Use 'pairs' and not 'ipairs' so that nil holes in\n"
"                        -- the returned values are tolerated.\n"
"                        --\n"
"                        for i,v in pairs(t) do\n"
"                            me[i]= v\n"
"                        end\n"
"                    end\n"
"                    \n"
"                    -- Check errors even if we'd first peeked them via [-1]\n"
"                    -- (or '.error') and then came for the actual results.\n"
"                    --\n"
"                    if rawget(me, -1) and k~=-1 then\n"
"                        error( t[2], 3 )    -- level that takes to customer's code\n"
"                                            -- TBD: level does not seem to have effect!\n"
"                    end\n"
"                    return rawget( me, k )\n"
"                    --\n"
"                elseif k==\"status\" then     -- me.status\n"
"                    return thread_status(me._ud)\n"
"                    --\n"
"                else\n"
"                    error( \"Unknown key: \"..k )\n"
"                end\n"
"             end\n"
"    }\n"
"\n"
"-----\n"
"-- h= lanes.gen( [libs_str|opt_tbl [, ...],] lane_func ) ( [...] )\n"
"--\n"
"-- 'libs': nil:     no libraries available (default)\n"
"--         \"\":      only base library ('assert', 'print', 'unpack' etc.)\n"
"--         \"math,os\": math + os + base libraries (named ones + base)\n"
"--         \"*\":     all standard libraries available\n"
"--\n"
"-- 'opt': .priority:  int (-2..+2) smaller is lower priority (0 = default)\n"
"--\n"
"--	      .cancelstep: bool | uint\n"
"--            false: cancellation check only at pending Linda operations\n"
"--                   (send/receive) so no runtime performance penalty (default)\n"
"--            true:  adequate cancellation check (same as 100)\n"
"--            >0:    cancellation check every x Lua lines (small number= faster\n"
"--                   reaction but more performance overhead)\n"
"--\n"
"--        .globals:  table of globals to set for a new thread (passed by value)\n"
"--\n"
"--        ... (more options may be introduced later) ...\n"
"--\n"
"-- Calling with a function parameter ('lane_func') ends the string/table\n"
"-- modifiers, and prepares a lane generator. One can either finish here,\n"
"-- and call the generator later (maybe multiple times, with different parameters) \n"
"-- or add on actual thread arguments to also ignite the thread on the same call.\n"
"--\n"
"local lane_proxy\n"
"\n"
"local valid_libs= {\n"
"    [\"package\"]= true,\n"
"    [\"table\"]= true,\n"
"    [\"io\"]= true,\n"
"    [\"os\"]= true,\n"
"    [\"string\"]= true,\n"
"    [\"math\"]= true,\n"
"    [\"debug\"]= true,\n"
"    --\n"
"    [\"base\"]= true,\n"
"    [\"coroutine\"]= true,\n"
"    [\"*\"]= true\n"
"}\n"
"\n"
"function gen( ... )\n"
"    local opt= {}\n"
"    local libs= nil\n"
"    local lev= 2  -- level for errors\n"
"\n"
"    local n= select('#',...)\n"
"    \n"
"    if n==0 then\n"
"        error( \"No parameters!\" )\n"
"    end\n"
"\n"
"    for i=1,n-1 do\n"
"        local v= select(i,...)\n"
"        if type(v)==\"string\" then\n"
"            libs= libs and libs..\",\"..v or v\n"
"        elseif type(v)==\"table\" then\n"
"            for k,vv in pairs(v) do\n"
"                opt[k]= vv\n"
"            end\n"
"        elseif v==nil then\n"
"            -- skip\n"
"        else\n"
"            error( \"Bad parameter: \"..tostring(v) )\n"
"        end\n"
"    end\n"
"\n"
"    local func= select(n,...)\n"
"    if type(func)~=\"function\" then\n"
"        error( \"Last parameter not function: \"..tostring(func) )\n"
"    end\n"
"\n"
"    -- Check 'libs' already here, so the error goes in the right place\n"
"    -- (otherwise will be noticed only once the generator is called)\n"
"    --\n"
"    if libs then\n"
"        for s in string_gmatch(libs, \"[%a*]+\") do\n"
"            if not valid_libs[s] then\n"
"                error( \"Bad library name: \"..s )\n"
"            end\n"
"        end\n"
"    end\n"
"    \n"
"    local prio, cs, g_tbl\n"
"\n"
"    for k,v in pairs(opt) do\n"
"            if k==\"priority\" then prio= v\n"
"        elseif k==\"cancelstep\" then cs= (v==true) and 100 or\n"
"                                        (v==false) and 0 or \n"
"                                        type(v)==\"number\" and v or\n"
"                                        error( \"Bad cancelstep: \"..tostring(v), lev )\n"
"        elseif k==\"globals\" then g_tbl= v\n"
"        --..\n"
"        elseif k==1 then error( \"unkeyed option: \".. tostring(v), lev )\n"
"        else error( \"Bad option: \".. tostring(k), lev )\n"
"        end\n"
"    end\n"
"\n"
"    -- Lane generator\n"
"    --\n"
"    return function(...)\n"
"              return lane_proxy( thread_new( func, libs, cs, prio, g_tbl,\n"
"                                             ... ) )     -- args\n"
"           end\n"
"end\n"
"\n"
"lane_proxy= function( ud )\n"
"    local proxy= {\n"
"        _ud= ud,\n"
"        \n"
"        -- void= me:cancel()\n"
"        --\n"
"        cancel= function(me) thread_cancel(ud) end,\n"
"        \n"
"        -- [...]|[nil,err]= me:join( [wait_secs=-1] [,propagate=true] )\n"
"        --\n"
"        join= function( me, wait, propagate ) \n"
"                return thread_wait(ud,wait,propagate)\n"
"            end,\n"
"        }\n"
"    assert( proxy._ud )\n"
"    setmetatable( proxy, lane_mt )\n"
"\n"
"    return proxy\n"
"end\n"
"\n"
"\n"
"---=== Lindas ===---\n"
"\n"
"-- We let the C code attach methods to userdata directly\n"
"\n"
"-----\n"
"-- linda_ud= lanes.linda()\n"
"--\n"
"function linda()\n"
"    local proxy= _deep_userdata( linda_id )\n"
"    assert( (type(proxy) == \"userdata\") and getmetatable(proxy) )\n"
"    return proxy\n"
"end\n"
"\n"
"\n"
"---=== Timers ===---\n"
"\n"
"-- \n"
"-- Linda protocol to timer lane:\n"
"--\n"
"--  \"set\": linda_h, key, wakeup_at_secs|0, repeat_secs|0\n"
"--\n"
"local timer_gateway_key= \"set\"\n"
"local first_time_key= \"first time\"\n"
"\n"
"local first_time= timer_gateway:get(first_time_key) == nil\n"
"timer_gateway:set(first_time_key,true)\n"
"\n"
"-----\n"
"-- = timer( linda_h, key_val, date_tbl|first_secs [,period_secs] )\n"
"--\n"
"function timer( linda, key, a, period )\n"
"\n"
"    if a==0.0 then\n"
"        -- Stop the timer (no 'period') or anyways return right away\n"
"        --\n"
"        if period and period>0 then\n"
"            timer( linda, key, period, period )\n"
"        else\n"
"            timer_gateway:send( \"set\", linda, key, 0, 0 )   -- clear the timer\n"
"        end\n"
"        \n"
"        -- Caller expects to get current time stamp in Linda, on return\n"
"        -- (like the timer had expired instantly); do this as late as possible\n"
"        -- to get most accurate current time\n"
"        --\n"
"        linda:set( key, now_secs() )\n"
"\n"
"    else\n"
"        local wakeup_at= type(a)==\"table\" and wakeup_conv(a)    -- given point of time\n"
"                                           or now_secs()+a\n"
"        -- queue to timer\n"
"        --\n"
"        timer_gateway:send( \"set\", linda, key, wakeup_at, period or 0 )\n"
"    end\n"
"end\n"
"\n"
"--\n"
"-- Timer lane; initialize only on the first 'require \"lanes\"' instance\n"
"--\n"
"if first_time then\n"
"    local table_remove= assert( table.remove )\n"
"    local table_insert= assert( table.insert )\n"
"\n"
"    --\n"
"    -- { [deep_linda_lightuserdata]= { [deep_linda_lightuserdata]=linda_h, \n"
"    --                                 [key]= { wakeup_secs [,period_secs] } [, ...] },\n"
"    -- }\n"
"    --\n"
"    -- Collection of all running timers, indexed with linda's & key.\n"
"    --\n"
"    -- Note that we need to use the deep lightuserdata identifiers, instead\n"
"    -- of 'linda_h' themselves as table indices. Otherwise, we'd get multiple\n"
"    -- entries for the same timer.\n"
"    --\n"
"    -- The 'hidden' reference to Linda proxy is used in 'check_timers()' but\n"
"    -- also important to keep the Linda alive, even if all outside world threw\n"
"    -- away pointers to it (which would ruin uniqueness of the deep pointer).\n"
"    -- Now we're safe.\n"
"    --\n"
"    local collection= {}\n"
"\n"
"    --\n"
"    -- set_timer( linda_h, key, wakeup_at_secs|0 [, period_secs] )\n"
"    --\n"
"    local function set_timer( linda, key, wakeup_at, period )\n"
"    \n"
"        assert( type(wakeup_at)==\"number\" )\n"
"        assert( period==nil or type(period)==\"number\" )\n"
"\n"
"        local linda_deep= linda:deep()\n"
"        assert( linda_deep )\n"
"\n"
"        -- Find or make a lookup for this timer\n"
"        --\n"
"        local t1= collection[linda_deep]\n"
"        if not t1 then\n"
"            t1= { [linda_deep]= linda }     -- proxy to use the Linda\n"
"            collection[linda_deep]= t1\n"
"        end\n"
"    \n"
"        if wakeup_at==0 then\n"
"            -- Clear the timer\n"
"            --\n"
"            t1[key]= nil\n"
"\n"
"            -- Remove empty tables from collection; speeds timer checks and\n"
"            -- lets our 'safety reference' proxy be gc:ed as well.\n"
"            --\n"
"            local empty= true\n"
"            for k,_ in pairs(t1) do\n"
"                if k~= linda_deep then\n"
"                    empty= false; break\n"
"                end\n"
"            end\n"
"            if empty then\n"
"                collection[linda_deep]= nil\n"
"            end\n"
"            \n"
"            -- Note: any unread timer value is left at 'linda[key]' intensionally;\n"
"            --       clearing a timer just stops it.\n"
"        else\n"
"            -- New timer or changing the timings\n"
"            --\n"
"            local t2= t1[key]\n"
"            if not t2 then\n"
"                t2= {}; t1[key]= t2\n"
"            end\n"
"    \n"
"            t2[1]= wakeup_at\n"
"            t2[2]= period   -- can be 'nil'\n"
"        end\n"
"    end\n"
"\n"
"    -----\n"
"    -- [next_wakeup_at]= check_timers()\n"
"    --\n"
"    -- Check timers, and wake up the ones expired (if any)\n"
"    --\n"
"    -- Returns the closest upcoming (remaining) wakeup time (or 'nil' if none).\n"
"    --\n"
"    local function check_timers()\n"
"\n"
"        local now= now_secs()\n"
"        local next_wakeup\n"
"\n"
"        for linda_deep,t1 in pairs(collection) do\n"
"            for key,t2 in pairs(t1) do\n"
"                --\n"
"                if key==linda_deep then\n"
"                    -- no 'continue' in Lua :/\n"
"                else\n"
"                    -- 't2': { wakeup_at_secs [,period_secs] }\n"
"                    --\n"
"                    local wakeup_at= t2[1]\n"
"                    local period= t2[2]     -- may be 'nil'\n"
"                    \n"
"                    if wakeup_at <= now then    \n"
"                        local linda= t1[linda_deep]\n"
"                        assert(linda)\n"
"    \n"
"                        linda:set( key, now )\n"
"        \n"
"                        -- 'pairs()' allows the values to be modified (and even\n"
"                        -- removed) as far as keys are not touched\n"
"                                                \n"
"                        if not period then\n"
"                            -- one-time timer; gone\n"
"                            --\n"
"                            t1[key]= nil\n"
"                            wakeup_at= nil   -- no 'continue' in Lua :/\n"
"                        else\n"
"                            -- repeating timer; find next wakeup (may jump multiple repeats)\n"
"                            --\n"
"                            repeat\n"
"                                wakeup_at= wakeup_at+period\n"
"                            until wakeup_at > now\n"
"    \n"
"                            t2[1]= wakeup_at\n"
"                        end\n"
"                    end\n"
"                    \n"
"                    if wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\n"
"                        next_wakeup= wakeup_at\n"
"                    end \n"
"                end\n"
"            end -- t2 loop\n"
"        end -- t1 loop\n"
"        \n"
"        return next_wakeup  -- may be 'nil'\n"
"    end    \n"
"\n"
"    -----\n"
"    -- Snore loop (run as a lane on the background)\n"
"    --\n"
"    local function loop()\n"
"        while true do\n"
"\n"
"            local next_wakeup= check_timers()\n"
"\n"
"            -- Sleep until next timer to wake up, or a set/clear command\n"
"            --\n"
"            local secs= next_wakeup and (next_wakeup - now_secs()) or nil\n"
"            local linda= timer_gateway:receive( secs, timer_gateway_key )\n"
"\n"
"            if linda then\n"
"                local key= timer_gateway:receive( 0.0, timer_gateway_key )\n"
"                local wakeup_at= timer_gateway:receive( 0.0, timer_gateway_key )\n"
"                local period= timer_gateway:receive( 0.0, timer_gateway_key )\n"
"                assert( key and wakeup_at and period )\n"
"\n"
"                set_timer( linda, key, wakeup_at, period>0 and period or nil )\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"    --\n"
"    -- Run timer lane with high priority, to get trustworthy timings.\n"
"    --\n"
"    gen( \"io\", { priority=max_prio }, loop )()\n"
"end\n"
"\n"
"\n"
"\n"
"---=== Lock & atomic generators ===---\n"
"\n"
"-- These functions are just surface sugar, but make solutions easier to read.\n"
"-- Not many applications should even need explicit locks or atomic counters.\n"
"\n"
"--\n"
"-- lock_f= lanes.genlock( linda_h, key [,N_uint=1] )\n"
"--\n"
"-- = lock_f( +M )   -- acquire M\n"
"--      ...locked...\n"
"-- = lock_f( -M )   -- release M\n"
"--\n"
"-- Returns an access function that allows 'N' simultaneous entries between\n"
"-- acquire (+M) and release (-M). For binary locks, use M==1.\n"
"--\n"
"function genlock( linda, key, N )\n"
"    linda:limit(key,N)\n"
"    linda:set(key,nil)  -- clears existing data\n"
"\n"
"    --\n"
"    -- [true [, ...]= trues(uint)\n"
"    --\n"
"    local function trues(n)\n"
"        if n>0 then return true,trues(n-1) end\n"
"    end\n"
"\n"
"    return\n"
"    function(M)\n"
"        if M>0 then\n"
"            -- 'nil' timeout allows 'key' to be numeric\n"
"            linda:send( nil, key, trues(M) )    -- suspends until been able to push them\n"
"        else\n"
"            for i=1,-M do\n"
"                linda:receive( key )\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"\n"
"--\n"
"-- atomic_f= lanes.genatomic( linda_h, key [,initial_num=0.0] )\n"
"--\n"
"-- int= atomic_f( [diff_num=1.0] )\n"
"--\n"
"-- Returns an access function that allows atomic increment/decrement of the\n"
"-- number in 'key'.\n"
"--\n"
"function genatomic( linda, key, initial_val )\n"
"    linda:limit(key,2)          -- value [,true]\n"
"    linda:set(key,initial_val or 0.0)   -- clears existing data (also queue)\n"
"\n"
"    return\n"
"    function(diff)\n"
"        -- 'nil' allows 'key' to be numeric\n"
"        linda:send( nil, key, true )    -- suspends until our 'true' is in\n"
"        local val= linda:get(key) + (diff or 1.0)\n"
"        linda:set( key, val )   -- releases the lock, by emptying queue\n"
"        return val\n"
"    end\n"
"end\n"
"\n"
"\n"
"--the end\n"
"",

"wetgenes.snipets","-- just snippets of code for copypasta do not run as it should do nothing\n"
"-- this files is intended as a central place to keep upto date incase things need to be changed\n"
"\n"
"-- copy functions into locals\n"
"local assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- copy libs into locals\n"
"local coroutine,package,string,table,math,io,os,debug=coroutine,package,string,table,math,io,os,debug\n"
"\n"
"-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"",

"fenestra.font","\r\n"
"\r\n"
"--\r\n"
"-- draw a font\r\n"
"--\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.font\")\r\n"
"\r\n"
"\r\n"
"--\r\n"
"-- Return a font object we can use to draw text with\r\n"
"--\r\n"
"-- \"base\" is the built in 8x8 font\r\n"
"-- \"sans\" is the default proportional font\r\n"
"--\r\n"
"function setup(win,name)\r\n"
"\r\n"
"\r\n"
"	local font={}\r\n"
"	\r\n"
"	font.name=nil -- base by default\r\n"
"	if name==\"sans\" then font.name=\"sans\" end\r\n"
"	\r\n"
"	font.sx=8 -- base size of each char in this font\r\n"
"	font.sy=8\r\n"
"	\r\n"
"	font.px=0 -- current drawing position for this font\r\n"
"	font.py=0\r\n"
"	\r\n"
"	font.color=0xffffffff -- the current color to draw in\r\n"
"	\r\n"
"--\r\n"
"-- To simplify drawing the fonts are drawn not at the baseline but as their top/left corners\r\n"
"-- this way we can return a width and height of the total area neeeded to draw, you will need to handle\r\n"
"-- baseline offsets when positioning text. The whole baseline thing is a bit oldskool anyhow.\r\n"
"-- If you wish to have multiple sized fonts on a single line it is better if we make that\r\n"
"-- as hard as possible :)\r\n"
"--\r\n"
"-- also fonts are drawn in the directions of x++ and y--,\r\n"
"-- use open gl transforms to position the 0,0 wherever you want before drawing here\r\n"
"--	\r\n"
"	\r\n"
"--\r\n"
"-- cleanup this font\r\n"
"--\r\n"
"	function font.clean()\r\n"
"	end\r\n"
"	\r\n"
"--\r\n"
"-- make this font active\r\n"
"--\r\n"
"	function font.active(force)\r\n"
"		if force or win.font ~= font then\r\n"
"			win.font=font\r\n"
"			win.flat_font(font.name)\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"--\r\n"
"-- set the position and color and size, any input may be nil for no change\r\n"
"--\r\n"
"	function font.set(px,py,color,sx,sy)\r\n"
"		font.active()\r\n"
"		font.px=px or font.px\r\n"
"		font.py=py or font.py\r\n"
"		font.color=color or font.color		\r\n"
"		font.sx=sx or font.sx\r\n"
"		font.sy=sy or sx or font.sy\r\n"
"		\r\n"
"	end\r\n"
"--\r\n"
"-- how big an area does this string require, return width,height\r\n"
"--\r\n"
"	function font.size(text,size)\r\n"
"		font.active()\r\n"
"		if size then font.sx=size font.sy=size end\r\n"
"		if text then return win.flat_measure({size=font.sx,s=text}) , font.sy end\r\n"
"	end\r\n"
"--\r\n"
"-- draw this string, optionally apply a different color to each char using the colors array\r\n"
"--\r\n"
"	function font.draw(text,colors)\r\n"
"		font.active()\r\n"
"		win.flat_print({x=font.px,y=font.py,size=font.sx,color=font.color,s=text,c=colors})\r\n"
"	end\r\n"
"--\r\n"
"-- number of characters that fit in this width\r\n"
"--\r\n"
"	function font.fits(width,text,size)\r\n"
"		font.active()\r\n"
"		if size then font.sx=size font.sy=size end\r\n"
"		if text then return win.flat_fits({size=font.sx,s=text,width=width}) end\r\n"
"	end\r\n"
"	\r\n"
"--\r\n"
"-- which char is under this xpos, ( 0 is first and -1 is unknown )\r\n"
"--\r\n"
"	function font.which(x,text,size)\r\n"
"		font.active()\r\n"
"		if size then font.sx=size font.sy=size end\r\n"
"		if text then return win.flat_which({size=font.sx,s=text,x=x}) end\r\n"
"	end\r\n"
"\r\n"
"--\r\n"
"-- break this string into an array of strings with proper word wrapping to the given width\r\n"
"-- whitespace will be removed from the begining of the strings\r\n"
"--\r\n"
"	function font.wrap(width,text,size)\r\n"
"		font.active()\r\n"
"		if size then font.sx=size font.sy=size end\r\n"
"		if text then\r\n"
"		\r\n"
"			local s=text\r\n"
"			local s1=0\r\n"
"			local ss={}\r\n"
"			while #s>0 do\r\n"
"				s1=font.fits(width,s)\r\n"
"				if s1>=0 then\r\n"
"					local bp=s1\r\n"
"					\r\n"
"					local sa,sb=s:find(\"\\n"
"\")		-- new lines force breaks\r\n"
"					if sa and sa<bp then bp=sa end\r\n"
"					\r\n"
"					local wa,wb=s:sub(bp+1):find(\"^%s+\") -- white space at end?\r\n"
"					\r\n"
"					if #s == bp then -- the end of string\r\n"
"					\r\n"
"					elseif wa then -- perfect split, followed by space\r\n"
"					\r\n"
"						bp=bp+wb -- include the space at the end\r\n"
"						\r\n"
"					else -- find the space before\r\n"
"					\r\n"
"						local a,b = s:find(\"%s+\")\r\n"
"						\r\n"
"						while a do\r\n"
"							if a<s1 then bp=b else break end\r\n"
"							a,b = s:find(\"%s+\",b+1)\r\n"
"						end\r\n"
"						\r\n"
"					end\r\n"
"					ss[#ss+1]=s:sub(1,bp)\r\n"
"					s=s:sub(bp+1)\r\n"
"				else\r\n"
"					break\r\n"
"				end\r\n"
"			end\r\n"
"\r\n"
"			return ss\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	return font\r\n"
"end\r\n"
"\r\n"
"",

"fenestra.widget.slide","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"-- two basic widgets merged together to give a simple slide or scrollbar \r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.slide\")\r\n"
"\r\n"
"local widget_data=require(\"fenestra.widget.data\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"--	local it=widget.slide\r\n"
"\r\n"
"\r\n"
"	widget:snap()\r\n"
"\r\n"
"--	it.drag.text=it.datx:get_string()\r\n"
"	\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function layout(widget)\r\n"
"\r\n"
"	widget.drag.hx=widget.datx:get_size(widget.hx)\r\n"
"	widget.drag.hy=widget.daty:get_size(widget.hy)\r\n"
"\r\n"
"	widget.meta.layout(widget)	\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"function slide_snap(it)\r\n"
"\r\n"
"-- auto snap positions when draged\r\n"
"	it.drag.px=it.datx:snap( it.hx , it.drag.hx , it.drag.px )\r\n"
"	it.drag.pxd=it.pxd+it.drag.px\r\n"
"	\r\n"
"-- upside down y so need to twiddle it, pyr is \"the right way up\"\r\n"
"	it.drag.py=it.daty:snap( it.hy , it.drag.hy , it.drag.py )\r\n"
"	it.drag.pyd=it.pyd-it.drag.py\r\n"
"	\r\n"
"end\r\n"
"	\r\n"
"function setup(widget,def)\r\n"
"--	local it={} -- our main data so as not to clobber widget values\r\n"
"--	it.widget=widget\r\n"
"--	widget.slide=it\r\n"
"	widget.class=\"slide\"\r\n"
"	\r\n"
"	widget.snap=slide_snap\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.layout=layout\r\n"
"	\r\n"
"--setup constraints in x and y \r\n"
"	widget.datx=widget_data.new_data(def.datx)\r\n"
"	widget.daty=widget_data.new_data(def.daty)\r\n"
"\r\n"
"-- auto add the draging button as a child\r\n"
"	widget.drag=widget:add({class=\"drag\",color=0xffffffff,hy=widget.daty:get_size(widget.hy),hx=widget.datx:get_size(widget.hx),pxf=widget.datx:get_pos(),pyf=widget.daty:get_pos(),data=widget.data})\r\n"
"	\r\n"
"	return widget\r\n"
"end\r\n"
"",

"fenestra.widget.drag","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.drag\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"\r\n"
"	if widget.data then\r\n"
"		widget.text=widget.data:get_string()\r\n"
"	end\r\n"
"\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.drag=it\r\n"
"	widget.class=\"drag\"\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.draw=draw\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"",

"wetgenes.grd","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- the core module previously lived in \"grd\" now it is in \"wetgenes.grd.core\" with this wrapper code\n"
"\n"
"module(\"wetgenes.grd\")\n"
"\n"
"local core=require(\"wetgenes.grd.core\")\n"
"\n"
"\n"
"create=function(...)\n"
"\n"
"	return core.create(...)\n"
"	\n"
"end\n"
"",

"wetgenes.www.ngx.img","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.img\"]=_M\n"
"\n"
"\n"
"function get(...)\n"
"	log(\"img.get:\")\n"
"\n"
"--	return core.get(...)\n"
"\n"
"end\n"
"\n"
"function resize(...)\n"
"	log(\"img.resize:\")\n"
"\n"
"--	return core.resize(...)\n"
"\n"
"end\n"
"\n"
"function composite(...)\n"
"	log(\"img.composite:\")\n"
"\n"
"--	return core.composite(...)\n"
"\n"
"end\n"
"",

"wetgenes","local string=string\n"
"local table=table\n"
"local math=math\n"
"\n"
"local type=type\n"
"local pairs=pairs\n"
"local ipairs=ipairs\n"
"local tostring=tostring\n"
"local setmetatable=setmetatable\n"
"local unpack=unpack\n"
"local setfenv=setfenv\n"
"\n"
"--\n"
"-- Some generic and useful functions, pull them into locals like so:\n"
"--[[\n"
"\n"
"local export,lookup,set_env=require(\"wetgenes\"):export(\"export\",\"lookup\",\"set_env\")\n"
"\n"
"]]--\n"
"\n"
"--local _ENV=require(\"wetquire\").remodule(\"wetgenes\")\n"
"module(\"wetgenes\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- export given names from this table as multiple returns\n"
"-- can be used to pull function pointers out of a module\n"
"--\n"
"-- local lookup=require(\"wetgenes.util\"):export(\"lookup\")\n"
"--\n"
"-- shove it into your module to have a similar effect\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"function export(env,...)\n"
"	local tab={}\n"
"	for i,v in ipairs{...} do\n"
"		tab[i]=env[v]\n"
"	end\n"
"	return unpack(tab)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- safe lookup within a table that returns nil if any part of the lookup is nil\n"
"-- so we never cause an error, just returns nil\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function lookup(tab,...)\n"
"	for i,v in ipairs{...} do\n"
"		if type(tab)~=\"table\" then return nil end\n"
"		tab=tab[v]\n"
"	end\n"
"	return tab\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- since setfenv is going byebyes here is a plan to future proof code\n"
"--\n"
"-- we set the envirtonment of the code that called us only if setfenv exists\n"
"-- and we allways return the new environment\n"
"--\n"
"-- so the following can be used to change the current environment\n"
"-- and it should work in lua 5.1 or 5.2\n"
"--\n"
"-- local _ENV=set_env(new_environment)\n"
"--\n"
"-- the same is also done in the require overload provided by wetquire.lua\n"
"-- so once you wetquire and overload the environment then the following can be used\n"
"--\n"
"-- local _ENV=module(\"name\")\n"
"--\n"
"-- or using wetquire without overloading\n"
"--\n"
"-- local _ENV=require(\"wetquire\").remodule(\"name\")\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function set_env(env)\n"
"	if setfenv then setfenv(2,env) end\n"
"	return env\n"
"end\n"
"",

"wetgenes.bake.pathfix","-- make sure we have the package path setup and working to find everything, this should be made smrtr\n"
"-- i mean you still have to find this file in the first place...\n"
"\n"
"package.path =package.path.. \";../bin/lua/?.lua;../bin/lua/?/init.lua\"\n"
"\n"
"if os.getenv(\"SHELL\") and string.sub(os.getenv(\"SHELL\"),1,5)== \"/bin/\" then\n"
"	package.cpath=package.cpath..\";../bin/exe/?.so\"\n"
"else\n"
"	package.cpath=package.cpath..\";../bin/exe/?.dll\"\n"
"end\n"
"",

"wetgenes.waka","\n"
"--\n"
"-- a waka is made of chunks\n"
"-- chunks are made of text that contains links\n"
"-- a word that begins with / or http: is a link\n"
"-- there is no waka markup, if you want markup then use xhtml\n"
"--\n"
"\n"
"local table=table\n"
"local string=string\n"
"\n"
"\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"\n"
"local string=string\n"
"local type=type\n"
"local tostring=tostring\n"
"\n"
"local require=require\n"
"local loadstring=loadstring\n"
"local setfenv=setfenv\n"
"local pcall=pcall\n"
"\n"
"-- my string functions\n"
"local str=require(\"wetgenes.string\")\n"
"local sbox=require(\"wetgenes.sandbox\")\n"
"\n"
"\n"
"module(\"wetgenes.waka\")\n"
"\n"
"local split_lines		=str.split_lines\n"
"local split_words		=str.split_words\n"
"local split_whitespace	=str.split_whitespace\n"
"local split_equal		=str.split_equal\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- turn a string into a tag array\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function text_to_tags(text)\n"
"	local r={}\n"
"	\n"
"	if text then\n"
"		if string.find(text,\",\") then -- coma seperated\n"
"			local a=split_words(text,\",\")\n"
"			for i,v in ipairs(a) do\n"
"				local s=str.trim(v)\n"
"				if #s>0 then r[s]=true end\n"
"			end\n"
"		else -- white space seperated\n"
"			local a=split_words(text)\n"
"			for i,v in ipairs(a) do\n"
"				local s=str.trim(v)\n"
"				if #s>0 then r[s]=true end\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	return r\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- take some text and break it into named chunks\n"
"-- returns a lookup table of chunks and numerical list of these chunks in the order they where first defined\n"
"-- body is the default chunk name\n"
"--\n"
"-- a chunk is a line that begins with #\n"
"-- the part after the # and ending with whitespace is the chunk name\n"
"-- all text following this line is part of that chunk\n"
"-- the default section if none is give is \"body\", so any whitespace at the start of the file\n"
"-- before the first # line will be assigned to this chunk\n"
"-- data may follow this chunk name, if multiple chunks of the same name\n"
"-- are defined they are simple merged into one\n"
"-- and each #chunk line is combined into one chunk data\n"
"--\n"
"-- use option=value after the section name to provide options, so somthing like this\n"
"--\n"
"-- #name opt=val opt=val opt=val\n"
"-- # opt=val\n"
"-- here is some text\n"
"-- # opt=val\n"
"-- here is some more text\n"
"-- ## special comment, this line is ignored\n"
"-- ## comments are just a line that begins with two hashes\n"
"--\n"
"-- is a valid chunk, all of the opt=val will be assigned to the same chunk\n"
"-- and all the other text will be joined as that chunks body\n"
"--\n"
"-- pass in chunks and you can merge multiple texts into one chunk\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function text_to_chunks(text,chunks)\n"
"\n"
"local chunkend -- special end of chunk test\n"
"\n"
"	chunks=chunks or {}\n"
"\n"
"	local function manifest_chunk(line,oldchunk)\n"
"		local opts=split_words( line:sub(2) ) -- skip # at start of line\n"
"		local name=string.lower( opts[1] or \"body\" )\n"
"		local chunk\n"
"		local c2=line:sub(2,2)\n"
"				\n"
"		if c2:find(\"%s\") then -- if first char after # is whitespace, then use the old chunk \n"
"			chunk=oldchunk\n"
"		end\n"
"		\n"
"		if not chunk then\n"
"			chunk=chunks[name] -- do we already have this chunk?\n"
"		end\n"
"		\n"
"		if chunk then -- update an old chunk\n"
"		\n"
"			for i=1,#opts do local v=opts[i]\n"
"				table.insert( chunk.opts , v ) -- add extra opts\n"
"				local a,b=split_equal(v)\n"
"				if a then chunk.opts[a]=b end\n"
"			end\n"
"			\n"
"		else -- create a new chunk\n"
"		\n"
"			chunk={} -- make default chunk\n"
"\n"
"-- set some default options depending on the chunk name\n"
"\n"
"			if name:sub(1,4)==\"body\" then -- all chunks begining with \"body\" are waka format by default\n"
"				opts.form=\"waka\"\n"
"			end\n"
"\n"
"			if name:sub(1,5)==\"title\" then -- all chunks begining with \"title\" are trimed by default\n"
"				opts.trim=\"ends\"\n"
"			end\n"
"\n"
"			if name:sub(1,3)==\"css\" then -- all chunks begining with \"css\" append children by default\n"
"				opts.append=\"on\"\n"
"			end\n"
"		\n"
"			if name:sub(1,3)==\"lua\" then -- all chunks begining with \"lua\" are lua code by default\n"
"				opts.form=\"lua\"\n"
"			end\n"
"			\n"
"-- the actual options will overide the defaults\n"
"\n"
"			for i=1,#opts do local v=opts[i]\n"
"				local a,b=split_equal(v)\n"
"				if a then opts[a]=b end\n"
"			end\n"
"			\n"
"			chunk.id=#chunks+1\n"
"			chunk.name=name\n"
"			chunk.opts=opts\n"
"			chunk.lines={}\n"
"			\n"
"			chunks[chunk.id]=chunk		-- save chunk in chunks as numbered id\n"
"			chunks[chunk.name]=chunk	-- and as name\n"
"		end\n"
"		\n"
"		return chunk\n"
"	end\n"
"		\n"
"	local lines=split_lines(text)\n"
"	\n"
"	local chunk\n"
"	\n"
"	for i=1,#lines do local v=lines[i] -- ipairs\n"
"		\n"
"		local c=v:sub(1,1) -- the first char is special\n"
"		\n"
"		if c==\"#\" then -- start of chunk\n"
"		\n"
"			if chunkend then -- waiting for special end everything is inserted\n"
"			\n"
"				if chunkend==v:sub(1,#chunkend) then -- got it\n"
"					chunkend=nil\n"
"				else\n"
"					if not chunk then chunk=manifest_chunk(\"#body\") end --sanity				\n"
"					table.insert(chunk.lines , v)\n"
"				end\n"
"				\n"
"			else\n"
"\n"
"				if \"#[[\"==v:sub(1,3) then -- special open\n"
"				\n"
"					chunkend=\"#]]\"..v:sub(4) -- any special hash we need to close\n"
"				\n"
"				elseif v:sub(2,2)~=\"#\" then -- skip all comments\n"
"\n"
"					chunk=manifest_chunk(v,chunk)\n"
"\n"
"				end\n"
"				\n"
"			end\n"
"			\n"
"		else -- normal lime add to the current chunk\n"
"		\n"
"			if not chunk then chunk=manifest_chunk(\"#body\") end --sanity\n"
"			\n"
"			table.insert(chunk.lines , v)\n"
"		end\n"
"	\n"
"	end\n"
"	\n"
"	for i=1,#chunks do local v=chunks[i] -- perform some final actions on all chunks\n"
"	\n"
"		v.text=table.concat(v.lines) -- merge the split lines back together into one string\n"
"		\n"
"	end\n"
"	\n"
"	return chunks\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- merge source data into dest data, dest data may be nil in which case this \n"
"-- works like a copy. Return the dest chunk. It is intended that you have a\n"
"-- a number of chunks and then merge them together into a final data chunk\n"
"-- using this function, the first merge creates a new dest chunk. the final result\n"
"-- will have a new ordering depending on the merged chunks but the numerical array\n"
"-- can still be used to loop through chunks\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function chunks_merge(dest,source)\n"
"\n"
"	local dest=dest or {}\n"
"	\n"
"	local locked=dest.opts and dest.opts.opts.lock==\"on\" -- parent chunk locked\n"
"			\n"
"	for i,v in ipairs(source) do\n"
"	\n"
"		local c=dest[v.name] -- merge or\n"
"		\n"
"		local function set_data()\n"
"			if c.opts.append==\"on\" then -- add new lines to the end of the chunk rather than replace\n"
"				c.text=(c.text or \"\") .. ( v.text or \"\" )\n"
"				c.lines=split_lines(c.text) -- also need to build lines?\n"
"			else -- just replace\n"
"				c.lines=v.lines -- set or override\n"
"				c.text=v.text -- set or override\n"
"			end\n"
"			for ii,vv in pairs(v.opts) do\n"
"				c.opts[ii]=vv\n"
"			end\n"
"		end\n"
"		\n"
"		if not c then -- make a new chunk\n"
"			c={}\n"
"			c.id=#dest+1\n"
"			c.name=v.name\n"
"			c.opts={}\n"
"			dest[c.id]=c -- link it into dest by array\n"
"			dest[c.name]=c -- and by name\n"
"			\n"
"			set_data()\n"
"		else\n"
"			if not locked then -- skip lock\n"
"				set_data()\n"
"			end\n"
"		end\n"
"\n"
"	end\n"
"\n"
"	return dest\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get a html given some simple waka text\n"
"--\n"
"-- \\n"
" are turned into <br/> tags\n"
"-- and words that look like links are turned into links\n"
"-- any included html should get escaped so this is \"safe\" to use on user input\n"
"--\n"
"-- aditional opts\n"
"--\n"
"-- we need to know the base_url of this page when building links, if this is not given\n"
"-- then relative links may bork?\n"
"--\n"
"-- setting escape_html to true prevents any html from getting through\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function waka_to_html(input,opts)\n"
"	opts=opts or {}\n"
"\n"
"local base_url=opts.base_url or \"\"\n"
"local escape_html=opts.escape_html or false\n"
"\n"
"	local r={}\n"
"	local esc\n"
"	if escape_html then -- simple html escape\n"
"		esc=function(s) \n"
"			local escaped = { ['<']='&lt;', ['>']='&gt;', [\"&\"]='&amp;' , [\"\\n"
"\"]='<br/>\\n"
"' }\n"
"			return (s:gsub(\"[<>&\\n"
"]\", function(c) return escaped[c] or c end))\n"
"		end\n"
"	else -- no escape just convert \\n"
" to <br/>\n"
"		esc=function(s) \n"
"			local escaped = { [\"\\n"
"\"]='<br/>\\n"
"' }\n"
"			return (s:gsub(\"[\\n"
"]\", function(c) return escaped[c] or c end))\n"
"		end\n"
"	end\n"
"	\n"
"	local function link( url , str )\n"
"		table.insert(r,\"<a href=\\\"\"..url..\"\\\">\"..esc(str)..\"</a>\")\n"
"	end\n"
"	local function text( str )\n"
"		table.insert(r,esc(str))\n"
"	end\n"
"\n"
"	local tokens=split_whitespace(input)\n"
"	\n"
"	for i2=1,#tokens do local token=tokens[i2]\n"
"	\n"
"		local done=false\n"
"		\n"
"		local len=token:len()\n"
"		\n"
"		if len>=2 then -- too short to be a link\n"
"		\n"
"			local c1=token:sub(1,1) -- some chars to check\n"
"			\n"
"			if c1 == \"/\" then -- a very simple link relative to where we are\n"
"			\n"
"				local chars=\"[%w/%-%+_#%.:]+\"\n"
"				\n"
"--				if token:sub(1,3)==\"///\" then chars=\"[%w/%-%+_#%.:]+\" end -- allow common domain chars\n"
"			\n"
"				local s=token:sub(2) -- skip this first char\n"
"				\n"
"				local f1,f2=s:find(chars)\n"
"				if f1 then -- must find a word\n"
"					local s1=s:sub(f1,f2)\n"
"					if s1:sub(-1)==\".\" then -- trim trailing dot\n"
"						f2=f2-1\n"
"						s1=s:sub(f1,f2)\n"
"					end\n"
"					local ss=split_words(s1,\"/\")\n"
"					local tail=ss[#ss] \n"
"					link(s1,tail or s1)\n"
"					if f2<s:len() then -- some left over string\n"
"						text(s:sub(f2+1))\n"
"					end\n"
"					done=true\n"
"				end\n"
"				\n"
"			elseif token:sub(1,7)==\"http://\" then\n"
"					link(token,token)\n"
"					done=true\n"
"\n"
"			elseif token:sub(1,8)==\"https://\" then\n"
"					link(token,token)\n"
"					done=true\n"
"			end\n"
"			\n"
"		end\n"
"		\n"
"		\n"
"		if not done then -- unhandled token, just add it\n"
"			text(token)				\n"
"		end\n"
"	\n"
"	end\n"
"	\n"
"	return table.concat(r)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- turn some chunks into their prefered form, escape, trim and expand\n"
"--\n"
"-- i need a naming convention that make sense so this is now calledm\n"
"-- refine_chunks with coarse meaning unrefined\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function form_chunks(srv,chunks,opts) return refine_chunks(srv,chunks,opts) end\n"
"function refine_chunks(srv,chunks,opts)\n"
"\n"
"	opts=opts or {}\n"
"\n"
"	local refined={}\n"
"	\n"
"	for i,v in pairs(opts) do -- copy opts into refined\n"
"		refined[i]=v\n"
"	end\n"
"\n"
"-- start by compiling the lua chunks and running its pageopts hook\n"
"	for i,v in ipairs(chunks) do\n"
"	\n"
"		if v.opts.form==\"lua\" then -- we have some lua code for this page\n"
"			local e=sbox.make_env()\n"
"			v.env=e -- store it for later\n"
"			e.text=v.text -- let code know its sourcecode\n"
"			local f,err=loadstring(v.text)\n"
"			e.text=err or v.text -- replace with error for simple parse display\n"
"			if f then\n"
"				setfenv(f, e)\n"
"				pcall(f)\n"
"			end\n"
"			\n"
"			if v.env.hook_pageopts then\n"
"				pcall(function() v.env.hook_pageopts(srv.pageopts) end) -- update pageopts?\n"
"			end\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"	\n"
"	for i,v in ipairs(chunks) do -- do basic process of all of the page chunks into their prefered form \n"
"		local s=v.text\n"
"		\n"
"		local format=v.opts.form\n"
"		local trim=v.opts.trim\n"
"		\n"
"		if trim==\"ends\" then s=str.trim(s) end -- trim whitespace, useful for one word chunks?\n"
"\n"
"		if format==\"nohtml\" then -- like normal but all html is escaped\n"
"\n"
"			s=waka_to_html(s,{base_url=opts.baseurl,escape_html=true}) \n"
"\n"
"		elseif format==\"import\" then -- very special import, treat as chunk of lua import opts/code\n"
"		\n"
"			local e=sbox.make_env()\n"
"			local f,err=loadstring(s)\n"
"			if f then\n"
"				setfenv(f, e)\n"
"				pcall(f)\n"
"			else\n"
"				s=err\n"
"			end\n"
"\n"
"-- this should be split off into a plugin system...\n"
"			\n"
"			if e.import==\"blog\" then\n"
"			\n"
"				e.hook   = e.hook   or opts.hook\n"
"				e.limit=e.limit or 5\n"
"				e.layer=e.layer or 0\n"
"				e.sort=e.sort or \"pubdate\"\n"
"				\n"
"				if not opts.noblog then -- prevent recursions\n"
"					local blog=require(\"blog\")\n"
"					s=blog.chunk_import(srv,e)\n"
"				end\n"
"				\n"
"			elseif e.import==\"note\" then\n"
"			\n"
"				e.hook   = e.hook   or opts.hook\n"
"				e.limit=e.limit or 5\n"
"				e.sort=e.sort or \"pubdate\"\n"
"				\n"
"				if not opts.nonote then -- prevent recursions\n"
"					local note=require(\"note\")\n"
"					s=note.chunk_import(srv,e)\n"
"				end\n"
"				\n"
"			elseif e.import==\"comic\" then\n"
"			\n"
"				e.hook   = e.hook   or opts.hook\n"
"				e.limit=e.limit or 5\n"
"				e.sort=e.sort or \"pubdate\"\n"
"				\n"
"				if not opts.nocomic then -- prevent recursions\n"
"					local comic=require(\"comic\")\n"
"					s=comic.chunk_import(srv,e)\n"
"				end\n"
"				\n"
"			elseif e.import==\"gsheet\" then -- we need to grab some json from google\n"
"			\n"
"				local gsheet=require(\"waka.gsheet\")\n"
"				e.offset = e.offset or opts.offset -- can choose new pages\n"
"				e.limit  = e.limit  or opts.limit -- can choose new pages\n"
"				e.query  = e.query  or opts.query\n"
"				e.plate  = e.plate  or opts.plate\n"
"				e.key    = e.key    or opts.key\n"
"				e.hook   = e.hook   or opts.hook -- callback function to fixup data\n"
"				s=gsheet.getwaka(srv,e) -- get a string\n"
"				\n"
"			elseif e.import==\"wikipedia\" then -- we need to import some xml from wikipedia\n"
"			\n"
"				local wikipedia=require(\"waka.wikipedia\")\n"
"				e.offset = e.offset or opts.offset -- can choose new pages\n"
"				e.limit  = e.limit  or opts.limit -- can choose new pages\n"
"				e.name  = e.name  or opts.name -- get this page\n"
"				e.search  = e.search  or opts.search -- search for\n"
"				e.hook   = e.hook   or opts.hook -- callback function to fixup data\n"
"				\n"
"				s=wikipedia.getwaka(srv,e) -- get a string\n"
"				\n"
"			elseif e.import==\"picasa\" then -- we need to import some imagedata from picasssa\n"
"			\n"
"				local picassa=require(\"waka.picasa\")\n"
"				e.offset = e.offset or opts.offset -- can choose new pages\n"
"				e.limit  = e.limit  or opts.limit -- can choose new pages\n"
"				e.user  = e.user  or opts.user -- user name\n"
"				e.album  = e.album  or opts.album -- album name\n"
"				e.authkey  = e.authkey  or opts.authkey -- authkey if needed\n"
"				e.hook   = e.hook   or opts.hook -- callback function to fixup data\n"
"				e.plate   = e.plate   or opts.plate -- display plate\n"
"				\n"
"				s=picassa.getwaka(srv,e) -- get a string or tab\n"
"				\n"
"			elseif e.import==\"json\" then -- we need to import some json from somewhere\n"
"			\n"
"				local waka_json=require(\"waka.json\")\n"
"				e.url  = e.url  or opts.url -- what to get\n"
"				e.cachetime  = e.cachetime  or opts.cachetime -- how long to cache for\n"
"				e.hook   = e.hook   or opts.hook -- callback function to fixup data\n"
"				e.plate   = e.plate   or opts.plate -- display plate\n"
"				\n"
"				s=waka_json.getwaka(srv,e) -- get a string or tab\n"
"				\n"
"			end\n"
"		\n"
"		elseif format==\"waka\" then -- basic waka format, html allowed but links are upgraded and line ends are <br/>\n"
"\n"
"			s=waka_to_html(s,{base_url=opts.baseurl,escape_html=false})\n"
"\n"
"		else -- raw\n"
"			\n"
"			s=s\n"
"\n"
"		end\n"
"\n"
"		refined[v.name]=s\n"
"	end\n"
"	\n"
"-- end by running any refined lua hooks\n"
"	for i,v in ipairs(chunks) do\n"
"		if v.opts.form==\"lua\" then -- we have some lua code for this page\n"
"			\n"
"			if v.env then -- stick the env table in the refined table\n"
"				refined[v.name]=v.env\n"
"				if v.env.hook_refined then\n"
"					pcall(function() v.env.hook_refined(refined) end) -- update refined data\n"
"				end\n"
"			end\n"
"		end\n"
"	end\n"
"\n"
"	\n"
"	return refined\n"
"end\n"
"",

"box2d.wrap","\r\n"
"\r\n"
"local print=print\r\n"
"local table=table\r\n"
"local pairs=pairs\r\n"
"\r\n"
"local core = require(\"box2d.core\")\r\n"
"\r\n"
"\r\n"
"module(\"box2d.wrap\")\r\n"
"\r\n"
"--\r\n"
"-- Call new to get a unique table full of functions associated\r\n"
"-- with lots of tasty up values for easy use\r\n"
"--\r\n"
"-- this gives you a table full of functions to call\r\n"
"--\r\n"
"-- local world=require(\"box2d.wrap\").world()\r\n"
"--\r\n"
"function world(def) -- create a new world\r\n"
"\r\n"
"local world={}\r\n"
"\r\n"
"	if def then for i,v in pairs(def) do world[i]=v end end -- shallow copy def data \r\n"
"	\r\n"
"	world.hash={} -- a lookup table to turn internal lightuserdatas into associated lua tables (eg for safe callbacks)\r\n"
"\r\n"
"	world.core=core.setup(world) -- allocate a hard core\r\n"
"	core.get(world.core,world) -- update the soft body with current settings from the hard core\r\n"
"	\r\n"
"	function world.delete() -- delete this world\r\n"
"		return core.clean(world.core)\r\n"
"	end\r\n"
"	\r\n"
"	function world.step(tim,iter) -- run the simulation\r\n"
"		return core.step(world.core, tim or 1/50, iter or 10)\r\n"
"	end\r\n"
"\r\n"
"	function world.body(def) -- create a body in the world\r\n"
"		local body={}\r\n"
"		body.shapes={}\r\n"
"		body.core = core.body(world.core, def)\r\n"
"		\r\n"
"		function body.delete() -- delete this body\r\n"
"			core.body_delete(world.core, body.core)\r\n"
"		end\r\n"
"	\r\n"
"		function body.get()\r\n"
"			core.body_get(world.core, body.core, body)\r\n"
"		end\r\n"
"		\r\n"
"		function body.set(t)\r\n"
"			core.body_set(world.core, body.core,t)\r\n"
"		end\r\n"
"		\r\n"
"		function body.shape(def)\r\n"
"			world.shape(body,def)\r\n"
"		end\r\n"
"		\r\n"
"		core.body_get(world.core, body.core, body)\r\n"
"			\r\n"
"		return body\r\n"
"	end\r\n"
"	\r\n"
"	function world.shape(body,def) -- create a shape in the body\r\n"
"		local shape={}\r\n"
"		table.insert(body.shapes,shape)\r\n"
"		shape.core = core.body_shape(world.core, body.core , def)\r\n"
"		\r\n"
"		function shape.delete() -- delete this body\r\n"
"			core.body_shape_delete(world.core, body.core, shape.core )\r\n"
"		end\r\n"
"		\r\n"
"		return shape\r\n"
"	end\r\n"
"	\r\n"
"	function world.joint(def) -- create a joint\r\n"
"		local joint={}\r\n"
"		joint.core = core.joint(world.core, def)\r\n"
"		\r\n"
"		function joint.delete() -- delete this joint\r\n"
"			core.joint_delete(world.core, joint.core )\r\n"
"		end\r\n"
"		\r\n"
"		return shape\r\n"
"	end\r\n"
"	\r\n"
"	return world\r\n"
"end\r\n"
"\r\n"
"",

"apps","\n"
"-- create a global function that can be called to fix lua paths so we can find things\n"
"-- unfortunatly you still have to know where this file is first and run a \n"
"-- dofile(\"thisfile\") need to come up with a better plan, possibly preload a module?\n"
"\n"
"local package=package\n"
"local require=require\n"
"local string=string\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local print=print\n"
"local os=os\n"
"local io=io\n"
"\n"
"module(\"apps\")\n"
"\n"
"--\n"
"-- get/set current dir\n"
"--\n"
"local get_cd=function()\n"
"	local lfs=require(\"lfs\")\n"
"\n"
"	return string.gsub(lfs.currentdir(),'\\\\','/')\n"
"\n"
"end\n"
"local set_cd=function(str)\n"
"	local lfs=require(\"lfs\")\n"
"\n"
"	lfs.chdir(str)\n"
"\n"
"end\n"
"local file_exists=function(str)\n"
"	local fp=io.open(str,\"r\")\n"
"	if fp then fp:close() return true end\n"
"	return false\n"
"end\n"
"\n"
"	\n"
"function setpaths(dll,dirs)\n"
"\n"
"	if dll then\n"
"		local cpath={}\n"
"		for i,v in ipairs(dirs) do\n"
"			cpath[#cpath+1]=v .. \"?.\" .. dll\n"
"			cpath[#cpath+1]=v .. \"?/init.\" .. dll\n"
"		end\n"
"		cpath[#cpath+1]=package.cpath\n"
"		package.cpath=table.concat(cpath,\";\")\n"
"	end\n"
"	\n"
"	local path={}\n"
"	for i,v in ipairs(dirs) do\n"
"		path[#path+1]=v .. \"lua/?.lua\"\n"
"		path[#path+1]=v .. \"lua/?/init.lua\"\n"
"	end\n"
"	path[#path+1]=package.path\n"
"	package.path=table.concat(path,\";\")\n"
"\n"
"end\n"
"\n"
"--\n"
"-- find where our exe lives\n"
"--\n"
"function find_bin()\n"
"\n"
"	local dir=get_cd()\n"
"\n"
"	local tdirs={ -- look in these dirs\n"
"		dir,\n"
"		dir..\"/bin\",\n"
"		dir..\"/..\",\n"
"		dir..\"/../bin\",\n"
"		dir..\"/../lua\",\n"
"		dir..\"/../lua/bin\",\n"
"		dir..\"/../..\",\n"
"		dir..\"/../../bin\",\n"
"		dir..\"/../../..\",\n"
"		dir..\"/../../../bin\",\n"
"	}\n"
"	local bin_dir=dir..\"/\"\n"
"	for i=1,#tdirs do local v=tdirs[i]\n"
"		if file_exists(v..\"/lua/apps.lua\") then bin_dir=v..\"/\" break end -- found a bin dir?\n"
"	end\n"
"\n"
"	return bin_dir\n"
"end\n"
"\n"
"--\n"
"-- this needs to get more searchy so it can find where the lua app is without any explicit values\n"
"--\n"
"function find(name)\n"
"\n"
"	local lfs=require(\"lfs\")\n"
"\n"
"\n"
"-- we are looking for a dir/lua/name.lua and dir will be our base dir so look in various places\n"
"\n"
"	local osflavour=\"win\"\n"
"	local os_shell=os.getenv(\"SHELL\")\n"
"	if os_shell and string.sub(os_shell,1,5)== \"/bin/\" then -- if your shell is not here then we assume windows...\n"
"		osflavour=\"nix\"\n"
"	end\n"
"\n"
"	local dll=\"dll\"\n"
"	if osflavour==\"nix\" then dll=\"so\" end\n"
"\n"
"	bin_dir=find_bin()\n"
"	\n"
"print(\"BIN PATH\",bin_dir,dll)\n"
"\n"
"\n"
"	local dir=get_cd()\n"
"	local tdirs={ -- look in these dirs\n"
"	\n"
"		dir,\n"
"		dir..\"/\"..name,\n"
"		dir..\"/apps/\"..name,\n"
"		dir..\"/lua/\"..name,\n"
"		dir..\"/lua/apps/\"..name,\n"
"		\n"
"		dir..\"/..\",\n"
"		dir..\"/../\"..name,\n"
"		dir..\"/../apps/\"..name,\n"
"		dir..\"/../lua/\"..name,\n"
"		dir..\"/../lua/apps/\"..name,\n"
"		\n"
"		dir..\"/../..\",\n"
"		dir..\"/../../\"..name,\n"
"		dir..\"/../../apps/\"..name,\n"
"		dir..\"/../../lua/\"..name,\n"
"		dir..\"/../../lua/apps/\"..name,\n"
"		\n"
"	}\n"
"	local app_dir=dir..\"/\"\n"
"	local app_name=name\n"
"	for i=1,#tdirs do local v=tdirs[i]\n"
"		if file_exists(v..\"/lua/\"..name..\".lua\") then app_dir=v..\"/\" break end -- found a base dir?\n"
"		if file_exists(v..\"/lua/app.lua\") then app_dir=v..\"/\" app_name=\"app\" break end -- found a base dir?\n"
"	end\n"
"\n"
"print(\"APP PATH\",app_dir,dll)\n"
"\n"
"	setpaths(dll,{app_dir,bin_dir})\n"
"\n"
"	return app_dir,app_name\n"
"end\n"
"\n"
"\n"
"-- only call this once\n"
"-- probably on the commandline\n"
"function start(_name,...)\n"
"\n"
"	path_orig=package.path\n"
"	cpath_orig=package.cpath\n"
"\n"
"	exe=\"exe\"\n"
"	name=_name\n"
"	dll=\"so\"\n"
"\n"
"	dir,appname=find(name)\n"
"\n"
"	path=package.path\n"
"	cpath=package.cpath\n"
"	\n"
"	args=(...)\n"
"	\n"
"	print(\"appname \",appname)\n"
"	print(\"apps.exe\",exe)\n"
"	print(\"apps.name\",name)\n"
"	print(\"apps.dll\",dll)\n"
"	print(\"apps.dir\",dir)\n"
"	print(\"apps.args\",args)\n"
"\n"
"	return require(appname).start(...)\n"
"end\n"
"",

"fenestra.widget.data","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"--\r\n"
"-- handle widgets data values\r\n"
"--\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.data\")\r\n"
"\r\n"
"local call_hook=function(dat,hook)\r\n"
"	local hooks=dat.hooks\r\n"
"	local type_hooks=type(hooks)\r\n"
"	if type_hooks==\"function\" then -- master function\r\n"
"		return hooks(hook,dat)\r\n"
"	elseif type_hooks==\"table\" and hooks[hook] then -- or table of functions\r\n"
"		return hooks[hook](dat)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"-- set number (may trigger hook)\r\n"
"local data_value=function(dat,val)\r\n"
"	if dat.class==\"number\" then\r\n"
"		if val then val=tonumber(val) end -- auto convert from string\r\n"
"		if val and val~=dat.num then -- change value\r\n"
"			if dat.min and dat.num<dat.min then dat.num=dat.min end\r\n"
"			if dat.max and dat.num>dat.max then dat.num=dat.max end\r\n"
"			dat.str=dat:get_string() -- cache on change\r\n"
"			dat:call_hook(\"value\") -- call value hook, which may choose to mod the num some more...\r\n"
"		end\r\n"
"		return dat.num\r\n"
"	else\r\n"
"		if val and val~=dat.str then -- change value\r\n"
"			dat.str=val\r\n"
"			dat:call_hook(\"value\") -- call value hook, which may choose to mod the num some more...\r\n"
"		end\r\n"
"		return dat.str\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"-- a string to put in the handle\r\n"
"local data_get_string=function(dat)\r\n"
"	if dat.class==\"number\" then return tostring(dat.num) end\r\n"
"	return dat.str\r\n"
"end\r\n"
"\r\n"
"-- how wide or tall should the handle be given the size of the parent?\r\n"
"local data_get_size=function(dat,w)\r\n"
"	local ret=16\r\n"
"	if dat.min==dat.max then\r\n"
"		ret=w					-- fullsize\r\n"
"	elseif dat.size==0 then\r\n"
"		ret=w/4					-- some random room to scroll\r\n"
"	else\r\n"
"		ret=w*dat.size			-- use the given size\r\n"
"	end\r\n"
"	if ret<16 then ret=16 end\r\n"
"	if ret>w then ret=w end\r\n"
"	return ret\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-- get display pos, given the size of the parent and our size?\r\n"
"local data_get_pos=function(dat,psiz,bsiz)\r\n"
"	if dat.step==0 then -- no snap\r\n"
"		return ((dat.num-dat.min)/(dat.max-dat.min))\r\n"
"	else\r\n"
"		return ((dat.num-dat.min)/(dat.max-dat.min))\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"-- given the parents size and our relative position/size within it\r\n"
"-- update dat.num and return a new position (for snapping)\r\n"
"local data_snap=function(dat,psiz,bsiz,bpos)\r\n"
"	if dat.step==0 then -- no snap\r\n"
"		if dat.max==dat.min then dat:value(dat.min) return 0 end -- do not move\r\n"
"		\r\n"
"		local f=bpos/(psiz-bsiz)\r\n"
"		dat:value(dat.min+((dat.max-dat.min)*f))\r\n"
"		\r\n"
"		return bpos\r\n"
"		\r\n"
"	else\r\n"
"	\r\n"
"		if dat.max==dat.min then dat:value(dat.min) return 0 end -- do not move\r\n"
"		\r\n"
"		local f=bpos/(psiz-bsiz)\r\n"
"		local n=math.floor(0.5+(((dat.max-dat.min)*f)/dat.step))\r\n"
"\r\n"
"		dat:value(dat.min+(n*dat.step))\r\n"
"		\r\n"
"		return math.floor((psiz-bsiz)*((dat.num-dat.min)/(dat.max-dat.min)))\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function new_data(dat)\r\n"
"\r\n"
"	local dat=dat or {} -- probably use what is passed in only fill in more values\r\n"
"--	dat.widget=it.widget\r\n"
"--	dat.it=it\r\n"
"--	dat.id=id\r\n"
"\r\n"
"	dat.class=dat.class or \"number\" -- could also be a \"string\"\r\n"
"\r\n"
"-- make default values and ranges for every possible class\r\n"
"-- this is very heavy data...\r\n"
"\r\n"
"	dat.lst=dat.lst or {}\r\n"
"\r\n"
"	dat.str=dat.str or \"\"\r\n"
"	dat.str_idx=dat.str_idx or 0\r\n"
"\r\n"
"	dat.num=dat.num or 0\r\n"
"	dat.min=dat.min or 0 -- not negative by default\r\n"
"	dat.max=dat.max or (2^48) -- a big old number\r\n"
"	dat.size=dat.size or 0 -- if 0 then button is auto sized to some value\r\n"
"	dat.step=dat.step or 0 -- if 0 then there is no quantization\r\n"
"	\r\n"
"	\r\n"
"-- setup callback functions\r\n"
"\r\n"
"	dat.call_hook=call_hook\r\n"
"\r\n"
"	dat.get_string=data_get_string -- should be moved into value() ?\r\n"
"	dat.get_size=data_get_size\r\n"
"	dat.get_pos=data_get_pos\r\n"
"	\r\n"
"-- get or set the value\r\n"
"	dat.value=data_value\r\n"
"\r\n"
"-- work out snapping for scroll bars	\r\n"
"	dat.snap=data_snap\r\n"
"\r\n"
"	dat:value(dat,dat.num) -- triger value changed/set callbacks\r\n"
"	\r\n"
"	return dat\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"\r\n"
"",

"state.menu","\r\n"
"\r\n"
"local _G=_G\r\n"
"\r\n"
"local win=win\r\n"
"\r\n"
"local print=print\r\n"
"\r\n"
"local _M=module(...)\r\n"
"\r\n"
"\r\n"
"--	local block=master:add({hx=640,hy=480,color=0x00000000,static=true})\r\n"
"\r\n"
"local hooks={}\r\n"
"	function hooks.click(widget)\r\n"
"print(widget.id)\r\n"
"		if widget.id then\r\n"
"			if widget.id==\"yarn\" then\r\n"
"				_G.goto(\"yarn\")\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	\r\n"
"function setup()\r\n"
"\r\n"
"	win.widget:remove_all()\r\n"
"	local top=win.widget:add({hx=640,hy=480,mx=1,class=\"hx\",ax=0,ay=0})\r\n"
"	\r\n"
"	top:add({sy=5,sx=1})\r\n"
"	top:add({text=\"Play Sword Stone\",color=0x88ff0000,id=\"yarn\",hooks=hooks})\r\n"
"	top:add({sy=5,sx=1})\r\n"
"	\r\n"
"	win.widget:layout()\r\n"
"	\r\n"
"	win.widget.state=\"ready\"\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function clean()\r\n"
"	win.widget:remove_all()\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"",

"wetgenes.html","\n"
"local table=table\n"
"local string=string\n"
"\n"
"local type=type\n"
"local tostring=tostring\n"
"local setmetatable=setmetatable\n"
"\n"
"-- my string functions\n"
"local str=require(\"wetgenes.string\")\n"
"\n"
"module(\"wetgenes.html\")\n"
"\n"
"--\n"
"-- use the replace function from wetgenes.string\n"
"--\n"
"replace=str.replace\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- build a string from a template,  with a table to be used as its environment\n"
"--\n"
"-- this environment will not get modified by the called function as it is wrapped here\n"
"--\n"
"-- even though the calling function is free to modify the table it gets\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"get=function(html,src,env)\n"
"\n"
"	local new_env={}\n"
"	if env then setmetatable(new_env,{__index=env})	end -- wrap to protect\n"
"\n"
"	if html[src] then src=html[src] end\n"
"	\n"
"	if type(src)==\"function\" then return src(new_env) end\n"
"	\n"
"	if type(src)==\"string\" and env then return replace(src,new_env) end\n"
"\n"
"	return tostring(src)\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- very basic html esc to stop tags and entities from doing bad things\n"
"-- running text submitted from a user through this function should stop it from doing\n"
"-- anything other than just being text, it doesnt guarantee that it is valid xhtml / whatever\n"
"-- We just turn a few important characters into entities.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function esc(s)\n"
"	local escaped = { ['<']='&lt;', ['>']='&gt;', [\"&\"]='&amp;' }\n"
"	return (s:gsub(\"[<>&]\", function(c) return escaped[c] end))\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- basic url escape, so as not to trigger url get params or anything else by mistake \n"
"-- so = & # % ? \" ' are bad and get replaced with %xx\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_esc(s)\n"
"	return string.gsub(s, \"([&=%%%#%?%'%\\\" ><])\", function(c)\n"
"		return string.format(\"%%%02x\", string.byte(c))\n"
"	end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- a url escape, that only escapes the string deliminators ' and \" \n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_esc_string(s)\n"
"	return string.gsub(s, \"(['%\\\" ])\", function(c)\n"
"		return string.format(\"%%%02x\", string.byte(c))\n"
"	end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert any %xx into single chars\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_unesc(s)\n"
"	return string.gsub(s, \"%%(%x%x)\", function(hex)\n"
"		return string.char(tonumber(hex, 16))\n"
"	end)\n"
"end\n"
"\n"
"",

"fenestra.widget.scroll","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"-- a scrolling area, the widget is biger than display area but scroll bars allow you to see it all\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.scroll\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"\r\n"
"	local pan=widget.pan\r\n"
"	\r\n"
"	local pan_px=-widget.datx.num\r\n"
"	local pan_py=widget.daty.num\r\n"
"	\r\n"
"	if pan_px~=pan.pan_px or pan_py~=pan.pan_py then\r\n"
"	\r\n"
"		pan.pan_px=pan_px\r\n"
"		pan.pan_py=pan_py\r\n"
"		\r\n"
"		pan:set_dirty()\r\n"
"	end\r\n"
"\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function draw(widget)\r\n"
"\r\n"
"--	local it=widget.scroll\r\n"
"	\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"function layout(widget)\r\n"
"\r\n"
"--	local it=widget.scroll\r\n"
"	\r\n"
"	widget.meta.layout(widget.pan)\r\n"
"\r\n"
"	widget.datx.max=widget.pan.hx-widget.pan.sx\r\n"
"	if widget.datx.max<0 then widget.datx.max=0 end\r\n"
"	widget.datx.size=widget.pan.sx/widget.pan.hx\r\n"
"	\r\n"
"	widget.daty.max=widget.pan.hy-widget.pan.sy\r\n"
"	if widget.daty.max<0 then widget.daty.max=0 end\r\n"
"	widget.daty.size=widget.pan.sy/widget.pan.hy\r\n"
"	\r\n"
"	widget.meta.layout(widget)\r\n"
"end\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.scroll=it\r\n"
"	widget.class=\"scroll\"\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.layout=layout\r\n"
"	widget.draw=draw\r\n"
"\r\n"
"-- auto add the draging button as a child\r\n"
"	local ss=16\r\n"
"	if widget.hx<ss*2 then ss=widget.hx/2 end\r\n"
"	if widget.hy<ss*2 then ss=widget.hy/2 end\r\n"
"	\r\n"
"	widget.datx={max=1}\r\n"
"	widget.daty={max=1}\r\n"
"	\r\n"
"	widget.pan=		widget:add({class=\"pan\",	hx=widget.hx-ss,	hy=widget.hy-ss,	})\r\n"
"	widget.slidey=	widget:add({class=\"slide\",	hx=ss,				hy=widget.hy-ss,	px=widget.hx-ss,	py=0,\r\n"
"		datx={max=0},daty=widget.daty,color=0xffffffff})\r\n"
"	widget.slidex=	widget:add({class=\"slide\",	hx=widget.hx-ss,	hy=ss,           	px=0,           	py=widget.hy-ss,\r\n"
"		datx=widget.datx,daty={max=0},color=0xffffffff})\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"",

"spew.comm","\n"
"\n"
"\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local string=string\n"
"local math=math\n"
"local os=os\n"
"local print=print\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"--\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"module(\"spew.comm\")\n"
"\n"
"\n"
"-- all connections look up by client\n"
"cons=cons or {}\n"
"\n"
"-- waiting with data to read\n"
"active=active or {}\n"
"\n"
"-- create table of connections for use in socket.select\n"
"recvt=recvt or {}\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- create a con for this client\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function setup(client,opts)\n"
"\n"
"	if not client then return nil end\n"
"	\n"
"opts=opts or {}\n"
"\n"
"	local con={}\n"
"	cons[client]=con\n"
"	\n"
"	con.client=client\n"
"	con.format=opts.format\n"
"	con.linein={} -- lines come in here\n"
"	con.msg={} -- our current incoming msg for spew communication deltas\n"
"\n"
"-- keep a table for connect to use\n"
"	local n=#recvt+1\n"
"	recvt[n]=client\n"
"	recvt[client]=n\n"
"\n"
"	client:settimeout(0.00001) -- this is a hack fix?\n"
"	\n"
"	return con\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- remove this client from active clients, destroying the con\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function clean(client)\n"
"\n"
"local con=cons[client]\n"
"\n"
"	client:close()\n"
"	\n"
"	local n=recvt[client]\n"
"	recvt[client]=nil\n"
"	table.remove(recvt,n)\n"
"	\n"
"	cons[client]=nil\n"
"	active[client]=nil\n"
"\n"
"	return con\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get con from client\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function con(client)\n"
"	return cons[client]\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- client connect\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function connected(client,format)\n"
"\n"
"local con=cons[client]\n"
"\n"
"	client:settimeout(0.00001) -- this is a hack fix?\n"
"\n"
"	return con\n"
"end\n"
"				\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- client disconnect\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function disconnect(client)\n"
"	return clean(client)\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- send a line to a client\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function send(client,line)\n"
"\n"
"local con=cons[client]\n"
"\n"
"	if ( not client ) or ( not line ) or ( not con ) then return end\n"
"	\n"
"	if line~=\"\" then\n"
"	\n"
"		client:send(line)\n"
"		\n"
"--print(line)\n"
"\n"
"	end\n"
"\n"
"	return con\n"
"end\n"
"\n"
"	\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- receive some data from a client\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function received(client,line)\n"
"\n"
"local con=cons[client]\n"
"\n"
"local line_term=\"\\0\" -- spew default\n"
"\n"
"	if con.format==\"spew\" then -- default\n"
"--		line_term=\"\\0\"\n"
"	elseif con.format==\"telnet\" then -- break on \\n"
" not \\0\n"
"		line_term=\"\\n"
"\"\n"
"	elseif con.format==\"irc\" then -- break on \\n"
" not \\0\n"
"		line_term=\"\\n"
"\"\n"
"	elseif con.format==\"websocket\" then -- break on \\255 not \\0\n"
"		line_term=\"\\255\"\n"
"	end\n"
"	\n"
"	if con.lineparts then -- continue our cache\n"
"	\n"
"		con.lineparts=con.lineparts..line			\n"
"		\n"
"	else -- start new cache\n"
"	\n"
"		con.lineparts=line\n"
"		\n"
"	end\n"
"	\n"
"	if string.len(con.lineparts)>16384 then -- catch large packets\n"
"		return clean(client) -- and close connection on spam\n"
"	end\n"
"	\n"
"	local zero,linepart\n"
"	\n"
"	zero=string.find(con.lineparts,line_term)\n"
"	\n"
"	while zero do -- we have a command or more to split up\n"
"	\n"
"		if zero>1 then\n"
"		\n"
"			linepart=string.sub(con.lineparts,1,zero-1) -- command\n"
"			con.lineparts=string.sub(con.lineparts,zero+1) -- remainder\n"
"		\n"
"			table.insert(con.linein,linepart) -- handle this line later\n"
"		else\n"
"			con.lineparts=string.sub(con.lineparts,zero+1) -- remainder\n"
"		end\n"
"		\n"
"		zero=string.find(con.lineparts,line_term)\n"
"	end\n"
"\n"
"	if con.linein[1] then active[client]=con end -- flag the connection as waiting\n"
"\n"
"	return con\n"
"end\n"
"\n"
"\n"
"\n"
"",

"wetgenes.www.ngx","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\rlocal coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\rlocal log=require(\"wetgenes.www.any.log\").log\r\rmodule(...)\r\r",

"wetgenes.www.any.cache","\n"
"if ngx then\n"
"	return require(\"wetgenes.www.ngx.cache\")\n"
"else\n"
"	return require(\"wetgenes.www.gae.cache\")\n"
"end\n"
"",

"fenestra.avatar","\r\n"
"local bit=require('bit')\r\n"
"\r\n"
"\r\n"
"-- very simple xml parsing into a table\r\n"
"local sxml=require(\"simpxml\")\r\n"
"\r\n"
"local string=string\r\n"
"local table=table\r\n"
"local ipairs=ipairs\r\n"
"local math=math\r\n"
"local loadstring=loadstring\r\n"
"local pcall=pcall\r\n"
"local error=error\r\n"
"local io=io\r\n"
"local type=type\r\n"
"local tonumber=tonumber\r\n"
"\r\n"
"-- imported global functions\r\n"
"local sub = string.sub\r\n"
"local match = string.match\r\n"
"local find = string.find\r\n"
"local push = table.insert\r\n"
"local pop = table.remove\r\n"
"local append = table.insert\r\n"
"local concat = table.concat\r\n"
"local floor = math.floor\r\n"
"local write = io.write\r\n"
"local read = io.read\r\n"
"local type = type\r\n"
"local setfenv = setfenv\r\n"
"local tostring=tostring\r\n"
"local pairs=pairs\r\n"
"local ipairs=ipairs\r\n"
"local unpack=unpack\r\n"
"\r\n"
"local _G = _G\r\n"
"\r\n"
"local apps=apps\r\n"
"local wldir=apps.dir or \"\"\r\n"
"\r\n"
"module(\"fenestra.avatar\")\r\n"
"\r\n"
"--\r\n"
"-- avatar part group information\r\n"
"--\r\n"
"-- group is where the object is located, IE head\r\n"
"-- then look up the actual xox filename using the easy name used on a soul \r\n"
"-- finally you now have a chunk of data that describes this xox\r\n"
"--\r\n"
"xox_groups={\r\n"
"\r\n"
"inmouth =\r\n"
"{ \r\n"
"	joint					= { xox=	\"inmouth_joint\"			; boi=1; grl=1; active=1; };\r\n"
"	fag						= { xox=	\"inmouth_fag\"			; boi=1; grl=1; active=1; };\r\n"
"	pipe					= { xox=	\"inmouth_pipe\"			; boi=1; grl=1; active=1; };\r\n"
"	cigar					= { xox=	\"inmouth_cigar\"			; boi=1; grl=1; active=1; };\r\n"
"	sushi_nigiri			= { xox=	\"inmouth_sushi_nigiri\"	; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"inhand =\r\n"
"{ \r\n"
"	dagger					= { xox=	\"item_dagger_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	hammer					= { xox=	\"item_hammer_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	pistol					= { xox=	\"item_pistol_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	joint					= { xox=	\"item_joint_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	fag						= { xox=	\"item_fag_fist\"				; boi=1; grl=1; active=1; };\r\n"
"	joint					= { xox=	\"item_joint_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	pipe					= { xox=	\"item_pipe_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	cigar					= { xox=	\"item_cigar_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	bottle					= { xox=	\"item_bottle_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	bottle_smashed			= { xox=	\"item_bottle_smashed_fist\"	; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"beard =\r\n"
"{ \r\n"
"	default					= { xox=	\"beard_circle\"			; boi=1; grl=0; active=1; };\r\n"
"	circle					= { xox=	\"beard_circle\"			; boi=1; grl=0; active=1; };\r\n"
"	circle_point			= { xox=	\"beard_circle_point\"	; boi=1; grl=0; active=1; };\r\n"
"	tash					= { xox=	\"beard_tash\"			; boi=1; grl=0; active=1; };\r\n"
"	whiskers				= { xox=	\"beard_whiskers\"		; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"body =\r\n"
"{ \r\n"
"	\r\n"
"	bare					= { xox=	\"body_bare\"				; boi=1; grl=0; active=1; };\r\n"
"	bare_boobs				= { xox=	\"body_bare_boobs\"		; boi=0; grl=1; active=1; };\r\n"
"	\r\n"
"	robox					= { xox=	\"body_robox\"			; boi=0; grl=0; active=1; };\r\n"
"	\r\n"
"	bodess					= { xox=	\"body_bodess\"			; boi=0; grl=1; active=1; };\r\n"
"	\r\n"
"	tshirt					= { xox=	\"body_tshirt\"			; boi=1; grl=0; active=1; };\r\n"
"	tshirt_boobs			= { xox=	\"body_tshirt_boobs\"		; boi=0; grl=1; active=1; };\r\n"
"	tshirt_boobs_low		= { xox=	\"body_tshirt_boobs_low\"	; boi=0; grl=1; active=1; };\r\n"
"	\r\n"
"	coat					= { xox=	\"body_coat\"				; boi=1; grl=0; active=1; };\r\n"
"	overalls				= { xox=	\"body_overalls\"			; boi=1; grl=0; active=1; };\r\n"
"	vest					= { xox=	\"body_vest\"				; boi=1; grl=0; active=1; };\r\n"
"	vest_boobs				= { xox=	\"body_vest_boobs\"		; boi=0; grl=1; active=1; };\r\n"
"	\r\n"
"	tie						= { xox=	\"body_tie\"				; boi=1; grl=0; active=1; };\r\n"
"	tie_boobs				= { xox=	\"body_tie_boobs\"		; boi=0; grl=1; active=1; };\r\n"
"\r\n"
"	default					= { xox=	\"body\"					; boi=1; grl=0; active=1; };\r\n"
"	bare_boobs_small		= { xox=	\"body_bare_boobsa\"		; boi=0; grl=1; active=0; };\r\n"
"	bare_boobs_medium		= { xox=	\"body_bare_boobsc\"		; boi=0; grl=1; active=0; };\r\n"
"	bare_boobs_large		= { xox=	\"body_bare_boobse\"		; boi=0; grl=1; active=0; };\r\n"
"	bare_chest				= { xox=	\"body_bare_chest\"		; boi=1; grl=0; active=0; };\r\n"
"	bare_gut				= { xox=	\"body_bare_gut\"			; boi=1; grl=0; active=0; };\r\n"
"	bodess_medium			= { xox=	\"body_bodessc\"			; boi=0; grl=1; active=0; };\r\n"
"	bodess_large			= { xox=	\"body_bodesse\"			; boi=0; grl=1; active=0; };\r\n"
"	tshirt_boobs_small		= { xox=	\"body_tshirt_boobsa\"	; boi=0; grl=1; active=0; };\r\n"
"	tshirt_boobs_medium		= { xox=	\"body_tshirt_boobsc\"	; boi=0; grl=1; active=0; };\r\n"
"	tshirt_boobs_large		= { xox=	\"body_tshirt_boobse\"	; boi=0; grl=1; active=0; };\r\n"
"	tshirt_chest			= { xox=	\"body_tshirt_chest\"		; boi=1; grl=0; active=0; };\r\n"
"	tshirt_gut				= { xox=	\"body_tshirt_gut\"		; boi=1; grl=0; active=0; };\r\n"
"	tshirt_lowcut_large		= { xox=	\"body_tshirt_lowcute\"	; boi=0; grl=3; active=0; };\r\n"
"	tshirt_skinny			= { xox=	\"body_tshirt_skinny\"	; boi=1; grl=0; active=0; };\r\n"
"	\r\n"
"},\r\n"
"\r\n"
"tail =\r\n"
"{ \r\n"
"	default					= { xox=	\"tail\"					; boi=1; grl=1; active=1; };\r\n"
"	bunny					= { xox=	\"tail_bunny\"			; boi=0; grl=1; active=1; };\r\n"
"	devil					= { xox=	\"tail_devil\"			; boi=0; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"ear =\r\n"
"{ \r\n"
"	default					= { xox=	\"ear\"					; boi=1; grl=1; active=1; };\r\n"
"	big						= { xox=	\"ear_big\"				; boi=1; grl=1; active=1; };\r\n"
"	big_sticky				= { xox=	\"ear_big_sticky\"		; boi=1; grl=1; active=1; };\r\n"
"	robox					= { xox=	\"ear_robox\"				; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"eye =\r\n"
"{ \r\n"
"	default					= { xox=	\"eye\"					; boi=1; grl=1; active=1; };\r\n"
"	bigbrow					= { xox=	\"eye_bigbrow\"			; boi=1; grl=1; active=1; };\r\n"
"	brow					= { xox=	\"eye_brow\"				; boi=0; grl=0; active=1; };\r\n"
"	tribrow					= { xox=	\"eye_tribrow\"			; boi=1; grl=1; active=1; };\r\n"
"	robox					= { xox=	\"eye_robox\"				; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"eyeball =\r\n"
"{ \r\n"
"	default					= { xox=	\"eyeball\"				; boi=5; grl=5; active=1; };\r\n"
"	diamond					= { xox=	\"eyeball_cat\"			; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"foot =\r\n"
"{ \r\n"
"	default					= { xox=	\"foot\"					; boi=1; grl=1; active=1; };\r\n"
"	bare					= { xox=	\"foot_bare\"				; boi=1; grl=1; active=1; };\r\n"
"	boot					= { xox=	\"foot_boot\"				; boi=1; grl=1; active=1; };\r\n"
"	flipflop				= { xox=	\"foot_flipflop\"			; boi=1; grl=1; active=1; };\r\n"
"	slipper					= { xox=	\"foot_slipper\"			; boi=1; grl=1; active=1; };\r\n"
"	heel					= { xox=	\"foot_heel\"				; boi=0; grl=1; active=1; };\r\n"
"	shoe					= { xox=	\"foot_shoe\"				; boi=1; grl=1; active=1; };\r\n"
"	hoof					= { xox=	\"foot_hoof\"				; boi=0; grl=0; active=1; };\r\n"
"	robox					= { xox=	\"foot_robox\"			; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"hair =\r\n"
"{ \r\n"
"	topspiked_short			= { xox=	\"hair_topspiked_short\"		; boi=1; grl=1; active=1; };\r\n"
"	peak					= { xox=	\"hair_peak\"					; boi=1; grl=1; active=1; };\r\n"
"	\r\n"
"	bob						= { xox=	\"hair_bob\"					; boi=1; grl=1; active=1; };\r\n"
"	goth_long				= { xox=	\"hair_goth_long\"			; boi=1; grl=1; active=1; };\r\n"
"	spikey_short			= { xox=	\"hair_spikey_short\"			; boi=1; grl=1; active=1; };\r\n"
"	trihawk_short			= { xox=	\"hair_trihawk_short\"		; boi=1; grl=1; active=1; };\r\n"
"	trihawk_hi				= { xox=	\"hair_trihawk_hi\"			; boi=1; grl=1; active=1; };\r\n"
"	hedgehog				= { xox=	\"hair_hedgehog\"				; boi=1; grl=1; active=1; };\r\n"
"	afro					= { xox=	\"hair_afro\"					; boi=1; grl=1; active=1; };\r\n"
"	afro_tall				= { xox=	\"hair_afro_tall\"			; boi=1; grl=1; active=1; };\r\n"
"		\r\n"
"	quiff					= { xox=	\"hair_quiff\"				; boi=1; grl=1; active=1; };\r\n"
"	curl_left				= { xox=	\"hair_curl_left\"			; boi=1; grl=1; active=1; };\r\n"
"	curl_right				= { xox=	\"hair_curl_right\"			; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"hair_base =\r\n"
"{ \r\n"
"	default					= { xox=	\"hair\"						; boi=1; grl=1; active=1; };\r\n"
"	bowl					= { xox=	\"hair_bowl\"					; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"hair_xtra =\r\n"
"{ \r\n"
"	ponytail				= { xox=	\"hair_ponytail\"				; boi=1; grl=1; active=1; };\r\n"
"	pigtails				= { xox=	\"hair_pigtails\"				; boi=1; grl=1; active=1; };\r\n"
"	long					= { xox=	\"hair_long\"					; boi=1; grl=1; active=1; };\r\n"
"	bunches					= { xox=	\"hair_bunches\"				; boi=1; grl=1; active=1; };\r\n"
"	bang					= { xox=	\"hair_bang_base\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_zigs				= { xox=	\"hair_bang_zigs\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_goff				= { xox=	\"hair_bang_goff\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_sidel				= { xox=	\"hair_bang_sidel\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_sider				= { xox=	\"hair_bang_sider\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_emol				= { xox=	\"hair_bang_emol\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_emor				= { xox=	\"hair_bang_emor\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_nerd				= { xox=	\"hair_bang_nerd\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_hugh				= { xox=	\"hair_bang_hugh\"			; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"hat =\r\n"
"{ \r\n"
"	baseball				= { xox=	\"hat_baseball\"				; boi=1; grl=1; active=1; };\r\n"
"	pirate					= { xox=	\"hat_pirate\"				; boi=1; grl=1; active=1; };\r\n"
"	kerchief				= { xox=	\"hat_kerchief\"				; boi=1; grl=1; active=1; };\r\n"
"	bunny_ears				= { xox=	\"hat_bunny_ears\"			; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"hand =\r\n"
"{ \r\n"
"	default					= { xox=	\"hand\"					; boi=1; grl=1; active=1; };\r\n"
"	foot					= { xox=	\"hand_foot\"				; boi=0; grl=0; active=1; };\r\n"
"	hoof					= { xox=	\"hand_hoof\"				; boi=0; grl=0; active=1; };\r\n"
"	robox					= { xox=	\"hand_robox\"			; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"head =\r\n"
"{ \r\n"
"	default					= { xox=	\"head\"					; boi=1; grl=1; active=1; };\r\n"
"	cheekbones				= { xox=	\"head_cheakbones\"		; boi=1; grl=1; active=0; };\r\n"
"	chub					= { xox=	\"head_chub\"				; boi=1; grl=1; active=0; };\r\n"
"	thin					= { xox=	\"head_thin\"				; boi=1; grl=1; active=0; };\r\n"
"	skull					= { xox=	\"head_skull\"			; boi=0; grl=0; active=1; };\r\n"
"	robox					= { xox=	\"head_robox\"			; boi=0; grl=0; active=1; };\r\n"
"	chinless				= { xox=	\"head_chinless\"			; boi=0; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"mouth =\r\n"
"{ \r\n"
"	default					= { xox=	\"mouth\"					; boi=1; grl=1; active=1; };\r\n"
"	bow						= { xox=	\"mouth_bow\"				; boi=1; grl=1; active=1; };\r\n"
"	bow_fat					= { xox=	\"mouth_bow_fat\"			; boi=1; grl=1; active=1; };\r\n"
"	bow_thin				= { xox=	\"mouth_bow_thin\"		; boi=1; grl=1; active=1; };\r\n"
"	fat						= { xox=	\"mouth_fat\"				; boi=1; grl=1; active=1; };\r\n"
"	thin					= { xox=	\"mouth_thin\"			; boi=1; grl=1; active=1; };\r\n"
"	beak					= { xox=	\"mouth_beak\"			; boi=0; grl=0; active=1; };\r\n"
"	squid					= { xox=	\"mouth_squid\"			; boi=0; grl=0; active=1; };\r\n"
"	jaw						= { xox=	\"mouth_jaw\"				; boi=0; grl=0; active=1; };\r\n"
"	robox					= { xox=	\"mouth_robox\"			; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"nose =\r\n"
"{ \r\n"
"	default					= { xox=	\"nose\"					; boi=1; grl=1; active=1; };\r\n"
"	small					= { xox=	\"nose_small\"			; boi=1; grl=1; active=1; };\r\n"
"	small_up				= { xox=	\"nose_small_up\"			; boi=1; grl=1; active=1; };\r\n"
"	snub					= { xox=	\"nose_snub\"				; boi=1; grl=1; active=1; };\r\n"
"	wide					= { xox=	\"nose_wide\"				; boi=1; grl=1; active=1; };\r\n"
"	wide_up					= { xox=	\"nose_wide_up\"			; boi=1; grl=1; active=1; };\r\n"
"	clown					= { xox=	\"nose_clown\"			; boi=0; grl=0; active=1; };\r\n"
"	snout					= { xox=	\"nose_snout\"			; boi=0; grl=0; active=1; };\r\n"
"	robox					= { xox=	\"nose_robox\"			; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"specs =\r\n"
"{ \r\n"
"	default					= { xox=	\"specs\"					; boi=1; grl=1; active=1; };\r\n"
"	round					= { xox=	\"specs_round\"			; boi=1; grl=1; active=1; };\r\n"
"	eyepatch_left			= { xox=	\"specs_eyepatch_left\"	; boi=1; grl=1; active=1; };\r\n"
"	eyepatch_right			= { xox=	\"specs_eyepatch_right\"	; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"}\r\n"
"for g,t in pairs(xox_groups) do\r\n"
"	for n,v in pairs(t) do\r\n"
"		v.group=g\r\n"
"		v.name=n\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- split a string into a table\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"local function split(div,str)\r\n"
"\r\n"
"  if (div=='') or not div then error(\"div expected\", 2) end\r\n"
"  if (str=='') or not str then error(\"str expected\", 2) end\r\n"
"  \r\n"
"  local pos,arr = 0,{}\r\n"
"  \r\n"
"  -- for each divider found\r\n"
"  for st,sp in function() return string.find(str,div,pos,false) end do\r\n"
"	table.insert(arr,sub(str,pos,st-1)) -- Attach chars left of current divider\r\n"
"	pos = sp + 1 -- Jump past current divider\r\n"
"  end\r\n"
"  \r\n"
"  if pos~=0 then\r\n"
"	table.insert(arr,sub(str,pos)) -- Attach chars right of last divider\r\n"
"  else\r\n"
"	table.insert(arr,str) -- return entire string\r\n"
"  end\r\n"
"  \r\n"
"  \r\n"
"  return arr\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find the basename from a filename\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"local function get_basename(name)\r\n"
"\r\n"
"	local a1=split(\"%/\",name)\r\n"
"	local a2=split(\"%.\",a1[#a1])\r\n"
"	local a3=split(\"%_\",a2[1])\r\n"
"	local s=a3[1]\r\n"
"	\r\n"
"	if s==\"left\" or s==\"right\" then s=a3[2] end\r\n"
"	\r\n"
"	return s\r\n"
"end\r\n"
"\r\n"
"function setup(win)\r\n"
"\r\n"
"	local function print(...)\r\n"
"		win._g.print(...)\r\n"
"	end\r\n"
"\r\n"
"	local ogl=win.ogl\r\n"
"\r\n"
"	local it={}\r\n"
"	\r\n"
"	it.basename_map={\r\n"
"		[	\"body\"			]	=	\"body\"				,\r\n"
"		[	\"head\"			]	=	\"head\"				,\r\n"
"		[	\"foot\"			]	=	\"left_foot\"			,\r\n"
"		[	\"foot_flip\"		]	=	\"right_foot\"		,\r\n"
"		[	\"hair\"			]	=	\"hair\"				,\r\n"
"		[	\"ear\"			]	=	\"left_ear\"			,\r\n"
"		[	\"ear_flip\"		]	=	\"right_ear\"			,\r\n"
"		[	\"nose\"			]	=	\"nose\"				,\r\n"
"		[	\"mouth\"			]	=	\"mouth\"				,\r\n"
"		[	\"eye\"			]	=	\"left_eye\"			,\r\n"
"		[	\"eye_flip\"		]	=	\"right_eye\"			,\r\n"
"		[	\"tail\"			]	=	\"tail\"				,\r\n"
"		[	\"hand\"			]	=	\"left_hand\"			,\r\n"
"		[	\"hand_flip\" 	]	=	\"right_hand\"		,\r\n"
"		[	\"eyeball\"		]	=	\"left_eyeball\"		,\r\n"
"		[	\"eyeball_flip\"	]	=	\"right_eyeball\"		,\r\n"
"	}\r\n"
"	\r\n"
"	it.bodyparts={\r\n"
"		body				={\"body\"},\r\n"
"		head				={\"head\"},\r\n"
"		left_foot			={\"foot\"},\r\n"
"		right_foot			={\"foot\"},\r\n"
"		hair				={\"hair\"},\r\n"
"		left_ear			={\"ear\"},\r\n"
"		right_ear			={\"ear\"},\r\n"
"		nose				={\"nose\"},\r\n"
"		mouth				={\"mouth\"},\r\n"
"		left_eye			={\"eye\"},\r\n"
"		right_eye			={\"eye\"},\r\n"
"		tail				={\"tail\"},\r\n"
"		left_hand			={\"hand\"},\r\n"
"		right_hand			={\"hand\"},\r\n"
"		left_eyeball		={\"eyeball\"},\r\n"
"		right_eyeball		={\"eyeball\"},\r\n"
"	}\r\n"
"	\r\n"
"	function it.clean()\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"--\r\n"
"-- Load avatar parts into an xsx for display\r\n"
"--	\r\n"
"	function it.map_xsx(xsx,soul)\r\n"
"	\r\n"
"\r\n"
"		for i,v in ipairs(xsx.items) do\r\n"
"		\r\n"
"			local name=get_basename(v.name)\r\n"
"			local flip=((v.flags%2)==1)\r\n"
"			if flip then name=name..\"_flip\" end\r\n"
"			\r\n"
"			local name=it.basename_map[name]\r\n"
"			\r\n"
"--			print(name or i)\r\n"
"			\r\n"
"			if name then\r\n"
"				local part=soul.vanilla.parts[name]\r\n"
"				if part then\r\n"
"					v.fname=v.fname or {}\r\n"
"					v.data=v.data or {}\r\n"
"					v.soulinfo=v.soulinfo or {}\r\n"
"					\r\n"
"					v.size[1]=part.xsize or 1 -- v.size[1]\r\n"
"					v.size[2]=part.ysize or 1 -- v.size[2]\r\n"
"					v.size[3]=part.zsize or 1 -- v.size[3]\r\n"
"					\r\n"
"					v.morphs[1]=part.morph0 or 0\r\n"
"					v.morphs[2]=part.morph1 or 0\r\n"
"					v.morphs[3]=part.morph2 or 0\r\n"
"					v.morphs[4]=part.morph3 or 0\r\n"
"					\r\n"
"					v.pos[1]=part.xpos or 0 -- v.size[1]\r\n"
"					v.pos[2]=part.ypos or 0 -- v.size[2]\r\n"
"					v.pos[3]=part.zpos or 0 -- v.size[3]\r\n"
"					\r\n"
"					for i=1,4 do\r\n"
"					\r\n"
"						v.soulinfo[i]=part[i]\r\n"
"							\r\n"
"						if part[i] and part[i].xox_info and part[i].xox_info.xox then\r\n"
"					\r\n"
"							local fname=\"data/avatar/xox/\"..part[i].xox_info.xox..\".xox\"\r\n"
"							\r\n"
"							if v.fname[i]~=fname then\r\n"
"							\r\n"
"								if v[i] then v[i].clean() end\r\n"
"								\r\n"
"								v.data[i]=win.data.load(fname)\r\n"
"								v[i]=win.xox(v.data[i])\r\n"
"								v.fname[i]=fname\r\n"
"								\r\n"
"							end\r\n"
"							\r\n"
"							if v[i] then\r\n"
"								for i,v in ipairs(v[i].surfaces or {}) do\r\n"
"								\r\n"
"									local surf=soul.vanilla.surfaces[v.name]\r\n"
"									if surf then\r\n"
"										v.argb =surf.argb  or v.argb\r\n"
"										v.spec =surf.spec  or v.spec\r\n"
"										v.gloss=surf.gloss or v.gloss\r\n"
"									end\r\n"
"--print(\"surf:\"..v.name..\" \"..v.spec..\" \"..v.gloss)\r\n"
"								\r\n"
"								end\r\n"
"								\r\n"
"								v[i].set()\r\n"
"							end\r\n"
"							\r\n"
"							\r\n"
"						else\r\n"
"							if v[i] then v[i].clean() end\r\n"
"							v[i]=nil\r\n"
"							v.fname[i]=nil\r\n"
"							v.data[i]=nil\r\n"
"						end\r\n"
"					end\r\n"
"					\r\n"
"				end\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"		xsx.set()\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"--\r\n"
"-- Load an avatars soul (xml file)\r\n"
"--	\r\n"
"	function it.load_soul(filename,d)\r\n"
"	\r\n"
"		local soul={}\r\n"
"		if not d then -- did not pass in data, read it from a file\r\n"
"--print(\"soul : \"..filename)\r\n"
"			local fp=io.open(filename,\"r\")\r\n"
"			d=fp:read(\"*a\")\r\n"
"			fp:close()\r\n"
"		end\r\n"
"		\r\n"
"		local tab=sxml.parse(d)\r\n"
"--print(sxml.tree_to_string(tab))\r\n"
"		local t=tab\r\n"
"		\r\n"
"		local function isa(t,s)\r\n"
"			if type(t)~=\"table\" then return false end\r\n"
"			if t[0]==s then return true end\r\n"
"			return false\r\n"
"		end\r\n"
"		\r\n"
"		local function fromhex(s)\r\n"
"			if s then\r\n"
"				if s:sub(1,2)==\"0x\" then\r\n"
"					return tonumber(s:sub(3),16)\r\n"
"				else\r\n"
"					return tonumber(s,16)\r\n"
"				end\r\n"
"			end\r\n"
"			return nil\r\n"
"		end\r\n"
"		local function fromnum(s)\r\n"
"			if s then return tonumber(s) end\r\n"
"			return nil\r\n"
"		end\r\n"
"		\r\n"
"		t=sxml.child(t,\"soul\")\r\n"
"		for i,v in ipairs(t) do\r\n"
"		\r\n"
"			if isa(v,\"flavour\") then -- for each flavour\r\n"
"			\r\n"
"				local dat={}\r\n"
"				soul[v.name]=dat\r\n"
"				dat.parts={}\r\n"
"				dat.surfaces={}\r\n"
"			\r\n"
"				for i,v in ipairs(v) do\r\n"
"				\r\n"
"					if isa(v,\"part\") then -- for each part\r\n"
"					\r\n"
"						local p={}\r\n"
"						dat.parts[v.name]=p\r\n"
"						\r\n"
"						for i,v in pairs(v) do\r\n"
"							if type(i)==\"string\" then -- set all attribs\r\n"
"								if i~=\"name\" then\r\n"
"									p[i]=v\r\n"
"								end\r\n"
"							end\r\n"
"						end\r\n"
"						\r\n"
"						local idx=1\r\n"
"						for i,v in ipairs(v) do\r\n"
"							if type(v)==\"table\" and v[0]==\"object\" then -- an object\r\n"
"								local o={}\r\n"
"								p[idx]=o\r\n"
"								\r\n"
"								for i,v in pairs(v) do\r\n"
"									if type(i)==\"string\" then -- set all attribs\r\n"
"										o[i]=v\r\n"
"									end\r\n"
"								end\r\n"
"								\r\n"
"								o.xox_info=xox_groups[ o.group ]\r\n"
"								if o.xox_info then\r\n"
"									o.xox_info=o.xox_info[ o.name ]\r\n"
"								end\r\n"
"								\r\n"
"								\r\n"
"								idx=idx+1\r\n"
"								if idx>4 then break end\r\n"
"							end\r\n"
"						end\r\n"
"						\r\n"
"						p.xpos=fromnum(p.xpos)\r\n"
"						p.ypos=fromnum(p.ypos)\r\n"
"						p.zpos=fromnum(p.zpos)\r\n"
"						\r\n"
"						p.xsize=fromnum(p.xsize)\r\n"
"						p.ysize=fromnum(p.ysize)\r\n"
"						p.zsize=fromnum(p.zsize)\r\n"
"						\r\n"
"						p.morph0=fromnum(p.morph0)\r\n"
"						p.morph1=fromnum(p.morph1)\r\n"
"						p.morph2=fromnum(p.morph2)\r\n"
"						p.morph3=fromnum(p.morph3)\r\n"
"\r\n"
"					\r\n"
"					elseif isa(v,\"surface\") then -- for each surface\r\n"
"					\r\n"
"						local p={}\r\n"
"						dat.surfaces[v.name]=p\r\n"
"						\r\n"
"						for i,v in pairs(v) do\r\n"
"							if type(i)==\"string\" then -- set all attribs\r\n"
"								if i~=\"name\" then\r\n"
"									p[i]=v\r\n"
"								end\r\n"
"							end\r\n"
"						end\r\n"
"						\r\n"
"						p.argb=bit.bor(fromhex(p.argb),0xff000000)\r\n"
"						p.spec=bit.bor(fromhex(p.spec),0xff000000)\r\n"
"						p.gloss=2+(tonumber(p.gloss)*126) -- make 0 a \"good gloss number\"\r\n"
"						\r\n"
"					end\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"--		print(soul)\r\n"
"\r\n"
"\r\n"
"-- whoops spilling\r\n"
"		soul.vanilla=soul.vanilla or soul.vanila\r\n"
"		soul.vanila=nil\r\n"
"-- whoops spilling\r\n"
"\r\n"
"		return soul\r\n"
"	end\r\n"
"	\r\n"
"--\r\n"
"-- Save an avatars soul (xml file)\r\n"
"--	\r\n"
"	function it.save_soul(soul,filename)\r\n"
"	\r\n"
"		local tree={}\r\n"
"		tree[1]={[0]=\"soul\",version=\"1.0\"}\r\n"
"		for i,v in pairs(soul) do\r\n"
"			local t=tree[1]\r\n"
"			t[#t+1]={[0]=\"flavour\",name=i}\r\n"
"			t=t[#t]\r\n"
"			for i,v in pairs(v.parts) do\r\n"
"				t[#t+1]={[0]=\"part\",name=i}\r\n"
"				local p=t[#t]\r\n"
"				for ii,vv in pairs(v) do\r\n"
"					if type(ii)==\"string\" then\r\n"
"						p[ii]=tostring(vv)\r\n"
"					end\r\n"
"				end\r\n"
"				for i=1,4 do\r\n"
"					p[#p+1]={[0]=\"object\"}\r\n"
"					local o=p[#p]\r\n"
"					for ii,vv in pairs(v[i] or {}) do\r\n"
"						if type(ii)==\"string\" and type(vv)~=\"table\" then\r\n"
"							o[ii]=tostring(vv)\r\n"
"						end\r\n"
"					end\r\n"
"				end\r\n"
"			end\r\n"
"			for i,v in pairs(v.surfaces) do\r\n"
"				t[#t+1]={[0]=\"surface\",name=i}\r\n"
"				local s=t[#t]\r\n"
"				for ii,vv in pairs(v) do\r\n"
"					if type(ii)==\"string\" then\r\n"
"						s[ii]=tostring(vv)\r\n"
"					end\r\n"
"				end\r\n"
"				if s.argb then s.argb=string.format(\"0x%08x\",s.argb) end -- use hex\r\n"
"				if s.spec then s.spec=string.format(\"0x%08x\",s.spec) end -- use hex\r\n"
"				if s.gloss then s.gloss=(s.gloss-2)/126 end -- slight number fiddle, sorry\r\n"
"			end\r\n"
"		end\r\n"
"	\r\n"
"		local fp=io.open(filename,\"w\")\r\n"
"		if not fp then return false,\"open failed\" end\r\n"
"		fp:write(\r\n"
"		sxml.tree_to_string(tree))\r\n"
"		fp:close()\r\n"
"		\r\n"
"		return true\r\n"
"	end\r\n"
"	\r\n"
"	return it\r\n"
"end\r\n"
"",

"mime","-----------------------------------------------------------------------------\n"
"-- MIME support for the Lua language.\n"
"-- Author: Diego Nehab\n"
"-- Conforming to RFCs 2045-2049\n"
"-- RCS ID: $Id: mime.lua,v 1.29 2007/06/11 23:44:54 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local ltn12 = require(\"ltn12\")\n"
"local mime = require(\"mime.core\")\n"
"local io = require(\"io\")\n"
"local string = require(\"string\")\n"
"module(\"mime\")\n"
"\n"
"-- encode, decode and wrap algorithm tables\n"
"encodet = {}\n"
"decodet = {}\n"
"wrapt = {}\n"
"\n"
"-- creates a function that chooses a filter by name from a given table\n"
"local function choose(table)\n"
"    return function(name, opt1, opt2)\n"
"        if base.type(name) ~= \"string\" then\n"
"            name, opt1, opt2 = \"default\", name, opt1\n"
"        end\n"
"        local f = table[name or \"nil\"]\n"
"        if not f then \n"
"            base.error(\"unknown key (\" .. base.tostring(name) .. \")\", 3)\n"
"        else return f(opt1, opt2) end\n"
"    end\n"
"end\n"
"\n"
"-- define the encoding filters\n"
"encodet['base64'] = function()\n"
"    return ltn12.filter.cycle(b64, \"\")\n"
"end\n"
"\n"
"encodet['quoted-printable'] = function(mode)\n"
"    return ltn12.filter.cycle(qp, \"\",\n"
"        (mode == \"binary\") and \"=0D=0A\" or \"\\r\\n"
"\")\n"
"end\n"
"\n"
"-- define the decoding filters\n"
"decodet['base64'] = function()\n"
"    return ltn12.filter.cycle(unb64, \"\")\n"
"end\n"
"\n"
"decodet['quoted-printable'] = function()\n"
"    return ltn12.filter.cycle(unqp, \"\")\n"
"end\n"
"\n"
"local function format(chunk)\n"
"    if chunk then\n"
"        if chunk == \"\" then return \"''\"\n"
"        else return string.len(chunk) end\n"
"    else return \"nil\" end\n"
"end\n"
"\n"
"-- define the line-wrap filters\n"
"wrapt['text'] = function(length)\n"
"    length = length or 76\n"
"    return ltn12.filter.cycle(wrp, length, length)\n"
"end\n"
"wrapt['base64'] = wrapt['text']\n"
"wrapt['default'] = wrapt['text']\n"
"\n"
"wrapt['quoted-printable'] = function()\n"
"    return ltn12.filter.cycle(qpwrp, 76, 76)\n"
"end\n"
"\n"
"-- function that choose the encoding, decoding or wrap algorithm\n"
"encode = choose(encodet)\n"
"decode = choose(decodet)\n"
"wrap = choose(wrapt)\n"
"\n"
"-- define the end-of-line normalization filter\n"
"function normalize(marker)\n"
"    return ltn12.filter.cycle(eol, 0, marker)\n"
"end\n"
"\n"
"-- high level stuffing filter\n"
"function stuff()\n"
"    return ltn12.filter.cycle(dot, 2)\n"
"end\n"
"",


0,0};

