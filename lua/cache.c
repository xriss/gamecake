
	const char *wetgenes_wetmods_version()
	{
		return "Featuring WetMods V13.627 https://bitbucket.org/xixs/lua\nprofiler wetgenes.pack.core zip zlib wetgenes.freetype.core bit wetgenes.ogg.core al.core alc.core wetgenes.tardis.core gles.core wetgenes.grd.core wetgenes.grdmap.core wetgenes.sod.core wetgenes.speak.core lash lfs socket.core mime.core sqlite lua51-lanes posix_c wetgenes.gamecake.core wetgenes.win.core wetgenes.win.linux.core";
	}


const char* wetgenes_cache_lua_mods[]={

"wetgenes.pack","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local pack={}\n"
"\n"
"local core=require(\"wetgenes.pack.core\")\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"local bit=require(\"bit\")\n"
"\n"
"--\n"
"-- Read a single member and return it\n"
"--\n"
"pack.read=function(dats,fmt,off)\n"
"	local datt,len=core.load(dats,{fmt},off)\n"
"	return datt and datt[1]\n"
"end\n"
"\n"
"--\n"
"-- Read an array of the same type\n"
"--\n"
"pack.load_array=function(dats,fmt,off,count)\n"
"	return core.load(dats,fmt,off,count)\n"
"end\n"
"\n"
"--\n"
"-- write an array of the same type\n"
"--\n"
"pack.save_array=function(dats,fmt,off,count,buff)\n"
"	return core.save(dats,fmt,off,buff)\n"
"end\n"
"\n"
"--\n"
"-- wrap the core functions with easier to use utility code\n"
"--\n"
"-- format is \"u32\",\"name\",...\n"
"-- where \"u32\" is a string id of a data type or the length of a string to read\n"
"-- name is the name of the table field to return the data in\n"
"--\n"
"-- we return a table and the length of the data read in bytes\n"
"-- \n"
"--\n"
"pack.load=function(dats,fmts,off)\n"
"\n"
"	local fmtt={} -- format field type\n"
"	local fmtn={} -- format field name\n"
"	\n"
"	local len=0\n"
"	for i=1,#fmts,2 do -- deinterlace\n"
"		local vt=fmts[i]\n"
"		local vn=fmts[i+1]\n"
"		\n"
"		len=len+1\n"
"		\n"
"		fmtt[len]=vt -- break input into two tables type and name\n"
"		fmtn[len]=vn\n"
"		\n"
"	end\n"
"\n"
"-- parse the data	\n"
"	local datt,len=core.load(dats,fmtt,off)\n"
"\n"
"-- now we assign the fields to their given names\n"
"\n"
"	local datr={}\n"
"	for i,v in ipairs(fmtn) do\n"
"		datr[v]=datt[i]\n"
"	end\n"
"\n"
"	return datr,len -- we return the parsed data and the length of the data we just read in bytes\n"
"end\n"
"\n"
"--\n"
"-- the reverse of load\n"
"-- we return a string and the length of the data written in bytes, ie the length of the string\n"
"--\n"
"pack.save=function(data,fmts,off)\n"
"	local fmtt={} -- format field type\n"
"	local fmtn={} -- format field name\n"
"	\n"
"	local len=0\n"
"	for i=1,#fmts,2 do\n"
"		local vt=fmts[i]\n"
"		local vn=fmts[i+1]\n"
"		\n"
"		len=len+1\n"
"		\n"
"		fmtt[len]=vt -- break input into two tables type and name\n"
"		fmtn[len]=vn\n"
"		\n"
"	end\n"
"	\n"
"	local datd={} -- place in correct order\n"
"	for i,v in pairs(fmtn) do\n"
"		datd[i]=data[v]\n"
"	end\n"
"\n"
"-- parse the data into a string\n"
"	local dat,len=core.save(datd,fmtt,off)\n"
"\n"
"	return dat,len -- we return the parsed data and the length of the data we just read in bytes\n"
"end\n"
"\n"
"pack.alloc=function(size)\n"
"	return core.alloc(size)\n"
"end\n"
"pack.sizeof=function(ud)\n"
"	return core.sizeof(ud)\n"
"end\n"
"pack.tostring=function(ud)\n"
"	return core.tostring(ud)\n"
"end\n"
"\n"
"\n"
"-- convert a 16bit color to 4 floats, with premultiplied alpha\n"
"-- ie so it can be used in a gl.Color() call\n"
"pack.argb4_pmf4=function(c)\n"
"	local r,g,b,a\n"
"	\n"
"	a=bit.band(bit.rshift(c,12),0xf)\n"
"	r=bit.band(bit.rshift(c, 8),0xf)\n"
"	g=bit.band(bit.rshift(c, 4),0xf)\n"
"	b=bit.band(c,0xf)\n"
"\n"
"	a=a/0xf\n"
"	return a*r/0xf,a*g/0xf,a*b/0xf,a\n"
"end\n"
"\n"
"-- same again but 32bit\n"
"pack.argb8_pmf4=function(c)\n"
"	local r,g,b,a\n"
"	\n"
"	a=bit.band(bit.rshift(c,24),0xff)\n"
"	r=bit.band(bit.rshift(c,16),0xff)\n"
"	g=bit.band(bit.rshift(c, 8),0xff)\n"
"	b=bit.band(c,0xff)\n"
"\n"
"	a=a/0xff\n"
"	return a*r/0xff,a*g/0xff,a*b/0xff,a\n"
"end\n"
"\n"
"-- pack 4 gl floats into 1 32bit color\n"
"pack.f4_argb=function(r,g,b,a)\n"
"	\n"
"	a=bit.band(a*0xff,0xff)\n"
"	r=bit.band(r*0xff,0xff)\n"
"	g=bit.band(g*0xff,0xff)\n"
"	b=bit.band(b*0xff,0xff)\n"
"	\n"
"	return  (a*0x01000000 + r*0x00010000 + g*0x00000100 + b*0x00000001)\n"
"end\n"
"\n"
"return pack\n"
"",

"socket.url","-----------------------------------------------------------------------------\n"
"-- URI parsing, composition and relative URL resolution\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: url.lua,v 1.38 2006/04/03 04:45:42 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module\n"
"-----------------------------------------------------------------------------\n"
"local string = require(\"string\")\n"
"local base = _G\n"
"local table = require(\"table\")\n"
"module(\"socket.url\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Module version\n"
"-----------------------------------------------------------------------------\n"
"_VERSION = \"URL 1.0.1\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Encodes a string into its escaped hexadecimal representation\n"
"-- Input\n"
"--   s: binary string to be encoded\n"
"-- Returns\n"
"--   escaped representation of string binary\n"
"-----------------------------------------------------------------------------\n"
"function escape(s)\n"
"    return string.gsub(s, \"([^A-Za-z0-9_])\", function(c)\n"
"        return string.format(\"%%%02x\", string.byte(c))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Protects a path segment, to prevent it from interfering with the\n"
"-- url parsing.\n"
"-- Input\n"
"--   s: binary string to be encoded\n"
"-- Returns\n"
"--   escaped representation of string binary\n"
"-----------------------------------------------------------------------------\n"
"local function make_set(t)\n"
"	local s = {}\n"
"	for i,v in base.ipairs(t) do\n"
"		s[t[i]] = 1\n"
"	end\n"
"	return s\n"
"end\n"
"\n"
"-- these are allowed withing a path segment, along with alphanum\n"
"-- other characters must be escaped\n"
"local segment_set = make_set {\n"
"    \"-\", \"_\", \".\", \"!\", \"~\", \"*\", \"'\", \"(\",\n"
"	\")\", \":\", \"@\", \"&\", \"=\", \"+\", \"$\", \",\",\n"
"}\n"
"\n"
"local function protect_segment(s)\n"
"	return string.gsub(s, \"([^A-Za-z0-9_])\", function (c)\n"
"		if segment_set[c] then return c\n"
"		else return string.format(\"%%%02x\", string.byte(c)) end\n"
"	end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Encodes a string into its escaped hexadecimal representation\n"
"-- Input\n"
"--   s: binary string to be encoded\n"
"-- Returns\n"
"--   escaped representation of string binary\n"
"-----------------------------------------------------------------------------\n"
"function unescape(s)\n"
"    return string.gsub(s, \"%%(%x%x)\", function(hex)\n"
"        return string.char(base.tonumber(hex, 16))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Builds a path from a base path and a relative path\n"
"-- Input\n"
"--   base_path\n"
"--   relative_path\n"
"-- Returns\n"
"--   corresponding absolute path\n"
"-----------------------------------------------------------------------------\n"
"local function absolute_path(base_path, relative_path)\n"
"    if string.sub(relative_path, 1, 1) == \"/\" then return relative_path end\n"
"    local path = string.gsub(base_path, \"[^/]*$\", \"\")\n"
"    path = path .. relative_path\n"
"    path = string.gsub(path, \"([^/]*%./)\", function (s)\n"
"        if s ~= \"./\" then return s else return \"\" end\n"
"    end)\n"
"    path = string.gsub(path, \"/%.$\", \"/\")\n"
"    local reduced\n"
"    while reduced ~= path do\n"
"        reduced = path\n"
"        path = string.gsub(reduced, \"([^/]*/%.%./)\", function (s)\n"
"            if s ~= \"../../\" then return \"\" else return s end\n"
"        end)\n"
"    end\n"
"    path = string.gsub(reduced, \"([^/]*/%.%.)$\", function (s)\n"
"        if s ~= \"../..\" then return \"\" else return s end\n"
"    end)\n"
"    return path\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Parses a url and returns a table with all its parts according to RFC 2396\n"
"-- The following grammar describes the names given to the URL parts\n"
"-- <url> ::= <scheme>://<authority>/<path>;<params>?<query>#<fragment>\n"
"-- <authority> ::= <userinfo>@<host>:<port>\n"
"-- <userinfo> ::= <user>[:<password>]\n"
"-- <path> :: = {<segment>/}<segment>\n"
"-- Input\n"
"--   url: uniform resource locator of request\n"
"--   default: table with default values for each field\n"
"-- Returns\n"
"--   table with the following fields, where RFC naming conventions have\n"
"--   been preserved:\n"
"--     scheme, authority, userinfo, user, password, host, port,\n"
"--     path, params, query, fragment\n"
"-- Obs:\n"
"--   the leading '/' in {/<path>} is considered part of <path>\n"
"-----------------------------------------------------------------------------\n"
"function parse(url, default)\n"
"    -- initialize default parameters\n"
"    local parsed = {}\n"
"    for i,v in base.pairs(default or parsed) do parsed[i] = v end\n"
"    -- empty url is parsed to nil\n"
"    if not url or url == \"\" then return nil, \"invalid url\" end\n"
"    -- remove whitespace\n"
"    -- url = string.gsub(url, \"%s\", \"\")\n"
"    -- get fragment\n"
"    url = string.gsub(url, \"#(.*)$\", function(f)\n"
"        parsed.fragment = f\n"
"        return \"\"\n"
"    end)\n"
"    -- get scheme\n"
"    url = string.gsub(url, \"^([%w][%w%+%-%.]*)%:\",\n"
"        function(s) parsed.scheme = s; return \"\" end)\n"
"    -- get authority\n"
"    url = string.gsub(url, \"^//([^/]*)\", function(n)\n"
"        parsed.authority = n\n"
"        return \"\"\n"
"    end)\n"
"    -- get query stringing\n"
"    url = string.gsub(url, \"%?(.*)\", function(q)\n"
"        parsed.query = q\n"
"        return \"\"\n"
"    end)\n"
"    -- get params\n"
"    url = string.gsub(url, \"%;(.*)\", function(p)\n"
"        parsed.params = p\n"
"        return \"\"\n"
"    end)\n"
"    -- path is whatever was left\n"
"    if url ~= \"\" then parsed.path = url end\n"
"    local authority = parsed.authority\n"
"    if not authority then return parsed end\n"
"    authority = string.gsub(authority,\"^([^@]*)@\",\n"
"        function(u) parsed.userinfo = u; return \"\" end)\n"
"    authority = string.gsub(authority, \":([^:]*)$\",\n"
"        function(p) parsed.port = p; return \"\" end)\n"
"    if authority ~= \"\" then parsed.host = authority end\n"
"    local userinfo = parsed.userinfo\n"
"    if not userinfo then return parsed end\n"
"    userinfo = string.gsub(userinfo, \":([^:]*)$\",\n"
"        function(p) parsed.password = p; return \"\" end)\n"
"    parsed.user = userinfo\n"
"    return parsed\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Rebuilds a parsed URL from its components.\n"
"-- Components are protected if any reserved or unallowed characters are found\n"
"-- Input\n"
"--   parsed: parsed URL, as returned by parse\n"
"-- Returns\n"
"--   a stringing with the corresponding URL\n"
"-----------------------------------------------------------------------------\n"
"function build(parsed)\n"
"    local ppath = parse_path(parsed.path or \"\")\n"
"    local url = build_path(ppath)\n"
"    if parsed.params then url = url .. \";\" .. parsed.params end\n"
"    if parsed.query then url = url .. \"?\" .. parsed.query end\n"
"	local authority = parsed.authority\n"
"	if parsed.host then\n"
"		authority = parsed.host\n"
"		if parsed.port then authority = authority .. \":\" .. parsed.port end\n"
"		local userinfo = parsed.userinfo\n"
"		if parsed.user then\n"
"			userinfo = parsed.user\n"
"			if parsed.password then\n"
"				userinfo = userinfo .. \":\" .. parsed.password\n"
"			end\n"
"		end\n"
"		if userinfo then authority = userinfo .. \"@\" .. authority end\n"
"	end\n"
"    if authority then url = \"//\" .. authority .. url end\n"
"    if parsed.scheme then url = parsed.scheme .. \":\" .. url end\n"
"    if parsed.fragment then url = url .. \"#\" .. parsed.fragment end\n"
"    -- url = string.gsub(url, \"%s\", \"\")\n"
"    return url\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Builds a absolute URL from a base and a relative URL according to RFC 2396\n"
"-- Input\n"
"--   base_url\n"
"--   relative_url\n"
"-- Returns\n"
"--   corresponding absolute url\n"
"-----------------------------------------------------------------------------\n"
"function absolute(base_url, relative_url)\n"
"    if base.type(base_url) == \"table\" then\n"
"        base_parsed = base_url\n"
"        base_url = build(base_parsed)\n"
"    else\n"
"        base_parsed = parse(base_url)\n"
"    end\n"
"    local relative_parsed = parse(relative_url)\n"
"    if not base_parsed then return relative_url\n"
"    elseif not relative_parsed then return base_url\n"
"    elseif relative_parsed.scheme then return relative_url\n"
"    else\n"
"        relative_parsed.scheme = base_parsed.scheme\n"
"        if not relative_parsed.authority then\n"
"            relative_parsed.authority = base_parsed.authority\n"
"            if not relative_parsed.path then\n"
"                relative_parsed.path = base_parsed.path\n"
"                if not relative_parsed.params then\n"
"                    relative_parsed.params = base_parsed.params\n"
"                    if not relative_parsed.query then\n"
"                        relative_parsed.query = base_parsed.query\n"
"                    end\n"
"                end\n"
"            else    \n"
"                relative_parsed.path = absolute_path(base_parsed.path or \"\",\n"
"                    relative_parsed.path)\n"
"            end\n"
"        end\n"
"        return build(relative_parsed)\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Breaks a path into its segments, unescaping the segments\n"
"-- Input\n"
"--   path\n"
"-- Returns\n"
"--   segment: a table with one entry per segment\n"
"-----------------------------------------------------------------------------\n"
"function parse_path(path)\n"
"	local parsed = {}\n"
"	path = path or \"\"\n"
"	--path = string.gsub(path, \"%s\", \"\")\n"
"	string.gsub(path, \"([^/]+)\", function (s) table.insert(parsed, s) end)\n"
"	for i = 1, table.getn(parsed) do\n"
"		parsed[i] = unescape(parsed[i])\n"
"	end\n"
"	if string.sub(path, 1, 1) == \"/\" then parsed.is_absolute = 1 end\n"
"	if string.sub(path, -1, -1) == \"/\" then parsed.is_directory = 1 end\n"
"	return parsed\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Builds a path component from its segments, escaping protected characters.\n"
"-- Input\n"
"--   parsed: path segments\n"
"--   unsafe: if true, segments are not protected before path is built\n"
"-- Returns\n"
"--   path: corresponding path stringing\n"
"-----------------------------------------------------------------------------\n"
"function build_path(parsed, unsafe)\n"
"	local path = \"\"\n"
"	local n = table.getn(parsed)\n"
"	if unsafe then\n"
"		for i = 1, n-1 do\n"
"			path = path .. parsed[i]\n"
"			path = path .. \"/\"\n"
"		end\n"
"		if n > 0 then\n"
"			path = path .. parsed[n]\n"
"			if parsed.is_directory then path = path .. \"/\" end\n"
"		end\n"
"	else\n"
"		for i = 1, n-1 do\n"
"			path = path .. protect_segment(parsed[i])\n"
"			path = path .. \"/\"\n"
"		end\n"
"		if n > 0 then\n"
"			path = path .. protect_segment(parsed[n])\n"
"			if parsed.is_directory then path = path .. \"/\" end\n"
"		end\n"
"	end\n"
"	if parsed.is_absolute then path = \"/\" .. path end\n"
"	return path\n"
"end\n"
"",

"wetgenes.www.ngx.memcache","--Copyright (c) 2006-2008 Neil Richardson (nrich@iinet.net.au)\n"
"--\n"
"--Permission is hereby granted, free of charge, to any person obtaining a copy \n"
"--of this software and associated documentation files (the \"Software\"), to deal\n"
"--in the Software without restriction, including without limitation the rights \n"
"--to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n"
"--copies of the Software, and to permit persons to whom the Software is \n"
"--furnished to do so, subject to the following conditions:\n"
"--\n"
"--The above copyright notice and this permission notice shall be included in all\n"
"--copies or substantial portions of the Software.\n"
"--\n"
"--THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"
"--IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"
"--FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n"
"--AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"
"--LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"
"--OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS \n"
"--IN THE SOFTWARE.\n"
"\n"
"-- kriss@xixs.com -- 2012\n"
"-- just fiddled with to use the ngx. socket and crc32, so I can use memcached under nginxngx\n"
"local ngx=ngx\n"
"module('wetgenes.www.ngx.memcache', package.seeall)\n"
"\n"
"--require('socket')\n"
"--require('CRC32')\n"
"\n"
"local SERVER_RETRIES = 10\n"
"\n"
"local STATS_KEYS = {\n"
"    malloc = true,\n"
"    sizes = true,\n"
"    slabs = true,\n"
"    items = true,\n"
"}\n"
"\n"
"local FLAGS = {\n"
"    'STORABLE',\n"
"    'COMPRESSED',\n"
"    'SERIALISED',\n"
"}\n"
"\n"
"local function warn(str)\n"
"    io.stderr:write(string.format('Warning: %s\\n"
"', tostring(str)))\n"
"end\n"
"\n"
"local function _select_server(cache, key)\n"
"	local server_count = #cache.servers\n"
"\n"
"	local hashfunc = cache.hash or ngx.crc32_short\n"
"\n"
"	if server_count == 1 then\n"
"		return cache.servers[1].socket\n"
"	else\n"
"\n"
"		local serverhash = hashfunc(key)\n"
"\n"
"		for i = 0, SERVER_RETRIES do\n"
"			local index = (serverhash % server_count) + 1\n"
"			local server = cache.servers[index].socket\n"
"\n"
"			if not server then\n"
"				serverhash = hashfunc(serverhash .. i)\n"
"			else\n"
"				return server\n"
"			end\n"
"		end\n"
"	end\n"
"\n"
"    error('No servers found')\n"
"    return nil\n"
"end\n"
"\n"
"local function _retrieve(cache, key, str)\n"
"    local server = _select_server(cache, key)\n"
"\n"
"    server:send(str .. '\\r\\n"
"')\n"
"\n"
"    local function toboolean(value)\n"
"	 if type(value) == 'string' then\n"
"	     if value == 'true' then\n"
"	    return true\n"
"	     elseif value == 'false' then\n"
"	    return false \n"
"	     end\n"
"	 end\n"
"\n"
"	\n"
"\n"
"\n"
"	 return nil\n"
"    end\n"
"\n"
"    local function extract_flags(str)\n"
"	 local num = tonumber(str)\n"
"	 local flags = {}\n"
"\n"
"	 for i = table.maxn(FLAGS), 1, -1 do\n"
"	local bf = 2 ^ (i - 1)\n"
"\n"
"	if num >= bf then\n"
"	    flags[FLAGS[i]] = true\n"
"	    num = num - bf\n"
"	end\n"
"	 end\n"
"\n"
"	 return flags\n"
"    end\n"
"\n"
"    local returndata = {}\n"
"    while true do\n"
"	 local line, err = server:receive()\n"
"\n"
"	if not line then break\n"
"	elseif line == 'END' then break\n"
"	 elseif string.sub(line, 1, 5) == 'VALUE' then\n"
"	local key,flagstr,size,cas = string.match(line, 'VALUE (%S+) (%d+) (%d+)')\n"
"	flags = extract_flags(flagstr)\n"
"\n"
"	local data = server:receive(size)\n"
"\n"
"	if flags.COMPRESSED and cache.compress_enabled then\n"
"	    data = cache.decompress(data)\n"
"	end\n"
"\n"
"            if flags.SERIALISED then\n"
"                returndata[key] = cache.decode(data)\n"
"            else\n"
"                local ldata = tonumber(data) or toboolean(data) \n"
"\n"
"                if ldata == nil then\n"
"                    if data == 'nil' then\n"
"                        returndata[key] = nil\n"
"                    else\n"
"                        returndata[key] = data\n"
"                    end\n"
"                else\n"
"                    returndata[key] = ldata\n"
"                end\n"
"            end\n"
"	 end\n"
"    end\n"
"\n"
"    return returndata\n"
"end\n"
"\n"
"local function _send(cache, key, str)\n"
"    local server = _select_server(cache, key)\n"
"\n"
"    server:send(str .. \"\\r\\n"
"\")\n"
"    local line, err = server:receive()\n"
"    \n"
"    if not err then return line end\n"
"end\n"
"\n"
"local function _store(cache, op, key, value, expiry)\n"
"    local str\n"
"    local flags = 0\n"
"\n"
"    if type(value) == 'table' then\n"
"	 str = cache.encode(value)    \n"
"	 -- TODO lookup rather than hard code \n"
"        flags = flags + 4\n"
"    else\n"
"	 str = tostring(value)\n"
"    end\n"
"\n"
"    if cache.compress_enabled and string.len(str) > cache.compress_threshold then\n"
"	 local cstr = cache.compress(str)\n"
"\n"
"	 if string.len(cstr) < (string.len(str) * 0.8) then\n"
"	str = cstr\n"
"\n"
"	-- TODO lookup rather than hard code \n"
"	flags = flags + 2\n"
"	 end\n"
"    end\n"
"\n"
"    local len = string.len(str)\n"
"\n"
"    expiry = expiry or 0\n"
"\n"
"    local cmd = op .. ' ' .. key .. ' ' .. flags .. ' ' .. expiry .. ' ' .. len .. '\\r\\n"
"' .. str\n"
"\n"
"    local res = _send(cache, key, cmd)\n"
"\n"
"    if res ~= 'STORED' then\n"
"	 return false, res\n"
"    end\n"
"\n"
"    return true\n"
"end\n"
"\n"
"local function set(cache, key, value, expiry)\n"
"    return _store(cache, 'set', key, value, expiry)\n"
"end\n"
"\n"
"local function add(cache, key, value, expiry)\n"
"    return _store(cache, 'add', key, value, expiry)\n"
"end\n"
"\n"
"local function replace(cache, key, value, expiry)\n"
"    return _store(cache, 'replace', key, value, expiry)\n"
"end\n"
"\n"
"local function get(cache, key)\n"
"    local dataset = _retrieve(cache, key, 'get ' .. key)\n"
"    return dataset[key]\n"
"end\n"
"\n"
"local function delete(cache, key)\n"
"    local res = _send(cache, key, 'delete ' .. key)\n"
"\n"
"    if res == 'NOT_FOUND' then\n"
"	 return false\n"
"    end\n"
"\n"
"    if res ~= 'DELETED' then\n"
"	 return false, res\n"
"    end\n"
"\n"
"    return true\n"
"end\n"
"\n"
"local function incr(cache, key, val)\n"
"    val = val or 1\n"
"	 \n"
"    local res = _send(cache, key, 'incr ' .. key .. ' ' .. val)\n"
"\n"
"    if res == 'ERROR' or res == 'CLIENT_ERROR' then\n"
"        return false, res\n"
"    end\n"
"\n"
"    return res\n"
"end\n"
"\n"
"local function decr(cache, key, val)\n"
"    val = val or 1\n"
"\n"
"    local res = _send(cache, key, 'decr ' .. key .. ' ' .. val)\n"
"\n"
"    if res == 'ERROR' or res == 'CLIENT_ERROR' then\n"
"        return false, res\n"
"    end\n"
"\n"
"    return res\n"
"end\n"
"\n"
"local function stats(cache, key)\n"
"    local servers = {}\n"
"\n"
"    key = key or ''\n"
"\n"
"    if string.len(key) > 0 and not STATS_KEYS[key] then\n"
"	 error(string.format(\"Unknown stats key '%s'\", key))\n"
"    end\n"
"\n"
"    for i,server in pairs(cache.servers) do\n"
"	 server.socket:send('stats ' .. key .. '\\r\\n"
"')\n"
"\n"
"	 local stats = {}\n"
"\n"
"	 while true do\n"
"	local line, err = server.socket:receive()\n"
"\n"
"	if line == 'END' or line == 'ERROR' then\n"
"	    break\n"
"	end\n"
"\n"
"	local k,v = string.match(line, 'STAT (%S+) (%S+)')\n"
"\n"
"	if k then\n"
"	    stats[k] = v\n"
"	end\n"
"	 end\n"
"\n"
"	 servers[server.name] = stats\n"
"    end\n"
"\n"
"    return servers\n"
"end \n"
"\n"
"local function get_multi(cache, ...)\n"
"    local dataset = nil\n"
"\n"
"    if table.maxn(cache.servers) > 1 then\n"
"	 dataset = {}\n"
"\n"
"	 for i,k in ipairs(arg) do\n"
"	local data = _retrieve(cache, k, 'get ' .. k)\n"
"	dataset[k] = data[k]\n"
"	 end\n"
"    else\n"
"	 local keys = table.concat(arg, ' ')\n"
"	 dataset = _retrieve(cache, keys, 'get ' .. keys)\n"
"    end\n"
"\n"
"    return dataset\n"
"end\n"
"\n"
"local function flush_all(cache)\n"
"    local success = true\n"
"\n"
"    for i,server in ipairs(cache.servers) do\n"
"	 server.socket:send('flush_all\\r\\n"
"')\n"
"	 local res = assert(server.socket:receive())\n"
"\n"
"	 if res ~= 'OK' then\n"
"	success = false\n"
"	 end\n"
"    end\n"
"\n"
"    return success\n"
"end\n"
"\n"
"local function disconnect_all(cache)\n"
"    while true do\n"
"	 local server = table.remove(cache.servers)\n"
"\n"
"	 if not server then\n"
"	break\n"
"	 end\n"
"\n"
"	 server.socket:close()\n"
"    end    \n"
"end\n"
"\n"
"local function set_hash(cache, hashfunc)\n"
"    cache.hash = hashfunc\n"
"end\n"
"\n"
"local function set_encode(cache, func)\n"
"    cache.encode = func\n"
"end\n"
"\n"
"local function set_decode(cache, func)\n"
"    cache.decode = func\n"
"end\n"
"\n"
"local function set_compress(cache, func)\n"
"    cache.compress = func\n"
"end\n"
"\n"
"local function set_decompress(cache, func)\n"
"    cache.decompress = func\n"
"end\n"
"\n"
"function Connect(hostlist, port)\n"
"    local servers = {}\n"
"\n"
"    if type(hostlist) == 'table' then\n"
"	 for i,host in pairs(hostlist) do\n"
"	local h, p\n"
"\n"
"	if type(host) == 'table' then\n"
"	    h = host[1]\n"
"	    p = host[2]\n"
"	elseif type(host) == 'string' then\n"
"	    h = host\n"
"	elseif type(host) == 'number' then\n"
"	    p = host\n"
"	    h = nil\n"
"	end\n"
"\n"
"	if not h then\n"
"	    h = '127.0.0.1'\n"
"	end\n"
"\n"
"	if not p then \n"
"	    p = 11211\n"
"	end\n"
"\n"
"	local server = ngx.socket.connect(h, p)\n"
"\n"
"	if not server then\n"
"	    warn('Could not connect to ' .. h .. ':' .. p)\n"
"	else\n"
"	    table.insert(servers, {socket = server, name = string.format('%s:%d', h, p)})\n"
"	end\n"
"	 end\n"
"    else\n"
"	 local address = hostlist\n"
"\n"
"	 if type(address) == 'number' then\n"
"	port = address\n"
"	address = nil\n"
"	 end\n"
"\n"
"	 if address == nil then\n"
"	address = '127.0.0.1'\n"
"	 end\n"
"\n"
"	 if port == nil then\n"
"	port = 11211\n"
"	 end\n"
"\n"
"	 local server = ngx.socket.connect(address, port)\n"
"\n"
"	 if not server then\n"
"	warn('Could not connect to ' .. address .. ':' .. port)\n"
"	 else\n"
"	servers = {{socket = server, name = string.format('%s:%d', address, port)}}\n"
"	 end\n"
"    end\n"
"\n"
"    if table.maxn(servers) < 1 then\n"
"	 error('No servers available')\n"
"    end\n"
"\n"
"    local cache = {\n"
"	 servers = servers,\n"
"\n"
"	 set_hash = set_hash,\n"
"	 set_encode = set_encode,\n"
"	 set_decode = set_decode,\n"
"	 set_decompress = set_decompress,\n"
"	 set_compress = set_compress,\n"
"\n"
"	 compress_enabled = false,\n"
"	 enable_compression = function(self, on)\n"
"	self.compress_enabled = on\n"
"	 end,\n"
"\n"
"	 hash = nil,\n"
"	 encode = function()\n"
"	error('No encode function set')\n"
"	 end,\n"
"\n"
"	 decode = function()\n"
"	error('No decode function set')\n"
"	 end,\n"
"\n"
"	 compress = function()\n"
"	error('No compress function set')\n"
"	 end,\n"
"\n"
"	 decompress = function()\n"
"	error('No decompress function set')\n"
"	 end,\n"
"\n"
"	 -- 10K default\n"
"	 compress_threshold = 10240,\n"
"	 set_compress_threshold = function(self, threshold)\n"
"	if threshold == nil then\n"
"	    self:enable_compression(false)\n"
"	else\n"
"	    self.compress_threshold = threshold\n"
"	end\n"
"	 end,\n"
"\n"
"	 set = set,\n"
"	 add = add,\n"
"	 replace = replace,\n"
"	 get = get,\n"
"	 delete = delete,\n"
"	 incr = incr,\n"
"	 decr = decr,\n"
"\n"
"	 get_multi = get_multi,\n"
"	 stats = stats,\n"
"	 flush_all = flush_all,\n"
"	 disconnect_all = disconnect_all,\n"
"    }\n"
"\n"
"    return cache\n"
"end\n"
"\n"
"function New(hostlist, port)\n"
"    return Connect(hostlist, port)\n"
"end\n"
"\n"
"-- \n"
"-- Memcached.lua\n"
"-- \n"
"-- A pure Lua implementation of a simple memcached client. 1 or more memcached server(s) are currently supported. Requires the luasocket library.\n"
"-- See http://www.danga.com/memcached/ for more information about memcached.\n"
"--\n"
"--\n"
"--\n"
"-- Synopsis\n"
"--\n"
"-- require('Memcached')\n"
"--\n"
"-- memcache = Memcached.Connect('some.host.com', 11000)\n"
"--    OR\n"
"-- memcache = Memcached.New('some.host.com', 11000)\n"
"--\n"
"-- memcache:set('some_key', 1234)\n"
"-- memcache:add('new_key', 'add new value')\n"
"-- memcache:replace('existing_key', 'replace old value')\n"
"--\n"
"-- cached_data = memcache:get('some_key')\n"
"--\n"
"-- memcache:delete('old_key')\n"
"--\n"
"--\n"
"--\n"
"-- Methods:\n"
"--\n"
"-- memcache = Memcached.Connect()\n"
"--    Connect to memcached server at localhost on port number 11211. \n"
"--\n"
"-- memcache = Memcached.Connect(host[, port])\n"
"--    Connect to memcached server at 'host' on port number 'port'. If port is not provided, port 11211 is used.  \n"
"--\n"
"---memcache = Memcached.Connect(port)\n"
"--    Connect to memcached server at localhost on port number 'port'.\n"
"--\n"
"-- memcache = Memcached.Connect({{'host', port}, 'host', port})  \n"
"--    Connect to multiple memcached servers.\n"
"--\n"
"-- memcache:set(key, value[, expiry])\n"
"--    Unconditionally sets a key to a given value in the memcache. The value for 'expiry' is the expiration\n"
"--    time (default is 0, never expire).\n"
"--     \n"
"-- memcache:add(key, value[, expiry])\n"
"--    Like set, but only stores in memcache if the key doesn't already exist.\n"
"--    \n"
"-- memcache:replace(key, value[, expiry])\n"
"--    Like set, but only stores in memcache if the key already exists. The opposite of add.\n"
"--    \n"
"-- value = memcache:get(key)\n"
"--    Retrieves a key from the memcache. Returns the value or nil\n"
"--    \n"
"-- values = memcache:get_multi(...)\n"
"--    Retrieves multiple keys from the memcache doing just one query.  Returns a table of key/value pairs that were available.\n"
"--    \n"
"-- memcache:delete(key)\n"
"--    Deletes a key. Returns true on deletion, false if the key was not found.\n"
"--    \n"
"-- value = memcache:incr(key[, value])\n"
"--    Sends a command to the server to atomically increment the value for key by value, or by 1 if value is nil. \n"
"--    Returns nil if key doesn't exist on server, otherwise it returns the new value after incrementing. Value should be zero or greater.\n"
"--    \n"
"-- value = memcache:decr(key[, value])\n"
"--    Like incr, but decrements. Unlike incr, underflow is checked and new values are capped at 0. If server value is 1, a decrement of 2 returns 0, not -1.\n"
"--\n"
"-- servers = memcache:stats([key])\n"
"--    Returns a table of statistical data regarding the memcache server(s). Allowed keys are:\n"
"--   '', 'malloc', 'sizes', 'slabs', 'items'\n"
"--\n"
"--  success = memcache:flush_all()\n"
"--     Runs the memcached \"flush_all\" command on all configured hosts, emptying all their caches. \n"
"--\n"
"--  memcache:disconnect_all()\n"
"--     Closes all cached sockets to all memcached servers.\n"
"--\n"
"--  memcache:set_hash(hashfunc)\n"
"--     Sets a custom hash function for key values. The default is a CRC32 hashing function.\n"
"--     'hashfunc' should be defined receiving a single string parameter and returing a single integer value.\n"
"--\n"
"--  memcache:set_encode(func)\n"
"--     Sets a custom encode function for serialising table values. 'func' should be defined receiving a single\n"
"--     table value and returning a single string value.\n"
"--\n"
"--  memcache:set_decode(func)\n"
"--     Sets a custom decode function for deserialising table values. 'func' should be defined receiving a \n"
"--     single single and returning a single table value\n"
"--\n"
"--  memcache:enable_compression(onflag)\n"
"--     Turns data compression support on or off.\n"
"--\n"
"--  memcache:set_compress_threshold(size)\n"
"--     Set the compression threshold. If the value to be stored is larger than `size' bytes (and compression \n"
"--     is enabled), compress before storing.\n"
"--\n"
"--  memcache:set_compress(func)\n"
"--     Sets a custom data compression function. 'func' should be defined receiving a single string value and\n"
"--     returning a single string value.\n"
"--\n"
"--  memcache:set_decompress(func)\n"
"--     Sets a custom data decompression function. 'func' should be defined receiving a single string value and\n"
"--     returning a single string value.\n"
"",

"wetgenes.gamecake.spew.profiles","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"local wwin=require(\"wetgenes.win\") -- system independent helpers\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"local wsbox=require(\"wetgenes.sandbox\")\r\n"
"local snames=require(\"wetgenes.gamecake.spew.names\")\r\n"
"local lfs ; pcall( function() lfs=require(\"lfs\") end ) -- may not have a filesystem\r\n"
"\r\n"
"\r\n"
"--local sql=require(\"sqlite\")\r\n"
"--local db=assert(sql.open(wwin.files_prefix..\"profiles.sql\"))\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"M.bake=function(oven,profiles)\r\n"
"\r\n"
"	profiles=profiles or {}\r\n"
"\r\n"
"	profiles.filename=wwin.files_prefix..\"profiles.lua\"\r\n"
"	\r\n"
"	local cake=oven.cake\r\n"
"	local canvas=cake.canvas\r\n"
"	\r\n"
"	local p\r\n"
"	local ps={}\r\n"
"\r\n"
"-- check profile data is valid\r\n"
"	function profiles.check()\r\n"
"		for i,p in pairs(ps) do\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"-- initialise profile data\r\n"
"	function profiles.init()\r\n"
"		ps={}\r\n"
"		for i=1,5 do\r\n"
"			p={}\r\n"
"			p.name=snames.random()\r\n"
"			ps[i]=p\r\n"
"		end\r\n"
"		profiles.select(1)\r\n"
"	end\r\n"
"	\r\n"
"-- load all profile data\r\n"
"	function profiles.load()\r\n"
"		if lfs then\r\n"
"print(\"Loading \"..profiles.filename)\r\n"
"			local fp=io.open(profiles.filename,\"r\")\r\n"
"			if fp then\r\n"
"				local s=fp:read(\"*all\")\r\n"
"				ps=wsbox.lson(s) -- safeish\r\n"
"				fp:close()\r\n"
"				profiles.select(1)\r\n"
"				profiles.check()\r\n"
"				return true\r\n"
"			end\r\n"
"		end\r\n"
"		return false\r\n"
"	end\r\n"
"	\r\n"
"-- save all profile data\r\n"
"	function profiles.save()\r\n"
"		if lfs then\r\n"
"print(\"Saving \"..profiles.filename)\r\n"
"			local fp=io.open(profiles.filename,\"w\")\r\n"
"			fp:write(wstr.serialize(ps))\r\n"
"			fp:close()\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"-- make this profile current\r\n"
"	function profiles.select(pid)\r\n"
"		profiles.pid=pid\r\n"
"		p=ps[pid] or ps[1]\r\n"
"	end\r\n"
"\r\n"
"-- set a value in the current profile\r\n"
"	function profiles.set(name,value)\r\n"
"		if p[name]~=value then\r\n"
"			p[name]=value\r\n"
"			profiles.save()\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"-- get a value from the current profile\r\n"
"	function profiles.get(name)\r\n"
"		return p[name]\r\n"
"	end\r\n"
"\r\n"
"-- set a score in the current profile\r\n"
"--[[\r\n"
"	function profiles.set_score(name,score)\r\n"
"		local scores=p[scores] or {}\r\n"
"		p[scores]=scores\r\n"
"		scores[#scores+1]=score\r\n"
"		profiles.save()\r\n"
"	end\r\n"
"]]\r\n"
"\r\n"
"-- simple iteration of all profiles, iterates the profile raw tab (ipairs)\r\n"
"	function profiles.ipairs()\r\n"
"		return ipairs(ps)\r\n"
"	end\r\n"
"	\r\n"
"\r\n"
"--make sure we have a dir to load/save profiles into\r\n"
"if lfs then\r\n"
"	lfs.mkdir(wwin.files_prefix:sub(1,-2)) -- skip trailing slash\r\n"
"end\r\n"
"\r\n"
"-- try autoload\r\n"
"if not profiles.load() then\r\n"
"-- or create and save a default file\r\n"
"	profiles.init()\r\n"
"	profiles.save()\r\n"
"end\r\n"
"\r\n"
"	return profiles\r\n"
"end\r\n"
"",

"wetgenes.fenestra.widget","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"--\r\n"
"-- handle widgets\r\n"
"--\r\n"
"\r\n"
"\r\n"
"local widget_meta=require(\"fenestra.widget.meta\")\r\n"
"local widget_skin=require(\"fenestra.widget.skin\")\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget\")\r\n"
"\r\n"
"\r\n"
"--\r\n"
"-- create a master widget\r\n"
"--\r\n"
"function setup(win,def)\r\n"
"\r\n"
"	local meta={}\r\n"
"	meta.__index=meta\r\n"
"	local master={} -- the master widget, all numerical keys of a widget are the widgets children\r\n"
"	setmetatable(master,meta)\r\n"
"	master.parent=master -- we are our own parent, probably safer than setting as null\r\n"
"	master.master=master -- and our own master\r\n"
"	\r\n"
"	master.font=def.font\r\n"
"	\r\n"
"	def.master=master\r\n"
"	def.meta=meta\r\n"
"	def.win=win\r\n"
"\r\n"
"	widget_meta.setup(def)\r\n"
"	widget_skin.setup(def)\r\n"
"	\r\n"
"-- default GUI size if no other is specified\r\n"
"	def.hx=def.hx or 640\r\n"
"	def.hy=def.hy or 480\r\n"
"	def.px=def.px or 0\r\n"
"	def.py=def.py or 0\r\n"
"	def.pxd=def.pxd or 0\r\n"
"	def.pyd=def.pyd or def.hy\r\n"
"\r\n"
"	def.class=def.class or \"master\"\r\n"
"	\r\n"
"	master:setup(def)\r\n"
"	\r\n"
"	return master -- our new widget is ready\r\n"
"\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.gamecake.widgets.skin","-- copy all globals into locals, some locals are renamed to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,luaload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local bit=require('bit')\n"
"local grd=require('wetgenes.grd')\n"
"local pack=require('wetgenes.pack')\n"
"local tardis=require('wetgenes.tardis')\n"
"\n"
"local wzips=require(\"wetgenes.zips\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"\n"
"local apps=apps\n"
"\n"
"local function explode_color(c)\n"
"\n"
"	local r,g,b,a\n"
"	\n"
"	a=bit.band(bit.rshift(c,24),0xff)\n"
"	r=bit.band(bit.rshift(c,16),0xff)\n"
"	g=bit.band(bit.rshift(c, 8),0xff)\n"
"	b=bit.band(c,0xff)\n"
"\n"
"	return r/0xff,g/0xff,b/0xff,a/0xff\n"
"end\n"
"\n"
"local function implode_color(r,g,b,a)\n"
"\n"
"	if type(r)==\"table\" then a=r[4] b=r[3] g=r[2] r=r[1] end -- convert from table?\n"
"	\n"
"	local c\n"
"	\n"
"	c=             bit.band(b*0xff,0xff)\n"
"	c=c+bit.lshift(bit.band(g*0xff,0xff),8)\n"
"	c=c+bit.lshift(bit.band(r*0xff,0xff),16)\n"
"	c=c+bit.lshift(bit.band(a*0xff,0xff),24)\n"
"\n"
"	return c\n"
"end\n"
"\n"
"\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"function M.bake(oven,wskin)\n"
"wskin=wskin or {}\n"
"\n"
"local gl=oven.gl\n"
"local cake=oven.cake\n"
"local images=cake.images\n"
"local sheets=cake.sheets\n"
"local canvas=cake.canvas\n"
"local font=canvas.font\n"
"local flat=canvas.flat\n"
"\n"
"local layouts=cake.layouts\n"
"\n"
"\n"
"local mode=nil\n"
"local texs={}\n"
"\n"
"local margin=0 -- whitespace\n"
"local border=0 -- solidspace\n"
"--\n"
"-- unload a skin, go back to the \"builtin\" default\n"
"--\n"
"function wskin.unload()\n"
"\n"
"	mode=nil\n"
"	texs={}\n"
"	\n"
"end\n"
"\n"
"\n"
"--\n"
"-- load a skin\n"
"--\n"
"function wskin.load(name)\n"
"	\n"
"	wskin.unload()\n"
"	\n"
"	if name then -- load a named skin\n"
"	\n"
"		if name==\"soapbar\" then\n"
"			mode=name\n"
"			\n"
"			images.TEXTURE_MIN_FILTER=gl.LINEAR -- disable mipmapping? it seems to feck draw33 up somehow?\n"
"			images.loads{\n"
"				\"wskins/\"..mode..\"/border\",\n"
"				\"wskins/\"..mode..\"/buttof\",\n"
"				\"wskins/\"..mode..\"/button\",\n"
"				\"wskins/\"..mode..\"/buttin\",\n"
"			}\n"
"			images.TEXTURE_MIN_FILTER=nil\n"
"			margin=15\n"
"			border=0\n"
"			\n"
"		end\n"
"			\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"--\n"
"-- add meta functions\n"
"--\n"
"function wskin.setup(def)\n"
"\n"
"--	load(def.win,\"test\")\n"
"\n"
"\n"
"	local master=def.master\n"
"	local meta=def.meta\n"
"	local win=def.win\n"
"--	local font=--[[def.font]]def.state.cake.fonts.get(1)\n"
"\n"
"	\n"
"local function draw33(tw,th, mw,mh, vxs,vys, vw,vh,invert)\n"
"		\n"
"--		local vw,vh=512,52\n"
"--		local mw,mh=24,24\n"
"\n"
"		local force_tww,force_thh\n"
"		\n"
"		if mw*4>tw then twwidx=1 end -- mipmap hack for small buttons\n"
"		if mh*4>th then thhidx=1 end\n"
"\n"
"		if mw*2 > vw then mw=vw/2 end\n"
"		if mh*2 > vh then mh=vh/2 end\n"
"\n"
"		\n"
"		local tww={mw/tw,(tw-2*mw)/tw,mw/tw}\n"
"		local thh={mh/th,(th-2*mh)/th,mh/th}\n"
"		local vww={mw,vw-2*mw,mw}\n"
"		local vhh={mh,vh-2*mh,mh}\n"
"		\n"
"\n"
"			local t={}\n"
"			local function drawbox() -- draw all 9 parts in one go\n"
"				flat.tristrip(\"xyzuv\",t)\n"
"			end\n"
"			local function tdrawbox( tx,ty, vx,vy , txp,typ, vxp,vyp )\n"
"			\n"
"				local ht=#t\n"
"				for i,v in ipairs{\n"
"					vx,		vy,		0,	tx,		ty, -- doubletap hack so we can start at any location\n"
"					vx,		vy,		0,	tx,		ty,\n"
"					vx+vxp,	vy,		0,	tx+txp,	ty,\n"
"					vx,		vy+vyp,	0,	tx,		ty+typ,\n"
"					vx+vxp,	vy+vyp,	0,	tx+txp,	ty+typ,\n"
"					vx+vxp,	vy+vyp,	0,	tx+txp,	ty+typ, -- doubletap hack so we can start at any location\n"
"				} do\n"
"					t[ht+i]=v\n"
"				end\n"
"			end\n"
"			\n"
"			if invert then -- draw inverted texture, sometimes useful as it flips highlights\n"
"				tdrawbox=function ( tx,ty, vx,vy , txp,typ, vxp,vyp )\n"
"					local ht=#t\n"
"					for i,v in ipairs{\n"
"						vx,		vy,		0,	1-(tx),		1-(ty), -- doubletap hack so we can start at any location\n"
"						vx,		vy,		0,	1-(tx),		1-(ty),\n"
"						vx+vxp,	vy,		0,	1-(tx+txp),	1-(ty),\n"
"						vx,		vy+vyp,	0,	1-(tx),		1-(ty+typ),\n"
"						vx+vxp,	vy+vyp,	0,	1-(tx+txp),	1-(ty+typ),\n"
"						vx+vxp,	vy+vyp,	0,	1-(tx+txp),	1-(ty+typ), -- doubletap hack so we can start at any location\n"
"						vx+vxp,	vy+vyp,	0,	1-(tx+txp),	1-(ty+typ), -- doubletap hack so we can start at any location\n"
"					} do\n"
"						t[ht+i]=v\n"
"					end\n"
"				end\n"
"			end\n"
"			\n"
"		local tx,ty=0,0\n"
"		local vx,vy=vxs,vys-- -vw/2,vh/2\n"
"\n"
"			for iy=1,3 do\n"
"				tx=0\n"
"				vx=vxs-- -vw/2\n"
"				for ix=1,3 do\n"
"\n"
"					tdrawbox( tx,ty, vx,vy , tww[twwidx or ix],thh[thhidx or iy], vww[ix],vhh[iy] ) -- fake texture sample to con mipmap mode\n"
"\n"
"					tx=tx+tww[ix]\n"
"					vx=vx+vww[ix]\n"
"				end\n"
"				ty=ty+thh[iy]\n"
"				vy=vy+vhh[iy]\n"
"			end\n"
"\n"
"		drawbox()\n"
"\n"
"\n"
"end\n"
"	\n"
"--\n"
"-- display this widget and its sub widgets\n"
"--\n"
"	function meta.draw_base(widget,f)\n"
"		local w=widget\n"
"	\n"
"		if debug_hook then debug_hook(\"draw\",widget) end\n"
"\n"
"--		gl.PopMatrix() -- expect the base to be pushed\n"
"		gl.PushMatrix()\n"
"--		gl.Translate(widget.px*widget.parent.sx,widget.py*widget.parent.sy,0)\n"
"		gl.Translate(widget.px,widget.py,0)\n"
"		\n"
"		local wsx=1\n"
"		local wsy=1\n"
"		\n"
"		if widget.anim then\n"
"			widget.anim:draw()		\n"
"		end\n"
"\n"
"		if w.sx~=1 or w.sy~=1 then\n"
"			gl.Translate(w.hx/2,w.hy/2,0)\n"
"			gl.Scale(w.sx,w.sy,1)\n"
"			gl.Translate(-w.hx/2,-w.hy/2,0)\n"
"		end\n"
"\n"
"\n"
"-- save draw matrix for later use, probably need to remove master.matrix from this before it is useful?\n"
"widget.matrix=gl.SaveMatrix()\n"
"\n"
"		\n"
"		if widget.clip then\n"
"print(\"clip widget\",widget,widget.px,widget.py,widget.id)		\n"
"			widget.layout=layouts.create{parent2={x=0,y=0,w=widget.master.hx,h=widget.master.hy},\n"
"				x=widget.pxd,\n"
"				y=widget.pyd,\n"
"				w=widget.hx,\n"
"				h=widget.hy}\n"
"			\n"
"			gl.MatrixMode(gl.PROJECTION)\n"
"			gl.PushMatrix()\n"
"			\n"
"			gl.MatrixMode(gl.MODELVIEW)\n"
"			gl.PushMatrix()\n"
"\n"
"\n"
"			widget.old_layout=widget.layout.apply(true) -- forced size\n"
"\n"
"--			gl.Translate(-widget.pxd,-widget.pyd,0)\n"
"		end\n"
"		\n"
"		if widget.pan_px and widget.pan_py and not widget.fbo  then -- fidle everything\n"
"--print(\"draw\",widget.pan_px,widget.pan_py)\n"
"			gl.Translate(-widget.pan_px*wsx,-widget.pan_py*wsy,0)\n"
"		end\n"
"		\n"
"		if widget.fbo then\n"
"			if widget.fbo.w~=widget.hx or widget.fbo.h~=widget.hy then -- resize so we need a new fbo\n"
"--print(\"new fbo\",widget.sx,widget.sy)\n"
"				widget.fbo:resize(widget.hx,widget.hy,0)\n"
"				widget.dirty=true -- flag redraw\n"
"			end				\n"
"		end\n"
"\n"
"--widget.old_layout\n"
"--widget.layout\n"
"\n"
"if ( not widget.fbo ) or widget.dirty then -- if no fbo and then we are always dirty... Dirty, dirty, dirty.\n"
"\n"
"		if widget.fbo then\n"
"--print(\"drawing into fbo\")\n"
"\n"
"			widget.fbo:bind_frame()\n"
"			widget.layout=layouts.create{parent={x=0,y=0,w=widget.fbo.w,h=widget.fbo.h}}\n"
"			\n"
"			gl.MatrixMode(gl.PROJECTION)\n"
"			gl.PushMatrix()\n"
"			\n"
"			gl.MatrixMode(gl.MODELVIEW)\n"
"			gl.PushMatrix()\n"
"\n"
"			widget.old_layout=widget.layout.apply()\n"
"\n"
"			gl.ClearColor(0,0,0,0)\n"
"			gl.Clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT)\n"
"\n"
"		\n"
"			gl.ClearColor(0,0,0,0)\n"
"			gl.Clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT)\n"
"\n"
"			gl.Translate(-widget.px*wsx,-widget.py*wsy,0)\n"
"			if widget.pan_px and widget.pan_py then -- fidle everything\n"
"				gl.Translate(-widget.pan_px*wsx,-widget.pan_py*wsy,0)\n"
"			end\n"
"			\n"
"			gl.PushMatrix() -- put new base matrix onto stack so we can pop to restore?\n"
"--			gl.PushMatrix() -- put new base matrix onto stack so we can pop to restore?\n"
"\n"
"		end\n"
"		\n"
"		widget.dirty=nil\n"
"\n"
"		\n"
"if f then f(widget) end		-- this does the custom drawing\n"
"		\n"
"\n"
"		for i,v in ipairs(widget) do -- iterate on children\n"
"			if not v.fbo or not v.dirty then -- terminate recursion at dirty fbo\n"
"				v:draw()\n"
"			end\n"
"		end\n"
"\n"
"		if widget.fbo then -- we have drawn into the fbo\n"
"			\n"
"--			gl.PopMatrix()\n"
"			gl.PopMatrix()\n"
"\n"
"--			widget.layout.clean()\n"
"\n"
"\n"
"			gl.BindFramebuffer(gl.FRAMEBUFFER, 0)\n"
"			\n"
"\n"
"			widget.old_layout.restore() --restore old viewport\n"
"			gl.MatrixMode(gl.PROJECTION)\n"
"			gl.PopMatrix()			\n"
"			gl.MatrixMode(gl.MODELVIEW)\n"
"			gl.PopMatrix()\n"
"\n"
"\n"
"			widget.layout=nil\n"
"			widget.old_layout=nil\n"
"		end\n"
"		\n"
"else -- we can only draw once\n"
"\n"
"		if widget.fbo then -- we need to draw our cached fbo\n"
"\n"
"		\n"
"			gl.Disable(gl.DEPTH_TEST)\n"
"			gl.Disable(gl.CULL_FACE)\n"
"		\n"
"--			gl.Translate(widget.sx,-widget.sy,0)\n"
"			gl.Color(1,1,1,1)\n"
"			\n"
"			widget.fbo:bind_texture()\n"
"			flat.tristrip(\"xyzuv\",{\n"
"				0,				0,				0,	0,1,\n"
"				widget.fbo.w,	0,				0,	1,1,\n"
"				0,				widget.fbo.h,	0,	0,0,\n"
"				widget.fbo.w,	widget.fbo.h,	0,	1,0,\n"
"			})\n"
"\n"
"--print(\"draw fbo\")\n"
"		end\n"
"		\n"
"end\n"
"\n"
"		if widget.clip then\n"
"		\n"
"			widget.old_layout.restore() --restore old viewport\n"
"			\n"
"			gl.MatrixMode(gl.PROJECTION)\n"
"			gl.PopMatrix()			\n"
"			gl.MatrixMode(gl.MODELVIEW)\n"
"			gl.PopMatrix()\n"
"\n"
"\n"
"			widget.layout=nil\n"
"			widget.old_layout=nil\n"
"\n"
"		end\n"
"		\n"
"		gl.PopMatrix()\n"
"	\n"
"		\n"
"		return widget\n"
"		\n"
"	end\n"
"	\n"
"	function meta.iterate_draw_color(widget)\n"
"		local layer=0\n"
"		return function()\n"
"			layer=layer+1\n"
"			local ret,r,g,b,a=meta.draw_color(widget,layer)\n"
"			if ret then return layer end\n"
"			return nil\n"
"		end \n"
"	end\n"
"	function meta.draw_color(widget,layer)\n"
"		local hilight=0\n"
"		local w=widget\n"
"		local master=widget.master\n"
"		local buttdown=false\n"
"		if ( master.press and master.over==widget ) or widget.state==\"selected\" then\n"
"			buttdown=true\n"
"		end\n"
"\n"
"		local c={explode_color(widget.color)}\n"
"\n"
"		if master.over==widget then\n"
"			if buttdown then\n"
"				if layer>1 then	\n"
"					local a=0.3\n"
"					gl.Color( c[1]*a,c[2]*a,c[3]*a,0 )\n"
"				else\n"
"					gl.Color( c[1],c[2],c[3],c[4] )\n"
"				end\n"
"			else\n"
"				if layer>1 then\n"
"					local a=0.6\n"
"					gl.Color( c[1]*a,c[2]*a,c[3]*a,0 )\n"
"				else\n"
"					gl.Color( c[1],c[2],c[3],c[4] )\n"
"				end\n"
"			end\n"
"		else\n"
"				if layer>1 then\n"
"					return false\n"
"				else\n"
"					gl.Color( c[1],c[2],c[3],c[4] )\n"
"				end\n"
"		end\n"
"		if layer>2 then return false end\n"
"		return true\n"
"	end\n"
"	\n"
"	function meta.draw(widget)\n"
"		local wsx=1\n"
"		local wsy=1\n"
"\n"
"		local w=widget\n"
"		local master=widget.master\n"
"	\n"
"		meta.draw_base(widget,function(widget)\n"
"						\n"
"		local txp,typ=0,0\n"
"		\n"
"		if widget.color then -- need a color to draw, so no color, no draw\n"
"		\n"
"			local style=widget.style\n"
"			\n"
"			if not style then -- make assumptions\n"
"			\n"
"				style=\"button\" -- default\n"
"\n"
"				if  widget.class==\"textedit\" then\n"
"				\n"
"					style=\"indent\" -- draw upside down button?\n"
"					\n"
"				elseif (not widget.hooks) then -- probably not a button\n"
"				\n"
"					style=\"flat\"\n"
"				\n"
"				end\n"
"			end\n"
"						\n"
"			local buttdown=false\n"
"			if ( master.press and master.over==widget ) or widget.state==\"selected\" then\n"
"				buttdown=true\n"
"			end\n"
"\n"
"			local hx=widget.hx\n"
"			local hy=widget.hy\n"
"			local bb=2\n"
"			local tl={1,1,1,0.25}\n"
"			local br={0,0,0,0.25}\n"
"			tl[1]=tl[1]*tl[4]\n"
"			tl[2]=tl[2]*tl[4]\n"
"			tl[3]=tl[3]*tl[4]\n"
"			br[1]=br[1]*br[4]\n"
"			br[2]=br[2]*br[4]\n"
"			br[3]=br[3]*br[4]\n"
"			\n"
"			if buttdown then -- flip highlight\n"
"				tl,br=br,tl\n"
"				txp=1\n"
"				typ=1\n"
"			end\n"
"			\n"
"for layer in meta.iterate_draw_color(widget) do -- something to draw, color has been set for this layer\n"
"\n"
"			if widget.sheet then -- custom graphics\n"
"\n"
"				sheets.get(widget.sheet):draw(widget.sheet_id or 1,widget.sheet_px or 0,widget.sheet_py or 0,0,widget.sheet_hx or hx,widget.sheet_hy or hy)\n"
"			\n"
"			elseif mode then -- got some images to play with\n"
"			\n"
"				if style==\"flat\" then\n"
"				\n"
"					images.bind(images.get(\"wskins/\"..mode..\"/border\"))\n"
"					txp=0\n"
"					typ=-1\n"
"\n"
"					draw33(128,128, 24,24, 0-margin,0-margin, hx+(margin*2),hy+(margin*2))\n"
"\n"
"				elseif style==\"indent\" then\n"
"\n"
"					images.bind(images.get(\"wskins/\"..mode..\"/buttin\"))\n"
"					txp=0\n"
"					typ=0\n"
"\n"
"					draw33(128,128, 24,24, 0-margin,0-margin, hx+(margin*2),hy+(margin*2),true)\n"
"\n"
"				elseif style==\"button\" then\n"
"\n"
"					if ( master.press and master.over==widget ) or widget.state==\"selected\" then\n"
"						images.bind(images.get(\"wskins/\"..mode..\"/buttin\"))\n"
"						txp=0\n"
"						typ=-1\n"
"					else\n"
"						images.bind(images.get(\"wskins/\"..mode..\"/button\"))\n"
"						txp=0\n"
"						typ=-2\n"
"					end\n"
"					\n"
"					draw33(128,128, 24,24, 0-margin,0-margin, hx+(margin*2),hy+(margin*2))\n"
"				end\n"
"								\n"
"			\n"
"			else -- builtin\n"
"			\n"
"			\n"
"			flat.quad(	0,		0,\n"
"						hx,		0,\n"
"						hx,		hy,\n"
"						0,		hy)\n"
"			gl.Color( tl[1],tl[2],tl[3],tl[4] )\n"
"			flat.quad(	0,		0,\n"
"						hx,		0,\n"
"						hx-bb,	bb,\n"
"						0+bb, 	bb)\n"
"			flat.quad(	0,		0,\n"
"						0+bb,	bb,\n"
"						0+bb, 	hy-bb,\n"
"						0,    	hy)\n"
"			gl.Color( br[1],br[2],br[3],br[4] )\n"
"			flat.quad( hx,  	hy,\n"
"						0,  	hy,\n"
"						0+bb,	hy-bb,\n"
"						hx-bb,	hy-bb)\n"
"			flat.quad(  hx,    0,\n"
"						hx,    hy,\n"
"						hx-bb, hy-bb,\n"
"						hx-bb, bb)\n"
"			end\n"
"end\n"
"			\n"
"		end\n"
"		\n"
"		if widget.text then\n"
"		\n"
"			local fy=widget:bubble(\"text_size\") or 16\n"
"\n"
"			local f=widget.font or widget.master.font or 1\n"
"			if f then\n"
"				if type(f)==\"number\" then\n"
"				else\n"
"					typ=typ-fy/8 -- reposition font slightly as fonts other than the builtin probably have descenders\n"
"				end\n"
"			end\n"
"			\n"
"			font.set(cake.fonts.get(f))\n"
"			font.set_size(fy,0)\n"
"\n"
"			local lines\n"
"			\n"
"			if widget.text_align==\"wrap\" then\n"
"				lines=font.wrap(widget.text,{w=widget.hx}) -- break into lines\n"
"				widget.lines=lines -- remember wraped text\n"
"			else\n"
"				lines={widget.text}\n"
"			end\n"
"\n"
"			local ty=typ\n"
"			local c=widget.text_color\n"
"			if widget.text_color_over then\n"
"				if master.over==widget then\n"
"					c=widget.text_color_over\n"
"				end\n"
"			end\n"
"			\n"
"			for i,line in ipairs(lines) do\n"
"			\n"
"				local tx=font.width(line)\n"
"				\n"
"				if widget.text_align==\"left\" or widget.text_align==\"wrap\" then\n"
"					tx=0\n"
"				elseif widget.text_align==\"right\" then\n"
"					tx=(widget.hx-tx)\n"
"				elseif widget.text_align==\"centerx\" then\n"
"					tx=(widget.hx-tx)/2\n"
"				else -- center a single line vertically as well\n"
"					tx=(widget.hx-tx)/2 \n"
"					ty=((widget.hy-fy)/2)+typ\n"
"				end\n"
"				\n"
"				tx=tx+txp\n"
"--				ty=ty+typ\n"
"				\n"
"				if i==1 then -- remember topleft of text position for first line\n"
"					widget.text_x=tx\n"
"					widget.text_y=ty\n"
"				end\n"
"\n"
"				if widget.text_color_shadow then\n"
"					gl.Color( pack.argb8_pmf4(widget.text_color_shadow) )\n"
"					font.set_xy((tx+1)*wsx,(ty+1)*wsy)\n"
"					font.draw(line)\n"
"				end\n"
"				\n"
"				gl.Color( pack.argb8_pmf4(c) )\n"
"				font.set_xy((tx)*wsx,(ty)*wsy)\n"
"--print(wstr.dump(line))\n"
"				font.draw(line)\n"
"				\n"
"				if widget.class==\"textedit\" then -- hack\n"
"					if widget.master.focus==widget or widget.master.edit==widget then --only draw curser in active widget\n"
"						if widget.master.throb>=128 then\n"
"							local sw=font.width(widget.text:sub(1,widget.data.str_idx))\n"
"\n"
"							font.set_xy((tx+sw)*wsx,(ty)*wsy)\n"
"							font.draw(\"_\")\n"
"						end\n"
"					end\n"
"				end\n"
"\n"
"				ty=ty+fy\n"
"			end\n"
"		end\n"
"		\n"
"		end)\n"
"		\n"
"		return widget\n"
"	end\n"
"\n"
"\n"
"\n"
"end\n"
"\n"
"return wskin\n"
"end\n"
"",

"wetgenes.www.gae.fetch","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local core=require(\"wetgenes.www.gae.fetch.core\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.fetch\"]=_M\n"
"\n"
"function countzero()\n"
"	count=0\n"
"	api_time=0\n"
"end\n"
"countzero()\n"
"\n"
"local kind_props={}	-- default global props mapped to kinds\n"
"\n"
"local start_time -- handle simple api benchmarking of some calls\n"
"local function apis()\n"
"	start_time=os.time()\n"
"end\n"
"local function apie(...)\n"
"	api_time=api_time+os.time()-start_time\n"
"	return ...\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"function get(...)\n"
"	apis()\n"
"	count=count+1\n"
"	return apie(core.get(...))\n"
"end\n"
"\n"
"\n"
"\n"
"function post(...)\n"
"	apis()\n"
"	count=count+1\n"
"	return apie(core.post(...))\n"
"end\n"
"",

"wetgenes.gamecake.spew.geom_wetiso","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local pack=require(\"wetgenes.pack\")\n"
"local wwin=require(\"wetgenes.win\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"local tardis=require(\"wetgenes.tardis\")	-- matrix/vector math\n"
"\n"
"local function dprint(a) print(wstr.dump(a)) end\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"M.bake=function(oven,wetiso)\n"
"	local wetiso=wetiso or {}\n"
"	wetiso.oven=oven\n"
"	\n"
"	wetiso.modname=M.modname\n"
"\n"
"	local cake=oven.cake\n"
"	local opts=oven.opts\n"
"	local canvas=cake.canvas\n"
"	local font=canvas.font\n"
"	local flat=canvas.flat\n"
"	local gl=oven.gl\n"
"	local sheets=cake.sheets\n"
"	local fbs=cake.framebuffers\n"
"\n"
"	local geom=oven.rebake(\"wetgenes.gamecake.spew.geom\")\n"
"\n"
"\n"
"wetiso.loads=function()\n"
"\n"
"end\n"
"		\n"
"wetiso.setup=function()\n"
"\n"
"	wetiso.loads()\n"
"\n"
"	wetiso.it=geom.icosahedron()\n"
"	local swap={\n"
"			{	3+16	,	1	,	0	},\n"
"			{	7		,	2	,	2	},\n"
"			{	4+16	,	3	,	1	},\n"
"			{	4+16	,	4	,	0	},\n"
"			{	4+16	,	5	,	1	},\n"
"			{	5+8		,	6	,	0	},\n"
"			{	7		,	7	,	2	},\n"
"			{	6+8		,	8	,	1	},\n"
"\n"
"			{	2+16	,	1+8	,	0	},\n"
"			{	6+8		,	2+8	,	2	},\n"
"			{	1+16	,	3+8	,	1	},\n"
"			{	4+16	,	4+8	,	0	},\n"
"			{	5+8		,	5+8	,	1	},\n"
"			{	8+8		,	6+8	,	0	},\n"
"			{	3+16	,	7+8	,	2	},\n"
"			{	3+16	,	8+8	,	1	},\n"
"\n"
"			{	1+16	,	1+16	,	0	},\n"
"			{	4+16	,	2+16	,	1	},\n"
"			{	4+16	,	3+16	,	0	},\n"
"			{	4+16	,	4+16	,	2	},\n"
"\n"
"		}\n"
"	local n=wetiso.it.polys\n"
"	for i,v in pairs(swap) do\n"
"		n[ v[1] ] , n[ v[2] ] = n[ v[2] ] , n[ v[1] ]\n"
"		\n"
"		local p=n[ v[2] ]\n"
"		for i=1,v[3] do\n"
"			table.insert(p,1,table.remove(p,#p)) -- rotate\n"
"		end\n"
"	end\n"
"\n"
"	geom.apply_bevel(wetiso.it,7/8)\n"
"\n"
"	wetiso.fbo=fbs.create()\n"
"\n"
"	wetiso.predraw()\n"
"end\n"
"\n"
"wetiso.clean=function()\n"
"\n"
"	wetiso.fbo:clean()\n"
"	wetiso.fbo=nil\n"
"	\n"
"end\n"
"\n"
"wetiso.predraw=function()\n"
"\n"
"	if not gl.programs.geom_wetiso then -- setup our special shaders\n"
"	\n"
"		gl.shaders.v_geom_wetiso={\n"
"		source=gl.defines.shaderprefix..[[\n"
"\n"
"uniform mat4 modelview;\n"
"uniform mat4 projection;\n"
"uniform vec4 color;\n"
"\n"
"attribute vec3 a_vertex;\n"
"attribute vec3 a_normal;\n"
"attribute vec2 a_texcoord;\n"
"\n"
"varying vec4  v_color;\n"
"varying vec3  v_normal;\n"
"varying vec3  v_pos;\n"
"varying vec2  v_texcoord;\n"
"varying float v_face;\n"
" \n"
"void main()\n"
"{\n"
"\n"
"	v_face=a_texcoord.x-1.0;\n"
"\n"
"	float vx=mod(v_face,8.0);\n"
"//	float vy=floor(v_face/8.0);\n"
"\n"
"    gl_Position = projection * modelview * vec4(a_vertex, 1.0);\n"
"    v_normal = normalize( mat3( modelview ) * a_normal );\n"
"	v_color=color;\n"
"\n"
"	int a=int(clamp(a_texcoord.y-1.0,0.0,2.0));\n"
"	\n"
"	if(a==2) {			v_texcoord=vec2(	 (vx+1.0)/8.0	,	 0.0	);\n"
"	} else if(a==1) {	v_texcoord=vec2(	 (vx+0.5)/8.0	,	 1.0	);\n"
"	} else {			v_texcoord=vec2(	 (vx    )/8.0	,	 0.0	);\n"
"	}\n"
"\n"
"}\n"
"\n"
"	]]\n"
"}\n"
"\n"
"		gl.shaders.f_geom_wetiso={\n"
"		source=gl.defines.shaderprefix..[[\n"
"\n"
"uniform sampler2D tex;\n"
"\n"
"varying vec4  v_color;\n"
"varying vec4  v_color2;\n"
"varying vec3  v_normal;\n"
"varying vec3  v_pos;\n"
"varying vec2  v_texcoord;\n"
"varying float v_face;\n"
"\n"
"\n"
"vec3 d=vec3(0.0,0.0,-1.0);\n"
"\n"
"void main(void)\n"
"{\n"
"	vec4 tc=vec4(0.0,0.0,0.0,0.0);\n"
"	if( floor(v_face+(1.0/4096.0)) == ceil(v_face-(1.0/4096.0)) )\n"
"	{\n"
"		tc=texture2D(tex, v_texcoord);\n"
"	}\n"
"\n"
"	vec3 n=normalize(v_normal);\n"
"	gl_FragColor= tc + (v_color*max( -n.z, 0.25 ))*(1.0-tc.a) ;\n"
"	gl_FragColor.a=1.0;\n"
"}\n"
"\n"
"	]]\n"
"}\n"
"\n"
"		gl.programs.geom_wetiso={\n"
"			vshaders={\"v_geom_wetiso\"},\n"
"			fshaders={\"f_geom_wetiso\"},\n"
"		}\n"
"	\n"
"	end\n"
"\n"
"	if not wetiso.fbo.texture then -- build our texture (happens after any stop/start)\n"
"\n"
"		gl.MatrixMode(gl.PROJECTION)\n"
"		gl.PushMatrix()\n"
"		gl.MatrixMode(gl.MODELVIEW)\n"
"		gl.PushMatrix()\n"
"\n"
"		wetiso.fbo:resize(1024,128,0)		\n"
"		wetiso.fbo:bind_frame()\n"
"		local layout=cake.layouts.create{parent={w=wetiso.fbo.w,h=wetiso.fbo.h,x=0,y=0}}\n"
"		local oldlay=layout.apply(wetiso.fbo.w,wetiso.fbo.h,1/4,wetiso.fbo.h*4)\n"
"		\n"
"		gl.ClearColor(pack.argb4_pmf4(0x0000))\n"
"		gl.Clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT)\n"
"		\n"
"--		cells.draw_walls()\n"
"			font.set(cake.fonts.get(\"Vera\")) -- default font\n"
"			font.set_size(64) -- 32 pixels high\n"
"\n"
"			gl.Color(1,1,1,1)\n"
"			for i=1,8 do\n"
"				local a=string.sub(\"W tgenes\",i,i)\n"
"--				local a=string.sub(\"12345678\",i,i)\n"
"				local w=font.width(a)\n"
"				font.set_xy((i-1)*128 + (128-w)/2 ,48)\n"
"				font.draw(a)\n"
"			end\n"
"--			font.draw(\"abcdefghijklmnopqrstuvwxyz\")\n"
"\n"
"			local a=\"e\" -- need an upside down E\n"
"			local w=font.width(a)\n"
"			gl.Translate(128 + 64 ,64)\n"
"			gl.Rotate(180 ,0,0,1 )\n"
"			font.set_xy( -(w/2)  , -32 -32 )\n"
"			font.draw(a)\n"
"\n"
"\n"
"		fbs.bind_frame(nil)\n"
"		\n"
"		wetiso.fbo:free_depth()\n"
"		wetiso.fbo:free_frame()\n"
"		-- but keep the texture and update its mipmaps\n"
"		wetiso.fbo:mipmap()\n"
"\n"
"		gl.MatrixMode(gl.PROJECTION)\n"
"		gl.PopMatrix()\n"
"		gl.MatrixMode(gl.MODELVIEW)\n"
"		gl.PopMatrix()\n"
"		\n"
"--		main.layout.restore()\n"
"		oldlay.restore()\n"
"\n"
"	end\n"
"	\n"
"	geom.predraw(wetiso.it,\"geom_wetiso\")\n"
"\n"
"end\n"
"\n"
"wetiso.draw=function()\n"
"\n"
"	wetiso.predraw() -- make sure buffers are valid\n"
"		\n"
"	wetiso.fbo:bind_texture()\n"
"	geom.draw(wetiso.it,\"geom_wetiso\")\n"
"	\n"
"end\n"
"\n"
"	return wetiso\n"
"end\n"
"",

"wetgenes.cgilua.session","--\r\n"
"-- Mysql helper functions\r\n"
"--\r\n"
"\r\n"
"require\"cgilua.cookies\"\r\n"
"\r\n"
"local sql=require(\"wetgenes.cgilua.mysql\")\r\n"
"\r\n"
"\r\n"
"local type,ipairs=type,ipairs\r\n"
"\r\n"
"local string=string\r\n"
"\r\n"
"local wet_html=require(\"wetgenes.html\")\r\n"
"\r\n"
"local cgi = wetgenes.cgilua or require(\"wetgenes.cgilua\")\r\n"
"local cfg = cfg\r\n"
"\r\n"
"\r\n"
"local cgilua=cgilua\r\n"
"\r\n"
"local dbg=dbg or function(s) cgilua.errorlog(s) end\r\n"
"\r\n"
"module(\"wetgenes.cgilua.session\")\r\n"
"\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- log in using a session\r\n"
"-- if need is set to true then redirect to a login page as a login is needed\r\n"
"--\r\n"
"-- pass in url of current page if needed, (escaping is icky)\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function login(need)\r\n"
"\r\n"
"local sess=cgilua.cookies.get(cfg.cookie_session)\r\n"
"\r\n"
"local redirect=\"http://join.wetgenes.\"..cfg.tld..\"/?redirect=\"..wet_html.url_esc(wet_html.url_esc(cgi.url_query))\r\n"
"\r\n"
"user={}\r\n"
"\r\n"
"\r\n"
"	if sess then\r\n"
"\r\n"
"		sess=string.gsub(sess, \"[^0-9a-zA-Z]+\", \"\" )\r\n"
"\r\n"
"\r\n"
"		local info=sql.execute([[SELECT\r\n"
"				u.alias, u.posts_ppg, u.time_zone, u.sig, u.last_visit, u.last_read, u.cat_collapse_status, u.users_opt,\r\n"
"				u.ignore_list, u.buddy_list, u.id, u.group_leader_list, u.email, u.login, u.sq, u.ban_expiry\r\n"
"				, u.avatar_loc , u.referer_id , s.time_sec , s.sys_id\r\n"
"			FROM ]]..cfg.mysql_prefix_fud..[[ses s\r\n"
"				INNER JOIN ]]..cfg.mysql_prefix_fud..[[users u ON u.id=(CASE WHEN s.user_id>2000000000 THEN 1 ELSE s.user_id END)\r\n"
"			WHERE ses_id=']]..sess..[[']])\r\n"
"\r\n"
"		local tab=sql.named(info,1)\r\n"
"\r\n"
"		if tab then -- session exists\r\n"
"		\r\n"
"			if cgi.ip==tab.sys_id then -- mild security fix, session is locked to ip\r\n"
"			\r\n"
"			\r\n"
"				user.fud=tab\r\n"
"				\r\n"
"				if tab.login==\"XIX\" or tab.login==\"shi\" then -- flag admin logins\r\n"
"					tab.admin=true\r\n"
"				end\r\n"
"			\r\n"
"--	dbg(\"success\")\r\n"
"	\r\n"
"			else\r\n"
"\r\n"
"				if need then\r\n"
"					cgi.redirect(redirect)\r\n"
"				end\r\n"
"--	dbg(\"fail bad ip \"..cgi.ip..\":\"..tab.sys_id)\r\n"
"\r\n"
"			end\r\n"
"			\r\n"
"			\r\n"
"		else -- user does not exist\r\n"
"		\r\n"
"--	dbg(\"fail bad sesson\")\r\n"
"			\r\n"
"			if need then\r\n"
"				cgi.redirect(redirect)\r\n"
"			end\r\n"
"			\r\n"
"		end\r\n"
"\r\n"
"	else\r\n"
"	\r\n"
"		if need then\r\n"
"			cgi.redirect(redirect)\r\n"
"		end\r\n"
"			\r\n"
"--	dbg(\"fail no session\")\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	return user\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"",

"wetgenes.gamecake.widgets.drag","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,wdrag)\r\n"
"wdrag=wdrag or {}\r\n"
"\r\n"
"function wdrag.mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wdrag.key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wdrag.update(widget)\r\n"
"\r\n"
"	if widget.data then\r\n"
"		widget.text=widget.data:get_string()\r\n"
"	end\r\n"
"\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function wdrag.draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wdrag.setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.drag=it\r\n"
"	widget.class=\"drag\"\r\n"
"	\r\n"
"	widget.key=wdrag.key\r\n"
"	widget.mouse=wdrag.mouse\r\n"
"	widget.update=wdrag.update\r\n"
"	widget.draw=wdrag.draw\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"\r\n"
"return wdrag\r\n"
"end\r\n"
"",

"glescode","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- generate a place to compile gl code into\n"
"-- this also contains matrix manipulation functions in the style of normal gl\n"
"-- and a simple Color replacement that just caches the color here for later use\n"
"\n"
"local bit=require(\"bit\")\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"local tardis=require(\"wetgenes.tardis\")\n"
"local tcore=require(\"wetgenes.tardis.core\") -- TODO: patch this into the base tardis core...\n"
"\n"
"local core=require(\"gles.core\")\n"
"\n"
"\n"
"local glescode={}\n"
"\n"
"\n"
"-- please pass in the gles base you wish to use, eg gles.gles2\n"
"-- returns a state table with compiler functions and places to\n"
"-- keep your source.\n"
"function glescode.create(gl)\n"
"\n"
"	local code={}\n"
"	for n,v in pairs(gl) do code[n]=v end\n"
"	\n"
"	code.cache={}\n"
"	code.cache.color=tcore.new_v4()\n"
"	\n"
"	function code.Color(...)\n"
"		tcore.set(code.cache.color,...) -- may not set anything if no arguments are given\n"
"		return code.cache.color -- safe way of getting this value (a 4 float userdata)\n"
"	end\n"
"\n"
"-- easy to type color helpers, returns 4 **PREMULTIPLIED** floats from color u16 or u32\n"
"	function code.C4(c) -- 0xffff -- ARGB\n"
"		local r,g,b,a	\n"
"		a=bit.band(bit.rshift(c,12),0xf)\n"
"		r=bit.band(bit.rshift(c, 8),0xf)\n"
"		g=bit.band(bit.rshift(c, 4),0xf)\n"
"		b=bit.band(c,0xf)\n"
"		a=a/0xf\n"
"		return a*r/0xf,a*g/0xf,a*b/0xf,a\n"
"	end\n"
"\n"
"	function code.C8(c) -- 0xffffffff -- AARRGGBB\n"
"		local r,g,b,a	\n"
"		a=bit.band(bit.rshift(c,24),0xff)\n"
"		r=bit.band(bit.rshift(c,16),0xff)\n"
"		g=bit.band(bit.rshift(c, 8),0xff)\n"
"		b=bit.band(c,0xff)\n"
"		a=a/0xff\n"
"		return a*r/0xff,a*g/0xff,a*b/0xff,a\n"
"	end\n"
"\n"
"\n"
"-- matrix functions\n"
"\n"
"	function code.reset_stacks()\n"
"		code.stacks={}		\n"
"		code.stack_mode=nil\n"
"		code.stack=nil\n"
"		code.stack_matrix=nil\n"
"	end\n"
"	code.reset_stacks() -- setup\n"
"\n"
"	function code.matrix(mode)\n"
"		local v=code.stacks[mode]\n"
"		return v[#v]\n"
"	end\n"
"	\n"
"	function code.MatrixMode(mode)\n"
"		code.stack_mode=mode\n"
"		code.stack=code.stacks[code.stack_mode]\n"
"		if not code.stack then -- create on use\n"
"			local m4=tcore.new_m4() tcore.m4_identity(m4)\n"
"			code.stack={ m4 }\n"
"			code.stacks[code.stack_mode]=code.stack\n"
"		end\n"
"		code.stack_matrix=assert(code.stack[#code.stack])\n"
"	end\n"
"\n"
"-- returns a matrix that can later be used in LoadMatrix\n"
"	function code.SaveMatrix(...)\n"
"		local m4=tcore.new_m4() tcore.set(m4,code.stack_matrix,16)\n"
"		return m4\n"
"	end\n"
"\n"
"	function code.LoadMatrix(...)\n"
"		tcore.set(code.stack_matrix,...)\n"
"	end\n"
"\n"
"	function code.MultMatrix(a)\n"
"		tcore.m4_product_m4(code.stack_matrix,a,code.stack_matrix)\n"
"	end\n"
"\n"
"-- we have our own majick code for this sort of thing\n"
"	function code.Frustum(...)\n"
"		error(\"frustrum not suported\")\n"
"	end\n"
"\n"
"	function code.LoadIdentity()\n"
"		tcore.m4_identity(code.stack_matrix)\n"
"	end\n"
"\n"
"	function code.Translate(vx,vy,vz)\n"
"		tcore.m4_translate(code.stack_matrix,vx,vy,vz)\n"
"	end\n"
"\n"
"	function code.Rotate(d,vx,vy,vz)\n"
"		tcore.m4_rotate(code.stack_matrix,d,vx,vy,vz)\n"
"	end\n"
"\n"
"	function code.Scale(vx,vy,vz)\n"
"		tcore.m4_scale_v3(code.stack_matrix,vx,vy,vz)\n"
"	end\n"
"\n"
"	function code.PushMatrix()		\n"
"		local m4=tcore.new_m4() tcore.set(m4,code.stack_matrix,16)\n"
"		code.stack[#code.stack+1]=m4\n"
"		code.stack_matrix=assert(code.stack[#code.stack])\n"
"	end\n"
"\n"
"	function code.PopMatrix()\n"
"		code.stack[#code.stack]=nil -- remove topmost\n"
"		code.stack_matrix=assert(code.stack[#code.stack]) -- this will assert on too many pops\n"
"	end\n"
"\n"
"-- compiler functions\n"
"\n"
"-- function to provide simple source for a shader program\n"
"	function code.progsrc(name,vsource,fsource)\n"
"		if not code.programs[name] then -- only do once\n"
"			code.shaders[\"v_\"..name]={source=vsource}\n"
"			code.shaders[\"f_\"..name]={source=fsource}\n"
"			code.programs[name]={\n"
"				vshaders={\"v_\"..name},\n"
"				fshaders={\"f_\"..name},\n"
"			}\n"
"		end\n"
"	end\n"
"\n"
"	code.shaders={}\n"
"	code.programs={}\n"
"	code.defines={}\n"
"\n"
"-- default shader prefix to use when building\n"
"	code.defines.shaderprefix=\"#version 100\\n"
"precision mediump float;\\n"
"\"\n"
"\n"
"	if core.fixed_pipeline_available then -- probably desktop GL so needs haxtbh\n"
"	\n"
"		code.defines.shaderprefix=\"#version 120\\n"
"\"\n"
"\n"
"	end\n"
"	\n"
"-- forget cached info when we lose context, it is important to call this\n"
"	function code.forget()\n"
"		for i,v in pairs(code.shaders) do\n"
"			v[0]=nil\n"
"		end\n"
"		for i,v in pairs(code.programs) do\n"
"			v[0]=nil\n"
"		end\n"
"	end\n"
"	\n"
"	function code.shader(stype,sname)\n"
"\n"
"		local s\n"
"		\n"
"		if type(sname)==\"string\" then\n"
"			s=assert(code.shaders[sname])\n"
"		else\n"
"			s=sname\n"
"			if not code.shaders[s] then\n"
"				local idx=#code.shaders+1\n"
"				code.shaders[s.name or idx]=s\n"
"				code.shaders[s]=s.name or idx\n"
"			end\n"
"			sname=s.name or (\"__inline__shader__\"..code.shaders[s])\n"
"		end\n"
"		\n"
"		if s[0] then return s[0] end\n"
"\n"
"-- Uhm, we could really use a shader lint or precompiler at this point, why does such a thing not exist?\n"
"-- I dont normaly care for lint but it would *really* make sense here...\n"
"\n"
"--print(\"Compiling shader \"..sname)\n"
"		s[0]=gl.CreateShader(stype)\n"
"		gl.ShaderSource(s[0],wstr.macro_replace(s.source,code.defines))\n"
"		gl.CompileShader(s[0])\n"
"		\n"
"		if gl.GetShader(s[0], gl.COMPILE_STATUS) == gl.FALSE then -- error\n"
"\n"
"			error( \"failed to build shader \" .. sname .. \"\\n"
"SHADER COMPILER ERRORS\\n"
"\\n"
"\" .. (gl.GetShaderInfoLog(s[0]) or \"stoopid droid\") .. \"\\n"
"\\n"
"\" )\n"
"		end\n"
"	\n"
"		return s[0]\n"
"	end\n"
"	\n"
"	local pbase={}\n"
"	local pmeta={__index=pbase}\n"
"	\n"
"	function code.program(pname)\n"
"		local p\n"
"		\n"
"		if type(pname)==\"string\" then\n"
"			p=assert(code.programs[pname])\n"
"		else\n"
"			p=pname\n"
"			if not code.programs[p] then\n"
"				local idx=#code.programs+1\n"
"				code.programs[p.name or idx]=p\n"
"				code.programs[p]=p.name or idx\n"
"			end\n"
"			pname=p.name or (\"__inline__program__\"..code.programs[p])\n"
"		end\n"
"		\n"
"		if not p[0] then\n"
"			setmetatable(p,pmeta)\n"
"\n"
"			p.cache={}\n"
"			p.vars={}\n"
"			p[0]=gl.CreateProgram()\n"
"			\n"
"			for i,v in ipairs(p.vshaders) do\n"
"				gl.AttachShader( p[0] , code.shader(gl.VERTEX_SHADER,v) )\n"
"			end\n"
"			for i,v in ipairs(p.fshaders) do\n"
"				gl.AttachShader( p[0] , code.shader(gl.FRAGMENT_SHADER,v) )\n"
"			end\n"
"			\n"
"--print(\"Linking program \"..pname)\n"
"			gl.LinkProgram(p[0])\n"
"		\n"
"			if gl.GetProgram(p[0], gl.LINK_STATUS) == gl.FALSE then -- error\n"
"\n"
"				print( gl.GetProgramInfoLog(p[0]) , \"\\n"
"\" )\n"
"\n"
"				error( \"failed to build program \"..pname )\n"
"			end\n"
"			\n"
"		end\n"
"		return p\n"
"	end\n"
"	\n"
"	function pbase.attrib(p,vname)\n"
"		local r=p.vars[vname]\n"
"		if r then return r end\n"
"		r=gl.GetAttribLocation(p[0],vname)\n"
"		p.vars[vname]=r\n"
"		return r\n"
"	end\n"
"\n"
"	function pbase.uniform(p,vname)\n"
"		local r=p.vars[vname]\n"
"		if r then return r end\n"
"		r=gl.GetUniformLocation(p[0],vname)\n"
"		p.vars[vname]=r\n"
"		return r\n"
"	end\n"
"\n"
"-- internal cache helpers\n"
"\n"
"	local function cache_set_v4(p,n,v)\n"
"		if not p.cache[n] then\n"
"			p.cache[n]=tcore.new_v4()\n"
"		end\n"
"		tcore.set(p.cache[n],v)\n"
"		return p.cache[n]\n"
"	end\n"
"	local function cache_set_m4(p,n,v)\n"
"		if not p.cache[n] then\n"
"			p.cache[n]=tcore.new_m4()\n"
"		end\n"
"		tcore.set(p.cache[n],v)\n"
"		return p.cache[n]\n"
"	end\n"
"\n"
"	local function cache_check_v4(p,n,v)\n"
"		if not p.cache[n] then return false end\n"
"		return tcore.compare(p.cache[n],v)\n"
"	end\n"
"	local function cache_check_m4(p,n,v)\n"
"		if not p.cache[n] then return false end\n"
"		return tcore.compare(p.cache[n],v)\n"
"	end\n"
"\n"
"-- set attribs\n"
"-- probably too hard to try and cache these here\n"
"-- due to the nature of vertexbuffers\n"
"\n"
" 	function pbase.attrib_ptr(p,vname,size,gltype,normalize,stride,ptr)\n"
"		local n=p:attrib(vname)\n"
"		gl.VertexAttribPointer(n,vname,size,gltype,normalize,stride,ptr)\n"
"	end\n"
"	function pbase.attrib_stream(p,vname,onoff)\n"
"		local n=p:attrib(vname)\n"
"		if onoff then\n"
"			gl.EnableVertexAttribArray(n)\n"
"		else\n"
"			gl.DisableVertexAttribArray(n)\n"
"		end\n"
"	end\n"
"	function pbase.attrib_v4(p,vname,v4)\n"
"		local n=p:attrib(vname)\n"
"		gl.VertexAttrib4f(n,v4)\n"
"	end\n"
"\n"
"-- set uniform values\n"
"-- try and cache these values to prevent updates which often seem rather expensive\n"
"\n"
"	function pbase.uniform_v4(p,vname,v4)\n"
"		if cache_check_v4(p,vname,v4) then return end\n"
"		local n=p:uniform(vname)\n"
"		gl.Uniform4f(n, cache_set_v4(p,vname,v4) )\n"
"	end\n"
"	function pbase.uniform_m4(p,vname,m4)\n"
"		if cache_check_m4(p,vname,m4) then return end\n"
"		local n=p:uniform(vname)\n"
"		gl.UniformMatrix4f(n,cache_set_m4(p,vname,m4))\n"
"	end\n"
"	\n"
"	return code\n"
"end\n"
"\n"
"\n"
"return glescode\n"
"",

"wetgenes.www.sqlite","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=print\n"
"\n"
"if ngx then\n"
"	log=require(\"wetgenes.www.any.log\").log\n"
"end\n"
"\n"
"local sql=require(\"sqlite\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"local function fixkind(kind) return kind:gsub(\"%p\",\"_\") end\n"
"\n"
"module(...)\n"
"\n"
"dbs={} -- tooglobal?pass in this or your own to the funcs anyhow\n"
"\n"
"function open(dbs,prefix,kind,postfix) -- multiple opens are ok and get you the same db\n"
"\n"
"	kind=fixkind(kind)\n"
"\n"
"	local db=dbs[kind]\n"
"	\n"
"	if db then return db end -- already open\n"
"	\n"
"	db=assert(sql.open(prefix..kind..postfix))\n"
"\n"
"	set_pragmas(db) -- always run this\n"
"\n"
"\n"
"	dbs[kind]=db -- remember\n"
"	return db\n"
"	\n"
"end\n"
"\n"
"function close(dbs,kind)\n"
"\n"
"	kind=fixkind(kind)\n"
"\n"
"	local db=dbs[kind]\n"
"	\n"
"	if db then\n"
"		sb:close()\n"
"		dbs[kind]=nil\n"
"	end\n"
"end\n"
"\n"
"-- setup pragmas, should run this after opening a db\n"
"function set_pragmas(db)\n"
"exec(db,[[\n"
"PRAGMA synchronous = 0 ;\n"
"PRAGMA encoding = \"UTF-8\" ;\n"
"]])\n"
"\n"
"-- tunrning sync off is dangerous, but so is life\n"
"-- technically its only dangerous if you lose power whilst writing to disk\n"
"-- this is perhaps less likely than file coruption on a failing disk\n"
"\n"
"end\n"
"\n"
"-- wrap db:exec with an error checker\n"
"function exec(db,s,f,d)\n"
"--log(s)\n"
"	if 	db:exec(s,f,d)~=sql.OK then error(db:errmsg()) end\n"
"end\n"
"\n"
"-- get all rows the sql requests\n"
"function rows(db,s)\n"
"\n"
"	local d={}\n"
"--	local f=function(d,count,v,n)\n"
"--		local dd={}\n"
"--		d[#d+1]=dd\n"
"--		for i=1,count do dd[ n[i] ]=v[i] end\n"
"--		return 0\n"
"--	end\n"
"	\n"
"	for r in db:nrows(s) do\n"
"		d[#d+1]=r\n"
"	end\n"
"\n"
"--	if 	db:exec(s,f,d)~=sql.OK then error(db:errmsg()) end\n"
"\n"
"	return d\n"
"end\n"
"\n"
"-- get first row the sql requests\n"
"function row(db,s)\n"
"	return rows(db,s)[1]\n"
"end\n"
"\n"
"-- get info about a table, this can only work if WE created the table\n"
"function get_info(db,kind)\n"
"\n"
"	kind=fixkind(kind)\n"
"\n"
"--[[\n"
"	local d=rows(db,\"PRAGMA table_info('\"..name..\"')\");\n"
"	print(wstr.serialize(d))\n"
"]]\n"
"\n"
"	local d=rows(db,\"select sql from sqlite_master where name = '\"..kind..\"';\")\n"
"	\n"
"	if not d[1] then return end -- no table of the given kind exists\n"
"	\n"
"-- grab the bit in brackets\n"
"	local _,_,s=string.find(d[1].sql,\"%((.*)%)\")\n"
"--print(s)\n"
"-- and split it by commas\n"
"	local a=wstr.split(s,\",\")\n"
"	\n"
"	tab={}\n"
"	\n"
"	local flags={\"NOT\",\"NULL\",\"INTEGER\",\"REAL\",\"TEXT\",\"BLOB\",\"PRIMARY\",\"FOREIGN\",\"KEY\",\"COLLATE\",\"BINARY\",\"NOCASE\",\"RTRIM\",\"UNIQUE\",\"CHECK\",\"DEFAULT\"}\n"
"	for i,v in ipairs(flags) do flags[v]=0 end -- set as this next word\n"
"	flags.DEFAULT=1 -- set as the next word\n"
"	\n"
"	for i,v in ipairs(a) do\n"
"		local c=wstr.split_words(v)\n"
"--		print(wstr.serialize(c))\n"
"		local d={}\n"
"		for i,v in ipairs(c) do d[v]=flags[v] and c[i+flags[v]] end -- set flags only if we recognise them\n"
"		local cmd=false\n"
"		for i,v in ipairs(flags) do if c[1]:sub(1,#v)==v then cmd=v end end\n"
"		if cmd then\n"
"			d.cmd=c[1] -- set the command\n"
"		else -- a named column\n"
"			d.name=c[1] -- set the name\n"
"			if d.name:sub(1,1)==\"'\" then d.name=d.name:sub(2,-2) end -- strip quotes\n"
"		end\n"
"\n"
"		tab[i]=d\n"
"	end\n"
"	\n"
"--	print(wstr.serialize(tab))\n"
"	return tab\n"
"end\n"
"\n"
"-- create or update a table, this can only update if *we* created the table using this function\n"
"-- info is the same as when returned from info function\n"
"-- the two arecompared and the table updated with any missing columns\n"
"-- so you may not get a a table in the exact order specified or it may have extra cruft etc\n"
"--\n"
"-- in general it should be safe to add columns to the end of the info and call this again\n"
"-- so we can modify existing tabs\n"
"function set_info(db,kind,info)\n"
"\n"
"	kind=fixkind(kind)\n"
"\n"
"--	print(wstr.serialize(info))\n"
"\n"
"	old=get_info(db,kind)\n"
"\n"
"-- build the sql string we need to run	\n"
"	local t={}\n"
"	local p=function(...) for i,v in ipairs{...} do t[#t+1]=tostring(v) end end\n"
"\n"
"-- add a column\n"
"	local function pdef(t)\n"
"		if t.name then\n"
"			p(\"'\"..t.name..\"'\")\n"
"			if t.INTEGER then\n"
"				p(\" INTEGER\")\n"
"			elseif t.REAL then\n"
"				p(\" REAL\")\n"
"			elseif t.TEXT then\n"
"				p(\" TEXT\")\n"
"			elseif t.BLOB then\n"
"				p(\" BLOB\")\n"
"			end\n"
"			if t.PRIMARY then\n"
"				p(\" PRIMARY KEY\")\n"
"			elseif t.UNIQUE then\n"
"				p(\" UNIQUE\")\n"
"			end\n"
"			if t.DEFAULT then\n"
"				p(\" DEFAULT \",t.DEFAULT) --- Only numbers? ...dont want defaults anyhow...\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"--check if is already added\n"
"	local function in_table(tab,name)\n"
"		for i,v in ipairs(tab) do\n"
"			if v.name==name then return true end\n"
"		end\n"
"	end\n"
"	\n"
"	if not old then -- create new\n"
"	\n"
"		p(\"CREATE TABLE \"..kind..\"( \")\n"
"		for i,v in ipairs(info) do\n"
"			if i>1 then p(\" , \") end\n"
"			pdef(v)\n"
"		end\n"
"		p(\" );\")\n"
"	\n"
"	else -- adjust\n"
"	\n"
"		local ch -- if set then we need to add these columns\n"
"		for i,v in ipairs(info) do\n"
"			if not in_table(old,v.name) then\n"
"				ch=ch or {}\n"
"				ch[#ch+1]=v\n"
"			end\n"
"		end\n"
"\n"
"		if ch then\n"
"			for i,v in ipairs(ch) do\n"
"				p(\"ALTER TABLE \"..kind..\" ADD COLUMN \")\n"
"				pdef(v)\n"
"				p(\" ;\")\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	if t[1] then -- something to do\n"
"--		print(table.concat(t))\n"
"		exec(db,table.concat(t))\n"
"	end\n"
"	\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- escape a string for sqlite use\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function escape(s)\n"
"	return \"X'\"..string.gsub(s, \".\", function (c)\n"
"		return string.format(\"%02x\", string.byte(c))\n"
"	end)..\"'\"\n"
"--	return \"'\"..s:gsub(\"'\",\"''\")..\"'\"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- turn a table into a string of values\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_values(tab)\n"
"\n"
"	local ns={}\n"
"	local ds={}\n"
"	for n,d in pairs(tab) do\n"
"		ns[#ns+1]=fixname(n)\n"
"		ds[#ds+1]=fixvalue(d)\n"
"	end\n"
"\n"
"	return \"(\"..table.concat(ns,\",\")..\")\"..\" VALUES (\"..table.concat(ds,\",\")..\")\"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- turn a table into a string of sets\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_valueset(tab)\n"
"\n"
"	local ss={}\n"
"	for n,d in pairs(tab) do\n"
"		ss[#ss+1]=fixname(n)\"=\"..fixvalue(d)\n"
"	end\n"
"\n"
"	return table.concat(ss,\",\")\n"
"end\n"
"\n"
"function fixvalue(v)\n"
"	if type(v)==\"string\" then\n"
"		return escape(v)\n"
"	else\n"
"		return tonumber(v)\n"
"	end\n"
"end\n"
"\n"
"function fixname(v)\n"
"	return '\"'..(tostring(v))..'\"' -- name must not include \" or '\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- insert or update data on clash, similar format to the lanes returned info\n"
"-- this function doesnt do anything it just builds a queery string that will\n"
"--\n"
"-- name == table name\n"
"-- tab == data to insert\n"
"--\n"
"-- this is a single insert or update, so there is only one row\n"
"--\n"
"-- any previous values not in the tab be lost, use update to only change some values\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_replace(name,tab)\n"
"	return \"REPLACE INTO \"..name..\" \"..make_values(tab)..\";\"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- insert only, similar format to the lanes returned info\n"
"-- this function doesnt do anything it just builds a queery string that will\n"
"--\n"
"-- name == table name\n"
"-- tab == data to insert\n"
"--\n"
"-- this is a single insert or update, so there is only one row\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_insert(name,tab)\n"
"	return \"INSERT INTO \"..name..\" \"..make_values(tab)..\";\"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- update only, similar format to the lanes returned info\n"
"-- this function doesnt do anything it just builds a queery string that will\n"
"--\n"
"-- name == table name\n"
"-- tab == data to insert\n"
"-- where == where to update (sql string)\n"
"--\n"
"-- this is a single insert or update, so there is only one row\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_update(name,tab,where)\n"
"\n"
"	return \"UPDATE \"..name..\" SET \"..make_valueset(tab)..\" WHERE \"..where..\";\"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert a table containing data about a query into an sqlite query string\n"
"--\n"
"-- this table was originally based around the restrictions of googles big table\n"
"-- so yes, it is a very limited subset\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function make_query(tab)\n"
"\n"
"	local operators={ -- require the use of C style ops\n"
"		[\"==\"]=\"=\",\n"
"		[\"<\"]=\"<\",\n"
"		[\">\"]=\">\",\n"
"		[\"<=\"]=\"<=\",\n"
"		[\">=\"]=\">=\",\n"
"		[\"!=\"]=\"<>\",\n"
"		}\n"
"\n"
"	local t={}\n"
"	local p=function(...)\n"
"		for i,v in ipairs{...} do t[#t+1]=tostring(v) end\n"
"	end\n"
"	\n"
"	p(\"SELECT *,ROWID FROM \",tab.kind,\" \")\n"
"	\n"
"	local wa=\"WHERE\"\n"
"	for i,v in ipairs(tab) do\n"
"		\n"
"		if v[1]==\"filter\" then\n"
"		\n"
"			local o=operators[ v[3] ] \n"
"			if o then\n"
"				p(wa,\" \",fixname(v[2]),o,fixvalue(v[4]),\" \")\n"
"			elseif string.upper(v[3])==\"IN\" then\n"
"				p(wa,\" \",fixname(v[2]),\"IN(\")\n"
"				for i,v in ipairs(v[4]) do\n"
"					if i~=1 then p(\",\") end -- separator\n"
"					p(fixvalue(v))\n"
"				end\n"
"				p(\") \")\n"
"			else\n"
"				error(\"UNSUPORTED SQLITE OPERATOR \"..tostring(v[3]))\n"
"			end\n"
"		\n"
"			wa=\"AND\" -- switch from WHERE to AND\n"
"		end\n"
"	end\n"
"\n"
"	local ss={}\n"
"	for i,v in ipairs(tab) do\n"
"		if v[1]==\"sort\" then\n"
"			if v[3]==\"DESC\" then\n"
"				ss[#ss+1]=fixname(v[2])..\" DESC\"\n"
"			\n"
"			else\n"
"				ss[#ss+1]=fixname(v[2])..\" ASC\"\n"
"			end		\n"
"		end\n"
"	end\n"
"	if ss[1] then\n"
"		p(\"ORDER BY \")\n"
"		p(table.concat(ss,\" , \"))\n"
"		p(\" \")\n"
"	end\n"
"	\n"
"	if tab.limit then\n"
"		p(\"LIMIT \",tab.limit,\" \")\n"
"	end\n"
"\n"
"	if tab.offset then\n"
"		p(\"OFFSET \",tab.offset,\" \")\n"
"	end\n"
"	\n"
"	p(\";\")\n"
"\n"
"	local s=table.concat(t)\n"
"	return s\n"
"end\n"
"\n"
"\n"
"",

"wetgenes.win.linux","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"local linux={}\n"
"\n"
"local core=require(\"wetgenes.win.linux.core\")\n"
"\n"
"\n"
"linux.msg=function(w)\n"
"	local m=core.msg(w)\n"
"	return m\n"
"end\n"
"\n"
"linux.send_intent=function(s)\n"
"	local e=wstr.url_encode(s)\n"
"	os.execute(\"xdg-open \\\"https://twitter.com/intent/tweet?text=\"..e..\"\\\"\")\n"
"end\n"
"\n"
"--\n"
"-- export all core functions not wrapped above\n"
"--\n"
"for n,v in pairs(core) do -- check the core\n"
"	if type(v)==\"function\" then -- only functions\n"
"		if not linux[n] then -- only if not prewrapped\n"
"			linux[n]=v\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"\n"
"\n"
"return linux\n"
"",

"wetgenes.bake","--+-----------------------------------------------------------------------------------------------------------------+--\r\n"
"--\r\n"
"-- (C) Kriss Daniels 2005 http://www.XIXs.com\r\n"
"--\r\n"
"-- This file made available under the terms of The MIT License : http://www.opensource.org/licenses/mit-license.php\r\n"
"--\r\n"
"-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n"
"--\r\n"
"-- The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n"
"--\r\n"
"-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n"
"--\r\n"
"--+-----------------------------------------------------------------------------------------------------------------+--\r\n"
"\r\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"--\r\n"
"-- A thrown together build toool, well some useful lua functions for making a build.\r\n"
"--\r\n"
"-- The intent is to optimise a fullbuild rather than a partial build,\r\n"
"--\r\n"
"-- it is the times you have to rebuild everything that causes you to go make a cup of tea, after all.\r\n"
"--\r\n"
"-- This is exceptionally true of windows where process creation has a huge overhead\r\n"
"--\r\n"
"-- Hopefully things are kept shrinkwrapped enough here to enable an easy unixy port when I need it (theywoz)\r\n"
"--\r\n"
"\r\n"
"local lfs=require(\"lfs\")\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"\r\n"
"module(\"wetgenes.bake\")\r\n"
"\r\n"
"osflavour=\"win\"\r\n"
"	\r\n"
"local os_shell=os.getenv(\"SHELL\")\r\n"
"if os_shell and string.sub(os_shell,1,5)== \"/bin/\" then\r\n"
"	osflavour=\"nix\"\r\n"
"end\r\n"
"\r\n"
"-- fullpaths to usefull commands\r\n"
"\r\n"
"cmd={}\r\n"
"\r\n"
"\r\n"
"-- place to store options\r\n"
"\r\n"
"opt={}\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"--\r\n"
"-- get/set current dir\r\n"
"--\r\n"
"get_cd=function()\r\n"
"\r\n"
"	return string.gsub(lfs.currentdir(),'\\\\','/')\r\n"
"\r\n"
"end\r\n"
"set_cd=function(str)\r\n"
"\r\n"
"	lfs.chdir(str)\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"--\r\n"
"-- combine strings and resolve . or .. and cancel out multiple // and switch \\ to /\r\n"
"-- so we should end up with a valid clean path\r\n"
"--\r\n"
"path_clean=function(...)\r\n"
"\r\n"
"local str\r\n"
"\r\n"
"	str=table.concat({...})\r\n"
"	str=string.gsub(str,'\\\\','/')\r\n"
"\r\n"
"	return(str)\r\n"
"\r\n"
"end\r\n"
"\r\n"
"--\r\n"
"-- as path_clean but add .exe (so we can easily not do this later if under unix)\r\n"
"--\r\n"
"path_clean_exe=function(...)\r\n"
"\n"
"if osflavour==\"nix\" then\n"
"	return(path_clean(...))\r\n"
"else\r\n"
"	return(path_clean(...)..'.exe')\r\n"
"end\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"--\r\n"
"-- return the substring after the last .\r\n"
"--\r\n"
"path_ext=function(str)\r\n"
"\r\n"
"	return(str)\r\n"
"\r\n"
"end\r\n"
"\r\n"
"--\r\n"
"-- perform some substitutions and then execute the command from the given cwd\r\n"
"--\r\n"
"execute=function(cwd,cmd,arg)\r\n"
"\r\n"
"	if cwd then\r\n"
"	\r\n"
"		lfs.chdir(cwd)\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	if arg then\r\n"
"	\r\n"
"		os.execute(cmd..' '..arg)\r\n"
"		\r\n"
"	else\r\n"
"	\r\n"
"		os.execute(cmd)\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"end\r\n"
"\n"
"\r\n"
"\r\n"
"--\r\n"
"-- given a filename make sure that its containing directory exists\r\n"
"--\r\n"
"create_dir_for_file=function(n)\r\n"
"	local t={}\r\n"
"	for w in string.gmatch(n, \"[^/]+\") do t[#t+1]=w end\r\n"
"	local s=\"\"\r\n"
"	t[#t]=nil -- remove the filename\r\n"
"	for i,v in ipairs(t) do\r\n"
"		s=s..v\r\n"
"		lfs.mkdir(s)\r\n"
"		s=s..\"/\"\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"--\r\n"
"-- get the filenames (relative to the basedir) of all files matching the filter\r\n"
"--\r\n"
"findfiles=function(opts)\r\n"
"if not opts then return end\r\n"
"if not opts.dir then return end\r\n"
"opts.basedir=opts.basedir or \".\" -- \".\" for current\r\n"
"opts.filter=opts.filter or \".\" -- include all files by default\r\n"
"opts.ret=opts.ret or {} -- return value is in opts.ret\r\n"
"\r\n"
"	local subdirs={}\r\n"
"	local d=opts.basedir..\"/\"..opts.dir\r\n"
"	if lfs.attributes(d) then -- only if dir exists\r\n"
"		for v in lfs.dir(d) do\r\n"
"			local a=lfs.attributes(d..\"/\"..v)\r\n"
"	--print(\"test\",v,a.mode)\r\n"
"			if a.mode==\"file\" then\r\n"
"				if string.find(v,opts.filter) then\r\n"
"	--print(\"found\",v)\r\n"
"					opts.ret[#opts.ret+1]=opts.dir..\"/\"..v\r\n"
"				end\r\n"
"			end\r\n"
"			if a.mode==\"directory\" then\r\n"
"				if v:sub(1,1)~=\".\" then\r\n"
"					subdirs[#subdirs+1]=v\r\n"
"				end\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"-- recurse\r\n"
"	local dir=opts.dir\r\n"
"	for i,v in ipairs(subdirs) do\r\n"
"		opts.dir=dir..\"/\"..v\r\n"
"		findfiles(opts)\r\n"
"	end\r\n"
"\r\n"
"	return opts\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"readfile=function(name)\r\n"
"	local fp=assert(io.open(name,\"r\"))\r\n"
"	local d=fp:read(\"*all\")\r\n"
"	fp:close()\r\n"
"	return d\r\n"
"end\r\n"
"\r\n"
"file_exists=function(name)\r\n"
"	local fp=(io.open(name,\"r\"))\r\n"
"--print(fp)\r\n"
"	if fp then fp:close() return true end\r\n"
"	return false\r\n"
"end\r\n"
"\r\n"
"writefile=function(name,data)\r\n"
"	local fp=assert(io.open(name,\"w\"))\r\n"
"	fp:write(data)\r\n"
"	fp:close()\r\n"
"end\r\n"
"\r\n"
"copyfile=function(frm,too)\r\n"
"	local text=readfile(frm)\r\n"
"	writefile(too,text)\r\n"
"end\r\n"
"\r\n"
"-- copy but with macro replacements\r\n"
"replacefile=function(frm,too,opts)\r\n"
"	local text=readfile(frm)\r\n"
"	text=wstr.replace(text,opts)\r\n"
"	writefile(too,text)\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert time stamp into a 2.3 version string like so vv.mmm\r\n"
"--\r\n"
"-- this gives us space for about 3 unique releases a day based on time\r\n"
"-- lets try not to releasemore than that, mkay :)\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function version_from_time(t,vplus)\r\n"
"\r\n"
"	vplus=vplus or 0 -- slight tweak if we need it\r\n"
"\r\n"
"	t=t or os.time()\r\n"
"\r\n"
"	local d=os.date(\"*t\",t)\r\n"
"\r\n"
"-- how far through the year are we\r\n"
"	local total=os.time{year=d.year+1,day=1,month=1} - os.time{year=d.year,day=1,month=1}\r\n"
"	local part=t - os.time{year=d.year,day=1,month=1}\r\n"
"\r\n"
"-- build major and minor version numbers\r\n"
"	local maj=math.floor(d.year-2000)\r\n"
"	local min=math.floor((part/total)*1000)+vplus\r\n"
"\r\n"
"	if min>=1000 then min=min-1000 maj=maj+1 end -- paranoia fix\r\n"
"\r\n"
"	return string.format(\"%02d.%03d\",maj,min)\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.win.android","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local android={}\n"
"\n"
"local core=require(\"wetgenes.win.android.core\")\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"local bit=require(\"bit\")\n"
"\n"
"--\n"
"-- simple debug print function, we wrap the core so it accepts multiple \n"
"-- args and behaves like luas print\n"
"--\n"
"android.print=function(...)\n"
"	local t={}\n"
"	for i,v in ipairs{...} do\n"
"		t[#t+1]=tostring(v)\n"
"	end\n"
"	core.print(table.concat(t,\"\\t\"))\n"
"end\n"
"local print=android.print\n"
"\n"
"\n"
"\n"
"android.win_ready=false\n"
"\n"
"android.create=function(opts)\n"
"\n"
"	repeat\n"
"		android.queue_all_msgs()\n"
"		android.sleep(1)\n"
"	until android.win_ready\n"
"\n"
"	return core.create(opts)\n"
"end\n"
"\n"
"android.queue={}\n"
"\n"
"android.queue_all_msgs=function()\n"
"\n"
"	local finished=false\n"
"	repeat\n"
"	\n"
"--		debug.sethook( function(event, line)\n"
"--		  local s = debug.getinfo(2).short_src\n"
"--		  print(s .. \":\" .. line)\n"
"--		end, \"l\")\n"
"\n"
"		local ma=core.msg()\n"
"\n"
"--		debug.sethook(nil, \"l\")\n"
"		\n"
"		if ma then\n"
"		\n"
"--print(\"andmsg\",wstr.dump(ma))\n"
"\n"
"			\n"
"			if ma.cmd==\"init_window\" then android.win_ready=true end -- flag that it is now ok to create\n"
"			\n"
"			local m\n"
"			\n"
"			if ma.event == \"app\" then\n"
"\n"
"				m={\n"
"					time=ma.eventtime,\n"
"					class=\"app\",\n"
"					cmd=ma.cmd,\n"
"				}\n"
"\n"
"--				if ma.cmd==\"config_changed\" then\n"
"--				end\n"
"			\n"
"			elseif ma.event == \"motion\" then\n"
"				\n"
"				if ma.source and bit.band( ma.source , 0x01000000 ) == 0x01000000 then -- joystick\n"
"\n"
"					for i=1,#ma.pointers do\n"
"						local p=ma.pointers[i]\n"
"						table.insert(android.queue,{\n"
"							time=ma.eventtime,\n"
"							class=\"joystick\",\n"
"							id=p.id, -- multiple joysticks I think?\n"
"							lx=p.lx,\n"
"							ly=p.ly,\n"
"							rx=p.rx,\n"
"							ry=p.ry,\n"
"							dx=p.dx,\n"
"							dy=p.dy,\n"
"						})\n"
"					end\n"
"					\n"
"				elseif ma.action and ma.pointers then\n"
"\n"
"					local act=0\n"
"					local action=ma.action%256\n"
"					local actidx=math.floor((ma.action/256)%256) + 1\n"
"\n"
"					if action==0 then act= 1 end -- single touch\n"
"					if action==1 then act=-1 end\n"
"\n"
"					if action==5 then act= 1 end -- multi touch\n"
"					if action==6 then act=-1 end\n"
"					\n"
"					local fingers={}\n"
"					for i=1,#ma.pointers do\n"
"						local p=ma.pointers[i]\n"
"						if act==0 or i~=actidx then -- just report position\n"
"							fingers[#fingers+1]={\n"
"								time=ma.eventtime,\n"
"								action=0,\n"
"								class=\"mouse\",\n"
"								x=p.x,\n"
"								y=p.y,\n"
"								pressure=p.pressure,\n"
"								fingers=fingers,\n"
"								finger=p.id, -- this is a unique id for the duration of this touch\n"
"							}\n"
"						else -- this is a finger going up/down\n"
"							fingers[#fingers+1]={\n"
"								time=ma.eventtime,\n"
"								action=act,\n"
"								class=\"mouse\",\n"
"								keycode=1,	-- always report all fingers as left mouse button\n"
"								x=p.x,\n"
"								y=p.y,\n"
"								pressure=p.pressure,\n"
"								fingers=fingers,\n"
"								finger=p.id,\n"
"							}\n"
"						end\n"
"					end\n"
"					-- send them all ourself\n"
"					for i,v in ipairs(fingers) do\n"
"						table.insert(android.queue,v)\n"
"					end\n"
"					\n"
"				end\n"
"\n"
"			elseif ma.event == \"key\" then\n"
"			\n"
"				if bit.band( ma.source , 0x00000400 ) == 0x00000400 then -- joystick\n"
"\n"
"					m={\n"
"						time=ma.eventtime,\n"
"						class=\"joykey\",\n"
"						ascii=\"\",\n"
"						action=( (ma.action==0) and 1 or -1),\n"
"						keycode=ma.keycode,\n"
"						keyname=string.format(\"android_%02x\",ma.keycode)\n"
"					}\n"
"				\n"
"				else\n"
"\n"
"					m={\n"
"						time=ma.eventtime,\n"
"						class=\"key\",\n"
"						ascii=\"\",\n"
"						action=( (ma.action==0) and 1 or -1),\n"
"						keycode=ma.keycode,\n"
"						keyname=string.format(\"android_%02x\",ma.keycode)\n"
"					}\n"
"\n"
"				end\n"
"\n"
"			end\n"
"			\n"
"			if m then\n"
"				table.insert(android.queue,m)\n"
"			end\n"
"			\n"
"--print(\"msg\",wstr.dump(android.queue[#android.queue]))\n"
"\n"
"		else\n"
"			finished=true\n"
"		end\n"
"		\n"
"	until finished\n"
"	\n"
"end\n"
"\n"
"android.msg=function()\n"
"	android.queue_all_msgs()\n"
"\n"
"	if android.queue[1] then\n"
"		return table.remove(android.queue,1)\n"
"	end\n"
"	\n"
"end\n"
"\n"
"android.stop=function(...)\n"
"	core.stop(...)\n"
"end\n"
"\n"
"android.start=function(...)\n"
"	core.start(...)\n"
"end\n"
"\n"
"--\n"
"-- export all core functions not wrapped above\n"
"--\n"
"for n,v in pairs(core) do -- check the core\n"
"	if type(v)==\"function\" then -- only functions\n"
"		if not android[n] then -- only if not prewrapped\n"
"			android[n]=v\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"return android\n"
"",

"wetgenes.hid","--\n"
"-- Copyright (C) 2013 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- wetgenes.hid is a higher level interface to the lowlevel core binding to hidapi\n"
"\n"
"local hid={}\n"
"\n"
"local core=require(\"wetgenes.hid.core\")\n"
"\n"
"for n,f in pairs(core) do hid[n]=f end\n"
"\n"
"\n"
"return hid\n"
"",

"wetgenes.fenestra.widget.skin","-- copy all globals into locals, some locals are renamed to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,luaload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local bit=require('bit')\n"
"local gl=require('gl')\n"
"local grd=require('wetgenes.grd')\n"
"\n"
"\n"
"local apps=apps\n"
"\n"
"local function explode_color(c)\n"
"\n"
"	local r,g,b,a\n"
"	\n"
"	a=bit.band(bit.rshift(c,24),0xff)\n"
"	r=bit.band(bit.rshift(c,16),0xff)\n"
"	g=bit.band(bit.rshift(c, 8),0xff)\n"
"	b=bit.band(c,0xff)\n"
"\n"
"	return r/0xff,g/0xff,b/0xff,a/0xff\n"
"end\n"
"\n"
"local function implode_color(r,g,b,a)\n"
"\n"
"	if type(r)==\"table\" then a=r[4] b=r[3] g=r[2] r=r[1] end -- convert from table?\n"
"	\n"
"	local c\n"
"	\n"
"	c=             bit.band(b*0xff,0xff)\n"
"	c=c+bit.lshift(bit.band(g*0xff,0xff),8)\n"
"	c=c+bit.lshift(bit.band(r*0xff,0xff),16)\n"
"	c=c+bit.lshift(bit.band(a*0xff,0xff),24)\n"
"\n"
"	return c\n"
"end\n"
"\n"
"\n"
"\n"
"module(\"fenestra.widget.skin\")\n"
"\n"
"local mode=nil\n"
"local texs={}\n"
"\n"
"local margin=0 -- whitespace\n"
"local border=0 -- solidspace\n"
"--\n"
"-- unload a skin, go back to the \"builtin\" default\n"
"--\n"
"function unload(win)\n"
"\n"
"	mode=nil\n"
"	texs={}\n"
"	\n"
"end\n"
"\n"
"\n"
"--\n"
"-- load a skin\n"
"--\n"
"function load(win,name)\n"
"\n"
"	unload(win)\n"
"\n"
"	if name then -- load a named skin\n"
"	\n"
"		if name==\"test\" then\n"
"			mode=name\n"
"\n"
"			texs.border=win.tex( grd.create(apps.dir..\"data/skins/test/border.png\"):convert(\"GRD_FMT_U8_ARGB\") )\n"
"			\n"
"			texs.buttof=win.tex( grd.create(apps.dir..\"data/skins/test/buttof.png\"):convert(\"GRD_FMT_U8_ARGB\") )\n"
"			texs.button=win.tex( grd.create(apps.dir..\"data/skins/test/button.png\"):convert(\"GRD_FMT_U8_ARGB\") )\n"
"			texs.buttin=win.tex( grd.create(apps.dir..\"data/skins/test/buttin.png\"):convert(\"GRD_FMT_U8_ARGB\") )\n"
"		\n"
"			margin=15\n"
"			border=0\n"
"		end\n"
"			\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"function draw33(tw,th, mw,mh, vxs,vys, vw,vh)\n"
"		\n"
"--		local vw,vh=512,52\n"
"--		local mw,mh=24,24\n"
"\n"
"		if mw*2 > vw then mw=vw/2 end\n"
"		if mh*2 > vh then mh=vh/2 end\n"
"\n"
"		\n"
"		local tww={mw/tw,(tw-2*mw)/tw,mw/tw}\n"
"		local thh={mh/th,(th-2*mh)/th,mh/th}\n"
"		local vww={mw,vw-2*mw,mw}\n"
"		local vhh={mh,vh-2*mh,mh}\n"
"		\n"
"		gl.Disable(gl.DEPTH_TEST)\n"
"		gl.Disable(gl.LIGHTING)\n"
"		gl.Disable(gl.CULL_FACE)\n"
"		gl.Enable(gl.TEXTURE_2D)\n"
"\n"
"\n"
"		gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR)\n"
"		gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)\n"
"\n"
"\n"
"		gl.Begin(gl.QUADS)\n"
"--			gl.Color({1,1,1,1})\n"
"			\n"
"			local function drawbox( tx,ty, vx,vy , txp,typ, vxp,vyp )\n"
"				gl.TexCoord(tx    ,ty)     gl.Vertex(vx,    vy)\n"
"				gl.TexCoord(tx+txp,ty)     gl.Vertex(vx+vxp,vy)\n"
"				gl.TexCoord(tx+txp,ty+typ) gl.Vertex(vx+vxp,vy+vyp)\n"
"				gl.TexCoord(tx    ,ty+typ) gl.Vertex(vx,    vy+vyp)\n"
"			end\n"
"			\n"
"		local tx,ty=0,0\n"
"		local vx,vy=vxs,vys-- -vw/2,vh/2\n"
"\n"
"			for iy=1,3 do\n"
"				tx=0\n"
"				vx=vxs-- -vw/2\n"
"				for ix=1,3 do\n"
"\n"
"					drawbox( tx,ty, vx,vy , tww[ix],thh[iy], vww[ix],-vhh[iy] )\n"
"\n"
"					tx=tx+tww[ix]\n"
"					vx=vx+vww[ix]\n"
"				end\n"
"				ty=ty+thh[iy]\n"
"				vy=vy-vhh[iy]\n"
"			end\n"
"			\n"
"		gl.End()\n"
"\n"
"\n"
"end\n"
"\n"
"--\n"
"-- add meta functions\n"
"--\n"
"function setup(def)\n"
"\n"
"--	load(def.win,\"test\")\n"
"\n"
"\n"
"	local master=def.master\n"
"	local meta=def.meta\n"
"	local win=def.win\n"
"	local font=def.font\n"
"	\n"
"--\n"
"-- display this widget and its sub widgets\n"
"--\n"
"	function meta.draw(widget)\n"
"		\n"
"		if debug_hook then debug_hook(\"draw\",widget) end\n"
"		\n"
"		\n"
"\n"
"		-- draw rectangle\n"
"\n"
"\n"
"		gl.PopMatrix() -- expect the base to be pushed\n"
"		gl.PushMatrix()\n"
"		\n"
"		gl.Translate(widget.pxd,widget.pyd,0)\n"
"		\n"
"		if widget.fbo then\n"
"			if widget.fbo.width~=widget.sx or widget.fbo.height~=widget.sy then -- resize so we need a new fbo\n"
"				widget.fbo:clean()\n"
"				widget.fbo=nil\n"
"			end\n"
"			if not widget.fbo then -- allocate a new fbo\n"
"--print(\"new fbo\",widget.sx,widget.sy)\n"
"				widget.fbo=_G.win.fbo(widget.sx,widget.sy,0)\n"
"				widget.dirty=true -- flag redraw\n"
"			end\n"
"				\n"
"		end\n"
"\n"
"if ( not widget.fbo ) or widget.dirty then -- if no fbo and then we are always dirty... Dirty, dirty, dirty.\n"
"\n"
"		if widget.fbo then\n"
"--print(\"into fbo\")\n"
"			\n"
"			gl.MatrixMode(gl.PROJECTION)\n"
"			gl.PushMatrix()\n"
"\n"
"			widget.fbo:bind()\n"
"			\n"
"--			gl.ClearColor(14/15,14/15,14/15,1)\n"
"			gl.ClearColor(0,0,0,0)\n"
"			gl.Clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT)\n"
"\n"
"			win.project23d(widget.sx/widget.sy,1,1024)\n"
"						\n"
"			gl.MatrixMode(gl.MODELVIEW)\n"
"			gl.LoadIdentity()\n"
"			gl.Translate(-widget.sx/2,widget.sy/2,-widget.sy/2)\n"
"			gl.Translate(-widget.pxd,-widget.pyd,0)\n"
"\n"
"			if widget.pan_px and widget.pan_py then -- fidle everything\n"
"				gl.Translate(widget.pan_px,widget.pan_py,0)\n"
"			end\n"
"						\n"
"			gl.PushMatrix() -- put new base matrix onto stack\n"
"		end\n"
"		\n"
"		widget.dirty=nil\n"
"				\n"
"		gl.Disable(gl.LIGHTING)\n"
"		gl.Disable(gl.DEPTH_TEST)\n"
"		gl.Disable(gl.CULL_FACE)\n"
"		gl.Disable(gl.TEXTURE_2D)\n"
"		\n"
"		local txp,typ=0,0\n"
"		\n"
"		if widget.color then\n"
"		\n"
"			if widget.highlight==\"shrink\" then\n"
"			\n"
"				gl.Color( explode_color(widget.color))\n"
"					\n"
"				if master.over==widget then\n"
"					gl.Translate(widget.hx/16,-widget.hy/16,0)\n"
"					gl.Scale(7/8,7/8,1)\n"
"				end\n"
"			\n"
"			elseif widget.highlight==\"none\" then\n"
"			\n"
"				gl.Color( explode_color(widget.color))\n"
"				\n"
"			elseif widget.highlight==\"text\" then\n"
"			\n"
"				gl.Color( explode_color(widget.color))\n"
"				\n"
"			else -- default is to darken everything slightly when it is not the active widget\n"
"			\n"
"				if master.over==widget then\n"
"					gl.Color( explode_color(widget.color))\n"
"				else\n"
"					local c={explode_color(widget.color)}\n"
"					c[3]=c[3]*14/15\n"
"					c[2]=c[2]*14/15\n"
"					c[1]=c[1]*14/15\n"
"					gl.Color( c )\n"
"				end\n"
"				\n"
"			end\n"
"			\n"
"			local hx=widget.hx\n"
"			local hy=widget.hy\n"
"			local bb=2\n"
"			local tl={1,1,1,0.25}\n"
"			local br={0,0,0,0.25}\n"
"			\n"
"			if ( master.active==widget and master.over==widget ) or widget.state==\"selected\" then\n"
"				tl,br=br,tl\n"
"				txp=1\n"
"				typ=1\n"
"			end\n"
"			\n"
"			if mode then\n"
"			\n"
"				if ( master.active==widget and master.over==widget ) or widget.state==\"selected\" then\n"
"					texs.buttin:bind()\n"
"					txp=0\n"
"					typ=-1\n"
"				else\n"
"					texs.button:bind()\n"
"					txp=0\n"
"					typ=-2\n"
"				end\n"
"				\n"
"				if widget.class==\"string\" then -- hack\n"
"					texs.border:bind()\n"
"				end\n"
"			gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR)\n"
"			gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR)\n"
"			\n"
"				draw33(128,128, 24,24, 0-margin,0+margin, hx+(margin*2),hy+(margin*2))\n"
"			\n"
"			else -- builtin\n"
"			\n"
"				gl.Begin(gl.QUADS)\n"
"					gl.Vertex(  0,   0)\n"
"					gl.Vertex( hx,   0)\n"
"					gl.Vertex( hx, -hy)\n"
"					gl.Vertex(  0, -hy)\n"
"				gl.End()\n"
"				gl.Color( tl )\n"
"				gl.Begin(gl.QUADS)\n"
"					gl.Vertex(  0,   0  )\n"
"					gl.Vertex( hx,   0  )\n"
"					gl.Vertex( hx-bb, -bb)\n"
"					gl.Vertex(  0+bb, -bb)\n"
"					\n"
"					gl.Vertex(  0,    0   )\n"
"					gl.Vertex(  0+bb, -bb )\n"
"					gl.Vertex(  0+bb, -hy+bb)\n"
"					gl.Vertex(  0,    -hy  )\n"
"				gl.End()\n"
"				gl.Color( br )\n"
"				gl.Begin(gl.QUADS)\n"
"					gl.Vertex( hx,   -hy  )\n"
"					gl.Vertex(  0,   -hy  )\n"
"					gl.Vertex(  0+bb, -hy+bb)\n"
"					gl.Vertex( hx-bb, -hy+bb)\n"
"					\n"
"					gl.Vertex(  hx,    0   )\n"
"					gl.Vertex(  hx,    -hy  )\n"
"					gl.Vertex(  hx-bb, -hy+bb)\n"
"					gl.Vertex(  hx-bb, -bb )\n"
"				gl.End()\n"
"			end\n"
"			\n"
"		end\n"
"		\n"
"		if widget.text then\n"
"		\n"
"			local tx,ty=font.size(widget.text,widget.text_size)\n"
"			\n"
"			local c=widget.text_color\n"
"			\n"
"			if widget.text_color_over then\n"
"				if master.over==widget then\n"
"					c=widget.text_color_over\n"
"				end\n"
"			end\n"
"			\n"
"			if widget.text_align==\"left\" then\n"
"				tx=0\n"
"				ty=0			\n"
"			elseif widget.text_align==\"right\" then\n"
"				tx=(widget.hx-tx)\n"
"				ty=(widget.hy-ty)			\n"
"			else\n"
"				tx=(widget.hx-tx)/2\n"
"				ty=(widget.hy-ty)/2\n"
"			end\n"
"			\n"
"			tx=tx+txp\n"
"			ty=ty+typ\n"
"			\n"
"			widget.text_x=tx\n"
"			widget.text_y=ty\n"
"\n"
"			font.set(tx,-ty,c,widget.text_size)\n"
"			font.draw(widget.text)\n"
"		\n"
"\n"
"				if widget.class==\"textedit\" then -- hack\n"
"					if widget.master.focus==widget then --only draw curser in active widget\n"
"						if widget.master.throb>=128 then\n"
"							local sw=font.size(widget.text:sub(1,widget.data.str_idx))\n"
"							gl.Enable(gl.COLOR_MATERIAL)\n"
"							win.flat_rect(\n"
"								tx+sw+0,-ty,\n"
"								tx+sw+2,-ty-widget.text_size,\n"
"								255*256*256*256)\n"
"							gl.Disable(gl.COLOR_MATERIAL)\n"
"						end\n"
"					end\n"
"				end\n"
"\n"
"		end\n"
"		\n"
"		for i,v in ipairs(widget) do\n"
"			if not v.fbo or not v.dirty then -- terminate recursion at dirty fbo\n"
"				v:draw()\n"
"			end\n"
"		end\n"
"\n"
"		if widget.fbo then -- we have drawn into the fbo\n"
"			\n"
"			gl.MatrixMode(gl.PROJECTION)\n"
"			gl.PopMatrix()\n"
"			\n"
"			gl.MatrixMode(gl.MODELVIEW)\n"
"			gl.PopMatrix()\n"
"			\n"
"			win.fbo_bind()\n"
"		end\n"
"		\n"
"else -- we can only draw once\n"
"\n"
"		if widget.fbo then -- we need to draw our cached fbo\n"
"		\n"
"			gl.Disable(gl.LIGHTING)\n"
"			gl.Disable(gl.DEPTH_TEST)\n"
"			gl.Disable(gl.CULL_FACE)\n"
"			gl.Disable(gl.TEXTURE_2D)\n"
"		\n"
"			gl.Translate(widget.sx/2,-widget.sy/2,0)\n"
"			gl.Color(1,1,1,1)\n"
"			widget.fbo:draw()\n"
"--print(\"draw fbo\")\n"
"		end\n"
"		\n"
"end\n"
"	\n"
"		\n"
"		return widget\n"
"	end\n"
"\n"
"\n"
"\n"
"end\n"
"",

"coxpcall","-------------------------------------------------------------------------------\n"
"-- Coroutine safe xpcall and pcall versions\n"
"--\n"
"-- Encapsulates the protected calls with a coroutine based loop, so errors can\n"
"-- be dealed without the usual Lua 5.x pcall/xpcall issues with coroutines\n"
"-- yielding inside the call to pcall or xpcall.\n"
"--\n"
"-- Authors: Roberto Ierusalimschy and Andre Carregal \n"
"-- Contributors: Thomas Harning Jr., Ignacio Burgueno, Fabio Mascarenhas\n"
"--\n"
"-- Copyright 2005 - Kepler Project (www.keplerproject.org)\n"
"--\n"
"-- $Id: coxpcall.lua,v 1.13 2008/05/19 19:20:02 mascarenhas Exp $\n"
"-------------------------------------------------------------------------------\n"
"\n"
"-------------------------------------------------------------------------------\n"
"-- Implements xpcall with coroutines\n"
"-------------------------------------------------------------------------------\n"
"local performResume, handleReturnValue\n"
"local oldpcall, oldxpcall = pcall, xpcall\n"
"\n"
"function handleReturnValue(err, co, status, ...)\n"
"    if not status then\n"
"        return false, err(debug.traceback(co, (...)), ...)\n"
"    end\n"
"    if coroutine.status(co) == 'suspended' then\n"
"        return performResume(err, co, coroutine.yield(...))\n"
"    else\n"
"        return true, ...\n"
"    end\n"
"end\n"
"\n"
"function performResume(err, co, ...)\n"
"    return handleReturnValue(err, co, coroutine.resume(co, ...))\n"
"end    \n"
"\n"
"function coxpcall(f, err, ...)\n"
"    local res, co = oldpcall(coroutine.create, f)\n"
"    if not res then\n"
"        local params = {...}\n"
"        local newf = function() return f(unpack(params)) end\n"
"        co = coroutine.create(newf)\n"
"    end\n"
"    return performResume(err, co, ...)\n"
"end\n"
"\n"
"-------------------------------------------------------------------------------\n"
"-- Implements pcall with coroutines\n"
"-------------------------------------------------------------------------------\n"
"\n"
"local function id(trace, ...)\n"
"  return ...\n"
"end\n"
"\n"
"function copcall(f, ...)\n"
"    return coxpcall(f, id, ...)\n"
"end\n"
"",

"wetgenes.box2d.wrap","\r\n"
"\r\n"
"local print=print\r\n"
"local table=table\r\n"
"local pairs=pairs\r\n"
"\r\n"
"local core = require(\"box2d.core\")\r\n"
"\r\n"
"\r\n"
"module(\"box2d.wrap\")\r\n"
"\r\n"
"--\r\n"
"-- Call new to get a unique table full of functions associated\r\n"
"-- with lots of tasty up values for easy use\r\n"
"--\r\n"
"-- this gives you a table full of functions to call\r\n"
"--\r\n"
"-- local world=require(\"box2d.wrap\").world()\r\n"
"--\r\n"
"function world(def) -- create a new world\r\n"
"\r\n"
"local world={}\r\n"
"\r\n"
"	if def then for i,v in pairs(def) do world[i]=v end end -- shallow copy def data \r\n"
"	\r\n"
"	world.hash={} -- a lookup table to turn internal lightuserdatas into associated lua tables (eg for safe callbacks)\r\n"
"\r\n"
"	world.core=core.setup(world) -- allocate a hard core\r\n"
"	core.get(world.core,world) -- update the soft body with current settings from the hard core\r\n"
"	\r\n"
"	function world.delete() -- delete this world\r\n"
"		return core.clean(world.core)\r\n"
"	end\r\n"
"	\r\n"
"	function world.step(tim,iter) -- run the simulation\r\n"
"		return core.step(world.core, tim or 1/50, iter or 10)\r\n"
"	end\r\n"
"\r\n"
"	function world.body(def) -- create a body in the world\r\n"
"		local body={}\r\n"
"		body.shapes={}\r\n"
"		body.core = core.body(world.core, def)\r\n"
"		\r\n"
"		function body.delete() -- delete this body\r\n"
"			core.body_delete(world.core, body.core)\r\n"
"		end\r\n"
"	\r\n"
"		function body.get()\r\n"
"			core.body_get(world.core, body.core, body)\r\n"
"		end\r\n"
"		\r\n"
"		function body.set(t)\r\n"
"			core.body_set(world.core, body.core,t)\r\n"
"		end\r\n"
"		\r\n"
"		function body.shape(def)\r\n"
"			world.shape(body,def)\r\n"
"		end\r\n"
"		\r\n"
"		core.body_get(world.core, body.core, body)\r\n"
"			\r\n"
"		return body\r\n"
"	end\r\n"
"	\r\n"
"	function world.shape(body,def) -- create a shape in the body\r\n"
"		local shape={}\r\n"
"		table.insert(body.shapes,shape)\r\n"
"		shape.core = core.body_shape(world.core, body.core , def)\r\n"
"		\r\n"
"		function shape.delete() -- delete this body\r\n"
"			core.body_shape_delete(world.core, body.core, shape.core )\r\n"
"		end\r\n"
"		\r\n"
"		return shape\r\n"
"	end\r\n"
"	\r\n"
"	function world.joint(def) -- create a joint\r\n"
"		local joint={}\r\n"
"		joint.core = core.joint(world.core, def)\r\n"
"		\r\n"
"		function joint.delete() -- delete this joint\r\n"
"			core.joint_delete(world.core, joint.core )\r\n"
"		end\r\n"
"		\r\n"
"		return shape\r\n"
"	end\r\n"
"	\r\n"
"	return world\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.bake.swf","\r\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"module(...)\r\n"
"\r\n"
"function build(tab)\r\n"
"\r\n"
"tab.arg=tab.arg or {}\r\n"
"\r\n"
"\r\n"
"local bake=require(\"wetgenes.bake\")\r\n"
"\r\n"
"local pp=require(\"wetgenes.pp\")\r\n"
"local lfs=require(\"lfs\")\r\n"
"\r\n"
"local no_art=false\r\n"
"\r\n"
"opts=opts or {} -- can pass in an opts of default options\r\n"
"\r\n"
"local opts_changed=false\r\n"
"local func\r\n"
"\r\n"
"	opts.VERSION_NUMBER=opts.VERSION_NUMBER or 0\r\n"
"\r\n"
"	func=loadfile(\"src/opts.lua\")\r\n"
"	if func then\r\n"
"		setfenv(func,opts)\r\n"
"		pcall(func)\r\n"
"	else\r\n"
"		opts_changed=true\r\n"
"	end\r\n"
"		\r\n"
"	for i=1,#tab.arg do\r\n"
"\r\n"
"		if tab.arg[i]==\"bump\" then\r\n"
"		\r\n"
"			opts.VERSION_NUMBER=opts.VERSION_NUMBER+0.001\r\n"
"		\r\n"
"			opts_changed=true\r\n"
"		end\r\n"
"		\r\n"
"		if tab.arg[i]==\"debug\" then\r\n"
"		\r\n"
"			opts.VERSION_BUILD=\"debug\"\r\n"
"		\r\n"
"			opts_changed=true\r\n"
"		end\r\n"
"		\r\n"
"		if tab.arg[i]==\"release\" then\r\n"
"		\r\n"
"			opts.VERSION_BUILD=\"release\"\r\n"
"		\r\n"
"			opts_changed=true\r\n"
"		end\r\n"
"		\r\n"
"		if tab.arg[i]==\"noart\" then\r\n"
"			no_art=true\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	if opts_changed then -- write out changed file\r\n"
"		local fp=io.open(\"src/opts.lua\",\"w\")\r\n"
"		for i,v in pairs(opts) do\r\n"
"		\r\n"
"			if type(v)==\"number\" then\r\n"
"				fp:write(i..\"=\"..v..\"\\n"
"\")\r\n"
"			elseif type(v)==\"string\" then\r\n"
"				fp:write(i..\"=\"..string.format(\"%q\",v)..\"\\n"
"\")\r\n"
"			end\r\n"
"		end\r\n"
"		fp:close()\r\n"
"	end\r\n"
"	\r\n"
"	\r\n"
"	\r\n"
"	\r\n"
"-- where we are building from\r\n"
"\r\n"
"bake.cd_base		=	bake.get_cd()\r\n"
"\r\n"
"-- where we are building to\r\n"
"\r\n"
"bake.cd_out		=	'out'\r\n"
"\r\n"
"lfs.mkdir('out')\r\n"
"lfs.mkdir('out/src')\r\n"
"lfs.mkdir('out/art')\r\n"
"\r\n"
"\r\n"
"\r\n"
"-- go up a dir from base cd and remember as main CD for building commands\r\n"
"\r\n"
"bake.set_cd(bake.get_cd()..'/..')\r\n"
"bake.cd=bake.get_cd()\r\n"
"\r\n"
"print('cd','=',bake.cd)\r\n"
"\r\n"
"\r\n"
"bake.cmd.xpp		=	bake.path_clean_exe( bake.cd , '/bin/xpp' )\r\n"
"bake.cmd.mtasc		=	bake.path_clean_exe( bake.cd , '/_mtasc/mtasc' )\r\n"
"bake.cmd.swfmill	=	bake.path_clean_exe( bake.cd , '/_swfmill/swfmill' )\r\n"
"bake.cmd.mtasc_path1=	bake.path_clean( bake.cd , '/_mtasc/std' )\r\n"
"bake.cmd.mtasc_path2=	bake.path_clean( bake.cd , '/_mtasc/std8' )\r\n"
"bake.cmd.mtasc_path3=	bake.path_clean( bake.cd , '/_mtasc/std9' )\r\n"
"\r\n"
"if bake.osflavour==\"nix\" then -- expected to be installed...\r\n"
"--	bake.cmd.mtasc=\"mtasc\"\r\n"
"	bake.cmd.swfmill=\"swfmill\"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"bake.set_cd(bake.cd_base)\r\n"
"\r\n"
"bake.files_as={}\r\n"
"for v in lfs.dir(\"src\") do -- do all files in the src dir\r\n"
"\r\n"
"	if string.find(v,\"%.as$\") then -- a .as file\r\n"
"\r\n"
"		v=string.gsub( v , \"%.as$\" , \"\") -- remove .as\r\n"
"		table.insert(bake.files_as,v)\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"bake.files_xml=\r\n"
"{\r\n"
"	tab.swf_name,\r\n"
"}\r\n"
"\r\n"
"bake.files_swf=\r\n"
"{\r\n"
"	tab.swf_name,\r\n"
"}\r\n"
"\r\n"
"bake.set_cd(bake.cd_base)\r\n"
"bake.copyfile( 'art/index.html' , 'out/index.html' )\r\n"
"bake.copyfile( 'art/swfobject.js' , 'out/swfobject.js' )\r\n"
"\r\n"
"\r\n"
"for i,v in ipairs(bake.files_as) do\r\n"
"\r\n"
"	pp.loadsave( 'src/'..v..'.as' , bake.cd_out..'/src/'..v..'.as' )\r\n"
"\r\n"
"end\r\n"
"\r\n"
"io.flush()\r\n"
"\r\n"
"if no_art then\r\n"
"print('****')\r\n"
"print('**SKIPING**SWFMILL**BUILD**STEP**')\r\n"
"print('****')\r\n"
"else\r\n"
"for i,v in ipairs( bake.files_xml ) do\r\n"
"\r\n"
"	pp.loadsave( 'art/'..v..'.xml' , bake.cd_out..'/art/'..v..'.xml' )\r\n"
"	\r\n"
"	bake.execute( bake.cd_base , bake.cmd.swfmill , '-v simple '..bake.cd_out..'/art/'..v..'.xml '..bake.cd_out..'/'..v..'.swf' )\r\n"
"\r\n"
"end\r\n"
"end\r\n"
"\r\n"
"for i,v in ipairs( bake.files_swf ) do\r\n"
"\r\n"
"	bake.execute( bake.cd_base , bake.cmd.mtasc , '-main -version 10 -v -cp '..bake.cmd.mtasc_path3..' -cp '..bake.cmd.mtasc_path2..' -cp '..bake.cmd.mtasc_path1..' -cp '..bake.cd_out..'/src -cp '..bake.cd..'/base/src -swf '..bake.cd_out..'/'..v..'.swf '..bake.cd_out..'/src/'..v..'.as' )\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"--xtra.copyfile( 'out/'..tab.swf_name..\".swf\" , '../../www/wetgenes/subs/data/swf/'..tab.swf_name..\".swf\" )\r\n"
"\r\n"
"end\r\n"
"",

"wetgenes.www.any.stashdata","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"\n"
"\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"local wdata=require(\"wetgenes.www.any.data\")\n"
"\n"
"default_props=\n"
"{\n"
"}\n"
"\n"
"default_cache=\n"
"{\n"
"	base=nil,  --\n"
"	func=nil,  -- require(base).func(srv,id) to rebuild this stash\n"
"	data={},  -- the data we stashed\n"
"}\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- allways this kind\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function kind(srv)\n"
"	return \"stash\"\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- check that entity has initial data and set any missing defaults\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function check(srv,ent)\n"
"\n"
"	local c=ent.cache\n"
"		\n"
"	return ent\n"
"end\n"
"\n"
"\n"
"\n"
"wdata.set_defs(_M) -- create basic data handling funcs\n"
"\n"
"wdata.setup_db(_M) -- make sure DB exists and is ready\n"
"\n"
"\n"
"",

"wetgenes.fenestra.widget.meta","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- generic default widget functions\n"
"\n"
"\n"
"module(\"fenestra.widget.meta\")\n"
"\n"
"-- available widget classes\n"
"classes={\n"
"\n"
"-- base classes\n"
"\n"
"	[\"master\"]=require(\"fenestra.widget.master\"),\n"
"	[\"button\"]=require(\"fenestra.widget.button\"),\n"
"	[\"drag\"]=require(\"fenestra.widget.drag\"),\n"
"	[\"text\"]=require(\"fenestra.widget.text\"),\n"
"	[\"textedit\"]=require(\"fenestra.widget.textedit\"),\n"
"\n"
"--classes built out of the base classes\n"
"\n"
"	[\"pan\"]=require(\"fenestra.widget.pan\"),\n"
"	[\"slide\"]=require(\"fenestra.widget.slide\"),\n"
"\n"
"	[\"scroll\"]=require(\"fenestra.widget.scroll\"),\n"
"\n"
"}\n"
"\n"
"--\n"
"-- add meta functions\n"
"--\n"
"function setup(def)\n"
"\n"
"--	local master=def.master\n"
"	local meta=def.meta\n"
"	local win=def.win\n"
"\n"
"-- set a dirty flag on this and all parents, this has a smart break, as if a child is dirty\n"
"-- then its parent must also be\n"
"-- the dirty flag is cleared on draw\n"
"	function meta.set_dirty(widget)\n"
"		widget.dirty=true\n"
"		while (widget.parent ~= widget) and not widget.parent.dirty do\n"
"			widget=widget.parent\n"
"			widget.dirty=true\n"
"		end\n"
"	end\n"
"\n"
"	function meta.call_hook(widget,hook,dat)\n"
"		local hooks=widget.hooks or widget.master.hooks\n"
"		local type_hooks=type(hooks)\n"
"		if type_hooks==\"function\" then -- master function\n"
"			hooks(hook,widget,dat)\n"
"		elseif type_hooks==\"table\" and hooks[hook] then -- or table of functions\n"
"			hooks[hook](widget,dat)\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- add a new widget as a child to this one\n"
"--\n"
"	function meta.add(parent,def)\n"
"		\n"
"		local widget={}\n"
"		setmetatable(widget,meta)\n"
"		table.insert(parent,widget)\n"
"		widget.parent=parent\n"
"		widget.master=parent.master\n"
"		widget:setup(def)\n"
"		widget.meta=meta		\n"
"		return widget\n"
"	end\n"
"	\n"
"--\n"
"-- remove from parent\n"
"--\n"
"	function meta.remove(widget)\n"
"	\n"
"		if widget.parent then\n"
"			for i,v in ipairs(widget.parent) do\n"
"				if v==widget then\n"
"					table.remove(widget.parent,i)\n"
"				end\n"
"			end\n"
"			widget.parent=nil\n"
"		end\n"
"		\n"
"	end	\n"
"--\n"
"-- add a previosuly created widget as a child to this widget\n"
"-- the widget will be forcibly removed...\n"
"--\n"
"	function meta.insert(parent,widget)\n"
"	\n"
"		meta.remove(widget) -- make sure we dont end up in two parents\n"
"		\n"
"		table.insert(parent,widget)\n"
"		widget.parent=parent\n"
"		widget.master=parent.master\n"
"		\n"
"		return widget\n"
"	end\n"
"\n"
"--\n"
"-- initial setup\n"
"--def\n"
"	function meta.setup(widget,def)\n"
"	\n"
"		widget.state=\"none\"\n"
"		\n"
"		widget.meta=meta\n"
"		\n"
"		widget.data=def.data -- this widget is synced with this data\n"
"		\n"
"		widget.class=def.class\n"
"		widget.highlight=def.highlight\n"
"		\n"
"		widget.id=def.id\n"
"		widget.user=def.user\n"
"		widget.hooks=def.hooks\n"
"		\n"
"		widget.sx=def.sx or def.hx or 1 -- (ratio)size for layout code\n"
"		widget.sy=def.sy or def.hy or 1 -- use hx and hy if its provided\n"
"		\n"
"		widget.mx=def.mx or 0 -- max (ratio)size for layout code\n"
"		widget.my=def.my or 0\n"
"		\n"
"\n"
"		\n"
"		-- if set these will generate rx,ry\n"
"		widget.pxf=def.pxf      -- local position, for sliders etc, goes from 0-1 \n"
"		widget.pyf=def.pyf      -- fractional position within container\n"
"\n"
"		widget.px=def.px or 0 -- relative pixel position (may generate)\n"
"		widget.py=def.py or 0\n"
"		\n"
"		widget.pxd=def.pxd or 0 -- absolute pixel position (very probably generated)\n"
"		widget.pyd=def.pyd or 0\n"
"		\n"
"		widget.pa=def.pa or 0 -- display rotation angle, possibly\n"
"\n"
"		\n"
"		-- if set these will generate hx,hy\n"
"		widget.hxf=def.hxf	  -- optional relative local size of container, possibly best not to use\n"
"		widget.hyf=def.hyf	  -- it does not have a default so may not be set\n"
"		\n"
"		widget.hx=def.hx or 0 -- absolute pixel size (may generate)\n"
"		widget.hy=def.hy or 0\n"
"		\n"
"		widget.hx_max=def.hx_max -- clip maximum layout size\n"
"		widget.hy_max=def.hy_max		\n"
"				\n"
"		widget.hx_fill=def.hx_fill -- if we wish to stretch this layout then this widget can fill up\n"
"		widget.hy_fill=def.hy_fill -- this much extra space where 1 is all of the avilable extra space\n"
"\n"
"		widget.color=def.color\n"
"		widget.text_color=def.text_color or widget.master.text_color or 0xff000000 -- black text\n"
"		widget.text_size=def.text_size or widget.master.text_size or 16 -- quite chunky text by default\n"
"		\n"
"		widget.text_color_over=def.text_color_over -- if set, switch text color on hover\n"
"		widget.text_align=def.text_align -- default is center\n"
"		\n"
"		widget.text=def.text -- display this text on the button\n"
"		\n"
"		if widget.color or widget.text then widget.solid=true end\n"
"		widget.solid=widget.solid or def.solid\n"
"		\n"
"		if widget.class and classes[widget.class] then -- got a class, call its setup, its setup can override other functions\n"
"			classes[widget.class].setup(widget,def)\n"
"		end\n"
"		\n"
"		if widget.master.ids and widget.id then widget.master.ids[widget.id]=widget end -- lookup by id\n"
"		\n"
"		widget:set_dirty()\n"
"		\n"
"		return widget\n"
"	end\n"
"--\n"
"-- and final cleanup\n"
"--\n"
"	function meta.clean(widget)\n"
"		widget:set_dirty()\n"
"		if widget.master.ids and widget.id then widget.master.ids[widget.id]=nil end -- remove id lookup\n"
"		if widget.fbo then widget.fbo:clean() end\n"
"		return widget\n"
"	end\n"
"--\n"
"-- live adjustment\n"
"--\n"
"	function meta.get(widget,val,...)\n"
"	\n"
"		if val==\"slide\" then\n"
"		\n"
"			local x=(widget.pxd-widget.parent.pxd) / (widget.parent.hx-widget.hx)\n"
"			local y=(widget.pyd-widget.parent.pyd) / (widget.parent.hy-widget.hy)\n"
"			\n"
"			\n"
"			return x,y\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	function meta.set(widget,val,...)\n"
"	local t={...}\n"
"	\n"
"		if val==\"slide\" then\n"
"			for i,v in ipairs(widget) do\n"
"			\n"
"				if type(t[1])==\"table\" then\n"
"					v.pxf=t[1][1] or v.pxf or 0\n"
"					v.pyf=t[1][2] or v.pyf or 0\n"
"				else\n"
"					v.pxf=t[1] or v.pxf or 0\n"
"					v.pyf=t[2] or v.pyf or 0\n"
"				end\n"
"				\n"
"--print(\"SET\",v.pxf,v.pyf)\n"
"\n"
"				v.px=(widget.hx-v.hx)*v.pxf -- local position relative to parents size\n"
"				v.py=(widget.hy-v.hy)*v.pyf\n"
"				\n"
"				v.pxd=widget.pxd+v.px -- absolute\n"
"				v.pyd=widget.pyd-v.py\n"
"				\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"--\n"
"-- initial layout of widgets, to put them into reasonable positions\n"
"--\n"
"	function meta.layout(widget)\n"
"--print(widget.class)\n"
"		if widget.class==\"flow\" or widget.class==\"hx\" then -- hx will be removed\n"
"			meta.layout_flow(widget)\n"
"		elseif widget.class==\"fill\" or widget.class==\"pan\" then\n"
"			meta.layout_fill(widget)\n"
"		elseif widget.class==\"slide\" or widget.class==\"pad\" then\n"
"			meta.layout_padding(widget)\n"
"		elseif widget.class==\"master\" or widget.class==\"abs\" then\n"
"			meta.layout_base(widget)\n"
"		else\n"
"			meta.layout_base(widget)\n"
"		end\n"
"	end\n"
"	\n"
"	function meta.layout_none(widget)\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"	function meta.layout_padding(widget)\n"
"		for i,v in ipairs(widget) do\n"
"\n"
"			if v.hxf then v.hx=widget.hx*v.hxf end -- generate size as a fraction of parent\n"
"			if v.hyf then v.hy=widget.hy*v.hyf end\n"
"			\n"
"			v.px=(widget.hx-v.hx)*v.pxf -- local position relative to parents size\n"
"			v.py=(widget.hy-v.hy)*v.pyf\n"
"\n"
"			v.pxd=widget.pxd+v.px -- local absolute position\n"
"			v.pyd=widget.pyd-v.py\n"
"\n"
"		end\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"\n"
"	function meta.layout_base(widget)\n"
"		for i,v in ipairs(widget) do\n"
"		\n"
"			if v.hxf then v.hx=widget.hx*v.hxf end -- generate size as a fraction of parent\n"
"			if v.hyf then v.hy=widget.hy*v.hyf end\n"
"			\n"
"			if v.pxf then v.px=(widget.hx)*v.pxf end -- local position relative to parents size\n"
"			if v.pyf then v.py=(widget.hy)*v.pyf end\n"
"\n"
"			v.pxd=widget.pxd+v.px -- absolute position\n"
"			v.pyd=widget.pyd-v.py\n"
"			\n"
"		end\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"\n"
"-- this is a fixed layout that works kind of like text\n"
"-- we do not adjust the hx,hy size of sub widgets\n"
"-- we just place them left to right top to bottom\n"
"-- finally we resize this widget to fit its content\n"
"-- the widgets sx,sy is used as default hx,hy for layout\n"
"	function meta.layout_fill(widget)\n"
"		\n"
"		local hx,hy=0,0\n"
"		local my=0\n"
"		local mhx,mhy=0,0\n"
"		function addone(w)\n"
"			w.px=hx\n"
"			w.py=hy\n"
"			hx=hx+w.hx\n"
"			if hx > mhx then mhx=hx end -- max x total size\n"
"			if w.hy > my then my=w.hy end -- max y size for this line\n"
"--print(w.id or \"?\",w.px,w.py,w.hx,w.hy)\n"
"		end\n"
"		\n"
"		function endoflines()\n"
"			widget.hx=mhx\n"
"			widget.hy=mhy\n"
"		end\n"
"		\n"
"		function endofline()\n"
"			hx=0\n"
"			hy=hy+my\n"
"			my=0\n"
"			mhy=hy\n"
"		end\n"
"		\n"
"		if #widget>0 then\n"
"		\n"
"			widget.hx=widget.sx -- use sx,sy as the base fill size\n"
"			widget.hy=widget.sy\n"
"		\n"
"			for i,w in ipairs(widget) do\n"
"			\n"
"				if hx+w.hx>widget.hx then\n"
"					if hx==0 then -- need one item per line so add it anyway\n"
"						addone(w)\n"
"						endofline()\n"
"					else -- skip this one, push it onto nextline\n"
"						endofline()\n"
"						addone(w)\n"
"					end\n"
"				else -- it fits so just add\n"
"					addone(w)\n"
"				end\n"
"			end\n"
"\n"
"			if hx>0 then endofline() end -- final end of line\n"
"			\n"
"			endoflines()\n"
"			\n"
"		end\n"
"		\n"
"		for i,v in ipairs(widget) do\n"
"			v.pxd=widget.pxd+v.px\n"
"			v.pyd=widget.pyd-v.py\n"
"		end\n"
"\n"
"-- layout sub sub widgets	\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"-- this is the magical layout that works like text\n"
"-- except things expand to fit the area\n"
"-- use sx,sy and mx,my to control what ends up where\n"
"	function meta.layout_flow(widget)\n"
"		local sx,sy=0,0\n"
"		local my=0\n"
"		local line=1\n"
"		\n"
"		function endoflines()\n"
"			local y=0\n"
"			for i,v in ipairs(widget) do\n"
"				v.hy=v.sy*widget.hy/sy\n"
"				if v.hy_max and v.hy > v.hy_max then v.hy = v.hy_max end\n"
"				v.py=y\n"
"				if v.endofline then y=y+v.hy end\n"
"--print(v.px..\",\"..v.py..\" - \"..v.hx..\",\"..v.hy)\n"
"			end\n"
"		end\n"
"		\n"
"		function endofline(i)\n"
"			local x=0\n"
"			for i=line,i do -- final line layout\n"
"				local v=widget[i]\n"
"				v.sy=my\n"
"				v.hx=v.sx*widget.hx/sx\n"
"				if v.hx_max and v.hx > v.hx_max then v.hx = v.hx_max end\n"
"				v.px=x\n"
"				x=x+v.hx\n"
"			end\n"
"			widget[i].endofline=true\n"
"			sx=0\n"
"			sy=sy+my\n"
"			my=0\n"
"			line=i+1\n"
"		end\n"
"		\n"
"		if #widget>0 then\n"
"			for i,v in ipairs(widget) do\n"
"			\n"
"				v.endofline=false\n"
"				if sx+v.sx>widget.mx then\n"
"					if sx==0 then -- only one on line\n"
"						if v.sy>my then my=v.sy end\n"
"						sx=sx+v.sx				\n"
"						endofline(i)\n"
"					else -- skip this one, push onto nextline\n"
"						endofline(i-1)\n"
"						if v.sy>my then my=v.sy end\n"
"						sx=sx+v.sx				\n"
"					end\n"
"				else\n"
"					if v.sy>my then my=v.sy end\n"
"					sx=sx+v.sx				\n"
"				end\n"
"			end\n"
"\n"
"			endofline(#widget)\n"
"			endoflines()\n"
"		end\n"
"		\n"
"		for i,v in ipairs(widget) do\n"
"			v.pxd=widget.pxd+v.px\n"
"			v.pyd=widget.pyd-v.py\n"
"		end\n"
"\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"--\n"
"-- handle key input\n"
"--\n"
"	function meta.key(widget,ascii,key,act)\n"
"	end\n"
"	\n"
"--\n"
"-- handle mouse input\n"
"--\n"
"	function meta.mouse(widget,act,x,y,key)\n"
"	\n"
"--print(x..\",\"..y..\" : \"..widget.px..\",\"..widget.py)\n"
"\n"
"		if widget.pan_px then x=x-widget.pan_px end\n"
"		if widget.pan_py then y=y-widget.pan_py end\n"
"\n"
"		if widget.solid and x>=widget.pxd and x<widget.pxd+widget.hx and y<=widget.pyd and y>widget.pyd-widget.hy then\n"
"		\n"
"			if act==\"down\" then\n"
"-- only set if null or our parent...\n"
"				if not widget.master.active or widget.master.active==widget.parent then\n"
"					widget.master.active=widget\n"
"					widget.master.active_x=x-widget.pxd\n"
"					widget.master.active_y=y-widget.pyd\n"
"				end\n"
"			end\n"
"			if act==\"up\" then\n"
"				if widget.master.active and widget.master.active==widget then -- widget clicked\n"
"					widget:call_hook(\"click\")\n"
"				end\n"
"			end\n"
"\n"
"			if not widget.master.active or widget.master.active==widget then -- over widget\n"
"				widget.master.over=widget\n"
"			end\n"
"		else\n"
"		\n"
"			if widget.master.over==widget then\n"
"				widget.master.over=nil\n"
"			end\n"
"		end\n"
"	\n"
"		for i,v in ipairs(widget) do\n"
"			v:mouse(act,x,y,key)\n"
"		end\n"
"	end\n"
"	\n"
"--\n"
"-- update this widget and its sub widgets\n"
"--\n"
"	function meta.update(widget)\n"
"	\n"
"		for i,v in ipairs(widget) do\n"
"			v:update()\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- remove all children of this widget\n"
"--\n"
"	function meta.remove_all(widget)\n"
"	\n"
"		local len=#widget\n"
"		for i=1,len do\n"
"			widget[i]=nil\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- clean and remove all children of this widget\n"
"--\n"
"	function meta.clean_all(widget)\n"
"	\n"
"		for i,v in ipairs(widget) do\n"
"			v:clean_all()\n"
"		end\n"
"		\n"
"		local len=#widget\n"
"		for i=1,len do\n"
"			widget[i]:clean()\n"
"			widget[i]=nil\n"
"		end\n"
"	end\n"
"\n"
"end\n"
"",

"wetquire","\n"
"local oldmodule=module\n"
"local oldrequire=require\n"
"\n"
"-- unhappy modules, do not use this code with them\n"
"local cruft_list={\n"
"	[\"lanes\"]=true,\n"
"	[\"socket\"]=true,\n"
"}\n"
"\n"
"local os=os\n"
"\n"
"-- a small attempt to replace the module function and to impliment live reloading of lua code\n"
"-- on demand without restarting a lua state, this is dodgy but rather useful for testing\n"
"-- and live server situations where downtime is to be avoided. Small changes can be pushed\n"
"-- to a live server seamlessly with a little care.\n"
"\n"
"--\n"
"-- This monkey patches module and require when you call overload and is best applied to the master environment\n"
"-- as early as possible.\n"
"--\n"
"\n"
"-- define functions as local here so they can call each other\n"
"local _overload\n"
"local _rerequire\n"
"local _remodule\n"
"local _require\n"
"local _module\n"
"\n"
"\n"
"-- modules loaded before this time whould be reloaded when required\n"
"-- defaults to 0, just set to os.time() then rerequire your main module\n"
"-- and it should reload every lua module that supports reloading\n"
"local reload_time=0\n"
"\n"
"--\n"
"-- we are about to use this new module function in this file so it needs to be\n"
"-- defined here\n"
"--\n"
"function _remodule(name)\n"
"--print(name)\n"
"--print(package.loaded[name])\n"
"	local mod = package.loaded[name] -- reuse old environment on a reload\n"
"	if mod~=\"table\" then --  or make a new one\n"
"		mod={}\n"
"	end\n"
"	\n"
"-- push some extra data into the module, this flags the module as being a remodule\n"
"-- and provides what I need to reload it from disk\n"
"-- if _MOD_FILENAME is not going to work then do not use this version of module\n"
"-- if you are expecting side effects from the normal module function then again\n"
"-- do not use this version :)\n"
"	mod._MOD_NAME=name\n"
"	mod._MOD_FILENAME=debug.getinfo(2).short_src -- where to reload from\n"
"	mod._MOD_LOADTIME=os.time() -- the time that we where loaded \n"
"\n"
"-- dbg\n"
"--	print(\"Loaded module : \".. mod._MOD_FILENAME)\n"
"\n"
"	package.loaded[name] = mod\n"
"	if setfenv then setfenv(2, mod) end -- setfenv may not exist in lua 5.2\n"
"\n"
"	return mod\n"
"end\n"
"\n"
"\n"
"--\n"
"-- A require function that can reload the lua source when told to do so\n"
"--\n"
"function _rerequire(s)\n"
"	if cruft_list[s] then return _require(s) end -- use old require and module functions\n"
"\n"
"	local oldstate=_overload(false)\n"
"\n"
"	local mod=oldrequire(s)\n"
"\n"
"	if type(mod)==\"table\" and mod._MOD_LOADTIME and ( mod._MOD_LOADTIME < reload_time ) then -- force reload\n"
"\n"
"		if mod._MOD_FILENAME then\n"
"			if not mod._MOD_DISABLE_RELOAD then\n"
"				local f,err=loadfile(mod._MOD_FILENAME)\n"
"				if f then\n"
"					f()\n"
"				else\n"
"					print(err) -- treat as warning\n"
"				end\n"
"			end\n"
"		end\n"
"	\n"
"	end\n"
"\n"
"	_overload(oldstate)\n"
"	return mod\n"
"end\n"
"\n"
"function _require(s)\n"
"	local oldstate=_overload(true)\n"
"	local mod=oldrequire(s)\n"
"	_overload(oldstate)\n"
"	return mod\n"
"end\n"
"\n"
"_module=oldmodule\n"
"\n"
"--\n"
"-- replace global functions, or restore (restore=true)\n"
"-- returns true if they where the original functions\n"
"--\n"
"function _overload(restore)\n"
"\n"
"	\n"
"	local oldstate\n"
"	\n"
"	oldstate=(require==oldrequire) -- true if functions are not replaced\n"
"	\n"
"	if restore then -- restore\n"
"\n"
"		require=oldrequire\n"
"		module=oldmodule\n"
"		\n"
"	else -- replace\n"
"	\n"
"		require=_rerequire\n"
"		module=_remodule\n"
"		\n"
"	end\n"
"\n"
"	return oldstate\n"
"end\n"
"\n"
"\n"
"--use all the above locals to create this module\n"
"\n"
"_remodule(\"wetquire\")\n"
"\n"
"_MOD_DISABLE_RELOAD=true -- disable reload of this module\n"
"\n"
"module=_module\n"
"require=_require\n"
"\n"
"remodule=_remodule\n"
"rerequire=_rerequire\n"
"\n"
"overload=_overload\n"
"--overload=function() return true end -- disable\n"
"\n"
"function set_reload_time(t)\n"
"	reload_time=t or os.time() -- mark all modules loaded before now as requiring a reload\n"
"end\n"
"",

"wetgenes.fenestra.font","\r\n"
"\r\n"
"--\r\n"
"-- draw a font\r\n"
"--\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.font\")\r\n"
"\r\n"
"\r\n"
"--\r\n"
"-- Return a font object we can use to draw text with\r\n"
"--\r\n"
"-- \"base\" is the built in 8x8 font\r\n"
"-- \"sans\" is the default proportional font\r\n"
"--\r\n"
"function setup(win,name)\r\n"
"\r\n"
"\r\n"
"	local font={}\r\n"
"	\r\n"
"	font.name=nil -- base by default\r\n"
"	if name==\"sans\" then font.name=\"sans\" end\r\n"
"	\r\n"
"	font.sx=8 -- base size of each char in this font\r\n"
"	font.sy=8\r\n"
"	\r\n"
"	font.px=0 -- current drawing position for this font\r\n"
"	font.py=0\r\n"
"	\r\n"
"	font.color=0xffffffff -- the current color to draw in\r\n"
"	\r\n"
"--\r\n"
"-- To simplify drawing the fonts are drawn not at the baseline but as their top/left corners\r\n"
"-- this way we can return a width and height of the total area neeeded to draw, you will need to handle\r\n"
"-- baseline offsets when positioning text. The whole baseline thing is a bit oldskool anyhow.\r\n"
"-- If you wish to have multiple sized fonts on a single line it is better if we make that\r\n"
"-- as hard as possible :)\r\n"
"--\r\n"
"-- also fonts are drawn in the directions of x++ and y--,\r\n"
"-- use open gl transforms to position the 0,0 wherever you want before drawing here\r\n"
"--	\r\n"
"	\r\n"
"--\r\n"
"-- cleanup this font\r\n"
"--\r\n"
"	function font.clean()\r\n"
"	end\r\n"
"	\r\n"
"--\r\n"
"-- make this font active\r\n"
"--\r\n"
"	function font.active(force)\r\n"
"		if force or win.font ~= font then\r\n"
"			win.font=font\r\n"
"			win.flat_font(font.name)\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"--\r\n"
"-- set the position and color and size, any input may be nil for no change\r\n"
"--\r\n"
"	function font.set(px,py,color,sx,sy)\r\n"
"		font.active()\r\n"
"		font.px=px or font.px\r\n"
"		font.py=py or font.py\r\n"
"		font.color=color or font.color		\r\n"
"		font.sx=sx or font.sx\r\n"
"		font.sy=sy or sx or font.sy\r\n"
"		\r\n"
"	end\r\n"
"--\r\n"
"-- how big an area does this string require, return width,height\r\n"
"--\r\n"
"	function font.size(text,size)\r\n"
"		font.active()\r\n"
"		if size then font.sx=size font.sy=size end\r\n"
"		if text then return win.flat_measure({size=font.sx,s=text}) , font.sy end\r\n"
"	end\r\n"
"--\r\n"
"-- draw this string, optionally apply a different color to each char using the colors array\r\n"
"--\r\n"
"	function font.draw(text,colors)\r\n"
"		font.active()\r\n"
"		win.flat_print({x=font.px,y=font.py,size=font.sx,color=font.color,s=text,c=colors})\r\n"
"	end\r\n"
"--\r\n"
"-- number of characters that fit in this width\r\n"
"--\r\n"
"	function font.fits(width,text,size)\r\n"
"		font.active()\r\n"
"		if size then font.sx=size font.sy=size end\r\n"
"		if text then return win.flat_fits({size=font.sx,s=text,width=width}) end\r\n"
"	end\r\n"
"	\r\n"
"--\r\n"
"-- which char is under this xpos, ( 0 is first and -1 is unknown )\r\n"
"--\r\n"
"	function font.which(x,text,size)\r\n"
"		font.active()\r\n"
"		if size then font.sx=size font.sy=size end\r\n"
"		if text then return win.flat_which({size=font.sx,s=text,x=x}) end\r\n"
"	end\r\n"
"\r\n"
"--\r\n"
"-- break this string into an array of strings with proper word wrapping to the given width\r\n"
"-- whitespace will be removed from the begining of the strings\r\n"
"--\r\n"
"	function font.wrap(width,text,size)\r\n"
"		font.active()\r\n"
"		if size then font.sx=size font.sy=size end\r\n"
"		if text then\r\n"
"		\r\n"
"			local s=text\r\n"
"			local s1=0\r\n"
"			local ss={}\r\n"
"			while #s>0 do\r\n"
"				s1=font.fits(width,s)\r\n"
"				if s1>=0 then\r\n"
"					local bp=s1\r\n"
"					\r\n"
"					local sa,sb=s:find(\"\\n"
"\")		-- new lines force breaks\r\n"
"					if sa and sa<bp then bp=sa end\r\n"
"					\r\n"
"					local wa,wb=s:sub(bp+1):find(\"^%s+\") -- white space at end?\r\n"
"					\r\n"
"					if #s == bp then -- the end of string\r\n"
"					\r\n"
"					elseif wa then -- perfect split, followed by space\r\n"
"					\r\n"
"						bp=bp+wb -- include the space at the end\r\n"
"						\r\n"
"					else -- find the space before\r\n"
"					\r\n"
"						local a,b = s:find(\"%s+\")\r\n"
"						\r\n"
"						while a do\r\n"
"							if a<s1 then bp=b else break end\r\n"
"							a,b = s:find(\"%s+\",b+1)\r\n"
"						end\r\n"
"						\r\n"
"					end\r\n"
"					ss[#ss+1]=s:sub(1,bp)\r\n"
"					s=s:sub(bp+1)\r\n"
"				else\r\n"
"					break\r\n"
"				end\r\n"
"			end\r\n"
"\r\n"
"			return ss\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	return font\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.bake.js","\r\n"
"local require=require\r\n"
"local loadfile=loadfile\r\n"
"local setfenv=setfenv\r\n"
"local pcall=pcall\r\n"
"local print=print\r\n"
"local pairs=pairs\r\n"
"local ipairs=ipairs\r\n"
"local type=type\r\n"
"\r\n"
"local string=string\r\n"
"local table=table\r\n"
"local io=io\r\n"
"local os=os\r\n"
"\r\n"
"module(...)\r\n"
"\r\n"
"function build(tab)\r\n"
"\r\n"
"local bake=require(\"wetgenes.bake\")\r\n"
"\r\n"
"local pp=require(\"wetgenes.pp\")\r\n"
"local lfs=require(\"lfs\")\r\n"
"\r\n"
"local no_art=false\r\n"
"\r\n"
"local opts=tab.opts or {} -- can pass in an opts of default options\r\n"
"\r\n"
"local opts_changed=false\r\n"
"local func\r\n"
"\r\n"
"	opts.VERSION_NUMBER=opts.VERSION_NUMBER or 0\r\n"
"\r\n"
"	func=loadfile(\"src/opts.lua\")\r\n"
"	if func then\r\n"
"		setfenv(func,opts)\r\n"
"		pcall(func)\r\n"
"	else\r\n"
"		opts_changed=true\r\n"
"	end\r\n"
"		\r\n"
"	for i=1,#tab.arg do\r\n"
"		\r\n"
"		if tab.arg[i]==\"bump\" then\r\n"
"		\r\n"
"			opts.VERSION_NUMBER=opts.VERSION_NUMBER+0.001\r\n"
"		\r\n"
"			opts_changed=true\r\n"
"		end\r\n"
"		\r\n"
"		if tab.arg[i]==\"debug\" then\r\n"
"		\r\n"
"			opts.VERSION_BUILD=\"debug\"\r\n"
"		\r\n"
"			opts_changed=true\r\n"
"		end\r\n"
"		\r\n"
"		if tab.arg[i]==\"release\" then\r\n"
"		\r\n"
"			opts.VERSION_BUILD=\"release\"\r\n"
"		\r\n"
"			opts_changed=true\r\n"
"		end\r\n"
"		\r\n"
"		if tab.arg[i]==\"noart\" then\r\n"
"			no_art=true\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	if opts_changed then -- write out changed file\r\n"
"		local fp=io.open(\"src/opts.lua\",\"w\")\r\n"
"		for i,v in pairs(opts) do\r\n"
"		\r\n"
"			if type(v)==\"number\" then\r\n"
"				fp:write(i..\"=\"..v..\"\\n"
"\")\r\n"
"			elseif type(v)==\"string\" then\r\n"
"				fp:write(i..\"=\"..string.format(\"%q\",v)..\"\\n"
"\")\r\n"
"			end\r\n"
"		end\r\n"
"		fp:close()\r\n"
"	end\r\n"
"	\r\n"
"	\r\n"
"	\r\n"
"	\r\n"
"-- where we are building from\r\n"
"bake.cd_base	=	bake.cd_base or bake.get_cd()\r\n"
"\r\n"
"-- where we are building to\r\n"
"bake.cd_out		=	bake.cd_out or 'out'\r\n"
"\r\n"
"lfs.mkdir(bake.cd_out)\r\n"
"lfs.mkdir(bake.cd_out..'/art')\r\n"
"lfs.mkdir(bake.cd_out..'/cache')\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"-- go up a dir from base cd and remember as main CD for building commands\r\n"
"\r\n"
"bake.set_cd(bake.get_cd()..'/..')\r\n"
"bake.cd=bake.get_cd()\r\n"
"\r\n"
"print('cd','=',bake.cd)\r\n"
"\r\n"
"\r\n"
"bake.cmd.java=\"java\" -- needed for minifier\r\n"
"bake.cmd.zip=\"zip\" -- needed to zip stuffs\r\n"
"\r\n"
"bake.cmd.lua		=	bake.path_clean_exe( bake.cd , '/exe/lua' )\r\n"
"\r\n"
"if bake.osflavour==\"nix\" then -- expected to be installed...\r\n"
"--	bake.cmd.mtasc=\"mtasc\"\r\n"
"--	bake.cmd.swfmill=\"swfmill\"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"bake.set_cd(bake.cd_base)\r\n"
"\r\n"
"bake.files_min_js=bake.files_min_js or {}\r\n"
"bake.files_min_js[ #bake.files_min_js + 1 ]=tab.name\r\n"
"\r\n"
"bake.files_js={}\r\n"
"for v in lfs.dir(\"src\") do -- add all .js files in the src dir\r\n"
"	if string.find(v,\"%.js$\") then\r\n"
"		v=string.gsub( v , \"%.js$\" , \"\")\r\n"
"		table.insert(bake.files_js,v)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"bake.files_css={}\r\n"
"for v in lfs.dir(\"src\") do -- add all .css files in the src dir\r\n"
"	if string.find(v,\"%.css$\") then\r\n"
"		v=string.gsub( v , \"%.css$\" , \"\")\r\n"
"		table.insert(bake.files_css,v)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"bake.files_html={}\r\n"
"for v in lfs.dir(\"src\") do -- and all .html files in the src dir\r\n"
"	if string.find(v,\"%.html$\") then\r\n"
"		v=string.gsub( v , \"%.html$\" , \"\")\r\n"
"		table.insert(bake.files_html,v)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"for i,v in ipairs(bake.files_js) do\r\n"
"	pp.loadsave( 'src/'..v..'.js' , bake.cd_out..'/'..v..'.js' )\r\n"
"end\r\n"
"for i,v in ipairs(bake.files_css) do\r\n"
"	pp.loadsave( 'src/'..v..'.css' , bake.cd_out..'/'..v..'.css' )\r\n"
"end\r\n"
"\r\n"
"for i,v in ipairs(bake.files_html) do\r\n"
"	pp.loadsave( 'src/'..v..'.html' , bake.cd_out..'/'..v..'.html' )\r\n"
"end\r\n"
"\r\n"
"-- generic pp of files,full paths from -> to\r\n"
"bake.files_pp=bake.files_pp or {}\r\n"
"for i,v in ipairs(bake.files_pp) do\r\n"
"	pp.loadsave( v[1] , v[2] )\r\n"
"end\r\n"
"\r\n"
"\r\n"
"io.flush()\r\n"
"\r\n"
"if no_art then\r\n"
"print('****')\r\n"
"print('**SKIPPING**ART**BUILD**STEP**')\r\n"
"print('****')\r\n"
"else\r\n"
"\r\n"
"\r\n"
"for i,v in ipairs(bake.files_min_js) do\r\n"
"print('compressing '..v)\r\n"
"	bake.execute( bake.cd_base , bake.cmd.java ,\r\n"
"\"-jar ../../js/class/compiler.jar --js_output_file \"..bake.cd_out..\"/\"..v..\".min.js --js \"..bake.cd_out..\"/\"..v..\".js\")\r\n"
"\r\n"
"end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.png$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.jpg$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.swf$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.css$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.mp3$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.ogg$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"art\",filter=\"%.wav$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\".\",dir=\"jslib\",filter=\"%.js$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/\"..v)\r\n"
"		bake.copyfile(v,bake.cd_out..\"/\"..v)\r\n"
"	end\r\n"
"	\r\n"
"-- build an application cache\r\n"
"\r\n"
"	for i,v in ipairs(tab.cache_files or {}) do\r\n"
"		local v1,v2\r\n"
"		if type(v)==\"table\" then\r\n"
"			v1=v[1]\r\n"
"			v2=v[2]\r\n"
"		else\r\n"
"			v1=v\r\n"
"			v2=v\r\n"
"		end\r\n"
"print('caching out/'..v1..\" as \"..v2)\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/cache/\"..v2)\r\n"
"		bake.copyfile(\"out/\"..v1,bake.cd_out..\"/cache/\"..v2)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=bake.cd_out..\"/cache\",dir=\".\",filter=\"\"}\r\n"
"	local mc=table.concat(r.ret,\"\\n"
"\")..\"\\n"
"\"\r\n"
"	local fp=io.open(bake.cd_out..\"/cache/cache.manifest\",\"w\")\r\n"
"	fp:write(\"CACHE MANIFEST\\n"
"\")\r\n"
"	fp:write(\"#Updated on \"..os.date()..\"\\n"
"\")\r\n"
"	fp:write(mc)\r\n"
"	fp:close()\r\n"
"	\r\n"
"-- zip everything in the cache, this is our distribution package\r\n"
"	bake.execute(bake.cd_out..\"/cache\",bake.cmd.zip,\"../\"..tab.name..\".zip * -r\")\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"",

"wetgenes.www.any.users","if ngx then\n"
"	return require(\"wetgenes.www.ngx.users\")\n"
"else\n"
"	return require(\"wetgenes.www.gae.users\")\n"
"end\n"
"",

"wetgenes.win.windows","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local windows={}\n"
"\n"
"local core=require(\"wetgenes.win.windows.core\")\n"
"\n"
"\n"
"--\n"
"-- export all core functions not wrapped above\n"
"--\n"
"for n,v in pairs(core) do -- check the core\n"
"	if type(v)==\"function\" then -- only functions\n"
"		if not windows[n] then -- only if not prewrapped\n"
"			windows[n]=v\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"\n"
"\n"
"return windows\n"
"",

"wetgenes.www.any.log","if ngx then\r	return require(\"wetgenes.www.ngx.log\")\relse\r	return require(\"wetgenes.www.gae.log\")\rend\r",

"wetgenes.xox","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- we handle the lua side loading and manipulation of 3d vertex/polygon buffers\n"
"-- this can be used for file/data processing but needs you to pass in contexts\n"
"-- for basic opengl drawing funcs\n"
"\n"
"local dprint=function(...) print(wstr.dump(...)) end\n"
"local wxml=require(\"wetgenes.simpxml\")\n"
"local wzips=require(\"wetgenes.zips\")\n"
"\n"
"local wxox={}\n"
"wxox.name=\"wetgenes.xox\"\n"
"package.loaded[wxox.name]=wxox\n"
"\n"
"--the idx used here is 1 based like all lua tables\n"
"local meta_buff={__index={\n"
"	get=function(buff,idx,tab)\n"
"		if type(idx)==\"number\" then\n"
"			tab=tab or {}\n"
"			local base=(idx-1)*buff.stride\n"
"			for i=1,buff.stride do\n"
"				tab[i]=buff.list[base+i]\n"
"			end\n"
"			return tab\n"
"		else\n"
"		end\n"
"	end,\n"
"	set=function(buff,idx,tab)\n"
"		if type(idx)==\"number\" then\n"
"			local base=(idx-1)*buff.stride\n"
"			for i=1,buff.stride do\n"
"				buff.list[base+i]=tab[i]\n"
"			end\n"
"			if idx>buff.count then buff.count=idx end -- keep length\n"
"			return idx\n"
"		else\n"
"		end\n"
"	end,\n"
"	push=function(buff,tab)\n"
"		return buff:set(buff.count+1,tab)\n"
"	end,\n"
"	iter=function(buff)\n"
"		local i = 0\n"
"		local n = buff.count\n"
"		return function ()\n"
"			i = i + 1\n"
"			if i <= n then return i,buff:get(i) end\n"
"		end\n"
"	end,\n"
"}}\n"
"\n"
"function wxox.create_buff(opts)\n"
"	buff=opts and opts.buff or {}\n"
"	setmetatable(buff,meta_buff)\n"
"	buff.list={}\n"
"	buff.stride=opts.stride or 1\n"
"	buff.count=opts.count or 0\n"
"	return buff\n"
"end\n"
"\n"
"function wxox.create_verts(opts)\n"
"	verts=opts and opts.verts or {}\n"
"	verts.buff=wxox.create_buff({stride=3})\n"
"	return verts\n"
"end\n"
"\n"
"function wxox.create_tris(opts)\n"
"	tris=opts and opts.tris or {}\n"
"	tris.buff=wxox.create_buff({stride=4})	\n"
"	return tris\n"
"end\n"
"\n"
"function wxox.create_edges(opts)\n"
"	edges=opts and opts.edges or {}\n"
"	edges.buff=wxox.create_buff({stride=3})\n"
"	return edges\n"
"end\n"
"\n"
"function wxox.create_mats(opts)\n"
"	mats=opts and opts.mats or {}\n"
"\n"
"	mats.list={}\n"
"	\n"
"	return mats\n"
"end\n"
"\n"
"\n"
"function wxox.load_dae(xox,fname)\n"
"\n"
"local s=wzips.readfile(fname)\n"
"\n"
"print(\"loaded \",#s,\"bytes\")\n"
"\n"
"local x=wxml.parse(s)\n"
"\n"
"--print(\"loaded \",wxml.unparse(x))\n"
"\n"
"local ids={}\n"
"local function do_ids(t)\n"
"	for i=1,#t do local v=t[i]\n"
"		if type(v)==\"table\" then\n"
"			if v.id then ids[v.id]=v end\n"
"			do_ids(v)\n"
"		end\n"
"	end\n"
"end\n"
"do_ids(x)\n"
"\n"
"--[[\n"
"for id,v in pairs(ids) do\n"
"print(\"\\\"\"..id..\"\\\"\")\n"
"end\n"
"]]\n"
"\n"
"local function get_dat(id)\n"
"	if id:sub(1,1) == \"#\" then\n"
"		id=id:sub(2)\n"
"	end\n"
"	local d=ids[id]\n"
"	if d[0]==\"source\" or d[0]==\"float_array\" then\n"
"		return d \n"
"	else\n"
"		local t=wxml.descendent(d,\"input\")\n"
"		return get_dat(t.source)\n"
"	end\n"
"end\n"
"\n"
"local function scan_nums(s)\n"
"	local a={}\n"
"	for w in string.gfind(s, \"([^%s]+)\") do\n"
"		local n=tonumber(w)\n"
"		a[#a+1]=n\n"
"	end	\n"
"	return a\n"
"end\n"
"\n"
"local sources={}\n"
"local function get_source(id)\n"
"	if sources[id] then return sources[id] end\n"
"	\n"
"	local d=get_dat(id)\n"
"	\n"
"	local a=wxml.descendent(d,\"accessor\")\n"
"	local it={}\n"
"	\n"
"	it.stride=tonumber(a.stride)\n"
"	it.names={}\n"
"\n"
"	for i,v in ipairs( wxml.descendents(a,\"param\") ) do\n"
"		it.names[#it.names+1]=v.name\n"
"	end\n"
"	\n"
"	it.data=scan_nums( get_dat(a.source)[1] )\n"
"	\n"
"	sources[id]=it\n"
"	return it\n"
"end\n"
"\n"
"\n"
"local geo\n"
"\n"
"local t=wxml.descendent(x,\"library_geometries\")\n"
"for i=1,#t do local v=t[i]\n"
"	if v[0]==\"geometry\" then\n"
"		geo={}\n"
"		geo.name=v.name\n"
"		geo.mesh=wxml.descendent(v,\"mesh\")\n"
"		break\n"
"	end\n"
"end\n"
"\n"
"\n"
"\n"
"--print(\"loading object named \\\"\"..geo.name..\"\\\"\")\n"
"\n"
"local polys={}\n"
"for i,v in ipairs( wxml.descendents(geo.mesh,\"polylist\")) do -- handle each polylist chunk\n"
"\n"
"	local p={}\n"
"	polys[#polys+1]=p\n"
"	\n"
"	p.inputs={}\n"
"	\n"
"	p.stride=0\n"
"	for i,l in ipairs( wxml.descendents(v,\"input\") ) do\n"
"		local m={}\n"
"		p.inputs[#p.inputs+1]=m\n"
"		\n"
"		m.semantic=l.semantic\n"
"		m.offset=tonumber(l.offset)\n"
"		m.source=get_source(l.source)\n"
"		if m.offset > p.stride then p.stride=m.offset end\n"
"	end\n"
"	p.stride=p.stride+1 -- this is how we guess this number?\n"
"	p.vcount=scan_nums( wxml.descendent(v,\"vcount\")[1] )\n"
"	p.p=scan_nums( wxml.descendent(v,\"p\")[1] )\n"
"	\n"
"--	dprint( p )\n"
"\n"
"end\n"
"\n"
"print(\"found poly list count \\\"\"..#polys..\"\\\"\")\n"
"\n"
"\n"
"	for ips,ps in ipairs(polys) do\n"
"	\n"
"\n"
"		local off=1\n"
"		for ipc,pc in ipairs(ps.vcount) do\n"
"		\n"
"			local db={}\n"
"			local function push(n)\n"
"				db[#db+1]=n\n"
"			end\n"
"\n"
"			local pxx\n"
"			if pc==3 then\n"
"				pxx={1,2,3}\n"
"			elseif pc==4 then\n"
"				pxx={1,2,4,4,2,3}\n"
"			end\n"
"			\n"
"			for _,i in ipairs(pxx) do\n"
"				\n"
"				for j=1,ps.stride do\n"
"				\n"
"					local v=ps.p[ off+(ps.stride*(i-1))+j-1 ]\n"
"					\n"
"					if ps.inputs[j].semantic == \"VERTEX\" then\n"
"\n"
"						local s=ps.inputs[j].source\n"
"						for n=1,3 do\n"
"							push( s.data[ (v*s.stride) +n ] )\n"
"						end\n"
"						\n"
"					end\n"
"					\n"
"				end\n"
"				\n"
"			end\n"
"			off=off+ps.stride*pc\n"
"			\n"
"-- the data that came in *could* be all over the place\n"
"-- so we duplicate points with a plan to auto merge them back together later\n"
"\n"
"			for i=1,#db,9 do -- 3 verts per tri , 3 numbers per vert\n"
"				local v1=xox.verts.buff:push({db[i+0],db[i+1],db[i+2]})\n"
"				local v2=xox.verts.buff:push({db[i+3],db[i+4],db[i+5]})\n"
"				local v3=xox.verts.buff:push({db[i+6],db[i+7],db[i+8]})\n"
"				xox.tris.buff:push({v1,v2,v3,1})\n"
"			end\n"
"			\n"
"--			gl.Color(0.5,ipc/#ps.vcount,0.5,1) -- draw drop shadow\n"
"--			canvas.flat.tristrip(\"xyz\",db)\n"
"			\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	return xox\n"
"end\n"
"\n"
"-- draw using a gamecake canvas\n"
"function wxox.draw_canvas(xox,canvas)\n"
"\n"
"	for i,v in xox.tris.buff:iter() do\n"
"	\n"
"		local p1=xox.verts.buff:get(v[1])\n"
"		local p2=xox.verts.buff:get(v[2])\n"
"		local p3=xox.verts.buff:get(v[3])\n"
"\n"
"		canvas.flat.tristrip(\"xyz\",{\n"
"			p1[1],p1[2],p1[3],\n"
"			p2[1],p2[2],p2[3],\n"
"			p3[1],p3[2],p3[3],\n"
"		})\n"
"		\n"
"	end\n"
"\n"
"	return xox\n"
"end\n"
"\n"
"local meta_xox={__index={\n"
"	load_dae=wxox.load_dae,\n"
"	draw_canvas=wxox.draw_canvas,\n"
"}}\n"
"\n"
"\n"
"-- create verts / tris / mats in a single object\n"
"function wxox.create_xox(opts)\n"
"	local xox=opts and opts.xox or {}\n"
"\n"
"	setmetatable(xox,meta_xox)\n"
"	\n"
"	xox.verts=wxox.create_verts()\n"
"	xox.tris =wxox.create_tris()\n"
"	xox.mats =wxox.create_mats()\n"
"\n"
"--	xox.edges=wxox.create_edges()\n"
"\n"
"	\n"
"	return xox\n"
"end\n"
"\n"
"return wxox\n"
"",

"wetgenes.www.ngx.serv","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.ngx.log\").log\n"
"local debug=require(\"debug\")\n"
"\n"
"\n"
"local cache=require(\"wetgenes.www.ngx.cache\")\n"
"\n"
"\n"
"\n"
"local ngx=require(\"ngx\")\n"
"\n"
"-- does this overloading let us just use the socket module?\n"
"--[[\n"
"local socket=assert(require(\"socket\"))\n"
"socket.tcp=ngx.socket.tcp\n"
"socket.udp=ngx.socket.udp\n"
"socket.connect=ngx.socket.connect\n"
"]]\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.serv\"]=_M\n"
"\n"
"function serv()\n"
"	xpcall(serv2,function(msg,lev)\n"
"		log( msg )\n"
"		log( debug.traceback() )\n"
"	end)\n"
"end\n"
"\n"
"-- work out which is our vhost but do not do any more setup, returns srv\n"
"function serv_srv()\n"
"\n"
"	local opts=require(\"opts\")\n"
"	if opts.setup then opts.setup() end -- may need to in itialize stuff\n"
"\n"
"	local srv=require(\"wetgenes.www.ngx.srv\").new()\n"
"	ngx.ctx=srv -- this is out ctx\n"
"	\n"
"	for i,v in ipairs(opts.vhosts_map or {} ) do\n"
"		srv.vhost=v[2]\n"
"		if ngx.var.host:find(v[1]) then break end\n"
"	end	\n"
"\n"
"	return srv\n"
"	\n"
"end\n"
"\n"
"function serv2()\n"
"\n"
"	local opts=require(\"opts\")\n"
"	local srv=serv_srv()\n"
"	\n"
"--	if srv.vhost then log(\"VHOST = \"..srv.vhost) end\n"
"	\n"
"	srv.opts=function(...)\n"
"		local t=opts.vhosts[srv.vhost] or opts\n"
"		for i,v in ipairs({...}) do\n"
"			t=t and t[v]\n"
"		end\n"
"		return t\n"
"	end\n"
"	\n"
"	-- shove this basic functions into the global name space\n"
"	-- they will work with the opts to serv this app as needed\n"
"	local basic=require(\"base.basic\")\n"
"	\n"
"\n"
"	if not srv.opts().require_all_done then\n"
"		srv.opts().require_all_done=true\n"
"\n"
"--		log(\"require all mods\")\n"
"\n"
"		for n,v in pairs(opts.mods) do\n"
"			if type(n)==\"string\" then\n"
"--				log(\"require \"..n)\n"
"				local m,err=pcall(require,n)\n"
"				if not m then\n"
"					log(\"require failed on mod \"..n..\"\\n"
"\"..(err or \"\"))\n"
"				end\n"
"			end\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"	\n"
"	basic.serv(srv)\n"
"\n"
"end\n"
"",

"wetgenes.gamecake.widgets.file","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"-- a scrolling area, the widget is biger than display area but scroll bars allow you to see it all\r\n"
"\r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,wfile)\r\n"
"wfile=wfile or {}\r\n"
"\r\n"
"function wfile.mouse(widget,act,x,y,key)\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wfile.key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wfile.update(widget)\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function wfile.draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"function wfile.setup(widget,def)\r\n"
"	widget.class=\"file\"\r\n"
"	\r\n"
"	widget.key=wfile.key\r\n"
"	widget.mouse=wfile.mouse\r\n"
"	widget.update=wfile.update\r\n"
"	widget.draw=wfile.draw\r\n"
"\r\n"
"-- auto add the draging button as a child\r\n"
"--[[\r\n"
"	local ss=16\r\n"
"	if widget.hx<ss*2 then ss=widget.hx/2 end\r\n"
"	if widget.hy<ss*2 then ss=widget.hy/2 end\r\n"
"	\r\n"
"	widget.pan=		widget:add({class=\"pan\",	hx=widget.hx-ss,	hy=widget.hy-ss,	})\r\n"
"	widget.slidey=	widget:add({class=\"slide\",	hx=ss,				hy=widget.hy-ss,	px=widget.hx-ss,	py=0,\r\n"
"		datx={max=0},daty={max=1},color=0xffffffff})\r\n"
"	widget.slidex=	widget:add({class=\"slide\",	hx=widget.hx-ss,	hy=ss,           	px=0,           	py=widget.hy-ss,\r\n"
"		datx={max=1},daty={max=0},color=0xffffffff})\r\n"
"]]\r\n"
"	return widget\r\n"
"end\r\n"
"\r\n"
"return wfile\r\n"
"end\r\n"
"",

"wetgenes.www.gae.log","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local core=require(\"wetgenes.www.gae.log.core\")\n"
"\n"
"\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.log\"]=_M\n"
"\n"
"\n"
"function log(a,b)\n"
"\n"
"	return core.log(a,b)\n"
"\n"
"end\n"
"",

"wetgenes.cgilua","--\r\n"
"-- Some cgilua helper functions\r\n"
"--\r\n"
"\r\n"
"local cgi\r\n"
"local cgilua=cgilua\r\n"
"\r\n"
"local string=string\r\n"
"local table=table\r\n"
"local math=math\r\n"
"\r\n"
"local type=type\r\n"
"local pairs=pairs\r\n"
"local setfenv=setfenv\r\n"
"\r\n"
"local socket=require(\"socket\")\r\n"
"local misc=require(\"wetgenes.cgilua.misc\")\r\n"
"\r\n"
"module(\"wetgenes.cgilua\")\r\n"
"cgi=_M -- cgi should point to this module\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- print a debug string somewhere useful\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"dbg=function(s)\r\n"
"	cgilua.errorlog(s)\r\n"
"	if not headers_sent then \r\n"
"		contentheader(\"text\", \"html\")\r\n"
"	end\r\n"
"	cgilua.put(s)\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- just a copy of some cgilua put\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"put=function(s)\r\n"
"	cgilua.put(s)\r\n"
"end\r\n"
"header=function(a,b)\r\n"
"	cgilua.header(a,b)\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- Set content type and remember headers have been sent\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function contentheader(type, subtype)\r\n"
"\r\n"
"	if headers_sent then return end -- so this is safe to call multiple times\r\n"
"	\r\n"
"	headers_sent=true -- flag\r\n"
"	\r\n"
"	cgilua.contentheader(type, subtype)\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- redirect\r\n"
"-- either with headers or throw out some javascript if that is too late\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function redirect(url)\r\n"
"\r\n"
"	if headers_sent then\r\n"
"\r\n"
"		cgilua.put([[<script type=\"text/javascript\"> window.location = ]]..string.format(\"%q\",url)..[[; </script>]])\r\n"
"\r\n"
"	else\r\n"
"\r\n"
"		cgilua.redirect(url)\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- Build some always useful information about this request\r\n"
"-- into this module\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function setup() -- call setup once to set global values for this request?\r\n"
"\r\n"
"	start_time=socket.gettime()\r\n"
"	query_count=0\r\n"
"	\r\n"
"	math.randomseed( math.floor(start_time*1000) )\r\n"
"	math.random()\r\n"
"\r\n"
"	headers_sent=false\r\n"
"\r\n"
"	path=cgilua.servervariable(\"SCRIPT_NAME\")..cgilua.servervariable(\"PATH_INFO\")\r\n"
"\r\n"
"	server=cgilua.servervariable(\"SERVER_NAME\")\r\n"
"\r\n"
"	query=cgilua.servervariable(\"QUERY_STRING\")\r\n"
"\r\n"
"	ip=cgilua.servervariable(\"REMOTE_ADDR\")\r\n"
"	ipnum=misc.ipstr_to_number(ip)\r\n"
"\r\n"
"	url=\"http://\"..server..path\r\n"
"	url_query=url\r\n"
"\r\n"
"	if query and query~=\"\" then url_query=url..\"?\"..query end\r\n"
"	-- url_query is now probably full if we need to redirect to ourselves (which we often do)\r\n"
"	\r\n"
"	slash=misc.str_split(\"/\",url) --  a normally useful array\r\n"
"\r\n"
"	-- the lua query/post are dangerous as they may contain tables...\r\n"
"	-- this creates safe copies that are only strings\r\n"
"\r\n"
"	gets={}\r\n"
"	for i,v in pairs(cgilua.QUERY) do\r\n"
"		if type(i)==\"string\" and type(v)==\"string\" then -- do not allow tables to break simple code\r\n"
"			gets[i]=v\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	posts={}\r\n"
"	for i,v in pairs(cgilua.POST) do\r\n"
"		if type(i)==\"string\" and type(v)==\"string\" then -- do not allow tables to break simple code\r\n"
"			posts[i]=v\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	json=nil\r\n"
"	if gets.fmt==\"json\" or posts.fmt==\"json\" then -- a special json request, start building the return\r\n"
"		json={}\r\n"
"		json.doups={}\r\n"
"	end\r\n"
"	\r\n"
"	return _M\r\n"
"end\r\n"
"",

"wetgenes.freetype","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local freetype={}\n"
"\n"
"local core=require(\"wetgenes.freetype.core\")\n"
"\n"
"local base={}\n"
"local meta={}\n"
"meta.__index=base\n"
"\n"
"function freetype.create()\n"
"\n"
"	local ft={}\n"
"	\n"
"	ft[0]=core.create()	\n"
"	setmetatable(ft,meta)\n"
"	\n"
"--	ft:info()\n"
"	\n"
"	return ft\n"
"end\n"
"\n"
"base.load_file=function(ft,s)\n"
"	local r,err=core.load_file(ft[0],s)\n"
"	ft:info()\n"
"end\n"
"\n"
"base.load_data=function(ft,s)\n"
"	local r,err=core.load_data(ft[0],s)\n"
"	ft:info()\n"
"end\n"
"\n"
"base.destroy=function(ft)\n"
"	local r,err=core.destroy(ft[0])\n"
"	ft:info()\n"
"end\n"
"\n"
"base.size=function(ft,x,y)\n"
"	local r,err=core.size(ft[0],x,y)\n"
"	ft:info()\n"
"	return ft\n"
"end\n"
"\n"
"base.glyph=function(ft,id)\n"
"	local r,err=core.glyph(ft[0],id)\n"
"	ft:info()\n"
"	return ft\n"
"end\n"
"\n"
"base.render=function(ft,id)\n"
"	local r,err=core.render(ft[0],id)\n"
"	ft:info()\n"
"	return ft\n"
"end\n"
"\n"
"base.tab=function(ft)\n"
"	local r,err=core.tab(ft[0])\n"
"	ft:info()\n"
"	return ft\n"
"end\n"
"\n"
"base.grd=function(ft,g)\n"
"	local r,err=core.grd(ft[0],g[0])\n"
"	ft:info()\n"
"	g:info()\n"
"	return ft\n"
"end\n"
"\n"
"base.info=function(ft)\n"
"	core.info(ft[0],ft)\n"
"--[[\n"
"	if ft.error then\n"
"		assert(not ft.error,ft.error)\n"
"	end\n"
"]]\n"
"	return ft\n"
"end\n"
"\n"
"return freetype\n"
"",

"wetgenes.gamecake.mods.console.buffedit","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"-- a 1 line buffer edit, how you display it is up to you\r\n"
"-- has a simple history, just pass in key presses\r\n"
"-- this is intended for commandline style editing\r\n"
"\r\n"
"\r\n"
"module(\"wetgenes.gamecake.mods.console.buffedit\")\r\n"
"\r\n"
"function keypress(it,ascii,key,act)\r\n"
"\r\n"
"	if act==1 or act==0 then\r\n"
"	\r\n"
"		if key==\"left\" then\r\n"
"\r\n"
"			it.line_idx=it.line_idx-1\r\n"
"			if it.line_idx<0 then it.line_idx=0 end\r\n"
"			\r\n"
"			it.throb=255\r\n"
"						\r\n"
"		elseif key==\"right\" then\r\n"
"	\r\n"
"			it.line_idx=it.line_idx+1\r\n"
"			if it.line_idx>#it.line then it.line_idx=#it.line end\r\n"
"			\r\n"
"			it.throb=255\r\n"
"			\r\n"
"		elseif key==\"home\" then\r\n"
"		\r\n"
"			it.line_idx=0\r\n"
"		\r\n"
"		elseif key==\"end\" then\r\n"
"		\r\n"
"			it.line_idx=#it.line\r\n"
"		\r\n"
"		elseif key==\"back\" then\r\n"
"	\r\n"
"			if it.line_idx >= #it.line then -- at end\r\n"
"			\r\n"
"				it.line=it.line:sub(1,-2)\r\n"
"				it.line_idx=#it.line\r\n"
"			\r\n"
"			elseif it.line_idx == 0 then -- at start\r\n"
"			\r\n"
"			elseif it.line_idx == 1 then -- near start\r\n"
"			\r\n"
"				it.line=it.line:sub(2)\r\n"
"				it.line_idx=it.line_idx-1\r\n"
"			\r\n"
"			else -- somewhere in the line\r\n"
"			\r\n"
"				it.line=it.line:sub(1,it.line_idx-1) .. it.line:sub(it.line_idx+1)\r\n"
"				it.line_idx=it.line_idx-1\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"			it.throb=255\r\n"
"			\r\n"
"		elseif key==\"delete\" then\r\n"
"	\r\n"
"			if it.line_idx >= #it.line then -- at end\r\n"
"			\r\n"
"\r\n"
"			elseif it.line_idx == 0 then -- at start\r\n"
"			\r\n"
"				it.line=it.line:sub(2)\r\n"
"				it.line_idx=0\r\n"
"			\r\n"
"			else -- somewhere in the line\r\n"
"			\r\n"
"				it.line=it.line:sub(1,it.line_idx) .. it.line:sub(it.line_idx+2)\r\n"
"				it.line_idx=it.line_idx\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"			it.throb=255\r\n"
"			\r\n"
"		elseif key==\"enter\" or key==\"return\" then\r\n"
"		\r\n"
"			if act==1 then -- ignore repeats on enter key\r\n"
"			\r\n"
"				local f=it.line\r\n"
"--				fenestra._g.print(\">\"..f)\r\n"
"				\r\n"
"				table.insert(it.history,it.line)\r\n"
"				\r\n"
"				while #it.history > it.history_max do\r\n"
"					table.remove(it.history,1)\r\n"
"				end\r\n"
"		\r\n"
"				it.history_idx=#it.history+1\r\n"
"			\r\n"
"				it.line=\"\"\r\n"
"				it.line_idx=0\r\n"
"				\r\n"
"				if f and it.enter then -- callback?\r\n"
"				\r\n"
"					it:enter(f)\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"		elseif key==\"up\" then\r\n"
"		\r\n"
"			it.history_idx=it.history_idx-1\r\n"
"			if it.history_idx<0 then it.history_idx=#it.history end\r\n"
"			it.line=it.history[it.history_idx] or \"\"\r\n"
"			it.line_idx=#it.line\r\n"
"		\r\n"
"		elseif key==\"down\" then\r\n"
"		\r\n"
"			it.history_idx=it.history_idx+1\r\n"
"			if it.history_idx>#it.history then it.history_idx=0 end\r\n"
"			it.line=it.history[it.history_idx] or \"\"\r\n"
"			it.line_idx=#it.line\r\n"
"			\r\n"
"		elseif ascii~=\"\" then -- not a blank string\r\n"
"			local c=string.byte(ascii)\r\n"
"			\r\n"
"			if c>=32 and c<128 then\r\n"
"			\r\n"
"				if it.line_idx >= #it.line then -- put at end\r\n"
"				\r\n"
"					it.line=it.line..ascii\r\n"
"					it.line_idx=#it.line\r\n"
"					\r\n"
"				elseif it.line_idx == 0 then -- put at start\r\n"
"				\r\n"
"					it.line=ascii..it.line\r\n"
"					it.line_idx=it.line_idx+1\r\n"
"					\r\n"
"				else -- need to insert into line\r\n"
"				\r\n"
"					it.line=it.line:sub(1,it.line_idx) .. ascii .. it.line:sub(it.line_idx+1)\r\n"
"					it.line_idx=it.line_idx+1\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"				it.throb=255\r\n"
"				\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	return true\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(it)\r\n"
"\r\n"
"	it.throb=it.throb-4\r\n"
"	if it.throb<0 then it.throb=255 end\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function create()\r\n"
"\r\n"
"local it={}\r\n"
"\r\n"
"	it.history={}\r\n"
"	it.history_idx=0\r\n"
"	it.history_max=64\r\n"
"	it.line=\"\"\r\n"
"	it.line_idx=0\r\n"
"\r\n"
"	it.throb=255\r\n"
"	\r\n"
"	it.keypress=keypress\r\n"
"	it.update=update\r\n"
"\r\n"
"	return it\r\n"
"end\r\n"
"",

"wetgenes.www.ngx.img","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"local fetch=require(\"wetgenes.www.any.fetch\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"local grd=require(\"wetgenes.grd\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.img\"]=_M\n"
"\n"
"\n"
"\n"
"\n"
"function get(data,fmt)\n"
"--	log(\"img.get:\")\n"
"	\n"
"\n"
"	local gfmt=grd.HINT_PNG\n"
"	if fmt==\"jpeg\" then gfmt=grd.HINT_JPG end\n"
"	\n"
"	local g=grd.create()\n"
"	g:load_data(data,gfmt)\n"
"\n"
"	return g\n"
"end\n"
"\n"
"function resize(g,x,y)\n"
"--	log(\"img.resize:\")\n"
"\n"
"	if g.width==0 or g.height==0 then return nil end\n"
"\n"
"	g:convert(grd.FMT_U8_ARGB) -- need this format\n"
"\n"
"	if ( x * g.height/g.width ) <= y then -- aspect fits at maximum width\n"
"\n"
"		g:scale( x , x * g.height/g.width , 1 )\n"
"	\n"
"	else\n"
"\n"
"		g:scale( y * g.width/g.height , y , 1 )\n"
"	\n"
"	end\n"
"\n"
"	return g\n"
"end\n"
"\n"
"function composite(t)\n"
"--	log(\"img.composite:\")\n"
"\n"
"	local go=grd.create(grd.FMT_U8_ARGB,t.width,t.height,1)\n"
"	\n"
"	for i,v in ipairs(t) do\n"
"		v[1]:convert(grd.FMT_U8_ARGB)\n"
"		go:blit(v[1],v[2],v[3])\n"
"	end\n"
"	\n"
"	return go\n"
"end\n"
"\n"
"\n"
"function memsave(g,fmt)\n"
"\n"
"	local gfmt=grd.HINT_PNG\n"
"	if fmt then fmt=fmt:lower() end\n"
"	if fmt==\"jpeg\" then gfmt=grd.HINT_JPG end\n"
"\n"
"	local function file_read(filename)\n"
"		local fp=assert(io.open(filename,\"rb\"))\n"
"		local d=assert(fp:read(\"*a\"))\n"
"		fp:close()\n"
"		return d\n"
"	end\n"
"	\n"
"	local filename=os.tmpname()\n"
"	\n"
"	g:save(filename,gfmt)\n"
"	\n"
"	g.body=file_read(filename)\n"
"	g.format=fmt\n"
"	\n"
"	os.remove(filename)\n"
"	\n"
"	return g\n"
"end\n"
"",

"wetgenes.gamecake.spew.about.sinescroll","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local pack=require(\"wetgenes.pack\")\n"
"local wwin=require(\"wetgenes.win\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"local tardis=require(\"wetgenes.tardis\")	-- matrix/vector math\n"
"\n"
"local tcore=require(\"wetgenes.tardis.core\")\n"
"\n"
"-- This curve used here is the curvy part of splines.\n"
"-- input 0 to 1 and output 0 to 1 smoothing into and from the 0 and 1  (like a sinwave going from -1 to +1)\n"
"local function spine(a)\n"
"	local aa=a*a\n"
"	return ((aa+(aa*2))-((aa*a)*2))\n"
"end\n"
"-- input 0 to 1 and output 0 to 1 to 0 so it loops smoothly\n"
"local function spine2(a)\n"
"	a=a*2\n"
"	if a>1 then a=2-a end\n"
"	local aa=a*a\n"
"	return ((aa+(aa*2))-((aa*a)*2))\n"
"end\n"
"\n"
"\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"function M.bake(oven,about)\n"
"	about=about or {}\n"
"\n"
"	local gl=oven.gl\n"
"	local cake=oven.cake\n"
"	\n"
"	local sounds=cake.sounds\n"
"	local canvas=cake.canvas\n"
"	local fbs=cake.framebuffers\n"
"	\n"
"	local flat=canvas.flat\n"
"	local font=canvas.font\n"
"	\n"
"	local wetiso=oven.rebake(\"wetgenes.gamecake.spew.geom_wetiso\")\n"
"	local geom=oven.rebake(\"wetgenes.gamecake.spew.geom\")\n"
"\n"
"\n"
"	local opts={\n"
"		width=640,\n"
"		height=480,\n"
"	}\n"
"	\n"
"	about.title=\"WetGenes presents GameCake\"\n"
"	about.text=[[\n"
"*SKIP*\n"
"\n"
"	Welcome to the world of tomorrow!!!\n"
"	\n"
"	Nice to have you visit.\n"
"\n"
"*SKIP*\n"
"Cracked by unknownKLOWN!!!\n"
"*SKIP*\n"
"Supplied by dIvhEdbUy0!!!\n"
"*SKIP*\n"
"Greetz to No1 and No6!\n"
"*SKIP*\n"
"\n"
"]]\n"
"	\n"
"	about.layout=cake.layouts.create{}\n"
"	\n"
"	about.shaders=function()\n"
"		gl.progsrc(\"about_sinescroll\",\n"
"		[[{shaderprefix}\n"
"\n"
"		uniform mat4 modelview;\n"
"		uniform mat4 projection;\n"
"		uniform vec4 color;\n"
"\n"
"		attribute vec3 a_vertex;\n"
"		attribute vec2 a_texcoord;\n"
"\n"
"		varying vec4  v_color;\n"
"		varying vec3  v_pos;\n"
"		varying vec2  v_texcoord;\n"
"		 \n"
"		void main()\n"
"		{\n"
"			gl_Position = projection * modelview * vec4(a_vertex, 1.0);\n"
"			v_color=color;\n"
"			v_texcoord=a_texcoord;\n"
"		}\n"
"\n"
"		]],[[{shaderprefix}\n"
"\n"
"		uniform vec4 vars;\n"
"\n"
"		uniform sampler2D tex;\n"
"\n"
"		varying vec4  v_color;\n"
"		varying vec3  v_pos;\n"
"		varying vec2  v_texcoord;\n"
"\n"
"		void main(void)\n"
"		{\n"
"			float n=v_texcoord.x + vars[0]*3.0;\n"
"			vec2  t=v_texcoord * vec2(1.0,480.0/128.0) ;\n"
"			t.y+=(-140.0/128.0) + sin(n*16.0)*128.0/480.0;\n"
"			\n"
"			vec4 c=vec4( sin(t.y*2.0),sin(t.y*3.0),sin(t.y*4.0),1.0);\n"
"			gl_FragColor=texture2D(tex, t) * c;\n"
"		}\n"
"\n"
"		]])\n"
"	end\n"
"	\n"
"	about.setup=function()\n"
"\n"
"		if oven.last and oven.last~=about then about.exit=oven.last end -- remeber where we came from\n"
"\n"
"\n"
"		wetiso.setup()\n"
"	\n"
"		about.words=wstr.split_words(about.text)\n"
"		about.words_idx=1 -- the next word to get\n"
"		about.scroll={dx=0}\n"
"\n"
"		about.shaders()\n"
"		about.co=coroutine.create(about.thunk)\n"
"		\n"
"		if about.playtune then\n"
"			about.playtune()\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	about.clean=function()\n"
"		if about.fbo then\n"
"			about.fbo:clean()\n"
"			about.fbo=nil\n"
"		end\n"
"	end\n"
"	\n"
"	about.update=function()\n"
"		assert(coroutine.resume(about.co))\n"
"	end\n"
"	\n"
"	about.predraw=function()\n"
"\n"
"	end\n"
"\n"
"	about.draw=function()\n"
"\n"
"		about.layout.apply(opts.width,opts.height,1/4,opts.width*4,\"clip\")\n"
"\n"
"		canvas.gl_default() -- reset gl state\n"
"\n"
"		gl.ClearColor(gl.C4(0x0000))\n"
"		gl.Clear(gl.COLOR_BUFFER_BIT)--+gl.DEPTH_BUFFER_BIT)\n"
"\n"
"		gl.PushMatrix()\n"
"\n"
"		if about.thunkdraw then about.thunkdraw() end\n"
"		\n"
"		gl.PopMatrix()\n"
"\n"
"	end\n"
"\n"
"-- use an fbo for the scroll text so we can jiggle it in a shader	\n"
"	about.draw_fbo=function(f)\n"
"\n"
"		if not about.fbo then about.fbo=fbs.create() end\n"
"\n"
"		gl.MatrixMode(gl.PROJECTION)\n"
"		gl.PushMatrix()\n"
"		gl.MatrixMode(gl.MODELVIEW)\n"
"		gl.PushMatrix()\n"
"		\n"
"		local fsx=1024\n"
"		local fsy=128\n"
"\n"
"		about.fbo:resize(fsx,fsy,1)\n"
"		fbs.bind_frame(about.fbo)\n"
"		local old_layout=cake.layouts.create{parent={w=fsx,h=fsy,x=0,y=0}}.apply(fsx,fsy,1/4,fsx*8)\n"
"		\n"
"		gl.ClearColor(gl.C4(0x0000))\n"
"		gl.Clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT)\n"
"\n"
"		\n"
"		-- draw stuff\n"
"		if f then f() end\n"
"		\n"
"		fbs.bind_frame(nil) -- remove fbs binding, should pop a stack?\n"
"		\n"
"		gl.MatrixMode(gl.PROJECTION)\n"
"		gl.PopMatrix()\n"
"		gl.MatrixMode(gl.MODELVIEW)\n"
"		gl.PopMatrix()\n"
"		\n"
"		old_layout.restore()\n"
"		\n"
"	end\n"
"\n"
"\n"
"	about.thunk=function()\n"
"		local tim=0\n"
"	\n"
"		local next_word=function()\n"
"			local s=about.words[ about.words_idx]\n"
"			about.words_idx=about.words_idx+1\n"
"			if about.words_idx > #about.words then about.words_idx=1 end				\n"
"			return s\n"
"		end\n"
"		local fill_words=function()\n"
"			local scr=about.scroll\n"
"\n"
"			font.set(cake.fonts.get(\"Vera\")) -- need to calculate widths\n"
"			font.set_size(64,0)\n"
"			\n"
"			local dx=scr.dx\n"
"			for i,v in ipairs(scr) do\n"
"				dx=dx+v.w\n"
"			end\n"
"			while dx<640+128 do\n"
"				local s=next_word()\n"
"				local w=font.width(s)\n"
"				w=w+24\n"
"				if s==\"*SKIP*\" then\n"
"					s=\"\"\n"
"					w=640\n"
"				end\n"
"				scr[#scr+1]={s=s,w=w}\n"
"				dx=dx+w\n"
"			end\n"
"		end\n"
"		local remove_words=function()\n"
"			local scr=about.scroll\n"
"			while scr[1] and scr.dx + scr[1].w < -128 do\n"
"				scr.dx=scr.dx+scr[1].w\n"
"				table.remove(scr,1)\n"
"			end\n"
"		end\n"
"		local update_scroll=function()\n"
"			local scr=about.scroll\n"
"\n"
"			scr.dx=scr.dx-4			\n"
"\n"
"			fill_words()\n"
"			remove_words()\n"
"\n"
"\n"
"		end\n"
"		local draw_scroll=function()\n"
"			local scr=about.scroll\n"
"\n"
"			about.draw_fbo(function()\n"
"			\n"
"				font.set(cake.fonts.get(\"Vera\")) -- default font\n"
"				font.set_size(64,0)\n"
"\n"
"				gl.Color(spine2((tim%128)/128),spine2((tim%96)/96),spine2((tim%64)/64)+0.5,1)\n"
"\n"
"				local dx=scr.dx\n"
"				for i,v in ipairs(scr) do\n"
"					font.set_xy(dx,0)\n"
"					font.draw(v.s)\n"
"					dx=dx+v.w\n"
"				end\n"
"				\n"
"			end)\n"
"\n"
"			gl.BindTexture(gl.TEXTURE_2D, about.fbo.texture)\n"
"			gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR)\n"
"			gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR)\n"
"			gl.Color(gl.C4(0xffff))\n"
"			\n"
"			local p=gl.program(\"about_sinescroll\")\n"
"			gl.UseProgram( p[0] )\n"
"			p:uniform_v4(\"vars\", { ((tim%1024)/1024)*math.pi ,0,0,0 } )\n"
"\n"
"			flat.tristrip(\"xyzuv\",{\n"
"				0,		0,			0,		0,				1,\n"
"				640,	0,			0,		640/1024,		1,\n"
"				0,		480,		0,		0,				0,\n"
"				640,	480,		0,		640/1024,		0,\n"
"			},\"about_sinescroll\")\n"
"\n"
"\n"
"		end\n"
"\n"
"		local draw_title=function()\n"
"			local s=about.title\n"
"\n"
"			font.set(cake.fonts.get(\"Vera\")) -- default font\n"
"			font.set_size(160,0)\n"
"			local w=font.width(s)\n"
"			gl.Color(spine2((tim%64)/64)+0.5,spine2((tim%128)/128),spine2((tim%96)/96),1)\n"
"			font.set_xy((w-640)*-spine2((tim%128)/128),-40)\n"
"			font.draw(s)\n"
"\n"
"			font.set_xy((w-640)*-spine2(((tim+64)%128)/128),480-160)\n"
"			font.draw(s)\n"
"		end\n"
"\n"
"		local setup_bobs=function()\n"
"			about.bobs={}\n"
"			for i=1,32 do\n"
"				local v={}\n"
"				about.bobs[#about.bobs+1]=v\n"
"				\n"
"				v.px=math.random(0,1280)\n"
"				v.py=math.random(0,480)\n"
"				v.ss=math.random(8,64)\n"
"				v.t=math.random(0,16384)\n"
"			end\n"
"			table.sort(about.bobs,function(a,b)return a.ss<b.ss end)\n"
"		end\n"
"		\n"
"		local update_bobs=function()\n"
"		\n"
"			for i,v in ipairs(about.bobs) do\n"
"				v.px=v.px+v.ss*0.25\n"
"				if v.px>640+128 then v.px=v.px-1280 end\n"
"				v.t=v.t-(v.ss*4/64)\n"
"			end\n"
"		end\n"
"\n"
"		local draw_bobs=function()\n"
"			\n"
"			for i,v in ipairs(about.bobs) do\n"
"				gl.Color(0,0.25*v.ss/64,0.75*v.ss/64,1)\n"
"				gl.PushMatrix()\n"
"				gl.Translate(v.px,v.py,0)\n"
"				gl.Scale(v.ss,v.ss,v.ss)\n"
"				gl.Rotate(v.t,0,-1,0)\n"
"				gl.Rotate(v.t/8,1,0,0)\n"
"				gl.Enable(gl.CULL_FACE)\n"
"				wetiso.draw()\n"
"				gl.Disable(gl.CULL_FACE)\n"
"				gl.PopMatrix()\n"
"			end\n"
"				\n"
"		end\n"
"\n"
"		local update=function()\n"
"			tim=tim+1\n"
"			update_bobs()\n"
"			update_scroll()\n"
"			coroutine.yield()\n"
"		end\n"
"		\n"
"		local draw=function()\n"
"			draw_bobs()\n"
"			draw_title()\n"
"			draw_scroll()\n"
"\n"
"			local c=about.clear_color or {0,0,0,0}\n"
"			if c[4]>0 then\n"
"				gl.Color(c[1],c[2],c[3],c[4])\n"
"				flat.tristrip(\"xyz\",{\n"
"					0,		0,			0,\n"
"					640,	0,			0,\n"
"					0,		480,		0,\n"
"					640,	480,		0,\n"
"				})\n"
"			end\n"
"		end\n"
"		\n"
"		setup_bobs()\n"
"		about.thunkdraw=draw -- set what to draw\n"
"\n"
"		about.clear_color={1,1,1,1}\n"
"		coroutine.yield()\n"
"\n"
"		for i=254,0,-2 do\n"
"			local a=i/255 a=a*a\n"
"			about.clear_color={a,a,a,a}\n"
"			update()\n"
"		end\n"
"		about.clear_color={0,0,0,0}\n"
"\n"
"		while true do\n"
"			update()\n"
"		end\n"
"		\n"
"		while true do coroutine.yield() end\n"
"	end\n"
"\n"
"	function about.msg(m)\n"
"	\n"
"		if m.class==\"key\" or m.class==\"mouse\" or m.class==\"joykey\" then\n"
"			if m.action==-1 then\n"
"				if about.exitname then\n"
"					oven.next=oven.rebake(about.exitname)\n"
"				else\n"
"					if about.exit then oven.next=about.exit end\n"
"				end\n"
"			end\n"
"		end\n"
"\n"
"	end\n"
"\n"
"	return about\n"
"end\n"
"",

"wetgenes.www.any.mail","if ngx then\r	return require(\"wetgenes.www.ngx.mail\")\relse\r	return require(\"wetgenes.www.gae.mail\")\rend\r\r",

"wetgenes.gamecake.framebuffers","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local grd=require(\"wetgenes.grd\")\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"function M.bake(oven,framebuffers)\n"
"		\n"
"	local gl=oven.gl\n"
"	local cake=oven.cake\n"
"	\n"
"	local funcs={}\n"
"	local metatable={__index=funcs}\n"
"	\n"
"	framebuffers.data={}\n"
"\n"
"	framebuffers.create = function(w,h,d)\n"
"\n"
"		local fbo={w=0,h=0,d=0}\n"
"		\n"
"		framebuffers.resize(fbo,w or 0,h or 0,d or 0)\n"
"				\n"
"		framebuffers.data[fbo]=fbo\n"
"		\n"
"		setmetatable(fbo,metatable)\n"
"		\n"
"		return fbo\n"
"	end\n"
"\n"
"\n"
"	framebuffers.start = function()\n"
"		for v,n in pairs(framebuffers.data) do\n"
"--			framebuffers.resize(v,v.w,v.h,v.d) -- realloc\n"
"		end\n"
"	end\n"
"\n"
"	framebuffers.stop = function()\n"
"		for v,n in pairs(framebuffers.data) do\n"
"			framebuffers.clean(v)\n"
"		end\n"
"\n"
"	end\n"
"\n"
"	framebuffers.free_depth = function(fbo)\n"
"		if fbo.depth then\n"
"			gl.DeleteRenderbuffer(fbo.depth)\n"
"			fbo.depth=nil\n"
"		end\n"
"	end\n"
"\n"
"	framebuffers.free_texture = function(fbo)\n"
"		if fbo.texture then\n"
"			gl.DeleteTexture(fbo.texture)\n"
"			fbo.texture=nil\n"
"		end\n"
"	end\n"
"\n"
"	framebuffers.free_frame = function(fbo)\n"
"		if fbo.frame then\n"
"			gl.DeleteFramebuffer(fbo.frame)\n"
"			fbo.frame=nil\n"
"		end\n"
"	end\n"
"\n"
"	framebuffers.clean = function(fbo)\n"
"		framebuffers.free_depth(fbo)\n"
"		framebuffers.free_texture(fbo)\n"
"		framebuffers.free_frame(fbo)\n"
"	end\n"
"\n"
"	framebuffers.bind_texture = function(fbo)\n"
"		if fbo then\n"
"			gl.BindTexture(gl.TEXTURE_2D, fbo.texture or 0)\n"
"		else\n"
"			gl.BindTexture(gl.TEXTURE_2D, 0)\n"
"		end\n"
"	end\n"
"	\n"
"	framebuffers.bind_frame = function(fbo)\n"
"		if fbo then\n"
"			gl.BindFramebuffer(gl.FRAMEBUFFER, fbo.frame or 0)\n"
"		else\n"
"			gl.BindFramebuffer(gl.FRAMEBUFFER,0)\n"
"		end\n"
"	end\n"
"	\n"
"	framebuffers.check = function(fbo)\n"
"		framebuffers.resize(fbo,fbo.w,fbo.h,fbo.d) -- realloc if we need to\n"
"	end\n"
"	\n"
"	framebuffers.resize = function(fbo,w,h,d)\n"
"\n"
"		if w==0 then h=0 d=0 end\n"
"		if h==0 then d=0 w=0 end\n"
"	\n"
"		if w==0 or h==0 or w~=fbo.w or h~=fbo.h or d~=fbo.d then -- size 0 or any change means free everything\n"
"			framebuffers.clean(fbo)\n"
"		end\n"
"		\n"
"		if w~=0 and h~=0 then \n"
"			if d~=0 then\n"
"				if not fbo.depth then\n"
"					fbo.depth=gl.GenRenderbuffer()\n"
"					gl.BindRenderbuffer(gl.RENDERBUFFER, fbo.depth)\n"
"					gl.RenderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h)\n"
"				end\n"
"			end\n"
"			if not fbo.texture then\n"
"				fbo.texture=gl.GenTexture()\n"
"				gl.BindTexture(gl.TEXTURE_2D, fbo.texture)\n"
"				gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,fbo.TEXTURE_MIN_FILTER or framebuffers.TEXTURE_MIN_FILTER or gl.LINEAR_MIPMAP_LINEAR)\n"
"				gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,fbo.TEXTURE_MAG_FILTER or framebuffers.TEXTURE_MAG_FILTER or gl.LINEAR)\n"
"				gl.TexParameter(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)\n"
"				gl.TexParameter(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)\n"
"				gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, 0)\n"
"				gl.GenerateMipmap(gl.TEXTURE_2D)\n"
"				gl.BindTexture(gl.TEXTURE_2D, 0)\n"
"			end\n"
"			if not fbo.frame then\n"
"				fbo.frame=gl.GenFramebuffer()\n"
"				gl.BindFramebuffer(gl.FRAMEBUFFER, fbo.frame)\n"
"\n"
"				if fbo.depth then -- optional depth\n"
"					gl.FramebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, fbo.depth)\n"
"				end\n"
"				gl.FramebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fbo.texture, 0)\n"
"\n"
"				assert( gl.CheckFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE)\n"
"				\n"
"				gl.BindFramebuffer(gl.FRAMEBUFFER, 0)\n"
"			end\n"
"		end\n"
"		\n"
"		fbo.w=w\n"
"		fbo.h=h\n"
"		fbo.d=d\n"
"		\n"
"	end\n"
"	\n"
"	framebuffers.mipmap = function(fbo)\n"
"		if fbo.texture then\n"
"			gl.BindTexture(gl.TEXTURE_2D, fbo.texture)\n"
"			gl.GenerateMipmap(gl.TEXTURE_2D)	\n"
"		end\n"
"	end\n"
"\n"
"-- read back data from a framebuffer, return it in a grd object\n"
"	framebuffers.download = function(fbo,w,h,x,y)\n"
"	\n"
"		w=w or fbo.w\n"
"		h=h or fbo.h\n"
"		x=x or 0\n"
"		y=y or 0\n"
"\n"
"		local g=assert(grd.create(grd.FMT_U8_RGBA_PREMULT,w,h,1))\n"
"\n"
"		framebuffers.bind_frame(fbo)\n"
"		\n"
"		gl.ReadPixels(\n"
"			x,\n"
"			y,\n"
"			w,\n"
"			h,\n"
"			gl.RGBA,\n"
"			gl.UNSIGNED_BYTE,\n"
"			g.data )\n"
"			\n"
"		g:flipy() -- opengl data comes in upside down\n"
"		\n"
"		gl.BindFramebuffer(gl.FRAMEBUFFER, 0)\n"
"		\n"
"		return g\n"
"	end\n"
"\n"
"\n"
"-- set some functions into the metatable of each fbo\n"
"	for i,n in ipairs({\n"
"		\"clean\",\n"
"		\"check\",\n"
"		\"bind_frame\",\n"
"		\"bind_texture\",\n"
"		\"resize\",\n"
"		\"download\",\n"
"		\"mipmap\",\n"
"		\"free_depth\",\n"
"		\"free_texture\",\n"
"		\"free_frame\",\n"
"		}) do\n"
"		funcs[n]=framebuffers[n]\n"
"	end\n"
"\n"
"	return framebuffers\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"",

"wetgenes.win.nacl","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local nacl={}\n"
"\n"
"local core=require(\"wetgenes.win.nacl.core\")\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"\n"
"local import=[[\n"
"\n"
"#define VK_LBUTTON	1\n"
"#define VK_RBUTTON	2\n"
"#define VK_CANCEL	3\n"
"#define VK_MBUTTON	4\n"
"#if (_WIN32_WINNT >= 0x0500)\n"
"#define VK_XBUTTON1	5\n"
"#define VK_XBUTTON2	6\n"
"#endif\n"
"#define VK_BACK	8\n"
"#define VK_TAB	9\n"
"#define VK_CLEAR	12\n"
"#define VK_RETURN	13\n"
"#define VK_SHIFT	16\n"
"#define VK_CONTROL	17\n"
"#define VK_MENU	18\n"
"#define VK_PAUSE	19\n"
"#define VK_CAPITAL	20\n"
"#define VK_KANA	0x15\n"
"#define VK_HANGEUL	0x15\n"
"#define VK_HANGUL	0x15\n"
"#define VK_JUNJA	0x17\n"
"#define VK_FINAL	0x18\n"
"#define VK_HANJA	0x19\n"
"#define VK_KANJI	0x19\n"
"#define VK_ESCAPE	0x1B\n"
"#define VK_CONVERT	0x1C\n"
"#define VK_NONCONVERT	0x1D\n"
"#define VK_ACCEPT	0x1E\n"
"#define VK_MODECHANGE	0x1F\n"
"#define VK_SPACE	32\n"
"#define VK_PRIOR	33\n"
"#define VK_NEXT	34\n"
"#define VK_END	35\n"
"#define VK_HOME	36\n"
"#define VK_LEFT	37\n"
"#define VK_UP	38\n"
"#define VK_RIGHT	39\n"
"#define VK_DOWN	40\n"
"#define VK_SELECT	41\n"
"#define VK_PRINT	42\n"
"#define VK_EXECUTE	43\n"
"#define VK_SNAPSHOT	44\n"
"#define VK_INSERT	45\n"
"#define VK_DELETE	46\n"
"#define VK_HELP	47\n"
"#define VK_LWIN	0x5B\n"
"#define VK_RWIN	0x5C\n"
"#define VK_APPS	0x5D\n"
"#define VK_SLEEP	0x5F\n"
"#define VK_NUMPAD0	0x60\n"
"#define VK_NUMPAD1	0x61\n"
"#define VK_NUMPAD2	0x62\n"
"#define VK_NUMPAD3	0x63\n"
"#define VK_NUMPAD4	0x64\n"
"#define VK_NUMPAD5	0x65\n"
"#define VK_NUMPAD6	0x66\n"
"#define VK_NUMPAD7	0x67\n"
"#define VK_NUMPAD8	0x68\n"
"#define VK_NUMPAD9	0x69\n"
"#define VK_MULTIPLY	0x6A\n"
"#define VK_ADD	0x6B\n"
"#define VK_SEPARATOR	0x6C\n"
"#define VK_SUBTRACT	0x6D\n"
"#define VK_DECIMAL	0x6E\n"
"#define VK_DIVIDE	0x6F\n"
"#define VK_F1	0x70\n"
"#define VK_F2	0x71\n"
"#define VK_F3	0x72\n"
"#define VK_F4	0x73\n"
"#define VK_F5	0x74\n"
"#define VK_F6	0x75\n"
"#define VK_F7	0x76\n"
"#define VK_F8	0x77\n"
"#define VK_F9	0x78\n"
"#define VK_F10	0x79\n"
"#define VK_F11	0x7A\n"
"#define VK_F12	0x7B\n"
"#define VK_F13	0x7C\n"
"#define VK_F14	0x7D\n"
"#define VK_F15	0x7E\n"
"#define VK_F16	0x7F\n"
"#define VK_F17	0x80\n"
"#define VK_F18	0x81\n"
"#define VK_F19	0x82\n"
"#define VK_F20	0x83\n"
"#define VK_F21	0x84\n"
"#define VK_F22	0x85\n"
"#define VK_F23	0x86\n"
"#define VK_F24	0x87\n"
"#define VK_NUMLOCK	0x90\n"
"#define VK_SCROLL	0x91\n"
"#define VK_LSHIFT	0xA0\n"
"#define VK_RSHIFT	0xA1\n"
"#define VK_LCONTROL	0xA2\n"
"#define VK_RCONTROL	0xA3\n"
"#define VK_LMENU	0xA4\n"
"#define VK_RMENU	0xA5\n"
"#if (_WIN32_WINNT >= 0x0500)\n"
"#define VK_BROWSER_BACK	0xA6\n"
"#define VK_BROWSER_FORWARD	0xA7\n"
"#define VK_BROWSER_REFRESH	0xA8\n"
"#define VK_BROWSER_STOP	0xA9\n"
"#define VK_BROWSER_SEARCH	0xAA\n"
"#define VK_BROWSER_FAVORITES	0xAB\n"
"#define VK_BROWSER_HOME	0xAC\n"
"#define VK_VOLUME_MUTE	0xAD\n"
"#define VK_VOLUME_DOWN	0xAE\n"
"#define VK_VOLUME_UP	0xAF\n"
"#define VK_MEDIA_NEXT_TRACK	0xB0\n"
"#define VK_MEDIA_PREV_TRACK	0xB1\n"
"#define VK_MEDIA_STOP	0xB2\n"
"#define VK_MEDIA_PLAY_PAUSE	0xB3\n"
"#define VK_LAUNCH_MAIL	0xB4\n"
"#define VK_LAUNCH_MEDIA_SELECT	0xB5\n"
"#define VK_LAUNCH_APP1	0xB6\n"
"#define VK_LAUNCH_APP2	0xB7\n"
"#endif\n"
"#define VK_OEM_1	0xBA\n"
"#if (_WIN32_WINNT >= 0x0500)\n"
"#define VK_OEM_PLUS	0xBB\n"
"#define VK_OEM_COMMA	0xBC\n"
"#define VK_OEM_MINUS	0xBD\n"
"#define VK_OEM_PERIOD	0xBE\n"
"#endif\n"
"#define VK_OEM_2	0xBF\n"
"#define VK_OEM_3	0xC0\n"
"#define VK_OEM_4	0xDB\n"
"#define VK_OEM_5	0xDC\n"
"#define VK_OEM_6	0xDD\n"
"#define VK_OEM_7	0xDE\n"
"#define VK_OEM_8	0xDF\n"
"#if (_WIN32_WINNT >= 0x0500)\n"
"#define VK_OEM_102	0xE2\n"
"#endif\n"
"#define VK_PROCESSKEY	0xE5\n"
"#if (_WIN32_WINNT >= 0x0500)\n"
"#define VK_PACKET	0xE7\n"
"#endif\n"
"#define VK_ATTN	0xF6\n"
"#define VK_CRSEL	0xF7\n"
"#define VK_EXSEL	0xF8\n"
"#define VK_EREOF	0xF9\n"
"#define VK_PLAY	0xFA\n"
"#define VK_ZOOM	0xFB\n"
"#define VK_NONAME	0xFC\n"
"#define VK_PA1	0xFD\n"
"#define VK_OEM_CLEAR	0xFE\n"
"\n"
"#define VK_0 0x30\n"
"#define VK_1 0x31\n"
"#define VK_2 0x32\n"
"#define VK_3 0x33\n"
"#define VK_4 0x34\n"
"#define VK_5 0x35\n"
"#define VK_6 0x36\n"
"#define VK_7 0x37\n"
"#define VK_8 0x38\n"
"#define VK_9 0x39\n"
"\n"
"#define VK_A 0x41\n"
"#define VK_B 0x42\n"
"#define VK_C 0x43\n"
"#define VK_D 0x44\n"
"#define VK_E 0x45\n"
"#define VK_F 0x46\n"
"#define VK_G 0x47\n"
"#define VK_H 0x48\n"
"#define VK_I 0x49\n"
"#define VK_J 0x4A\n"
"#define VK_K 0x4B\n"
"#define VK_L 0x4C\n"
"#define VK_M 0x4D\n"
"#define VK_N 0x4E\n"
"#define VK_O 0x4F\n"
"#define VK_P 0x50\n"
"#define VK_Q 0x51\n"
"#define VK_R 0x52\n"
"#define VK_S 0x53\n"
"#define VK_T 0x54\n"
"#define VK_U 0x55\n"
"#define VK_V 0x56\n"
"#define VK_W 0x57\n"
"#define VK_X 0x58\n"
"#define VK_Y 0x59\n"
"#define VK_Z 0x5A\n"
"\n"
"]]\n"
"\n"
"vkeys={}\n"
"\n"
"for l in import:gmatch(\"([^\\n"
"]*)\") do\n"
"	local define,value\n"
"	local state=\"start\"\n"
"	for w in l:gmatch(\"([^%s]+)\") do\n"
"		if state==\"start\" then\n"
"			if w==\"#define\" then\n"
"				state=\"define\"\n"
"			else\n"
"				break\n"
"			end\n"
"		elseif state==\"define\" then\n"
"			define=w\n"
"			state=\"value\"\n"
"		elseif state==\"value\" then\n"
"			value=w\n"
"				if define:sub(1,3)==\"VK_\" then -- sanity check\n"
"					define=define:sub(4)\n"
"					\n"
"					if value:sub(1,3)==\"VK_\" then -- allow lookback\n"
"						value=vkeys[value:sub(4)]\n"
"					end\n"
"					\n"
"					vkeys[define]=tonumber(value)\n"
"				end\n"
"			break\n"
"		else\n"
"			break\n"
"		end\n"
"	end\n"
"end\n"
"nkeys={}\n"
"for v,n in pairs(vkeys) do\n"
"	nkeys[n]=v\n"
"end\n"
"\n"
"import=nil -- free it just because\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"--\n"
"-- simple debug print function, we wrap the core so it accepts multiple \n"
"-- args and behaves like luas print\n"
"--\n"
"nacl.print=function(...)\n"
"	local t={}\n"
"	for i,v in ipairs{...} do\n"
"		t[#t+1]=tostring(v)\n"
"	end\n"
"	core.print(table.concat(t,\"\\t\"))\n"
"end\n"
"local print=nacl.print\n"
"\n"
"\n"
"nacl.swap_pending=false\n"
"function nacl.swap()\n"
"	nacl.swap_pending=true\n"
"--print(\"swap start\",nacl.time())\n"
"	core.swap(function()\n"
"--print(\"swap stop\",nacl.time())\n"
"		nacl.swap_pending=false\n"
"	end)\n"
"end\n"
"	\n"
"nacl.context=core.context\n"
"nacl.time=core.time\n"
"\n"
"nacl.call=core.call\n"
"nacl.getURL=core.getURL\n"
"\n"
"nacl.info=core.info\n"
"\n"
"nacl.queue={}\n"
"\n"
"local lastm\n"
"nacl.input_event=function(...)\n"
"--	print(\"NACL\",...)\n"
"	local a={...}\n"
"	local m\n"
"	\n"
"	if a[1]==\"mouse\" then\n"
"	\n"
"		local act=0\n"
"		if a[2]==0 then act=1 end -- down\n"
"		if a[2]==1 then act=-1 end --up\n"
"		\n"
"		local k=0\n"
"		if a[3]==0 then k=1 end -- left\n"
"\n"
"		m={\n"
"			time=nacl.time(),\n"
"			action=act,\n"
"			class=\"mouse\",\n"
"			keycode=k,--ma.pointers[1].id,\n"
"			x=a[4],\n"
"			y=a[5],\n"
"		}\n"
"		\n"
"	elseif a[1]==\"key\" then\n"
"	\n"
"		if a[2]==7 then -- down\n"
"			m={\n"
"				time=nacl.time(),\n"
"				class=\"key\",\n"
"				action=1,\n"
"				ascii=\"\",\n"
"				keycode=a[3],\n"
"				keyname= nkeys[ a[3] ] or string.format(\"nacl_%02x\",a[3]),			\n"
"			}\n"
"			lastm=m\n"
"		elseif a[2]==8 then -- up\n"
"			m={\n"
"				time=nacl.time(),\n"
"				class=\"key\",\n"
"				action=-1,\n"
"				ascii=\"\",\n"
"				keycode=a[3],\n"
"				keyname= nkeys[ a[3] ] or string.format(\"nacl_%02x\",a[3]),			\n"
"			}\n"
"			\n"
"			if lastm then m.ascii=lastm.ascii end -- hax\n"
"			\n"
"		elseif a[2]==9 then -- ascii\n"
"		\n"
"			if lastm then lastm.ascii=a[4] end -- hax\n"
"			\n"
"		end\n"
"	\n"
"	end\n"
"	\n"
"	if m then\n"
"		table.insert(nacl.queue,m)\n"
"	end\n"
"end\n"
"\n"
"nacl.msg=function()\n"
"	if nacl.queue[1] then\n"
"		return table.remove(nacl.queue,1)\n"
"	end\n"
"end\n"
"\n"
"\n"
"--\n"
"-- export all core functions not wrapped above\n"
"--\n"
"for n,v in pairs(core) do -- check the core\n"
"	if type(v)==\"function\" then -- only functions\n"
"		if not nacl[n] then -- only if not prewrapped\n"
"			nacl[n]=v\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"\n"
"return nacl\n"
"",

"socket.tp","-----------------------------------------------------------------------------\n"
"-- Unified SMTP/FTP subsystem\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: tp.lua,v 1.22 2006/03/14 09:04:15 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local string = require(\"string\")\n"
"local socket = require(\"socket\")\n"
"local ltn12 = require(\"ltn12\")\n"
"module(\"socket.tp\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Program constants\n"
"-----------------------------------------------------------------------------\n"
"TIMEOUT = 60\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Implementation\n"
"-----------------------------------------------------------------------------\n"
"-- gets server reply (works for SMTP and FTP)\n"
"local function get_reply(c)\n"
"    local code, current, sep\n"
"    local line, err = c:receive()\n"
"    local reply = line\n"
"    if err then return nil, err end\n"
"    code, sep = socket.skip(2, string.find(line, \"^(%d%d%d)(.?)\"))\n"
"    if not code then return nil, \"invalid server reply\" end\n"
"    if sep == \"-\" then -- reply is multiline\n"
"        repeat\n"
"            line, err = c:receive()\n"
"            if err then return nil, err end\n"
"            current, sep = socket.skip(2, string.find(line, \"^(%d%d%d)(.?)\"))\n"
"            reply = reply .. \"\\n"
"\" .. line\n"
"        -- reply ends with same code\n"
"        until code == current and sep == \" \"\n"
"    end\n"
"    return code, reply\n"
"end\n"
"\n"
"-- metatable for sock object\n"
"local metat = { __index = {} }\n"
"\n"
"function metat.__index:check(ok)\n"
"    local code, reply = get_reply(self.c)\n"
"    if not code then return nil, reply end\n"
"    if base.type(ok) ~= \"function\" then\n"
"        if base.type(ok) == \"table\" then\n"
"            for i, v in base.ipairs(ok) do\n"
"                if string.find(code, v) then\n"
"                    return base.tonumber(code), reply\n"
"                end\n"
"            end\n"
"            return nil, reply\n"
"        else\n"
"            if string.find(code, ok) then return base.tonumber(code), reply\n"
"            else return nil, reply end\n"
"        end\n"
"    else return ok(base.tonumber(code), reply) end\n"
"end\n"
"\n"
"function metat.__index:command(cmd, arg)\n"
"    if arg then\n"
"        return self.c:send(cmd .. \" \" .. arg.. \"\\r\\n"
"\")\n"
"    else\n"
"        return self.c:send(cmd .. \"\\r\\n"
"\")\n"
"    end\n"
"end\n"
"\n"
"function metat.__index:sink(snk, pat)\n"
"    local chunk, err = c:receive(pat)\n"
"    return snk(chunk, err)\n"
"end\n"
"\n"
"function metat.__index:send(data)\n"
"    return self.c:send(data)\n"
"end\n"
"\n"
"function metat.__index:receive(pat)\n"
"    return self.c:receive(pat)\n"
"end\n"
"\n"
"function metat.__index:getfd()\n"
"    return self.c:getfd()\n"
"end\n"
"\n"
"function metat.__index:dirty()\n"
"    return self.c:dirty()\n"
"end\n"
"\n"
"function metat.__index:getcontrol()\n"
"    return self.c\n"
"end\n"
"\n"
"function metat.__index:source(source, step)\n"
"    local sink = socket.sink(\"keep-open\", self.c)\n"
"    local ret, err = ltn12.pump.all(source, sink, step or ltn12.pump.step)\n"
"    return ret, err\n"
"end\n"
"\n"
"-- closes the underlying c\n"
"function metat.__index:close()\n"
"    self.c:close()\n"
"	return 1\n"
"end\n"
"\n"
"-- connect with server and return c object\n"
"function connect(host, port, timeout, create)\n"
"    local c, e = (create or socket.tcp)()\n"
"    if not c then return nil, e end\n"
"    c:settimeout(timeout or TIMEOUT)\n"
"    local r, e = c:connect(host, port)\n"
"    if not r then\n"
"        c:close()\n"
"        return nil, e\n"
"    end\n"
"    return base.setmetatable({c = c}, metat)\n"
"end\n"
"\n"
"",

"wetgenes.www.gae.cache","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local core=require(\"wetgenes.www.gae.cache.core\")\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.cache\"]=_M\n"
"\n"
"function countzero()\n"
"	count=0\n"
"	count_got=0\n"
"	api_time=0\n"
"\n"
"end\n"
"countzero()\n"
"\n"
"local start_time -- handle simple api benchmarking of some calls\n"
"local function apis()\n"
"	start_time=os.time()\n"
"end\n"
"local function apie(...)\n"
"	api_time=api_time+os.time()-start_time\n"
"	return ...\n"
"end\n"
"\n"
"\n"
"function clear(srv)\n"
"	apis()\n"
"	return apie(core.clear())\n"
"\n"
"end\n"
"\n"
"\n"
"function del(srv,id)\n"
"	if srv then srv.cache[id]=nil end\n"
"	apis()\n"
"	return apie(core.del(id))\n"
"\n"
"end\n"
"\n"
"function put(srv,id,tab,ttl)\n"
"	if srv then srv.cache[id]=tab end -- this local cache only lasts as long as a request\n"
"	apis()\n"
"--if( type(tab)~=\"string\" ) then log(type(tab)..\" \"..tostring(tab)) end -- it seems to be only safe to cache strings\n"
"	return apie(core.put(id,tab,ttl))\n"
"\n"
"end\n"
"\n"
"function get(srv,id)\n"
"	if srv and type(srv.cache[id])~=\"nil\" then return srv.cache[id] end -- very fast retry for multiple gets\n"
"	\n"
"	apis()\n"
"	count=count+1\n"
"\n"
"	local r=apie(core.get(id))\n"
"\n"
"	if type(r)~=\"nil\" then count_got=count_got+1 end -- a false is still a good result\n"
"\n"
"	return r\n"
"end\n"
"\n"
"function inc(srv,id,num,start)\n"
"	apis()\n"
"	local r=apie(core.inc(id,num,start))\n"
"	\n"
"	if srv then srv.cache[id]=r end -- so we can fast get it later in this request\n"
"\n"
"	return r\n"
"end\n"
"\n"
"",

"wetgenes.www.any.stash","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"local stashdata=require(\"wetgenes.www.any.stashdata\")\n"
"\n"
"\n"
"-- a stash is a simple long term cache, it lives in data entities and survives reboots\n"
"\n"
"module(...)\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- clear all stashed data, may fail...\n"
"-- everything in the stash should be recreatable\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function clear(srv,id)\n"
"\n"
"	return false --not gonna do this yet, appengine has issues anyhow\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- delete id from stash\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function del(srv,id)\n"
"	stashdata.del(srv,id)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- put id in stash\n"
"-- data is data to store (should be json encodable)\n"
"-- opts is a table of extra options\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function put(srv,id,data,opts)\n"
"	local e=stashdata.set(srv,id,function(srv,e)\n"
"		e.cache.data=data\n"
"		if opts then\n"
"			e.cache.base=opts.base\n"
"			e.cache.func=opts.func\n"
"		end\n"
"		return e\n"
"	end)\n"
"	if e then\n"
"		return e.cache.data, e\n"
"	end	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get id from stash\n"
"-- return data,entity\n"
"-- the entity can be used for extra validity checks of the date (IE last update  time)\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function get(srv,id)\n"
"	local e=stashdata.get(srv,id)\n"
"	if e then\n"
"		return e.cache.data, e\n"
"	end\n"
"end\n"
"",

"wetgenes.www.any.datadef","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"local json=require(\"wetgenes.json\")\n"
"\n"
"\n"
"module(\"wetgenes.www.any.datadef\")\n"
"\n"
"local wdata=require(\"wetgenes.www.any.data\")\n"
"local cache=require(\"wetgenes.www.any.cache\")\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- Create a new local entity filled with initial data\n"
"-- the id can be and often is nil\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_create(env,srv,id)\n"
"\n"
"	local ent={}\n"
"	\n"
"	ent.key={kind=env.kind(srv),id=id,notsaved=true} -- we will not know the key id until after we save\n"
"	ent.props={}\n"
"	\n"
"	local p=ent.props\n"
"	\n"
"	p.created=(srv and srv.time) or os.time()\n"
"	p.updated=(srv and srv.time) or p.created\n"
"	\n"
"	for i,v in pairs(env.default_props or {}) do\n"
"		p[i]=v\n"
"	end\n"
"\n"
"	wdata.build_cache(ent) -- this just copies the props across\n"
"	\n"
"-- these are json only vars\n"
"	local c=ent.cache\n"
"	\n"
"	for i,v in pairs(env.default_cache or {}) do\n"
"		c[i]=v\n"
"	end\n"
"\n"
"	return env.check(srv,ent)\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- Save to database\n"
"-- this calls check before putting and does not put if check says it is invalid\n"
"-- build_props is called so code should always be updating the cache values\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_put(env,srv,ent,tt)\n"
"	t=tt or wdata -- use transaction?\n"
"\n"
"	if not env.check(srv,ent) then return nil end -- check that this is valid to put\n"
"\n"
"	wdata.build_props(ent)\n"
"	local ks=t.put(ent)\n"
"	ent.key.notsaved=nil\n"
"	\n"
"	if ks then\n"
"		ent.key=wdata.keyinfo( ks ) -- update key with new id\n"
"		wdata.build_cache(ent)\n"
"		\n"
"		if not tt then env.cache_fix(srv,env.cache_what(srv,ent)) end -- destroy any cache if not in transaction\n"
"	end\n"
"\n"
"	return ks -- return the keystring which is an absolute name\n"
"end\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- Load from database, pass in id or entity\n"
"-- the props will be copied into the cache\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_get(env,srv,id,tt)\n"
"\n"
"	local ent=id\n"
"	\n"
"	if type(ent)~=\"table\" then -- get by id\n"
"		ent=env.create(srv)\n"
"		ent.key.id=id\n"
"	end\n"
"	\n"
"	local ck=env.cache_key(srv,ent.key.id)\n"
"	if not tt and ck then -- can try for cached value outside of transactions\n"
"		local ent=cache.get(srv,ck)\n"
"		if ent then return env.check(srv,--[[json.decode]](ent)) end -- Yay, we got a cached value\n"
"	end\n"
"	\n"
"	local t=tt or wdata -- use transaction?\n"
"	\n"
"	if not t.get(ent) then\n"
"		if not tt and ck then -- kill auto cache\n"
"			cache.del(srv,ck)\n"
"		end\n"
"		return nil\n"
"	end\n"
"	\n"
"	wdata.build_cache(ent)\n"
"	\n"
"	if not tt and ck then -- auto cache ent for one hour\n"
"		cache.put(srv,ck,--[[json.encode]](ent),60*60)\n"
"	end\n"
"	\n"
"	return env.check(srv,ent)\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- Load from database, pass in id or entity\n"
"-- the props will be copied into the cache\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_del(env,srv,id,tt)\n"
"\n"
"	local ent=id\n"
"	\n"
"	if type(ent)~=\"table\" then -- get by id\n"
"		ent=env.create(srv)\n"
"		ent.key.id=id\n"
"	end\n"
"	\n"
"	local t=tt or wdata -- use transaction?\n"
"	t.del(ent)\n"
"\n"
"	local ck=env.cache_key(srv,ent.key.id)\n"
"	cache.del(srv,ck)\n"
"		\n"
"end\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- get - update - put\n"
"--\n"
"-- f must be a function that changes the entity and returns true on success\n"
"-- id can be an id or an entity from which we will get the id\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_update(env,srv,id,f)\n"
"\n"
"	if type(id)==\"table\" then id=id.key.id end -- can turn an entity into an id\n"
"		\n"
"	for retry=1,10 do\n"
"		local mc={}\n"
"		local t=wdata.begin()\n"
"		local e=env.get(srv,id,t) -- must exist\n"
"		if e then\n"
"			env.cache_what(srv,e,mc) -- the original values\n"
"			if not e.key.notsaved then -- not a newly created entity\n"
"				if e.cache.updated>srv.time then -- stop any updates that time travel backwards\n"
"					t.rollback()\n"
"					log(\"DATA UPDATE FAILED TIMETRAVEL:\"..env.kind(srv)..\":\"..id)\n"
"					return false\n"
"				end\n"
"			end\n"
"			e.cache.updated=srv.time -- the function can change this change if it wishes\n"
"			if not f(srv,e) then -- hard fail\n"
"				t.rollback()\n"
"				log(\"DATA UPDATE FAILED FUNCTION:\"..env.kind(srv)..\":\"..id)\n"
"				return false\n"
"			end\n"
"			env.check(srv,e) -- keep consistant\n"
"			if env.put(srv,e,t) then -- entity put ok\n"
"				if t.commit() then -- success\n"
"					env.cache_what(srv,e,mc) -- the new values\n"
"					env.cache_fix(srv,mc) -- change any memcached values we just adjusted\n"
"					return e -- return the adjusted entity\n"
"				end\n"
"			end\n"
"		else\n"
"			t.rollback()\n"
"			log(\"DATA UPDATE FAILED MISSING:\"..env.kind(srv)..\":\"..id)\n"
"			return false\n"
"		end\n"
"		t.rollback() -- undo everything ready to try again\n"
"	end\n"
"	log(\"DATA UPDATE FAILED:\"..env.kind(srv)..\":\"..id)\n"
"end\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- this is like update, except entity will manifest if it does not exist\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_set(env,srv,id,f)\n"
"\n"
"	if type(id)==\"table\" then id=id.key.id end -- can turn an entity into an id\n"
"\n"
"	for retry=1,10 do\n"
"		local mc={}\n"
"		local t=wdata.begin()\n"
"		local e=env.get(srv,id,t) -- may or may not exist\n"
"		if not e then -- manifest\n"
"			e=env.create(srv,id)\n"
"		end\n"
"\n"
"		env.cache_what(srv,e,mc) -- the original values\n"
"		if not e.key.notsaved then -- not a newly created entity\n"
"			if e.cache.updated>srv.time then -- stop any updates that time travel backwards\n"
"				t.rollback()\n"
"				log(\"DATA SET FAILED TIMETRAVEL:\"..env.kind(srv)..\":\"..id)\n"
"				return false\n"
"			end\n"
"		end\n"
"		e.cache.updated=srv.time -- the function can change this change if it wishes\n"
"		if not f(srv,e) then -- hard fail\n"
"			t.rollback()\n"
"			log(\"DATA SET FAILED FUNCTION:\"..env.kind(srv)..\":\"..id)\n"
"			return false\n"
"		end\n"
"		env.check(srv,e) -- keep consistant\n"
"		if env.put(srv,e,t) then -- entity put ok\n"
"			if t.commit() then -- success\n"
"				env.cache_what(srv,e,mc) -- the new values\n"
"				env.cache_fix(srv,mc) -- change any memcached values we just adjusted\n"
"				return e -- return the adjusted entity\n"
"			end\n"
"		end\n"
"		t.rollback() -- undo everything ready to try again\n"
"	end\n"
"	log(\"DATA SET FAILED:\"..env.kind(srv)..\":\"..id)\n"
"	return false\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- get or create but does not put\n"
"--\n"
"-- use the check function to fill with any special defaults\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_manifest(env,srv,id)\n"
"\n"
"	if type(id)==\"table\" then id=id.key.id end -- can turn an entity into an id\n"
"\n"
"	local e=env.get(srv,id) -- may or may not exist\n"
"\n"
"	if e then\n"
"		return e\n"
"	else\n"
"		e=env.create(srv,id)\n"
"		return e\n"
"	end\n"
"	\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- what key name should we use to cache an entity?\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_cache_key(env,srv,id)\n"
"	if type(id)==\"table\" then id=id.key.id end -- can turn an entity into an id\n"
"	return \"ent=\"..env.kind(srv)..\"&id=\"..id\n"
"end\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- given an entity return or update a list of memcache keys we should recalculate\n"
"-- this list is a name->bool lookup\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_cache_what(env,srv,ent,mc)\n"
"	local mc=mc or {} -- can supply your own result table for merges	\n"
"	\n"
"	local ck=env.cache_key(srv,ent.key.id)\n"
"	if ck then\n"
"		mc[ ck ] = true\n"
"	end\n"
"	return mc\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- fix the memcache items previously produced by what_memcache\n"
"-- probably best just to delete them so they will automatically get rebuilt\n"
"-- but we could do more complicated things\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function def_cache_fix(env,srv,mc)\n"
"	for n,b in pairs(mc) do\n"
"		cache.del(srv,n)\n"
"	end\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- set these default functions into the given environment\n"
"-- these are functions that handle basic data management\n"
"--\n"
"-- you must also provide\n"
"--\n"
"-- a kind function\n"
"-- a check function\n"
"-- a table of default cache values\n"
"-- a table of default props values\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function set_defs(env)\n"
"\n"
"	env.create     = env.create or		function(srv,id)     return def_create(env,srv,id)         end\n"
"	env.manifest   = env.manifest or	function(srv,id)     return def_manifest(env,srv,id)       end\n"
"	env.put        = env.put or			function(srv,ent,t)  return def_put(env,srv,ent,t)         end\n"
"	env.get        = env.get or			function(srv,id,t)   return def_get(env,srv,id,t)          end\n"
"	env.del        = env.del or			function(srv,id,t)   return def_del(env,srv,id,t)          end\n"
"	env.set        = env.set or			function(srv,id,f)   return def_set(env,srv,id,f)	 	   end\n"
"	env.update     = env.update or		function(srv,id,f)   return def_update(env,srv,id,f)       end\n"
"	env.cache_key  = env.cache_key or	function(srv,id)     return def_cache_key(env,srv,id)      end\n"
"	env.cache_what = env.cache_what or	function(srv,ent,mc) return def_cache_what(env,srv,ent,mc) end\n"
"	env.cache_fix  = env.cache_fix or	function(srv,mc)     return def_cache_fix(env,srv,mc)      end\n"
"\n"
"	return env\n"
"end\n"
"\n"
"",

"wetgenes.www.any.iplog","\n"
"-- manage simple rate limiting by ip, this will stop run away scripts from taking the piss\n"
"-- these structures are stored only in memcache so are very fuzzy/lazy and not to be trusted\n"
"-- but should mostly work, for now this is just rate limiting but a callback to handle extras\n"
"-- will be added when I work out what these extras might be\n"
"\n"
"local cache=require(\"wetgenes.www.any.cache\")\n"
"local json=require(\"wetgenes.json\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log -- grab the func from the package\n"
"\n"
"\n"
"local tostring=tostring\n"
"local math=math\n"
"local os=os\n"
"\n"
"module(\"wetgenes.www.any.iplog\")\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- turn a time in seconds into\n"
"--\n"
"-- time in : minutes , hours , days\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function get_mhd(s)\n"
"	return math.floor(s/(60)) , math.floor(s/(60*60)) , math.floor(s/(60*60*24))\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- Create a new struct\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function create(ip)\n"
"	local it={}\n"
"	it.ip=ip\n"
"	it.mhd=	{ -- arrays for simple json tables\n"
"				{0,0,0}, -- count : minutes , hours , days\n"
"				{get_mhd(os.time())}, -- stamps : minutes , hours , days\n"
"			}\n"
"	return check(it)\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- check data structure, count zero any old data as it goes out of date\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function check(it)\n"
"	local mhd={get_mhd(os.time())}\n"
"	if it.mhd[2][1]~=mhd[1] then it.mhd[1][1]=0 it.mhd[2][1]=mhd[1] end\n"
"	if it.mhd[2][2]~=mhd[2] then it.mhd[1][2]=0 it.mhd[2][2]=mhd[2] end\n"
"	if it.mhd[2][3]~=mhd[3] then it.mhd[1][3]=0 it.mhd[2][3]=mhd[3] end\n"
"	return it\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- get or create if doesnt exist\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function manifest(ip)\n"
"	return get(ip) or create(ip)\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- get by ip\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function get(ip)\n"
"	local d=cache.get(nil,\"iplog=\"..ip)\n"
"	if d then\n"
"		return check(json.decode(d))\n"
"	end\n"
"	return nil\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- put\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function put(it)\n"
"	cache.put(nil,\"iplog=\"..it.ip , json.encode(it) , 60*60*24 )\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- increment the current use by one or n if given\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function inc(it,n)\n"
"	it.mhd[1][1]=it.mhd[1][1]+(n or 1)\n"
"	it.mhd[1][2]=it.mhd[1][2]+(n or 1)\n"
"	it.mhd[1][3]=it.mhd[1][3]+(n or 1)\n"
"	return it\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- this is the main ratelimit function you want, given an IP (string) mark up another access\n"
"-- and decide if we should bail on the request at this point, returns true if\n"
"-- it is ok to procede false if it isnt. The iplog structure is also in its second\n"
"-- return value for later inspection.\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function ratelimit(ip,n)\n"
"	local it=manifest(ip)\n"
"	inc(it,n)\n"
"	put(it) -- we do not care about overwrites, numbers are fuzzy\n"
"	if it.admin then return true,it end -- admin flag means it is always ok\n"
"	if it.mhd[1][1] > 200   then return false,it end -- max requests per minute\n"
"	if it.mhd[1][2] > 2000  then return false,it end -- max requests per hour\n"
"	if it.mhd[1][3] > 20000 then return false,it end -- max requests per day\n"
"	return true,it\n"
"end\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- mark this ip as admin so it is never rate limited\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function mark_as_admin(ip)\n"
"	local it=manifest(ip)\n"
"	if not it.admin then -- switch on flag\n"
"		it.admin=true\n"
"		put(it) -- we do not care about overwrites, numbers are fuzzy\n"
"	end\n"
"end\n"
"\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- get some html info about this ip (for use on the 503 error page)\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function html_info(ip)\n"
"	local it=manifest(ip)\n"
"\n"
"	return wstr.replace([[\n"
"<html> <title> Too Many Requests ( RATE LIMITED ) </title>\n"
"<body>\n"
"<center>\n"
"<h1>Your ip {ip} is being RATE LIMITED</h1>\n"
"<h3>You must wait a little while to access this server again.</h3>\n"
"<hr/>\n"
"<br/>\n"
"You have used {pm}% of your quota per minute.<br/>\n"
"<br/>\n"
"You have used {ph}% of your quota per hour.<br/>\n"
"<br/>\n"
"You have used {pd}% of your quota per day.<br/>\n"
"<br/>\n"
"<br/>\n"
"</center>\n"
"</body>\n"
"</html>\n"
"	]],{\n"
"		ip=ip,\n"
"		pm=math.floor(100*it.mhd[1][1]/200),\n"
"		ph=math.floor(100*it.mhd[1][2]/2000),\n"
"		pd=math.floor(100*it.mhd[1][3]/20000),\n"
"	})\n"
"end\n"
"\n"
"",

"socket.ftp","-----------------------------------------------------------------------------\n"
"-- FTP support for the Lua language\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: ftp.lua,v 1.45 2007/07/11 19:25:47 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local table = require(\"table\")\n"
"local string = require(\"string\")\n"
"local math = require(\"math\")\n"
"local socket = require(\"socket\")\n"
"local url = require(\"socket.url\")\n"
"local tp = require(\"socket.tp\")\n"
"local ltn12 = require(\"ltn12\")\n"
"module(\"socket.ftp\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Program constants\n"
"-----------------------------------------------------------------------------\n"
"-- timeout in seconds before the program gives up on a connection\n"
"TIMEOUT = 60\n"
"-- default port for ftp service\n"
"PORT = 21\n"
"-- this is the default anonymous password. used when no password is\n"
"-- provided in url. should be changed to your e-mail.\n"
"USER = \"ftp\"\n"
"PASSWORD = \"anonymous@anonymous.org\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Low level FTP API\n"
"-----------------------------------------------------------------------------\n"
"local metat = { __index = {} }\n"
"\n"
"function open(server, port, create)\n"
"    local tp = socket.try(tp.connect(server, port or PORT, TIMEOUT, create))\n"
"    local f = base.setmetatable({ tp = tp }, metat)\n"
"    -- make sure everything gets closed in an exception\n"
"    f.try = socket.newtry(function() f:close() end)\n"
"    return f\n"
"end\n"
"\n"
"function metat.__index:portconnect()\n"
"    self.try(self.server:settimeout(TIMEOUT))\n"
"    self.data = self.try(self.server:accept())\n"
"    self.try(self.data:settimeout(TIMEOUT))\n"
"end\n"
"\n"
"function metat.__index:pasvconnect()\n"
"    self.data = self.try(socket.tcp())\n"
"    self.try(self.data:settimeout(TIMEOUT))\n"
"    self.try(self.data:connect(self.pasvt.ip, self.pasvt.port))\n"
"end\n"
"\n"
"function metat.__index:login(user, password)\n"
"    self.try(self.tp:command(\"user\", user or USER))\n"
"    local code, reply = self.try(self.tp:check{\"2..\", 331})\n"
"    if code == 331 then\n"
"        self.try(self.tp:command(\"pass\", password or PASSWORD))\n"
"        self.try(self.tp:check(\"2..\"))\n"
"    end\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:pasv()\n"
"    self.try(self.tp:command(\"pasv\"))\n"
"    local code, reply = self.try(self.tp:check(\"2..\"))\n"
"    local pattern = \"(%d+)%D(%d+)%D(%d+)%D(%d+)%D(%d+)%D(%d+)\"\n"
"    local a, b, c, d, p1, p2 = socket.skip(2, string.find(reply, pattern))\n"
"    self.try(a and b and c and d and p1 and p2, reply)\n"
"    self.pasvt = {\n"
"        ip = string.format(\"%d.%d.%d.%d\", a, b, c, d),\n"
"        port = p1*256 + p2\n"
"    }\n"
"    if self.server then\n"
"        self.server:close()\n"
"        self.server = nil\n"
"    end\n"
"    return self.pasvt.ip, self.pasvt.port\n"
"end\n"
"\n"
"function metat.__index:port(ip, port)\n"
"    self.pasvt = nil\n"
"    if not ip then\n"
"        ip, port = self.try(self.tp:getcontrol():getsockname())\n"
"        self.server = self.try(socket.bind(ip, 0))\n"
"        ip, port = self.try(self.server:getsockname())\n"
"        self.try(self.server:settimeout(TIMEOUT))\n"
"    end\n"
"    local pl = math.mod(port, 256)\n"
"    local ph = (port - pl)/256\n"
"    local arg = string.gsub(string.format(\"%s,%d,%d\", ip, ph, pl), \"%.\", \",\")\n"
"    self.try(self.tp:command(\"port\", arg))\n"
"    self.try(self.tp:check(\"2..\"))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:send(sendt)\n"
"    self.try(self.pasvt or self.server, \"need port or pasv first\")\n"
"    -- if there is a pasvt table, we already sent a PASV command\n"
"    -- we just get the data connection into self.data\n"
"    if self.pasvt then self:pasvconnect() end\n"
"    -- get the transfer argument and command\n"
"    local argument = sendt.argument or\n"
"        url.unescape(string.gsub(sendt.path or \"\", \"^[/\\\\]\", \"\"))\n"
"    if argument == \"\" then argument = nil end\n"
"    local command = sendt.command or \"stor\"\n"
"    -- send the transfer command and check the reply\n"
"    self.try(self.tp:command(command, argument))\n"
"    local code, reply = self.try(self.tp:check{\"2..\", \"1..\"})\n"
"    -- if there is not a a pasvt table, then there is a server\n"
"    -- and we already sent a PORT command\n"
"    if not self.pasvt then self:portconnect() end\n"
"    -- get the sink, source and step for the transfer\n"
"    local step = sendt.step or ltn12.pump.step\n"
"    local readt = {self.tp.c}\n"
"    local checkstep = function(src, snk)\n"
"        -- check status in control connection while downloading\n"
"        local readyt = socket.select(readt, nil, 0)\n"
"        if readyt[tp] then code = self.try(self.tp:check(\"2..\")) end\n"
"        return step(src, snk)\n"
"    end\n"
"    local sink = socket.sink(\"close-when-done\", self.data)\n"
"    -- transfer all data and check error\n"
"    self.try(ltn12.pump.all(sendt.source, sink, checkstep))\n"
"    if string.find(code, \"1..\") then self.try(self.tp:check(\"2..\")) end\n"
"    -- done with data connection\n"
"    self.data:close()\n"
"    -- find out how many bytes were sent\n"
"    local sent = socket.skip(1, self.data:getstats())\n"
"    self.data = nil\n"
"    return sent\n"
"end\n"
"\n"
"function metat.__index:receive(recvt)\n"
"    self.try(self.pasvt or self.server, \"need port or pasv first\")\n"
"    if self.pasvt then self:pasvconnect() end\n"
"    local argument = recvt.argument or\n"
"        url.unescape(string.gsub(recvt.path or \"\", \"^[/\\\\]\", \"\"))\n"
"    if argument == \"\" then argument = nil end\n"
"    local command = recvt.command or \"retr\"\n"
"    self.try(self.tp:command(command, argument))\n"
"    local code = self.try(self.tp:check{\"1..\", \"2..\"})\n"
"    if not self.pasvt then self:portconnect() end\n"
"    local source = socket.source(\"until-closed\", self.data)\n"
"    local step = recvt.step or ltn12.pump.step\n"
"    self.try(ltn12.pump.all(source, recvt.sink, step))\n"
"    if string.find(code, \"1..\") then self.try(self.tp:check(\"2..\")) end\n"
"    self.data:close()\n"
"    self.data = nil\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:cwd(dir)\n"
"    self.try(self.tp:command(\"cwd\", dir))\n"
"    self.try(self.tp:check(250))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:type(type)\n"
"    self.try(self.tp:command(\"type\", type))\n"
"    self.try(self.tp:check(200))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:greet()\n"
"    local code = self.try(self.tp:check{\"1..\", \"2..\"})\n"
"    if string.find(code, \"1..\") then self.try(self.tp:check(\"2..\")) end\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:quit()\n"
"    self.try(self.tp:command(\"quit\"))\n"
"    self.try(self.tp:check(\"2..\"))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:close()\n"
"    if self.data then self.data:close() end\n"
"    if self.server then self.server:close() end\n"
"    return self.tp:close()\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- High level FTP API\n"
"-----------------------------------------------------------------------------\n"
"local function override(t)\n"
"    if t.url then\n"
"        local u = url.parse(t.url)\n"
"        for i,v in base.pairs(t) do\n"
"            u[i] = v\n"
"        end\n"
"        return u\n"
"    else return t end\n"
"end\n"
"\n"
"local function tput(putt)\n"
"    putt = override(putt)\n"
"    socket.try(putt.host, \"missing hostname\")\n"
"    local f = open(putt.host, putt.port, putt.create)\n"
"    f:greet()\n"
"    f:login(putt.user, putt.password)\n"
"    if putt.type then f:type(putt.type) end\n"
"    f:pasv()\n"
"    local sent = f:send(putt)\n"
"    f:quit()\n"
"    f:close()\n"
"    return sent\n"
"end\n"
"\n"
"local default = {\n"
"	path = \"/\",\n"
"	scheme = \"ftp\"\n"
"}\n"
"\n"
"local function parse(u)\n"
"    local t = socket.try(url.parse(u, default))\n"
"    socket.try(t.scheme == \"ftp\", \"wrong scheme '\" .. t.scheme .. \"'\")\n"
"    socket.try(t.host, \"missing hostname\")\n"
"    local pat = \"^type=(.)$\"\n"
"    if t.params then\n"
"        t.type = socket.skip(2, string.find(t.params, pat))\n"
"        socket.try(t.type == \"a\" or t.type == \"i\",\n"
"            \"invalid type '\" .. t.type .. \"'\")\n"
"    end\n"
"    return t\n"
"end\n"
"\n"
"local function sput(u, body)\n"
"    local putt = parse(u)\n"
"    putt.source = ltn12.source.string(body)\n"
"    return tput(putt)\n"
"end\n"
"\n"
"put = socket.protect(function(putt, body)\n"
"    if base.type(putt) == \"string\" then return sput(putt, body)\n"
"    else return tput(putt) end\n"
"end)\n"
"\n"
"local function tget(gett)\n"
"    gett = override(gett)\n"
"    socket.try(gett.host, \"missing hostname\")\n"
"    local f = open(gett.host, gett.port, gett.create)\n"
"    f:greet()\n"
"    f:login(gett.user, gett.password)\n"
"    if gett.type then f:type(gett.type) end\n"
"    f:pasv()\n"
"    f:receive(gett)\n"
"    f:quit()\n"
"    return f:close()\n"
"end\n"
"\n"
"local function sget(u)\n"
"    local gett = parse(u)\n"
"    local t = {}\n"
"    gett.sink = ltn12.sink.table(t)\n"
"    tget(gett)\n"
"    return table.concat(t)\n"
"end\n"
"\n"
"command = socket.protect(function(cmdt)\n"
"    cmdt = override(cmdt)\n"
"    socket.try(cmdt.host, \"missing hostname\")\n"
"    socket.try(cmdt.command, \"missing command\")\n"
"    local f = open(cmdt.host, cmdt.port, cmdt.create)\n"
"    f:greet()\n"
"    f:login(cmdt.user, cmdt.password)\n"
"    f.try(f.tp:command(cmdt.command, cmdt.argument))\n"
"    if cmdt.check then f.try(f.tp:check(cmdt.check)) end\n"
"    f:quit()\n"
"    return f:close()\n"
"end)\n"
"\n"
"get = socket.protect(function(gett)\n"
"    if base.type(gett) == \"string\" then return sget(gett)\n"
"    else return tget(gett) end\n"
"end)\n"
"\n"
"",

"wetgenes.snipets","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"\n"
"error([[\n"
"-- just snippets of code for copypasta do not run as it should do nothing\n"
"-- this files is intended as a central notepad\n"
"]])\n"
"\n"
"-- copy functions into locals\n"
"local assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- copy libs into locals\n"
"local coroutine,package,string,table,math,io,os,debug=coroutine,package,string,table,math,io,os,debug\n"
"\n"
"-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"",

"mime","-----------------------------------------------------------------------------\n"
"-- MIME support for the Lua language.\n"
"-- Author: Diego Nehab\n"
"-- Conforming to RFCs 2045-2049\n"
"-- RCS ID: $Id: mime.lua,v 1.29 2007/06/11 23:44:54 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local ltn12 = require(\"ltn12\")\n"
"local mime = require(\"mime.core\")\n"
"local io = require(\"io\")\n"
"local string = require(\"string\")\n"
"module(\"mime\")\n"
"\n"
"-- encode, decode and wrap algorithm tables\n"
"encodet = {}\n"
"decodet = {}\n"
"wrapt = {}\n"
"\n"
"-- creates a function that chooses a filter by name from a given table\n"
"local function choose(table)\n"
"    return function(name, opt1, opt2)\n"
"        if base.type(name) ~= \"string\" then\n"
"            name, opt1, opt2 = \"default\", name, opt1\n"
"        end\n"
"        local f = table[name or \"nil\"]\n"
"        if not f then \n"
"            base.error(\"unknown key (\" .. base.tostring(name) .. \")\", 3)\n"
"        else return f(opt1, opt2) end\n"
"    end\n"
"end\n"
"\n"
"-- define the encoding filters\n"
"encodet['base64'] = function()\n"
"    return ltn12.filter.cycle(b64, \"\")\n"
"end\n"
"\n"
"encodet['quoted-printable'] = function(mode)\n"
"    return ltn12.filter.cycle(qp, \"\",\n"
"        (mode == \"binary\") and \"=0D=0A\" or \"\\r\\n"
"\")\n"
"end\n"
"\n"
"-- define the decoding filters\n"
"decodet['base64'] = function()\n"
"    return ltn12.filter.cycle(unb64, \"\")\n"
"end\n"
"\n"
"decodet['quoted-printable'] = function()\n"
"    return ltn12.filter.cycle(unqp, \"\")\n"
"end\n"
"\n"
"local function format(chunk)\n"
"    if chunk then\n"
"        if chunk == \"\" then return \"''\"\n"
"        else return string.len(chunk) end\n"
"    else return \"nil\" end\n"
"end\n"
"\n"
"-- define the line-wrap filters\n"
"wrapt['text'] = function(length)\n"
"    length = length or 76\n"
"    return ltn12.filter.cycle(wrp, length, length)\n"
"end\n"
"wrapt['base64'] = wrapt['text']\n"
"wrapt['default'] = wrapt['text']\n"
"\n"
"wrapt['quoted-printable'] = function()\n"
"    return ltn12.filter.cycle(qpwrp, 76, 76)\n"
"end\n"
"\n"
"-- function that choose the encoding, decoding or wrap algorithm\n"
"encode = choose(encodet)\n"
"decode = choose(decodet)\n"
"wrap = choose(wrapt)\n"
"\n"
"-- define the end-of-line normalization filter\n"
"function normalize(marker)\n"
"    return ltn12.filter.cycle(eol, 0, marker)\n"
"end\n"
"\n"
"-- high level stuffing filter\n"
"function stuff()\n"
"    return ltn12.filter.cycle(dot, 2)\n"
"end\n"
"",

"wetgenes.win","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local jit=jit\n"
"\n"
"local wsbox=require(\"wetgenes.sandbox\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"local pack=require(\"wetgenes.pack\")\n"
"local bit=require(\"bit\")\n"
"\n"
"local win={}\n"
"local base={}\n"
"\n"
"local softcore=require(\"wetgenes.win.core\") -- we keep some generic C functions here\n"
"\n"
"local hardcore -- but use different hardcores depending on the system we compiled for and are running on\n"
"\n"
"local posix -- set if we are a posix system\n"
"\n"
"local args={...}\n"
"\n"
"\n"
"base.noblock=false\n"
"base.flavour=\"raw\"\n"
"\n"
"if type(args[2]==\"table\" ) then -- you can force a core by using a second arg to require\n"
"	hardcore=args[2]\n"
"end\n"
"\n"
"\n"
"if not hardcore then\n"
"	local suc,dat=pcall(function() return require(\"wetgenes.win.nacl\") end )\n"
"	if suc then hardcore=dat base.flavour=\"nacl\" base.noblock=true end\n"
"end\n"
"\n"
"if not hardcore then\n"
"	local suc,dat=pcall(function() return require(\"wetgenes.win.android\") end )\n"
"	if suc then hardcore=dat base.flavour=\"android\"\n"
"--		posix=require(\"posix\")\n"
"	end\n"
"end\n"
"\n"
"if not hardcore then\n"
"	local suc,dat=pcall(function() return require(\"wetgenes.win.raspi\") end )\n"
"	if suc then hardcore=dat base.flavour=\"raspi\"\n"
"		posix=require(\"posix\")\n"
"	end\n"
"end\n"
"\n"
"if not hardcore then\n"
"	local suc,dat=pcall(function() return require(\"wetgenes.win.windows\") end )\n"
"	if suc then hardcore=dat base.flavour=\"windows\" end\n"
"end\n"
"\n"
"if not hardcore then\n"
"	local suc,dat=pcall(function() return require(\"wetgenes.win.linux\") end )\n"
"	if suc then hardcore=dat base.flavour=\"linux\"\n"
"		posix=require(\"posix\")\n"
"	end\n"
"end\n"
"\n"
"win.hardcore=hardcore\n"
"win.softcore=softcore\n"
"win.posix=posix\n"
"\n"
"-- a dir to store config or user generated files in\n"
"win.files_prefix=\"./files/\"\n"
"-- a dir to store cache files in, may auto delete but also should be deleted by app\n"
"win.cache_prefix=\"./cache/\"\n"
"\n"
"\n"
"local meta={}\n"
"meta.__index=base\n"
"\n"
"setmetatable(win,meta)\n"
"\n"
"\n"
"function win.screen()\n"
"	local it={}\n"
"	if hardcore.screen then\n"
"		it.width,it.height=hardcore.screen()\n"
"	else\n"
"		it.width,it.height=0,0\n"
"	end\n"
"	return it\n"
"end\n"
"\n"
"-- key names are given in a raw OS flavour,\n"
"-- this maps tries to map these names to more generic ones\n"
"-- really you can never be sure what name a key has...\n"
"win.generic_keymap={\n"
"\n"
"\n"
"-- android patch\n"
"	[\"android_04\"]=\"escape\",\n"
"	[\"android_6f\"]=\"escape\",\n"
"	[\"android_42\"]=\"return\",\n"
"	[\"android_43\"]=\"back\",\n"
"	[\"android_70\"]=\"delete\",\n"
"	[\"android_13\"]=\"up\",\n"
"	[\"android_14\"]=\"down\",\n"
"	[\"android_15\"]=\"left\",\n"
"	[\"android_16\"]=\"right\",\n"
"	[\"android_17\"]=\"return\",\n"
"\n"
"\n"
"-- windows patch\n"
"	[\"backspace\"]=\"back\",\n"
"	[\"kp_enter\"]=\"enter\",\n"
"	[\"oem_3\"]=\"`\",\n"
"	[\"esc\"]=\"escape\",\n"
"	\n"
"-- linux patch\n"
"	[\"grave\"]=\"`\",\n"
"	\n"
"}\n"
"\n"
"function win.keymap(key)\n"
"	key=key:lower()\n"
"	return win.generic_keymap[key] or key\n"
"end\n"
"\n"
"function win.load_run_init()\n"
"\n"
"	local zips=require(\"wetgenes.zips\")\n"
"\n"
"-- Now load and run lua/init.lua which initalizes the window and runs the app\n"
"\n"
"	local s=zips.readfile(\"lua/init.lua\")\n"
"	\n"
"	assert(s) -- sanity, may want a seperate path for any missing init.lua ?\n"
"\n"
"	if s:sub(1,2)==\"#!\" then\n"
"		s=\"--\"..s -- ignore hashbang on first line\n"
"	end\n"
"	\n"
"	local f=assert(loadstring(s))\n"
"	\n"
"	return f()\n"
"\n"
"end\n"
"\n"
"--\n"
"-- Special android entry points, we pass in the location of the apk\n"
"-- this does things that must only happen once\n"
"--\n"
"function win.android_start(apk)\n"
"\n"
"--	if jit and jit.off then\n"
"--		jit.off()\n"
"--		hardcore.print(\"LUA JIT OFF\")\n"
"--	end -- jit breaks stuff?\n"
"\n"
"\n"
"-- replace print\n"
"	_G.print=hardcore.print\n"
"	print=_G.print\n"
"\n"
"	win.apk=apk\n"
"	local zips=require(\"wetgenes.zips\")\n"
"	zips.add_apk_file(win.apk)\n"
"	\n"
"	win.files_prefix=hardcore.get_files_prefix()..\"/\"\n"
"	win.cache_prefix=hardcore.get_cache_prefix()..\"/\"\n"
"\n"
"	win.smell=hardcore.smell_check()\n"
"\n"
"--print(win.files_prefix)\n"
"--print(win.cache_prefix)\n"
"\n"
"--print(\"ANDROID_SETUP with \",apk)\n"
"	\n"
"	return win.load_run_init()\n"
"end\n"
"\n"
"\n"
"--\n"
"-- Special nacl entry points, we pass in the url of the main zip we wish to load\n"
"-- this does things that must only happen once\n"
"--\n"
"local main -- gonna have to cache the main state here\n"
"function win.nacl_start(url)\n"
"--	_G.print=hardcore.print\n"
"--	print=_G.print\n"
"	\n"
"--	print(\"nacl start \",url)\n"
"\n"
"	local zips=require(\"wetgenes.zips\")\n"
"	\n"
"-- we want nacl msgs to go here.\n"
"	_G.nacl_input_event=function(...) return hardcore.input_event(...) end\n"
"\n"
"	hardcore.getURL(url,function(size,mem)	\n"
"--		print(\"nacl callback\",size,mem)\n"
"		\n"
"		zips.add_zip_data(mem)\n"
"		main=win.load_run_init()\n"
"\n"
"	end)\n"
"\n"
"--	print(\"nacl start done\")\n"
"\n"
"end\n"
"\n"
"function win.nacl_pulse() -- called 60ish times a second depending upon how retarted the browser is\n"
"\n"
"	if main then\n"
"		main:serv_pulse()\n"
"	end\n"
"end\n"
"\n"
"\n"
"function win.create(opts)\n"
"\n"
"	local w={}\n"
"	setmetatable(w,meta)\n"
"	\n"
"	if hardcore.create then\n"
"		w[0]=assert( hardcore.create(opts) )\n"
"	end\n"
"	w.msgstack={} -- can feed \"fake\" msgs into here (fifo stack) with table.push\n"
"	w.width=0\n"
"	w.height=0\n"
"	\n"
"	base.info(w)\n"
"	return w\n"
"end\n"
"\n"
"function base.destroy(w)\n"
"	if hardcore.destroy then\n"
"		hardcore.destroy(w[0],w)\n"
"	end\n"
"end\n"
"\n"
"function base.show(w,s)\n"
"	if hardcore.show then\n"
"		hardcore.show(w[0],s)\n"
"	end\n"
"end\n"
"\n"
"function base.info(w)\n"
"	if hardcore.info then\n"
"		hardcore.info(w[0],w)\n"
"--		print(\"WH\",w.width,w.height)\n"
"	end\n"
"end\n"
"\n"
"function base.context(w,opts)\n"
"	if hardcore.context then\n"
"		hardcore.context(w[0],opts)\n"
"	end\n"
"end\n"
"\n"
"function base.start(w)\n"
"	if hardcore.start then\n"
"		hardcore.start(w[0])\n"
"	end\n"
"end\n"
"\n"
"function base.stop(w)\n"
"	if hardcore.stop then\n"
"		hardcore.stop(w[0])\n"
"	end\n"
"end\n"
"\n"
"function base.swap(w)\n"
"	if hardcore.swap then\n"
"		hardcore.swap(w[0])\n"
"	end\n"
"end\n"
"\n"
"function base.peek(w)\n"
"	if hardcore.peek then\n"
"		return hardcore.peek(w[0])\n"
"	end\n"
"end\n"
"\n"
"function base.wait(w,t)\n"
"	if hardcore.wait then\n"
"		hardcore.wait(w[0],t)\n"
"	end\n"
"end\n"
"\n"
"-- a msg iterator\n"
"function base.msgs(w)\n"
"	return function() return w:msg() end\n"
"end\n"
"\n"
"-- push a msg onto the msgstack, so it feeds back into the input loop\n"
"function base.push_msg(w,m)\n"
"	w.msgstack[#w.msgstack+1]=m\n"
"end\n"
"\n"
"-- get the next msg or return nil if there are no more\n"
"function base.msg(w)\n"
"\n"
"	local m\n"
"	\n"
"	if not m and w.msgstack[1] then\n"
"		m=table.remove(w.msgstack,1)\n"
"	end\n"
"	if not m and hardcore.msg then\n"
"		m=hardcore.msg(w[0])\n"
"	end\n"
"	if not m and posix then\n"
"		m=base.posix_msg(w)\n"
"	end\n"
"	if not m and hardcore.smell_msg then\n"
"		m=hardcore.smell_msg() --hardcoded stuff\n"
"		if m then\n"
"			m=wsbox.lson(m)\n"
"--			print(wstr.dump(m))\n"
"		end\n"
"	end\n"
"\n"
"	if m then -- proccess the msg some more\n"
"	\n"
"		if m.keyname then -- run it through our keymap probably just force it to lowercase.\n"
"			m.keyname=win.keymap(m.keyname)\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	return m\n"
"end\n"
"\n"
"function base.jread(w,n)\n"
"	if hardcore.jread then\n"
"--print(\"jread\")	\n"
"		local pkt=hardcore.jread(w[0],n)\n"
"		local tab\n"
"		if pkt then\n"
"			tab=pack.load(pkt,{\"u32\",\"time\",\"s16\",\"value\",\"u8\",\"type\",\"u8\",\"number\"})\n"
"			tab.class=\"joy\"\n"
"		end\n"
"		return tab\n"
"	end\n"
"end\n"
"\n"
"\n"
"function base.sleep(...)\n"
"	if hardcore.sleep then\n"
"		for i,v in ipairs({...}) do	-- ignore first arg if it is a table so we can call with :\n"
"			if type(v)==\"number\" then\n"
"				hardcore.sleep(v)\n"
"			end\n"
"		end\n"
"	end\n"
"end\n"
"win.sleep=base.sleep\n"
"\n"
"function base.time()\n"
"	if hardcore.time then\n"
"		return hardcore.time()\n"
"	else\n"
"		return os.time()\n"
"	end\n"
"end\n"
"win.time=base.time\n"
"\n"
"function base.smell_check()\n"
"	if hardcore.smell_check then\n"
"		return hardcore.smell_check()\n"
"	end\n"
"end\n"
"\n"
"function base.glyph_8x8(n)\n"
"	return softcore.glyph_8x8(n)\n"
"end\n"
"win.glyph_8x8=base.glyph_8x8\n"
"\n"
"\n"
"function base.posix_open_events(w)\n"
"	if not posix then return end\n"
"\n"
"	base.posix_events={}\n"
"	local events=base.posix_events\n"
"	local fp=io.open(\"/proc/bus/input/devices\",\"r\")\n"
"	local tab={}\n"
"	for l in fp:lines() do\n"
"		local t=l:sub(1,3)\n"
"		local v=l:sub(4)\n"
"		if t==\"I: \" then\n"
"			tab={} -- start new device\n"
"			tab.bus		=string.match(v,\"Bus=([^%s]+)\")\n"
"			tab.vendor	=string.match(v,\"Vendor=([^%s]+)\")\n"
"			tab.product	=string.match(v,\"Product=([^%s]+)\")\n"
"			tab.version	=string.match(v,\"Version=([^%s]+)\")\n"
"		end\n"
"		if t==\"N: \" then\n"
"			tab.name=string.match(v,\"Name=\\\"([^\\\"]+)\")\n"
"		end\n"
"		if t==\"H: \" then\n"
"			local t=string.match(v,\"Handlers=(.+)\")\n"
"			tab.event=tonumber(string.match(t,\"event(%d+)\"))\n"
"			tab.js=tonumber(string.match(t,\"js(%d+)\"))\n"
"			tab.mouse=tonumber(string.match(t,\"mouse(%d+)\"))\n"
"			events[tab.event]=tab\n"
"			tab.handlers={}\n"
"			for n in string.gmatch(t,\"[^%s]+\") do\n"
"				tab.handlers[n]=true\n"
"				if n:sub(1,5)~=\"event\" then -- we already have events\n"
"					events[n]=tab\n"
"				end\n"
"			end\n"
"		end\n"
"	end\n"
"	fp:close()\n"
"	\n"
"--	print(wstr.dump(events))\n"
"\n"
"	local kbdcount=0\n"
"	for i=0,#events do local v=events[i]\n"
"		if v then\n"
"			if v.handlers.kbd then -- open as keyboard, there may be many of these and it is all a hacky\n"
"				v.fd=posix.open(\"/dev/input/event\"..v.event, bit.bor(posix.O_NONBLOCK , posix.O_RDONLY) )\n"
"				if v.fd then\n"
"					print(\"opened keyboard \"..kbdcount..\" on event\"..v.event..\" \"..v.name)\n"
"					v.fd_device=kbdcount\n"
"					v.fd_type=\"keyboard\"\n"
"					kbdcount=kbdcount+1\n"
"				else\n"
"					print(\"failed to open keyboard \"..kbdcount..\" on event\"..v.event..\" \"..v.name)\n"
"				end\n"
"			elseif v.js then -- open as joystick	\n"
"				v.fd=posix.open(\"/dev/input/event\"..v.event, bit.bor(posix.O_NONBLOCK , posix.O_RDONLY) )\n"
"				if v.fd then\n"
"					print(\"opened joystick \"..v.js..\" on event\"..v.event..\" \"..v.name)\n"
"					v.fd_device=v.js\n"
"					v.fd_type=\"joystick\"\n"
"				else\n"
"					print(\"failed to open joystick \"..v.js..\" on event\"..v.event..\" \"..v.name)\n"
"				end\n"
"			elseif v.mouse then -- open as mouse\n"
"				v.fd=posix.open(\"/dev/input/event\"..v.event, bit.bor(posix.O_NONBLOCK , posix.O_RDONLY) )\n"
"				if v.fd then\n"
"					print(\"opened mouse \"..v.mouse..\" on event\"..v.event..\" \"..v.name)\n"
"					v.fd_device=v.mouse\n"
"					v.fd_type=\"mouse\"\n"
"				else\n"
"					print(\"failed to open mouse \"..v.mouse..\" on event\"..v.event..\" \"..v.name)\n"
"				end\n"
"			end\n"
"		end\n"
"	end\n"
"\n"
"--	print(wstr.dump(events))\n"
"\n"
"	\n"
"end\n"
"function base.posix_read_events(w) -- call this until it returns nil to get all events\n"
"	if not posix then return end\n"
"	\n"
"	local events=base.posix_events\n"
"	for i=0,#events do local v=events[i]\n"
"		if v then\n"
"			if v.fd then\n"
"				local pkt=posix.read(v.fd,16)\n"
"				if pkt then\n"
"					local tab=pack.load(pkt,{\"u32\",\"secs\",\"u32\",\"micros\",\"u16\",\"type\",\"u16\",\"code\",\"u32\",\"value\"})\n"
"					tab.time=tab.secs+(tab.micros/1000000)\n"
"					tab.secs=nil\n"
"					tab.micros=nil\n"
"					tab.class=\"posix_\"..v.fd_type\n"
"					tab.posix_device=v -- please do not edit this\n"
"	--print(tab.class)\n"
"					return tab\n"
"				end\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"end\n"
"function base.posix_close_events(w)\n"
"	if not posix then return end\n"
"	base.posix_events=nil\n"
"end\n"
"\n"
"function base.posix_msg(w)\n"
"	if not base.posix_events then -- need to initialize\n"
"		base.posix_open_events(w)\n"
"	end\n"
"	return base.posix_read_events(w)\n"
"end\n"
"\n"
"\n"
"return win\n"
"",

"wetgenes.html","\n"
"local table=table\n"
"local string=string\n"
"\n"
"local type=type\n"
"local tostring=tostring\n"
"local setmetatable=setmetatable\n"
"\n"
"-- my string functions\n"
"local str=require(\"wetgenes.string\")\n"
"\n"
"module(\"wetgenes.html\")\n"
"\n"
"--\n"
"-- use the replace function from wetgenes.string\n"
"--\n"
"replace=str.replace\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- build a string from a template,  with a table to be used as its environment\n"
"--\n"
"-- this environment will not get modified by the called function as it is wrapped here\n"
"--\n"
"-- even though the calling function is free to modify the table it gets\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"get=function(html,src,env)\n"
"\n"
"	local new_env={}\n"
"	if env then setmetatable(new_env,{__index=env})	end -- wrap to protect\n"
"\n"
"	if html[src] then src=html[src] end\n"
"	\n"
"	if type(src)==\"function\" then return src(new_env) end\n"
"	\n"
"	if type(src)==\"string\" and env then return replace(src,new_env) end\n"
"\n"
"	return tostring(src)\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- very basic html esc to stop tags and entities from doing bad things\n"
"-- running text submitted from a user through this function should stop it from doing\n"
"-- anything other than just being text, it doesnt guarantee that it is valid xhtml / whatever\n"
"-- We just turn a few important characters into entities.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function esc(s)\n"
"	local escaped = { ['<']='&lt;', ['>']='&gt;', [\"&\"]='&amp;' }\n"
"	return (s:gsub(\"[<>&]\", function(c) return escaped[c] end))\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- basic url escape, so as not to trigger url get params or anything else by mistake \n"
"-- so = & # % ? \" ' are bad and get replaced with %xx\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_esc(s)\n"
"	return string.gsub(s, \"([&=%%%#%?%'%\\\" ><])\", function(c)\n"
"		return string.format(\"%%%02x\", string.byte(c))\n"
"	end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- a url escape, that only escapes the string deliminators ' and \" \n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_esc_string(s)\n"
"	return string.gsub(s, \"(['%\\\" ])\", function(c)\n"
"		return string.format(\"%%%02x\", string.byte(c))\n"
"	end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert any %xx into single chars\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_unesc(s)\n"
"	return string.gsub(s, \"%%(%x%x)\", function(hex)\n"
"		return string.char(tonumber(hex, 16))\n"
"	end)\n"
"end\n"
"\n"
"",

"wetgenes.bake.pathfix","-- make sure we have the package path setup and working to find everything, this should be made smrtr\n"
"-- i mean you still have to find this file in the first place...\n"
"\n"
"package.path =package.path.. \";../bin/lua/?.lua;../bin/lua/?/init.lua\"\n"
"\n"
"if os.getenv(\"SHELL\") and string.sub(os.getenv(\"SHELL\"),1,5)== \"/bin/\" then\n"
"	package.cpath=package.cpath..\";../bin/exe/?.so\"\n"
"else\n"
"	package.cpath=package.cpath..\";../bin/exe/?.dll\"\n"
"end\n"
"",

"wetgenes.json","--\n"
"-- wetjson\n"
"--         version 2011-02-04\n"
"--         use encode to encode a table and decode to decode a json string\n"
"--\n"
"-- other json encode/decode pure lua library seemed too slow\n"
"-- here is a fast and loose one lets see if it goes any faster :)\n"
"-- should be a direct replacement for JSON4Lua which is what I was using before\n"
"--\n"
"-- find the latest version online here\n"
"-- http://code.google.com/p/aelua/source/browse/trunk/aelua/lua/wetjson.lua\n"
"--\n"
"--\n"
"-- Copyright (C) 2011 by http://about.wetgenes.com/\n"
"--\n"
"-- Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"-- of this software and associated documentation files (the \"Software\"), to deal\n"
"-- in the Software without restriction, including without limitation the rights\n"
"-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"-- copies of the Software, and to permit persons to whom the Software is\n"
"-- furnished to do so, subject to the following conditions:\n"
"--\n"
"-- The above copyright notice and this permission notice shall be included in\n"
"-- all copies or substantial portions of the Software.\n"
"--\n"
"-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
"-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
"-- THE SOFTWARE.\n"
"--\n"
"\n"
"local table=table\n"
"local string=string\n"
"\n"
"\n"
"local print=print\n"
"local type=type\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"local tonumber=tonumber\n"
"local tostring=tostring\n"
"local math=math\n"
"local error=error\n"
"\n"
"module(...)\n"
"\n"
"null=function() return null end -- wetjson.null is a magick value to represent null\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- trim whitespace from ends of string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function trim(s)\n"
"  return (s:gsub(\"^%s*(.-)%s*$\", \"%1\"))\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- unescape a string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local unesc_tab={\n"
"	[\"b\"]=\"\\b\",\n"
"	[\"f\"]=\"\\f\",\n"
"	[\"n\"]=\"\\n"
"\",\n"
"	[\"r\"]=\"\\r\",\n"
"	[\"t\"]=\"\\t\",\n"
"}\n"
"local function unesc(s)\n"
"\n"
"	s=string.gsub(s, \"\\\\([^u])\", function(c)\n"
"		return unesc_tab[c] or c\n"
"    end)\n"
"\n"
"	s=string.gsub(s, \"\\\\u(%x%x%x%x)\", function(c)\n"
"		local n=tonumber(c,16) or 32\n"
"		if n>255 then return \" \" else -- need utf8?\n"
"			return string.char( n ) or \"\"\n"
"		end\n"
"    end)\n"
"    \n"
"  return s\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- escape a string anything outside of basic printable 7bit ascii or a \" or a \\\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function esc(s)\n"
"\n"
"	s=string.gsub(s, \"([^#-Z_-~ !%^%[%]])\", function(c)\n"
"		return string.format( \"\\\\u%04x\" , string.byte( c ) )\n"
"    end)\n"
"    \n"
"  return s\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split on interesting characters to create a table\n"
"--\n"
"-- a concat on the result would be a perfect reproduction of the original\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function split(text)\n"
"	local separator = \"[\\\",:{}%[%]']\"\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	\n"
"	while split_start do\n"
"		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end		-- the word\n"
"		table.insert(parts, text:sub(split_start, split_end))	-- the white space\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	\n"
"	return parts\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- is this an array?\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function is_array(t)\n"
"	local len=#t\n"
"	if len==0 then return false end -- short circuit\n"
"	for i,v in pairs(t) do\n"
"		if type(i)==\"number\" then\n"
"			if math.floor(i)~=i then -- must be int\n"
"				return false\n"
"			end\n"
"			if i<1 or i>len then -- and in this range\n"
"				return false\n"
"			end\n"
"		else\n"
"			return false\n"
"		end\n"
"	end\n"
"	return true\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- json string to table\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function decode(s,opts)\n"
"opts=opts or {}\n"
"\n"
"local t\n"
"\n"
"-- start by adjusting all \\\" escapes in the string into \\u0000 escapes\n"
"-- that way we do not have to worry about \" being anywhere apart\n"
"-- from real string deliminators which makes parsing easier?\n"
"-- this way we wont have to ignore \\\" as a special case inside strings\n"
"\n"
"	s=string.gsub(s, \"\\\\([\\\"])\", function(c)\n"
"		return string.format(\"\\\\u%04x\",string.byte(c))\n"
"    end)\n"
"\n"
"\n"
"-- now we break the string using any of the following characters as deliminators\n"
"-- {}[]:,\"\n"
"-- this gives an array of interesting points to parse\n"
"\n"
"	t=split(s,opts)\n"
"	\n"
"	local chash=0\n"
"	local out={}\n"
"	local top={tab=out,idx=1,inc=true}\n"
"	local stack={ top }\n"
"	local sb -- string buffer building for the use of\n"
"	local sbend -- the string terminator\n"
"	\n"
"	function err(s)\n"
"		error(s..\" (\"..chash..\")\")\n"
"	end\n"
"	\n"
"	function push(v)\n"
"		top=v\n"
"		stack[#stack+1]=top\n"
"	end\n"
"	\n"
"	function pop()\n"
"		stack[#stack]=nil\n"
"		top=stack[#stack]\n"
"		if not top then err(\"too many close brackets\") end\n"
"	end\n"
"	\n"
"	function setval()\n"
"		if top.idx==nil then -- set idx not val\n"
"			if type(val)==\"table\" then err(\"cannot use table as index\") end\n"
"			top.idx=val\n"
"			val=nil\n"
"		else\n"
"--print(top.idx,\"=\",val)\n"
"			top.tab[top.idx]=val\n"
"			if top.inc then top.idx=top.idx+1 else top.idx=nil end\n"
"		end\n"
"	end\n"
"	\n"
"	for i,v in ipairs(t) do\n"
"			\n"
"		if sb then -- continue building a string\n"
"		\n"
"			if v==sbend then -- end of string\n"
"				if sb[2] then\n"
"					val=unesc(table.concat(sb))\n"
"				else\n"
"					val=unesc(sb[1])\n"
"				end\n"
"				sb=nil\n"
"				setval()\n"
"			else\n"
"				sb[#sb+1]=v\n"
"			end\n"
"			\n"
"		else\n"
"		\n"
"			local l=trim(v) -- remove any white space from both ends\n"
"--print(l,#stack)			\n"
"			if #l>0 then -- ignore whitespace\n"
"			\n"
"				if l==\"\\\"\" then -- start a string \n"
"					sb={}\n"
"					sbend=\"\\\"\"\n"
"				elseif l==\"'\" then -- start a string \n"
"					sb={}\n"
"					sbend=\"'\"\n"
"				elseif l==\"{\" then\n"
"					val={}\n"
"					setval()\n"
"					push({tab=val})\n"
"					val=nil\n"
"				elseif l==\"}\" then\n"
"					pop()\n"
"				elseif l==\"[\" then\n"
"					val={}\n"
"					setval()\n"
"					push({tab=val,idx=1,inc=true})\n"
"					val=nil\n"
"				elseif l==\"]\" then\n"
"					pop()\n"
"				elseif l==\":\" then\n"
"				elseif l==\",\" then\n"
"				else\n"
"					val=l\n"
"					if val==\"true\" then val=true\n"
"					elseif val==\"false\" then val=false\n"
"					elseif val==\"null\" then val=null\n"
"					else\n"
"						val=tonumber(val) or val\n"
"					end\n"
"					setval()\n"
"				end\n"
"				\n"
"			end\n"
"		end\n"
"	\n"
"		chash=chash+#v -- very basic error locator\n"
"	end\n"
"	\n"
"	\n"
"	\n"
"--print(#t)\n"
"\n"
"	return out and out[1] , \"OK\"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- table to json string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function encode(tab,opts)\n"
"opts=opts or {}\n"
"\n"
"local out={}\n"
"local put=function(s)\n"
"	out[#out+1]=s or \"\"\n"
"end\n"
"\n"
"local encode_str\n"
"local encode_it\n"
"local encode_tab\n"
"\n"
"	function err(s)\n"
"		error(s)\n"
"	end\n"
"	\n"
"	if not tab then return err(\"null inout\") end\n"
"\n"
"	encode_str=function(str)\n"
"		return \"\\\"\"..esc(tostring(str))..\"\\\"\"\n"
"	end\n"
"	\n"
"	encode_it=function(it,t)\n"
"		t=t or type(it)\n"
"		if t==\"number\" then\n"
"			return tostring(it)\n"
"		elseif t==\"boolean\" then\n"
"			if it then return \"true\" else return \"false\" end\n"
"		elseif t==\"function\" then\n"
"			if it==null then return \"null\" end\n"
"		else\n"
"			return encode_str(it)\n"
"		end\n"
"		\n"
"		return \"\"\n"
"	end\n"
"	\n"
"	encode_tab=function(vv,array)\n"
"		local t\n"
"		local comma=false\n"
"		if array then\n"
"			put(\"[\")\n"
"			for i=1,#vv do local v=vv[i]\n"
"				put(comma and \",\") comma=true\n"
"				t=type(v)\n"
"				if t==\"table\" then\n"
"					encode_tab(v,is_array(v))\n"
"				else\n"
"					put(encode_it(v,t))\n"
"				end\n"
"			end\n"
"			put(\"]\")\n"
"		else\n"
"			put(\"{\")\n"
"			for i,v in pairs(vv) do\n"
"				put(comma and \",\") comma=true\n"
"				put(encode_it(i)) -- allow numbers or strings\n"
"				put(\":\")\n"
"				t=type(v)\n"
"				if t==\"table\" then\n"
"					encode_tab(v,is_array(v))\n"
"				else\n"
"					put(encode_it(v,t))\n"
"				end\n"
"			end\n"
"			put(\"}\")\n"
"		end\n"
"	end\n"
"\n"
"	encode_tab(tab,is_array(tab)) -- technically this should not be an array but we allow it\n"
"\n"
"\n"
"	return table.concat(out)\n"
"end\n"
"\n"
"",

"posix","-- Additions to the posix module (of luaposix).\n"
"local M = require \"posix_c\"\n"
"local posix = M\n"
"local bit\n"
"if _VERSION == \"Lua 5.1\" then bit = require \"bit\" else bit = require \"bit32\" end\n"
"\n"
"--- Create a file.\n"
"-- @param file name of file to create\n"
"-- @param mode permissions with which to create file\n"
"-- @return file descriptor, or -1 on error\n"
"function M.creat (file, mode)\n"
"  return posix.open (file, bit.bor (posix.O_CREAT, posix.O_WRONLY, posix.O_TRUNC), mode)\n"
"end\n"
"\n"
"--- Run a program like <code>os.execute</code>, but without a shell.\n"
"-- @param file filename of program to run\n"
"-- @param ... arguments to the program\n"
"-- @return status exit code, or nil if fork or wait fails\n"
"-- @return error message, or exit type if wait succeeds\n"
"function M.system (file, ...)\n"
"  local pid = posix.fork ()\n"
"  if pid == 0 then\n"
"    posix.execp (file, ...)\n"
"    -- Only get here if there's an error; kill the fork\n"
"    local _, no = posix.errno ()\n"
"    posix._exit (no)\n"
"  else\n"
"    local pid, reason, status = posix.wait (pid)\n"
"    return status, reason -- If wait failed, status is nil & reason is error\n"
"  end\n"
"end\n"
"\n"
"--- Check permissions like <code>access</code>, but for euid.\n"
"-- Based on the glibc function of the same name. Does not always check\n"
"-- for read-only file system, text busy, etc., and does not work with\n"
"-- ACLs &c.\n"
"-- @param file file to check\n"
"-- @param mode checks to perform (as for access)\n"
"-- @return 0 if access allowed; <code>nil</code> otherwise (and errno is set)\n"
"function M.euidaccess (file, mode)\n"
"  local pid = posix.getpid ()\n"
"\n"
"  if pid.uid == pid.euid and pid.gid == pid.egid then\n"
"    -- If we are not set-uid or set-gid, access does the same.\n"
"    return posix.access (file, mode)\n"
"  end\n"
"\n"
"  local stats = posix.stat (file)\n"
"  if not stats then\n"
"    return\n"
"  end\n"
"\n"
"  -- The super-user can read and write any file, and execute any file\n"
"  -- that anyone can execute.\n"
"  if pid.euid == 0 and ((not string.match (mode, \"x\")) or\n"
"                      string.match (stats.st_mode, \"x\")) then\n"
"    return 0\n"
"  end\n"
"\n"
"  -- Convert to simple list of modes.\n"
"  mode = string.gsub (mode, \"[^rwx]\", \"\")\n"
"\n"
"  if mode == \"\" then\n"
"    return 0 -- The file exists.\n"
"  end\n"
"\n"
"  -- Get the modes we need.\n"
"  local granted = stats.st_mode:sub (1, 3)\n"
"  if pid.euid == stats.st_uid then\n"
"    granted = stats.st_mode:sub (7, 9)\n"
"  elseif pid.egid == stats.st_gid or set.new (posix.getgroups ()):member (stats.st_gid) then\n"
"    granted = stats.st_mode:sub (4, 6)\n"
"  end\n"
"  granted = string.gsub (granted, \"[^rwx]\", \"\")\n"
"\n"
"  if string.gsub (\"[^\" .. granted .. \"]\", mode) == \"\" then\n"
"    return 0\n"
"  end\n"
"  posix.set_errno (EACCESS)\n"
"end\n"
"\n"
"--- Add one gettimeofday() returned timeval to another.\n"
"-- @param x a timeval\n"
"-- @param y another timeval\n"
"-- @return x + y, adjusted for usec overflow\n"
"function M.timeradd (x,y)\n"
"  local sec, usec = 0, 0\n"
"  if x.sec then sec = sec + x.sec end\n"
"  if y.sec then sec = sec + y.sec end\n"
"  if x.usec then usec = usec + x.usec end\n"
"  if y.usec then usec = usec + y.usec end\n"
"  if usec > 1000000 then\n"
"    sec = sec + 1\n"
"    usec = usec - 1000000\n"
"  end\n"
"\n"
"  return { sec = sec, usec = usec }\n"
"end\n"
"\n"
"--- Compare one gettimeofday() returned timeval with another\n"
"-- @param x a timeval\n"
"-- @param y another timeval\n"
"-- @return 0 if x and y are equal, >0 if x is newer, <0 if y is newer\n"
"function M.timercmp (x, y)\n"
"  local x = { sec = x.sec or 0, usec = x.usec or 0 }\n"
"  local y = { sec = y.sec or 0, usec = y.usec or 0 }\n"
"  if x.sec ~= y.sec then\n"
"    return x.sec - y.sec\n"
"  else\n"
"    return x.usec - y.usec\n"
"  end\n"
"end\n"
"\n"
"--- Subtract one gettimeofday() returned timeval from another.\n"
"-- @param x a timeval\n"
"-- @param y another timeval\n"
"-- @return x - y, adjusted for usec underflow\n"
"function M.timersub (x,y)\n"
"  local sec, usec = 0, 0\n"
"  if x.sec then sec = x.sec end\n"
"  if y.sec then sec = sec - y.sec end\n"
"  if x.usec then usec = x.usec end\n"
"  if y.usec then usec = usec - y.usec end\n"
"  if usec < 0 then\n"
"    sec = sec - 1\n"
"    usec = usec + 1000000\n"
"  end\n"
"\n"
"  return { sec = sec, usec = usec }\n"
"end\n"
"\n"
"return M\n"
"",

"wetgenes.zipsloader","-- this is a special loader function, it is loaded and injected into the package loaders automagically\r\n"
"-- just before the search for internal strings (so we can overload builting modules)\r\n"
"-- it should return a module function if it can find one within the registered zip files\r\n"
"-- this entire file is the function so when called ... contains the arguments passed into require\r\n"
"\r\n"
"\r\n"
"local wzips=package.loaded[\"wetgenes.zips\"] -- must be required and setup for this to work\r\n"
"if wzips and wzips.loader then\r\n"
"	return wzips.loader(...) -- real code lives here\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.cgilua.misc","\r\n"
"local assert,error,getfenv,getmetatable,ipairs,loadstring,next,pairs,pcall,print,rawget,rawset,setfenv,setmetatable,tonumber,tostring,type,unpack,xpcall = assert,error,getfenv,getmetatable,ipairs,loadstring,next,pairs,pcall,print,rawget,rawset,setfenv,setmetatable,tonumber,tostring,type,unpack,xpcall\r\n"
"\r\n"
"local string,table=string,table\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"wetgenes.cgilua.misc\")\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert an ipstr \"a.b.c.d\" to a number\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function ipstr_to_number(str)\r\n"
"\r\n"
"local num=0\r\n"
"\r\n"
"	for word in string.gmatch(str, \"[^.]+\") do num=num*256+tonumber(word) end\r\n"
"	\r\n"
"	return num\r\n"
"\r\n"
"end\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert a number to an ipstr \"a.b.c.d\"\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function number_to_ipstr(num)\r\n"
"\r\n"
"local h,s\r\n"
"\r\n"
"	h=string.format(\"%08x\",num)\r\n"
"\r\n"
"	s=tonumber( string.sub(h,1,2) , 16 ) .. \".\" ..\r\n"
"	  tonumber( string.sub(h,3,4) , 16 ) .. \".\" ..\r\n"
"	  tonumber( string.sub(h,5,6) , 16 ) .. \".\" ..\r\n"
"	  tonumber( string.sub(h,7,8) , 16 ) \r\n"
"\r\n"
"	return s\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- split a string into a table\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function str_split(div,str)\r\n"
"\r\n"
"  if (div=='') or not div then error(\"div expected\", 2) end\r\n"
"  if not str then error(\"str expected\", 2) end\r\n"
"  if str==\"\" then return {\"\"} end\r\n"
"  \r\n"
"  local pos,arr = 0,{}\r\n"
"  \r\n"
"  -- for each divider found\r\n"
"  for st,sp in function() return string.find(str,div,pos,true) end do\r\n"
"	table.insert(arr,string.sub(str,pos,st-1)) -- Attach chars left of current divider\r\n"
"	pos = sp + 1 -- Jump past current divider\r\n"
"  end\r\n"
"  \r\n"
"  if pos~=0 then\r\n"
"	table.insert(arr,string.sub(str,pos)) -- Attach chars right of last divider\r\n"
"  else\r\n"
"	table.insert(arr,str) -- return entire string\r\n"
"  end\r\n"
"  \r\n"
"  \r\n"
"  return arr\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- join a table of things into an english list with commas and an \"and\" at the end\r\n"
"-- returns nil if the table is empty\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function str_join_english_list(t)\r\n"
"\r\n"
"local s\r\n"
"\r\n"
"	for i,v in ipairs(t) do\r\n"
"	\r\n"
"		if not s then -- first\r\n"
"		\r\n"
"			s=v\r\n"
"			\r\n"
"		elseif t[i+1]==nil then -- last\r\n"
"		\r\n"
"			s=s..\" and \"..v\r\n"
"			\r\n"
"		else -- middle\r\n"
"		\r\n"
"			s=s..\", \"..v\r\n"
"			\r\n"
"		end\r\n"
"	\r\n"
"	end\r\n"
"\r\n"
"	return s\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert a string into a hex string\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function str_to_hex(s)\r\n"
"	return string.gsub(s, \".\", function (c)\r\n"
"		return string.format(\"%02x\", string.byte(c))\r\n"
"	end)\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- escape a string for mysql, convert to a (possibly large) number in hex\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function mysql_escape(s)\r\n"
"	return \"0x\"..str_to_hex(s)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- replace any %xx with the intended char, eg \"%20\" becomes a \" \"\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function url_decode(str)\r\n"
"    return string.gsub(str, \"%%(%x%x)\", function(hex)\r\n"
"        return string.char(tonumber(hex, 16))\r\n"
"    end)\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- replace % , & and = chars with %xx codes\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function url_encode(str)\r\n"
"    return string.gsub(str, \"([&=%%])\", function(c)\r\n"
"        return string.format(\"%%%02x\", string.byte(c))\r\n"
"    end)\r\n"
"--  return str\r\n"
"end\r\n"
"",

"wetgenes.win.raspi","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local raspi={}\n"
"\n"
"local core=require(\"wetgenes.win.raspi.core\")\n"
"\n"
"\n"
"--\n"
"-- export all core functions not wrapped above\n"
"--\n"
"for n,v in pairs(core) do -- check the core\n"
"	if type(v)==\"function\" then -- only functions\n"
"		if not raspi[n] then -- only if not prewrapped\n"
"			raspi[n]=v\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"\n"
"\n"
"return raspi\n"
"",

"wetgenes.tardis","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- Time And Relative Dimensions In Space\n"
"--\n"
"-- a lua library for manipulating time and space\n"
"-- pure lua by default and opengl in flavour\n"
"--\n"
"-- recoil in terror as we use two glyph names to describe structures\n"
"-- whilst typing in random strings of numbers that may or may not\n"
"-- contain tyops\n"
"--\n"
"-- v# vector [#]\n"
"-- m# matrix [#][#]\n"
"-- q4 quaternion (yeah its just a repackaged v4)\n"
"--\n"
"-- each class is a table of # values [1] to [#] , just access them\n"
"-- directly they are number streams formated the same way as opengl\n"
"-- (row-major) metatables are used to provide advanced functionality\n"
"--\n"
"-- This code may contain bugs,\n"
"-- do not use if you are not prepared to fix them.\n"
"--\n"
"-- https://bitbucket.org/xixs/bin/src/tip/lua/wetgenes/tardis.lua\n"
"--\n"
"-- This also needs to be overloaded with a float based C version\n"
"-- Which does partially exist but is only used in the GLES lib so far\n"
"-- This is now done, but probably should be an optional action.\n"
"-- Assuming I havent borked anything I can now improve the C side speed.\n"
"--\n"
"-- This seems to be the simplest (programmer orientated) description of\n"
"-- most of the maths used here so go read it\n"
"-- http://www.j3d.org/matrix_faq/matrfaq_latest.html\n"
"--\n"
"\n"
"local math=require(\"math\")\n"
"local table=require(\"table\")\n"
"local string=require(\"string\")\n"
"\n"
"local unpack=unpack\n"
"local getmetatable=getmetatable\n"
"local setmetatable=setmetatable\n"
"local type=type\n"
"local pairs=pairs\n"
"local ipairs=ipairs\n"
"local tostring=tostring\n"
"local tonumber=tonumber\n"
"local require=require\n"
"local error=error\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"-- a metatable typeof function\n"
"M.mtype_lookup=mtype_lookup or {}\n"
"function M.mtype(it)\n"
"	return M.mtype_lookup[getmetatable(it) or 0] or type(it)\n"
"end\n"
"\n"
"-- dumb class inheritance metatable creation\n"
"local function class(name,...)\n"
"\n"
"	if M[name] then return M[name] end\n"
"	\n"
"	local tab={} -- create new\n"
"	local sub={...} -- possibly multiple sub classes\n"
"\n"
"	if #sub>0 then -- inherit?\n"
"		for idx=#sub,1,-1 do -- reverse sub class order, so the ones to the left overwrite the ones on the right\n"
"			for i,v in pairs(sub[idx]) do tab[i]=v end -- each subclass overwrites all values\n"
"		end\n"
"	end\n"
"\n"
"	tab.__index=tab -- this metatable is its own index\n"
"\n"
"	M.mtype_lookup[name]=tab -- classtype metatable lookup\n"
"	M.mtype_lookup[tab]=name -- tab->name or name->tab\n"
"\n"
"	M[name]=tab\n"
"	return tab\n"
"end\n"
"\n"
"\n"
"\n"
"local array=class(\"array\")\n"
"\n"
"function array.__tostring(it) -- these classes are all just 1d arrays of numbers\n"
"	local t={}\n"
"	t[#t+1]=M.mtype(it)\n"
"	t[#t+1]=\"={\"\n"
"	for i=1,#it do\n"
"		t[#t+1]=tostring(it[i])\n"
"		if i~=#it then t[#t+1]=\", \" end\n"
"	end\n"
"	t[#t+1]=\"}\"\n"
"	return table.concat(t)\n"
"end\n"
"\n"
"function array.set(it,...)\n"
"	local n=1\n"
"	for i,v in ipairs{...} do\n"
"		if not it[n] then return it end -- got all the data we need (#it)\n"
"		if type(v)==\"number\" then\n"
"			it[n]=v\n"
"			n=n+1\n"
"		else\n"
"			for ii,vv in ipairs(v) do -- allow one depth of tables\n"
"				it[n]=vv\n"
"				n=n+1\n"
"			end\n"
"		end\n"
"	end\n"
"	return it\n"
"end\n"
"\n"
"function array.product(a,b,r)\n"
"	local mta=M.mtype(a)\n"
"	local mtb=M.mtype(b)\n"
"	if mta==\"m4\" then\n"
"		if     mtb==\"v3\" then\n"
"			return M.m4_product_v3(a,b,r)\n"
"		elseif mtb==\"v4\" then\n"
"			return M.m4_product_v4(a,b,r)\n"
"		elseif mtb==\"m4\" then\n"
"			return M.m4_product_m4(a,b,r)\n"
"		end\n"
"	elseif mta==\"q4\" then\n"
"		if     mtb==\"q4\" then\n"
"			return M.q4_product_q4(a,b,r)\n"
"		elseif mtb==\"v3\" then\n"
"			return M.q4_product_v3(a,b,r)\n"
"		end\n"
"	end\n"
"	error(\"tardis : \"..mta..\" product \"..mtb..\" not supported\",2)\n"
"end\n"
"\n"
"\n"
"local m2=class(\"m2\",array)\n"
"function m2.new(...) return setmetatable({0,0,0,0},m2):set(...) end\n"
"function m2.identity(it) return it:set(1,0, 0,1) end \n"
"function m2.determinant(it)\n"
"	return	 ( it[ 1 ]*it[ 2+2 ] )\n"
"			+( it[ 2 ]*it[ 2+1 ] )\n"
"			-( it[ 1 ]*it[ 2+1 ] )\n"
"			-( it[ 2 ]*it[ 2+1 ] )\n"
"end\n"
"function m2.minor_xy(it,x,y)\n"
"	return it[1+(2-(x-1))+((2-(y-1))*2)]\n"
"end\n"
"function m2.transpose(it,r)\n"
"	r=r or it\n"
"	return	 r:set(it[1],it[2+1], it[2],it[2+2])\n"
"end\n"
"function m2.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set(it[1]*s,it[2]*s, it[2+1]*s,it[2+2]*s)\n"
"end\n"
"function m2.cofactor(it,r)\n"
"	r=r or it\n"
"	local t={}\n"
"	for iy=1,2 do\n"
"		for ix=1,2 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=m2.minor_xy(it,ix,iy)\n"
"				if ((ix+iy)%2)==1 then t[#t]=-t[#t] end\n"
"			end\n"
"		end\n"
"	end\n"
"	return r\n"
"end\n"
"function m2.adjugate(it,r)\n"
"	r=r or it\n"
"	return m2.cofactor(m2.transpose(it,m2.new()),r)\n"
"end\n"
"function m2.inverse(it,r)\n"
"	r=r or it\n"
"	local ood=1/m2.determinant(it)	\n"
"	return m2.scale(m2.cofactor(m2.transpose(it,m2.new())),ood,r)\n"
"end\n"
"\n"
"local m3=class(\"m3\",m2)\n"
"function m3.new(...) return setmetatable({0,0,0,0,0,0,0,0,0},m3):set(...) end\n"
"function m3.identity(it) return it:set(1,0,0, 0,1,0, 0,0,1) end \n"
"function m3.determinant(it)\n"
"	return	 ( it[ 1 ]*it[ 3+2 ]*it[ 6+3 ] )\n"
"			+( it[ 2 ]*it[ 3+3 ]*it[ 6+1 ] )\n"
"			+( it[ 3 ]*it[ 3+1 ]*it[ 6+2 ] )\n"
"			-( it[ 1 ]*it[ 3+3 ]*it[ 6+2 ] )\n"
"			-( it[ 2 ]*it[ 3+1 ]*it[ 6+3 ] )\n"
"			-( it[ 3 ]*it[ 3+2 ]*it[ 6+1 ] )\n"
"end\n"
"function m3.minor_xy(it,x,y)\n"
"	local t={}\n"
"	for ix=1,3 do\n"
"		for iy=1,3 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=it[ix+((iy-1)*3)]\n"
"			end\n"
"		end\n"
"	end\n"
"	return m2.determinant(t)\n"
"end\n"
"function m3.transpose(it,r)\n"
"	r=r or it\n"
"	return	 r:set(it[1],it[3+1],it[6+1], it[2],it[3+2],it[6+2], it[3],it[3+3],it[6+3])\n"
"end\n"
"function m3.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set(it[1]*s,it[2]*s,it[3]*s, it[3+1]*s,it[3+2]*s,it[3+3]*s, it[6+1]*s,it[6+2]*s,it[6+3]*s)\n"
"end\n"
"function m3.cofactor(it,r)\n"
"	r=r or it\n"
"	local t={}\n"
"	for iy=1,3 do\n"
"		for ix=1,3 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=m3.minor_xy(it,ix,iy)\n"
"				if ((ix+iy)%2)==1 then t[#t]=-t[#t] end\n"
"			end\n"
"		end\n"
"	end\n"
"	return r:set(t)\n"
"end\n"
"function m3.adjugate(it,r)\n"
"	r=r or it\n"
"	return m3.cofactor(m3.transpose(it,m3.new()),r)\n"
"end\n"
"function m3.inverse(it,r)\n"
"	r=r or it\n"
"	local ood=1/m3.determinant(it)	\n"
"	return m3.scale(m3.cofactor(m3.transpose(it,m3.new())),ood,r)\n"
"end\n"
"\n"
"local m4=class(\"m4\",m3)\n"
"function m4.new(...) return setmetatable({0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},m4):set(...) end\n"
"function m4.identity(it) return it:set(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1) end \n"
"function m4.determinant(it)\n"
"return	(it[ 4 ] * it[ 4+3 ] * it[ 8+2 ] * it[ 12+1 ])-(it[ 3 ] * it[ 4+4 ] * it[ 8+2 ] * it[ 12+1 ])-\n"
"		(it[ 4 ] * it[ 4+2 ] * it[ 8+3 ] * it[ 12+1 ])+(it[ 2 ] * it[ 4+4 ] * it[ 8+3 ] * it[ 12+1 ])+\n"
"		(it[ 3 ] * it[ 4+2 ] * it[ 8+4 ] * it[ 12+1 ])-(it[ 2 ] * it[ 4+3 ] * it[ 8+4 ] * it[ 12+1 ])-\n"
"		(it[ 4 ] * it[ 4+3 ] * it[ 8+1 ] * it[ 12+2 ])+(it[ 3 ] * it[ 4+4 ] * it[ 8+1 ] * it[ 12+2 ])+\n"
"		(it[ 4 ] * it[ 4+1 ] * it[ 8+3 ] * it[ 12+2 ])-(it[ 1 ] * it[ 4+4 ] * it[ 8+3 ] * it[ 12+2 ])-\n"
"		(it[ 3 ] * it[ 4+1 ] * it[ 8+4 ] * it[ 12+2 ])+(it[ 1 ] * it[ 4+3 ] * it[ 8+4 ] * it[ 12+2 ])+\n"
"		(it[ 4 ] * it[ 4+2 ] * it[ 8+1 ] * it[ 12+3 ])-(it[ 2 ] * it[ 4+4 ] * it[ 8+1 ] * it[ 12+3 ])-\n"
"		(it[ 4 ] * it[ 4+1 ] * it[ 8+2 ] * it[ 12+3 ])+(it[ 1 ] * it[ 4+4 ] * it[ 8+2 ] * it[ 12+3 ])+\n"
"		(it[ 2 ] * it[ 4+1 ] * it[ 8+4 ] * it[ 12+3 ])-(it[ 1 ] * it[ 4+2 ] * it[ 8+4 ] * it[ 12+3 ])-\n"
"		(it[ 3 ] * it[ 4+2 ] * it[ 8+1 ] * it[ 12+4 ])+(it[ 2 ] * it[ 4+3 ] * it[ 8+1 ] * it[ 12+4 ])+\n"
"		(it[ 3 ] * it[ 4+1 ] * it[ 8+2 ] * it[ 12+4 ])-(it[ 1 ] * it[ 4+3 ] * it[ 8+2 ] * it[ 12+4 ])-\n"
"		(it[ 2 ] * it[ 4+1 ] * it[ 8+3 ] * it[ 12+4 ])+(it[ 1 ] * it[ 4+2 ] * it[ 8+3 ] * it[ 12+4 ])	\n"
"end\n"
"function m4.minor_xy(it,x,y)\n"
"	local t={}\n"
"	for ix=1,4 do\n"
"		for iy=1,4 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=it[ix+((iy-1)*4)]\n"
"			end\n"
"		end\n"
"	end\n"
"	return m3.determinant(t)\n"
"end\n"
"function m4.transpose(it,r)\n"
"	r=r or r\n"
"	return	 r:set(it[1],it[4+1],it[8+1],it[12+1], it[2],it[4+2],it[8+2],it[12+2], it[3],it[4+3],it[8+3],it[12+3], it[4],it[4+4],it[8+4],it[12+4])\n"
"end\n"
"function m4.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set(it[1]*s,it[2]*s,it[3]*s,it[4]*s, it[4+1]*s,it[4+2]*s,it[4+3]*s,it[4+4]*s, it[8+1]*s,it[8+2]*s,it[8+3]*s,it[8+4]*s, it[12+1]*s,it[12+2]*s,it[12+3]*s,it[12+4]*s)\n"
"end\n"
"function m4.cofactor(it,r)\n"
"	r=r or it\n"
"	local t={}\n"
"	for iy=1,4 do\n"
"		for ix=1,4 do\n"
"			if (ix~=x) and (iy~=y) then\n"
"				t[#t+1]=m4.minor_xy(it,ix,iy)\n"
"				if ((ix+iy)%2)==1 then t[#t]=-t[#t] end\n"
"			end\n"
"		end\n"
"	end\n"
"	return r:set(t)\n"
"end\n"
"function m4.adjugate(it,r)\n"
"	r=r or it\n"
"	return 	m4.cofactor(m4.transpose(it,m4.new()),r)\n"
"end\n"
"function m4.inverse(it,r)\n"
"	r=r or it\n"
"	local ood=1/m4.determinant(it)	\n"
"	return m4.scale(m4.cofactor(m4.transpose(it,m4.new())),ood,r)\n"
"end\n"
"function m4.identity(it)\n"
"	return it:set(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1)\n"
"end\n"
"function m4.translate(it,v3a,r)\n"
"	r=r or it\n"
"	local r1=it[12+1]+v3a[1]*it[1]+v3a[2]*it[5]+v3a[3]*it[9]\n"
"	local r2=it[12+2]+v3a[1]*it[2]+v3a[2]*it[6]+v3a[3]*it[10]\n"
"	local r3=it[12+3]+v3a[1]*it[3]+v3a[2]*it[7]+v3a[3]*it[11]\n"
"	return r:set(it[1],it[2],it[3],it[4], it[5],it[6],it[7],it[8], it[9],it[10],it[11],it[12], r1,r2,r3,it[16] )\n"
"end\n"
"\n"
"function m4.scale_v3(it,v3a,r)\n"
"	r=r or it\n"
"	local s1=v3a[1]\n"
"	local s2=v3a[2]\n"
"	local s3=v3a[3]\n"
"	return r:set(	s1*it[1],	s1*it[2],	s1*it[3],	s1*it[4],\n"
"					s2*it[5],	s2*it[6],	s2*it[7],	s2*it[8],\n"
"					s3*it[9],	s3*it[10],	s3*it[11],	s3*it[12],\n"
"					it[13],		it[14],		it[15],		it[16] )\n"
"end\n"
"\n"
"function m4.setrot(it,degrees,v3a)\n"
"\n"
"	local c=math.cos(-math.pi*degrees/180)\n"
"	local cc=1-c\n"
"	local s=math.sin(-math.pi*degrees/180)\n"
"	\n"
"	local x=v3a[1]\n"
"	local y=v3a[2]\n"
"	local z=v3a[3]\n"
"	\n"
"	local delta=0.001 -- a smallish number\n"
"	local dd=( (x*x) + (y*y) + (z*z) )\n"
"	if ( dd < (1-delta) ) or ( dd > (1+delta) ) then -- not even close to a unit vector\n"
"		local d=math.sqrt(dd)\n"
"		x=x/d\n"
"		y=y/d\n"
"		z=z/d\n"
"	end\n"
"\n"
"	return it:set(\n"
"		x*x*cc+c	,	x*y*cc-z*s	,	x*z*cc+y*s	, 	0	,\n"
"		x*y*cc+z*s	,	y*y*cc+c	,	y*z*cc-x*s	,	0	,\n"
"        x*z*cc-y*s	,	y*z*cc+x*s	,	z*z*cc+c	,	0	,\n"
"        0			,	0			,	0			,	1	)\n"
"\n"
"end\n"
"\n"
"function m4.rotate(it,degrees,v3a,r)\n"
"	local m4a=m4.new():setrot(degrees,v3a)\n"
"	return M.m4_product_m4(m4a,it,r)\n"
"end\n"
"\n"
"local v2=class(\"v2\",array)\n"
"function v2.new(...) return setmetatable({0,0},v2):set(...) end\n"
"function v2.identity(it) return it:set(0,0) end \n"
"function v2.lenlen(it)\n"
"	return (it[1]*it[1]) + (it[2]*it[2])\n"
"end\n"
"function v2.len(it)\n"
"	return math.sqrt( (it[1]*it[1]) + (it[2]*it[2]) )\n"
"end\n"
"function v2.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set( it[1]*s , it[2]*s )\n"
"end\n"
"function v2.normalize(it,r)\n"
"	return v2.scale(it,1/v2.len(it),r)\n"
"end\n"
"\n"
"local v3=class(\"v3\",v2)\n"
"function v3.new(...) return setmetatable({0,0,0},v3):set(...) end\n"
"function v3.identity(it) return it:set(0,0,0) end \n"
"function v3.lenlen(it)\n"
"	return (it[1]*it[1]) + (it[2]*it[2]) + (it[3]*it[3])\n"
"end\n"
"function v3.len(it)\n"
"	return math.sqrt( (it[1]*it[1]) + (it[2]*it[2]) + (it[3]*it[3]) )\n"
"end\n"
"function v3.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set( it[1]*s , it[2]*s , it[3]*s )\n"
"end\n"
"function v3.normalize(it,r)\n"
"	return v3.scale(it,1/v3.len(it),r)\n"
"end\n"
"function v3.add(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( va[1]+vb[1] , va[2]+vb[2] , va[3]+vb[3] )\n"
"end\n"
"function v3.sub(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( va[1]-vb[1] , va[2]-vb[2] , va[3]-vb[3] )\n"
"end\n"
"function v3.mul(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( (va[1]*vb[1]) , (va[2]*vb[2]) , (va[3]*vb[3]) )\n"
"end\n"
"function v3.dot(va,vb)\n"
"	return ( (va[1]*vb[1]) + (va[2]*vb[2]) + (va[3]*vb[3]) )\n"
"end\n"
"function v3.cross(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( (va[2]*vb[3])-(va[3]*vb[2]) , (va[3]*vb[1])-(va[1]*vb[3]) , (va[1]*vb[2])-(va[2]*vb[1]) )\n"
"end\n"
"\n"
"\n"
"local v4=class(\"v4\",v3)\n"
"function v4.new(...) return setmetatable({0,0,0,0},v4):set(...) end\n"
"function v4.identity(it) return it:set(0,0,0,0) end \n"
"function v4.to_v3(it,r) -- scale [4] to 1 then throw it away so we have a v3 xyz\n"
"	r=r or v3.new()\n"
"	local oow=1/it[4]\n"
"	return r:set( it[1]*oow , it[2]*oow , it[3]*oow )\n"
"end\n"
"function v4.lenlen(it)\n"
"	return (it[1]*it[1]) + (it[2]*it[2]) + (it[3]*it[3]) + (it[4]*it[4])\n"
"end\n"
"function v4.len(it)\n"
"	return math.sqrt( (it[1]*it[1]) + (it[2]*it[2]) + (it[3]*it[3]) + (it[4]*it[4]) )\n"
"end\n"
"function v4.scale(it,s,r)\n"
"	r=r or it\n"
"	return r:set( it[1]*s , it[2]*s , it[3]*s , it[4]*s )\n"
"end\n"
"function v4.normalize(it,r)\n"
"	return v4.scale(it,1/v4.len(it),r)\n"
"end\n"
"function v4.add(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( va[1]+vb[1] , va[2]+vb[2] , va[3]+vb[3] , va[4]+vb[4] )\n"
"end\n"
"function v4.sub(va,vb,r)\n"
"	r=r or va\n"
"	return r:set( va[1]-vb[1] , va[2]-vb[2] , va[3]-vb[3] , va[4]-vb[4] )\n"
"end\n"
"function v4.dot(va,vb)\n"
"	return ( (va[1]*vb[1]) + (va[2]*vb[2]) + (va[3]*vb[3]) + (va[4]*vb[4]) )\n"
"end\n"
"\n"
"\n"
"local q4=class(\"q4\",v4)\n"
"function q4.new(...) return setmetatable({0,0,0,1},q4):set(...) end\n"
"function q4.identity(it) return it:set(0,0,0,1) end \n"
"function q4.nlerp(qa,qb,sa,r)\n"
"	local sb=1-sa\n"
"	if qa.dot(qb) < 0 then sa=-sa end -- shortest fix\n"
"	r=r or va\n"
"	r:set( va[1]*sa+vb[1]*sb , va[2]*sa+vb[2]*sb , va[3]*sa+vb[3]*sb , va[4]*sa+vb[4]*sb )\n"
"	return r:normalize()\n"
"end\n"
"\n"
"function q4.setrot(it,degrees,v3a)\n"
"	local ah=degrees * (math.PI/360)\n"
"	local sh=math.sin(ah)\n"
"	return it:set( math.cos(ah) , v3a[1]*sh , v3a[2]*sh , v3a[3]*sh )\n"
"end\n"
"\n"
"function q4.rotate(it,degrees,v3a,r)\n"
"	local q4a=q4.new():setrot(degrees,v3a)\n"
"	return M.q4_product_q4(q4a,it,r)\n"
"end\n"
"\n"
"\n"
"\n"
"local line=class(\"line\",array)\n"
"line.set=nil -- disable\n"
"function line.new(...) return setmetatable({v3.new(),v3.new()},line) end -- [1]position , [2]normal\n"
"\n"
"local plane=class(\"plane\",line)\n"
"function plane.new(...) return setmetatable({v3.new(),v3.new()},plane) end -- [1]position , [2]normal\n"
"\n"
"\n"
"function M.line_intersect_plane(l,p,r)\n"
"	r=r or v3.new()\n"
"	local t=v3.new(p[1]):sub(l[1]) -- the line position relative to the plane\n"
"	local d=l[2]:dot(p[2]) -- the length of the line until it hits the plane\n"
"	if d~=0 then -- less errors please\n"
"		d=t:dot(p[2])/d\n"
"	end\n"
"	return r:set( l[1][1]+(l[2][1]*d) , l[1][2]+(l[2][2]*d) , l[1][3]+(l[2][3]*d) ) -- the point of intersection\n"
"end\n"
"\n"
"function M.q4_to_m4(q,m)\n"
"	if not m then m=m4.new() end\n"
"	local w,x,y,z=q[1],q[2],q[3],q[4]\n"
"    local xx,xy,xz,xw=x*x,x*y,x*z,x*w\n"
"    local    yy,yz,yw=    y*y,y*z,y*w\n"
"    local       zz,zw=        z*z,z*w\n"
"\n"
"	return m:set(\n"
"					1 - 2 * ( yy + zz ),\n"
"						2 * ( xy - zw ),\n"
"						2 * ( xz + yw ),0,\n"
"						2 * ( xy + zw ),\n"
"					1 - 2 * ( xx + zz ),\n"
"						2 * ( yz - xw ),0,\n"
"						2 * ( xz - yw ),\n"
"						2 * ( yz + xw ),\n"
"					1 - 2 * ( xx + yy ),0,\n"
"						0,0,0,1				)\n"
"end\n"
"\n"
"function M.q4_product_q4(q4a,q4b,r)\n"
"	r=r or q4b\n"
"    local r1 =  q4a[1] * q4b[4] + q4a[2] * q4b[3] - q4a[3] * q4b[2] + q4a[4] * q4b[1];\n"
"    local r2 = -q4a[1] * q4b[3] + q4a[2] * q4b[4] + q4a[3] * q4b[1] + q4a[4] * q4b[2];\n"
"    local r3 =  q4a[1] * q4b[2] - q4a[2] * q4b[1] + q4a[3] * q4b[4] + q4a[4] * q4b[3];\n"
"    local r4 = -q4a[1] * q4b[1] - q4a[2] * q4b[2] - q4a[3] * q4b[3] + q4a[4] * q4b[4];\n"
"	return r:set(r1,r2,r3,r4)\n"
"end\n"
"\n"
"function M.q4_product_v3(q4a,v3b,r)\n"
"	r=r or v3b\n"
"    local r1 =                    q4a[2] * v3b[3] - q4a[3] * v3b[2] + q4a[4] * v3b[1];\n"
"    local r2 = -q4a[1] * v3b[3]                   + q4a[3] * v3b[1] + q4a[4] * v3b[2];\n"
"    local r3 =  q4a[1] * v3b[2] - q4a[2] * v3b[1]                   + q4a[4] * v3b[3];\n"
"	return r:set(r1,r2,r3)\n"
"end\n"
"\n"
"function M.m4_product_v3(m4a,v3b,r)\n"
"	r=r or v3b\n"
"	local oow=1/( (m4a[   4]*v3b[1]) + (m4a[ 4+4]*v3b[2]) + (m4a[ 8+4]*v3b[3]) + (m4a[12+4] ) )\n"
"	local r1= oow * ( (m4a[   1]*v3b[1]) + (m4a[ 4+1]*v3b[2]) + (m4a[ 8+1]*v3b[3]) + (m4a[12+1] ) )\n"
"	local r2= oow * ( (m4a[   2]*v3b[1]) + (m4a[ 4+2]*v3b[2]) + (m4a[ 8+2]*v3b[3]) + (m4a[12+2] ) )\n"
"	local r3= oow * ( (m4a[   3]*v3b[1]) + (m4a[ 4+3]*v3b[2]) + (m4a[ 8+3]*v3b[3]) + (m4a[12+3] ) )\n"
"	return r:set(r1,r2,r3)\n"
"end\n"
"\n"
"function M.m4_product_m4(m4a,m4b,r)\n"
"	r=r or m4b\n"
"	local r1 = (m4a[   1]*m4b[   1]) + (m4a[   2]*m4b[ 4+1]) + (m4a[   3]*m4b[ 8+1]) + (m4a[   4]*m4b[12+1])\n"
"	local r2 = (m4a[   1]*m4b[   2]) + (m4a[   2]*m4b[ 4+2]) + (m4a[   3]*m4b[ 8+2]) + (m4a[   4]*m4b[12+2])\n"
"	local r3 = (m4a[   1]*m4b[   3]) + (m4a[   2]*m4b[ 4+3]) + (m4a[   3]*m4b[ 8+3]) + (m4a[   4]*m4b[12+3])\n"
"	local r4 = (m4a[   1]*m4b[   4]) + (m4a[   2]*m4b[ 4+4]) + (m4a[   3]*m4b[ 8+4]) + (m4a[   4]*m4b[12+4])\n"
"	local r5 = (m4a[ 4+1]*m4b[   1]) + (m4a[ 4+2]*m4b[ 4+1]) + (m4a[ 4+3]*m4b[ 8+1]) + (m4a[ 4+4]*m4b[12+1])\n"
"	local r6 = (m4a[ 4+1]*m4b[   2]) + (m4a[ 4+2]*m4b[ 4+2]) + (m4a[ 4+3]*m4b[ 8+2]) + (m4a[ 4+4]*m4b[12+2])\n"
"	local r7 = (m4a[ 4+1]*m4b[   3]) + (m4a[ 4+2]*m4b[ 4+3]) + (m4a[ 4+3]*m4b[ 8+3]) + (m4a[ 4+4]*m4b[12+3])\n"
"	local r8 = (m4a[ 4+1]*m4b[   4]) + (m4a[ 4+2]*m4b[ 4+4]) + (m4a[ 4+3]*m4b[ 8+4]) + (m4a[ 4+4]*m4b[12+4])\n"
"	local r9 = (m4a[ 8+1]*m4b[   1]) + (m4a[ 8+2]*m4b[ 4+1]) + (m4a[ 8+3]*m4b[ 8+1]) + (m4a[ 8+4]*m4b[12+1])\n"
"	local r10= (m4a[ 8+1]*m4b[   2]) + (m4a[ 8+2]*m4b[ 4+2]) + (m4a[ 8+3]*m4b[ 8+2]) + (m4a[ 8+4]*m4b[12+2])\n"
"	local r11= (m4a[ 8+1]*m4b[   3]) + (m4a[ 8+2]*m4b[ 4+3]) + (m4a[ 8+3]*m4b[ 8+3]) + (m4a[ 8+4]*m4b[12+3])\n"
"	local r12= (m4a[ 8+1]*m4b[   4]) + (m4a[ 8+2]*m4b[ 4+4]) + (m4a[ 8+3]*m4b[ 8+4]) + (m4a[ 8+4]*m4b[12+4])\n"
"	local r13= (m4a[12+1]*m4b[   1]) + (m4a[12+2]*m4b[ 4+1]) + (m4a[12+3]*m4b[ 8+1]) + (m4a[12+4]*m4b[12+1])\n"
"	local r14= (m4a[12+1]*m4b[   2]) + (m4a[12+2]*m4b[ 4+2]) + (m4a[12+3]*m4b[ 8+2]) + (m4a[12+4]*m4b[12+2])\n"
"	local r15= (m4a[12+1]*m4b[   3]) + (m4a[12+2]*m4b[ 4+3]) + (m4a[12+3]*m4b[ 8+3]) + (m4a[12+4]*m4b[12+3])\n"
"	local r16= (m4a[12+1]*m4b[   4]) + (m4a[12+2]*m4b[ 4+4]) + (m4a[12+3]*m4b[ 8+4]) + (m4a[12+4]*m4b[12+4])\n"
"	return r:set(r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15,r16)\n"
"end\n"
"\n"
"\n"
"--\n"
"-- build a simple field of view GL projection matrix designed to work in 2d or 3d and keep the numbers\n"
"-- easy for 2d positioning.\n"
"--\n"
"-- setting aspect to 640,480 and fov of 1 would mean at a z depth of 240 (which is y/2) then your view area would be\n"
"-- -320 to +320 in the x and -240 to +240 in the y.\n"
"--\n"
"-- fov is a tan like value (a view size inverse scalar) so 1 would be 90deg, 0.5 would be 45deg and so on\n"
"--\n"
"-- the depth parameter is only used to limit the range of the zbuffer so it covers 0 to depth\n"
"--\n"
"-- The following would be a reasonable default for an assumed 640x480 display.\n"
"--\n"
"-- m4_project23d(w,h,640,480,0.5,1024)\n"
"--\n"
"-- then at z=480 we would have one to one pixel scale...\n"
"-- the total view area volume from there would be -320 +320 , -240 +240 , -480 +(1024-480)\n"
"--\n"
"-- view_width and view_height must be the current width and height of the display in pixels or nil\n"
"-- we use this to wout out where to place our view such that it is always visible and keeps its aspect.\n"
"--\n"
"function M.m4_project23d(view_width,view_height,width,height,fov,depth)\n"
"\n"
"	local aspect=height/width\n"
"\n"
"	local m=m4.new()\n"
"	\n"
"	local f=depth\n"
"	local n=1\n"
"\n"
"	local win_aspect=((view_height or height)/(view_width or width))\n"
"		\n"
"	if (win_aspect > (aspect) ) 	then 	-- fit width to screen\n"
"	\n"
"		m[1] = ((aspect)*1)/fov\n"
"		m[6] = -((aspect)/win_aspect)/fov\n"
"		\n"
"	else									-- fit height to screen\n"
"	\n"
"		m[1] = win_aspect/fov\n"
"		m[6] = -1/fov\n"
"		\n"
"	end\n"
"	\n"
"	\n"
"	m[11] = -(f+n)/(f-n)\n"
"	m[12] = -1\n"
"\n"
"	m[15] = -2*f*n/(f-n)\n"
"	\n"
"	return m\n"
"end\n"
"\n"
"\n"
"--upgrade the above to hopefully faster C versions working on userdata arrays of floats\n"
"\n"
"local tcore=require(\"wetgenes.tardis.core\") -- use a \"faster?\" f32 C core\n"
"\n"
"-- allow read/write with magical [] lookups\n"
"function array.__len(it) return 1 end\n"
"function array.__index(it,n) return array[n] or tcore.read(it,n) end\n"
"function array.__newindex(it,n,v) tcore.write(it,n,v) end\n"
"\n"
"-- initialise an array\n"
"function array.set(it,...) tcore.set(it,...) return it end\n"
"\n"
"m2.set=array.set\n"
"m3.set=array.set\n"
"m4.set=array.set\n"
"\n"
"function m2.new(...) return tcore.alloc(4* 4,m2):set(...) end\n"
"function m3.new(...) return tcore.alloc(4* 9,m3):set(...) end\n"
"function m4.new(...) return tcore.alloc(4*16,m4):set(...) end\n"
"\n"
"function m2.__len(it) return 4 end\n"
"function m3.__len(it) return 9 end\n"
"function m4.__len(it) return 16 end\n"
"\n"
"function m2.__index(it,n) return m2[n] or tcore.read(it,n) end\n"
"function m3.__index(it,n) return m3[n] or tcore.read(it,n) end\n"
"function m4.__index(it,n) return m4[n] or tcore.read(it,n) end\n"
"\n"
"m2.__newindex=array.__newindex\n"
"m3.__newindex=array.__newindex\n"
"m4.__newindex=array.__newindex\n"
"\n"
"v2.set=array.set\n"
"v3.set=array.set\n"
"v4.set=array.set\n"
"q4.set=array.set\n"
"\n"
"function v2.new(...) return tcore.alloc(4* 2,v2):set(...) end\n"
"function v3.new(...) return tcore.alloc(4* 3,v3):set(...) end\n"
"function v4.new(...) return tcore.alloc(4* 4,v4):set(...) end\n"
"function q4.new(...) return tcore.alloc(4* 4,q4):set(...) end\n"
"\n"
"function v2.__len(it) return 2 end\n"
"function v3.__len(it) return 3 end\n"
"function v4.__len(it) return 4 end\n"
"function q4.__len(it) return 4 end\n"
"\n"
"function v2.__index(it,n) return v2[n] or tcore.read(it,n) end\n"
"function v3.__index(it,n) return v3[n] or tcore.read(it,n) end\n"
"function v4.__index(it,n) return v4[n] or tcore.read(it,n) end\n"
"function q4.__index(it,n) return q4[n] or tcore.read(it,n) end\n"
"\n"
"v2.__newindex=array.__newindex\n"
"v3.__newindex=array.__newindex\n"
"v4.__newindex=array.__newindex\n"
"q4.__newindex=array.__newindex\n"
"\n"
"-- replace some functions with C code\n"
"\n"
"M.m4_product_m4		=	tcore.m4_product_m4\n"
"\n"
"m4.identity			=	tcore.m4_identity\n"
"m4.rotate			=	tcore.m4_rotate\n"
"m4.scale_v3			=	tcore.m4_scale_v3\n"
"m4.translate		=	tcore.m4_translate\n"
"\n"
"		\n"
"--[[\n"
"print(\"test\")\n"
"local m=m4.new()--:indentity()\n"
"print(\"m4\",m)\n"
"m:identity()\n"
"print(\"m4\",m)\n"
"m:scale_v3(2,2,2)\n"
"print(\"m4\",m)\n"
"m:translate(2,2,2)\n"
"print(\"m4\",m)\n"
"\n"
"\n"
"print(\"test\")\n"
"local m=m2.new()--:indentity()\n"
"print(\"m2\",m)\n"
"m:identity()\n"
"print(\"m2\",m)\n"
"m:scale(2)\n"
"print(\"m2\",m)\n"
"\n"
"os.exit(0)\n"
"]]\n"
"\n"
"",

"wetgenes.fenestra.widget.master","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"-- widget class master\n"
"-- the master widget\n"
"\n"
"\n"
"\n"
"local gl=require('gl')\n"
"\n"
"module(\"fenestra.widget.master\")\n"
"\n"
"--\n"
"-- add meta functions\n"
"--\n"
"function setup(widget,def)\n"
"\n"
"	local master=widget\n"
"	local meta=widget.meta\n"
"--	local win=def.win\n"
"\n"
"	master.throb=0\n"
"	master.fbo=_G.win.fbo(0,0,0) -- use an fbo\n"
"\n"
"-- the master gets some special overloaded functions to do a few more things\n"
"	function master.update(widget)\n"
"	\n"
"		local throb=(widget.throb<128)\n"
"		\n"
"		widget.throb=widget.throb-4\n"
"		if widget.throb<0 then widget.throb=255 end\n"
"		\n"
"		if throb ~= (widget.throb<128) then -- dirty throb...\n"
"			if widget.focus then\n"
"				if widget.focus.class==\"textedit\" then\n"
"					widget.focus:set_dirty()\n"
"				end\n"
"			end\n"
"		end\n"
"\n"
"		meta.update(widget)\n"
"	end\n"
"	\n"
"	function master.layout(widget)\n"
"		meta.layout(widget)\n"
"		master.remouse(widget)\n"
"	end\n"
"\n"
"	local dirty_fbos={}\n"
"	local find_dirty_fbos\n"
"	find_dirty_fbos=function(widget)\n"
"		if widget.fbo and widget.dirty then\n"
"			dirty_fbos[ #dirty_fbos+1 ]=widget\n"
"		end\n"
"		for i,v in ipairs(widget) do\n"
"			find_dirty_fbos(v)\n"
"		end\n"
"	end\n"
"	\n"
"	function master.draw(widget)\n"
"		dirty_fbos={}\n"
"		find_dirty_fbos(widget)\n"
"	\n"
"		gl.Disable(gl.CULL_FACE)\n"
"		gl.Disable(gl.LIGHTING)\n"
"		gl.Disable(gl.DEPTH_TEST)\n"
"		gl.PushMatrix()\n"
"		\n"
"		if #dirty_fbos>0 then\n"
"			for i=#dirty_fbos,1,-1 do -- call in reverse so sub fbos can work\n"
"				meta.draw(dirty_fbos[i]) -- dirty, so this only builds the fbo\n"
"			end\n"
"		end\n"
"		\n"
"		meta.draw(widget)\n"
"		\n"
"		gl.PopMatrix()\n"
"	end\n"
"	\n"
"--\n"
"-- handle key input\n"
"--\n"
"	function master.key(widget,ascii,key,act)\n"
"\n"
"		if master.focus then -- key focus\n"
"		\n"
"			master.focus:key(ascii,key,act)\n"
"		end\n"
"\n"
"	end\n"
"\n"
"--\n"
"-- set the mouse position to its last position\n"
"-- call this after adding/removing widgets to make sure they highlight properly\n"
"--	\n"
"	function master.remouse(widget)\n"
"		local p=widget.last_mouse_position or {0,0}\n"
"		widget.mouse(widget,nil,p[1],p[2],nil)\n"
"	end\n"
"--\n"
"-- handle mouse input\n"
"--	\n"
"	function master.mouse(widget,act,x,y,key)\n"
"	\n"
"		master.last_mouse_position={x,y}\n"
"	\n"
"--		if widget.state==\"ready\" then\n"
"		\n"
"			if master.active and (master.active.parent.class==\"slide\" or master.active.parent.class==\"oldslide\") then -- slide :)\n"
"			\n"
"				local w=master.active\n"
"				local p=master.active.parent\n"
"				\n"
"				local minx=p.pxd\n"
"				local miny=p.pyd-p.hy+w.hy\n"
"				local maxx=p.pxd+p.hx-w.hx\n"
"				local maxy=p.pyd\n"
"				\n"
"				w.pxd=x-master.active_x\n"
"				w.pyd=y-master.active_y\n"
"				\n"
"				if w.pxd<minx then w.pxd=minx end\n"
"				if w.pxd>maxx then w.pxd=maxx end\n"
"				if w.pyd<miny then w.pyd=miny end\n"
"				if w.pyd>maxy then w.pyd=maxy end\n"
"				\n"
"				w.px=w.pxd-p.pxd\n"
"				w.py=p.pyd-w.pyd\n"
"			\n"
"				w:call_hook(\"slide\")\n"
"				\n"
"				w:set_dirty()\n"
"\n"
"			end\n"
"			\n"
"			local old_active=master.active\n"
"			local old_over=master.over\n"
"			for i,v in ipairs(widget) do\n"
"				meta.mouse(v,act,x,y,key)\n"
"			end\n"
"			\n"
"			if act==\"up\" then\n"
"				master.active=nil\n"
"			end\n"
"			\n"
"--mark as dirty\n"
"			if master.active~=old_active then\n"
"				if master.active then master.active:set_dirty() end\n"
"				if old_active then old_active:set_dirty() end\n"
"			end\n"
"			if master.over~=old_over then\n"
"				if master.over then master.over:set_dirty() end\n"
"				if old_over then old_over:set_dirty() end\n"
"			end\n"
"			\n"
"--		end\n"
"	end\n"
"--\n"
"end\n"
"",

"wetgenes.fenestra.widget.text","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.text\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"\r\n"
"	if widget.data then\r\n"
"		widget.text=widget.data:get_string()\r\n"
"	end\r\n"
"\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.button=it\r\n"
"	widget.class=\"text\"\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.draw=draw\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"",

"wetgenes.gamecake.fonts","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local zips=require(\"wetgenes.zips\")\n"
"\n"
"local ft=require(\"wetgenes.freetype\")\n"
"local grd=require(\"wetgenes.grd\")\n"
"local wwin=require(\"wetgenes.win\")\n"
"\n"
"local core=require(\"wetgenes.gamecake.core\")\n"
"\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"function M.bake(oven,fonts)\n"
"\n"
"	fonts.data={}\n"
"	\n"
"	local opts=oven.opts\n"
"	local cake=oven.cake\n"
"	local gl=oven.gl\n"
"\n"
"	fonts.zip=opts.zip\n"
"	fonts.prefix=opts.fontprefix or \"data/fonts/\"\n"
"	fonts.postfix=opts.fontpostfix or \".ttf\"\n"
"\n"
"\n"
"fonts.get=function(id)\n"
"	return fonts.data[id]\n"
"end\n"
"\n"
"fonts.set=function(id,d)\n"
"	fonts.data[id]=d\n"
"end\n"
"\n"
"\n"
"--\n"
"-- unload a previously loaded image\n"
"--\n"
"fonts.unload=function(id)\n"
"	\n"
"	local t=fonts.get(id)\n"
"\n"
"	if t then\n"
"		if gl then --gl mode\n"
"			for i,v in pairs(t.images or {}) do -- delete all the chars\n"
"				cake.images.unload( v.id )\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	fonts.set(id,nil)\n"
"end\n"
"\n"
"--\n"
"-- load a single image, and make it easy to lookup by the given id\n"
"--\n"
"fonts.load=function(filename,id)\n"
"	local t=fonts.get(id)\n"
"	\n"
"	if t then return t end --first check it is not already loaded\n"
"\n"
"	if type(filename)==\"number\" then -- builtin font id, so far we only have this one\n"
"\n"
"--print(\"Loading font 8x8\")\n"
"--oven.preloader(\"font 8x8\") --the preloader expects this font so do not confuse it\n"
"\n"
"		if gl then --gl mode\n"
"		\n"
"			t={}\n"
"			t.filename=filename\n"
"			fonts.set(id,t)\n"
"			t.size=8\n"
"\n"
"			t.chars={}\n"
"			t.images={}\n"
"			\n"
"			local g=grd.create(grd.FMT_U8_RGBA_PREMULT,16*16,16*16,1)\n"
"\n"
"			for i=32,127 do -- setup base textures for 7bit ascii\n"
"				\n"
"				local idx=math.floor((i-32)%16) -- 0-31 are unprintable chars\n"
"				local idy=math.floor((i-32)/16)\n"
"				\n"
"				local c={}\n"
"				t.chars[i]=c\n"
"				\n"
"				c.image=1\n"
"				\n"
"				c.add=8 -- character draw width which may be fractional\n"
"\n"
"				c.tx=(idx*16)+4\n"
"				c.ty=(idy*16)+4\n"
"\n"
"				c.x=-1 -- offsets to draw the bitmap at, whole pixels\n"
"				c.y=-1\n"
"				c.w=10 --size to draw, a 1 pixel border is good to have\n"
"				c.h=10\n"
"				\n"
"				c.u1=(c.tx-1)/(16*16)\n"
"				c.u2=(c.tx+9)/(16*16)\n"
"				c.v1=(c.ty-1)/(16*16)\n"
"				c.v2=(c.ty+9)/(16*16)\n"
"\n"
"				g:pixels(c.tx,c.ty,8,8,wwin.glyph_8x8(i)) -- splat into grid\n"
"\n"
"			end\n"
"\n"
"			t.images[1]=cake.images.upload_grd(nil,g) -- send to opengl\n"
"\n"
"		end\n"
"		\n"
"	else\n"
"\n"
"		local fname=fonts.prefix..filename..fonts.postfix\n"
"		\n"
"		local d=assert(zips.readfile(fname))\n"
"\n"
"--print(\"Loading font \",fname,#d)		\n"
"oven.preloader(fname)\n"
"\n"
"		if gl then --gl mode\n"
"		\n"
"			t={}\n"
"			t.filename=filename\n"
"			fonts.set(id,t)\n"
"			\n"
"			t.font=ft.create()\n"
"			t.data=d -- keep the data alive (the loader expects it to continue to exist)\n"
"			t.font:load_data(t.data)\n"
"			\n"
"			\n"
"			t.size=30\n"
"			t.font:size(t.size,t.size) -- render at 32x32 pixel size, all future numbers are relative to this size\n"
"			\n"
"			t.chars={}\n"
"			t.images={}\n"
"			\n"
"			local g=grd.create(grd.FMT_U8_RGBA_PREMULT,32*16,32*16,1)\n"
"			\n"
"			local gt=grd.create() -- tempory buffer\n"
"			for i=32,127 do -- setup base textures for 7bit ascii\n"
"\n"
"				local idx=math.floor((i-32)%16) -- 0-31 are unprintable chars\n"
"				local idy=math.floor((i-32)/16)\n"
"\n"
"				t.font:render(i) -- render\n"
"				t.font:grd(gt) -- copy to grd\n"
"				gt:convert(grd.FMT_U8_RGBA_PREMULT)\n"
"				\n"
"--				local c=fonts.cake.images.upload_grd(nil,g) -- send to opengl\n"
"				local c={}\n"
"				t.chars[i]=c\n"
"				\n"
"				c.image=1\n"
"				\n"
"				c.x=t.font.bitmap_left -- offsets to draw the bitmap at, whole pixels\n"
"				c.y=t.size-t.font.bitmap_top\n"
"--				c.add=math.floor(t.font.advance) -- character draw width\n"
"				c.add=t.font.advance -- character draw width possibly fractional\n"
"				\n"
"				c.w=gt.width\n"
"				c.h=gt.height\n"
"				\n"
"				c.tx=(idx*32)+1\n"
"				c.ty=(idy*32)+1\n"
"\n"
"				c.u1=(c.tx-1)    /(32*16)\n"
"				c.u2=(c.tx+c.w+1)/(32*16)\n"
"				c.v1=(c.ty-1)    /(32*16)\n"
"				c.v2=(c.ty+c.h+1)/(32*16)\n"
"				\n"
"				if c.w>=1 and c.h>=1 then -- must have size?\n"
"				\n"
"					local b=gt:pixels(0,0,c.w,c.h)\n"
"					g:pixels(c.tx,c.ty,c.w,c.h, b ) -- splat into grid\n"
"					\n"
"					-- remember border\n"
"					c.x=c.x-1\n"
"					c.y=c.y-1\n"
"					c.w=c.w+2\n"
"					c.h=c.h+2\n"
"					\n"
"				end\n"
"\n"
"			end\n"
"\n"
"	-- we keep the ttf font in memory around so we can reload chars or load new chars as we need them\n"
"\n"
"			t.images[1]=cake.images.upload_grd(nil,g) -- send to opengl\n"
"\n"
"			\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	if t then\n"
"		core.fontdata_sync(t)\n"
"	end\n"
"\n"
"	return t\n"
"	\n"
"end\n"
"\n"
"--\n"
"-- load many images from id=filename table\n"
"--\n"
"fonts.loads=function(tab)\n"
"\n"
"	for i,v in pairs(tab) do\n"
"	\n"
"		if type(i)==\"number\" then -- just use filename twice\n"
"			fonts.load(v,v)\n"
"		else\n"
"			fonts.load(v,i)\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"fonts.start = function()\n"
"\n"
"	for v,n in pairs(fonts.remember or {}) do\n"
"		fonts.load(v,n)\n"
"	end\n"
"	fonts.remember=nil\n"
"end\n"
"\n"
"fonts.stop = function()\n"
"\n"
"	fonts.remember={}\n"
"	\n"
"	for n,t in pairs(fonts.data) do\n"
"\n"
"		fonts.remember[t.filename]=n		\n"
"		fonts.unload(n)\n"
"\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"	return fonts\n"
"end\n"
"\n"
"\n"
"\n"
"",

"wetgenes.www.gae.img","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local core=require(\"wetgenes.www.gae.img.core\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.img\"]=_M\n"
"\n"
"\n"
"function get(...)\n"
"\n"
"	return core.get(...)\n"
"\n"
"end\n"
"\n"
"function resize(...)\n"
"\n"
"	return core.resize(...)\n"
"\n"
"end\n"
"\n"
"function composite(...)\n"
"\n"
"	return core.composite(...)\n"
"\n"
"end\n"
"",

"wetgenes.gamecake.sheets","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local grd=require(\"wetgenes.grd\")\n"
"local pack=require(\"wetgenes.pack\")\n"
"\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"function M.bake(oven,sheets)\n"
"\n"
"local base_sheet={}\n"
"local meta_sheet={__index=base_sheet}\n"
"\n"
"	local sheets={}\n"
"		\n"
"	sheets.data={}\n"
"	\n"
"	local opts=oven.opts\n"
"	local cake=oven.cake\n"
"	local gl=oven.gl\n"
"	local images=cake.images\n"
"	\n"
"sheets.get=function(id)\n"
"	return id and sheets.data[id]\n"
"end\n"
"\n"
"sheets.set=function(d,id)\n"
"	if not id then id = #sheets.data+1 end\n"
"	sheets.data[id]=d\n"
"end\n"
"\n"
"sheets.start=function()\n"
"	for i,v in pairs(sheets.data) do -- refresh image data after a stop\n"
"		if v.img_id and not v.img then\n"
"			v.img=images.get(v.img_id)\n"
"			if v.img then\n"
"				v:build_vbuf()\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"end\n"
"\n"
"sheets.stop=function()\n"
"	for i,v in pairs(sheets.data) do -- forget everything\n"
"		v.img=nil\n"
"		v:free_vbuf()\n"
"	end\n"
"end\n"
"\n"
"sheets.create=function(id)\n"
"\n"
"	local sheet=sheets.get(id)\n"
"	if sheet then return sheet end\n"
"	\n"
"	sheet={}\n"
"	sheet.sheets=sheets\n"
"	setmetatable(sheet,meta_sheet)\n"
"\n"
"	sheets.set(sheet,id)\n"
"\n"
"	return sheet\n"
"end\n"
"\n"
"sheets.createimg=function(id)\n"
"	return sheets.create(id):setimg(id)\n"
"end\n"
"\n"
"--\n"
"-- Load images and chop them up\n"
"--\n"
"sheets.loads_and_chops=function(tab)\n"
"\n"
"	for i,v in ipairs(tab) do\n"
"\n"
"		images.load(v[1],v[1])\n"
"		local img=sheets.createimg(v[1])\n"
"		img:chop(v[2],v[3],v[4],v[5],v[6],v[7])\n"
"		\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"function base_sheet.setimg(sheet,img_id)\n"
"\n"
"	sheet.img_id=img_id\n"
"	sheet.img=images.get(sheet.img_id)\n"
"\n"
"	return sheet\n"
"end\n"
"\n"
"\n"
"function base_sheet.chop(sheet,hx,hy,ox,oy,bx,by)\n"
"\n"
"	hx=hx or 1\n"
"	hy=hy or 1\n"
"\n"
"	ox=ox or 0\n"
"	oy=oy or 0\n"
"\n"
"	bx=bx or 0\n"
"	by=by or 0\n"
"	\n"
"-- coords are fractions of image, so the image can scale up/down but the code remains constant\n"
"	bx=bx*sheet.img.width\n"
"	by=by*sheet.img.height\n"
"	hx=hx*sheet.img.width\n"
"	hy=hy*sheet.img.height\n"
"	ox=ox*sheet.img.width\n"
"	oy=oy*sheet.img.height\n"
"	\n"
"	sheet.cx=math.floor( sheet.img.width / hx )\n"
"	sheet.cy=math.floor( sheet.img.height / hy )\n"
"	sheet.cc=sheet.cx*sheet.cy\n"
"	\n"
"	for iy=1,sheet.cy do\n"
"		for ix=1,sheet.cx do\n"
"			local i=(iy-1)*sheet.cx + ix\n"
"			local c={}\n"
"			sheet[i]=c\n"
"			c.sheet=sheet\n"
"			c.px=(ix-1)*hx+bx\n"
"			c.py=(iy-1)*hy+by\n"
"			c.hx=hx-bx*2\n"
"			c.hy=hy-by*2\n"
"			c.ox=ox-bx\n"
"			c.oy=oy-by\n"
"		end\n"
"	end\n"
"	\n"
"	sheet:build_vbuf()\n"
"	\n"
"	return sheet\n"
"end\n"
"\n"
"-- free the sheets vertex buffer\n"
"function base_sheet.free_vbuf(sheet)\n"
"\n"
"	if sheet.vbuf then -- free any previously allocated buffer\n"
"		gl.DeleteBuffer(sheet.vbuf)\n"
"	end\n"
"	\n"
"	sheet.vdat=nil\n"
"	sheet.vbuf=nil\n"
"\n"
"	return sheet\n"
"end\n"
"\n"
"-- buildvertex buffer containing all sprites in the sheet\n"
"function base_sheet.build_vbuf(sheet)\n"
"\n"
"	sheet:free_vbuf()\n"
"	\n"
"	sheet.vdat=pack.alloc(#sheet*4*5*4) -- 4 vertexs per sprite, 5 floats per vertex\n"
"	\n"
"	local tw=sheet.img.texture_width -- hacks for cards that do not suport non power of two texture sizes\n"
"	local th=sheet.img.texture_height -- we just use a part of this bigger texture\n"
"\n"
"--print(\"sheet\",#sheet,#sheet*4*5*4,(#sheet-1)*4*5*4,5*4)\n"
"\n"
"	for i,v in ipairs(sheet) do\n"
"		\n"
"--		local cxw=cx+cw\n"
"--		local cyh=cy+ch\n"
"		\n"
"		local ixw=(v.px+v.hx)/tw\n"
"		local iyh=(v.py+v.hy)/th\n"
"		local ix=v.px/tw\n"
"		local iy=v.py/th\n"
"\n"
"--print((i-1)*4*5*4,5*4)\n"
"		pack.save_array({\n"
"			0-v.ox,		0-v.oy,		0,		ix,		iy,\n"
"			v.hx-v.ox,	0-v.oy,		0,		ixw,	iy,\n"
"			0-v.ox,		v.hy-v.oy,	0,		ix,		iyh,\n"
"			v.hx-v.ox,	v.hy-v.oy,	0,		ixw,	iyh,\n"
"		},\"f32\",(i-1)*4*5*4,5*4,sheet.vdat)	\n"
"	\n"
"	end\n"
"	\n"
"	sheet.vbuf=gl.GenBuffer()\n"
"	gl.BindBuffer(gl.ARRAY_BUFFER,sheet.vbuf)\n"
"	gl.BufferData(gl.ARRAY_BUFFER,#sheet*4*5*4,sheet.vdat,gl.STATIC_DRAW)\n"
"\n"
"	return sheet\n"
"end\n"
"\n"
"function base_sheet.batch_draw(sheet)\n"
"\n"
"	gl.BindTexture(gl.TEXTURE_2D,sheet.img.id)	\n"
"	cake.canvas.flat.tristrip(\"xyzuv\",sheet.batch)\n"
"\n"
"end\n"
"\n"
"function base_sheet.batch_start(sheet)\n"
"	sheet.batch={}\n"
"	sheet.batch_record=true\n"
"end\n"
"\n"
"function base_sheet.batch_stop(sheet)\n"
"	sheet.batch_record=false\n"
"end\n"
"\n"
"function base_sheet.draw(sheet,i,px,py,rz,sx,sy,zf)\n"
"\n"
"	zf=zf or 0 -- allow z fix hacks\n"
"\n"
"	if i<1 or i>#sheet then error(\"sheet index out of bounds \"..i..\" of \"..#sheet) end\n"
"	\n"
"	if sheet.batch_record then -- cache for later drawing (rz is currently ignored, soz)\n"
"		local v=sheet[i]\n"
"		\n"
"		local tw=sheet.img.texture_width -- hacks for cards that do not suport non power of two texture sizes\n"
"		local th=sheet.img.texture_height -- we just use a part of this bigger texture\n"
"\n"
"		local ixw=(v.px+v.hx)/tw\n"
"		local iyh=(v.py+v.hy)/th\n"
"		local ix=v.px/tw\n"
"		local iy=v.py/th\n"
"\n"
"		\n"
"		if sx then\n"
"			sy=sy or sx\n"
"			sx=sx/v.hx\n"
"			sy=sy/v.hy\n"
"		else\n"
"			sx=1\n"
"			sy=1\n"
"		end\n"
"		\n"
"		local ox=v.ox*sx\n"
"		local oy=v.oy*sy\n"
"		local hx=v.hx*sx\n"
"		local hy=v.hy*sy\n"
"\n"
"		local t=\n"
"		{\n"
"			px-ox,		py-oy,		zf,		ix,		iy,\n"
"			px-ox,		py-oy,		zf,		ix,		iy,\n"
"			px+hx-ox,	py-oy,		zf,		ixw,	iy,\n"
"			px-ox,		py+hy-oy,	zf,		ix,		iyh,\n"
"			px+hx-ox,	py+hy-oy,	zf,		ixw,	iyh,\n"
"			px+hx-ox,	py+hy-oy,	zf,		ixw,	iyh,\n"
"		}\n"
"		\n"
"		for i,v in ipairs(t) do\n"
"			sheet.batch[ #sheet.batch+1 ]=v\n"
"		end\n"
"		\n"
"		return sheet\n"
"	end\n"
"\n"
"	if px then\n"
"		gl.MatrixMode(gl.MODELVIEW)\n"
"		gl.PushMatrix()\n"
"		gl.Translate(px,py,0)\n"
"		if rz then\n"
"			gl.Rotate(rz,0,0,1)\n"
"		end\n"
"		if sx then\n"
"			sy=sy or sx\n"
"			gl.Scale(sx/sheet[i].hx,sy/sheet[i].hy,1) -- fixed, ignore the base size of image when we scale. So size is absolute\n"
"		end\n"
"	end\n"
"	\n"
"	\n"
"	local p=gl.program(\"pos_tex\")\n"
"	\n"
"	gl.BindBuffer(gl.ARRAY_BUFFER,sheet.vbuf)\n"
"\n"
"	gl.UseProgram( p[0] )\n"
"	gl.UniformMatrix4f(p:uniform(\"modelview\"), gl.matrix(gl.MODELVIEW) )\n"
"	gl.UniformMatrix4f(p:uniform(\"projection\"), gl.matrix(gl.PROJECTION) )\n"
"\n"
"	gl.VertexAttribPointer(p:attrib(\"a_vertex\"),3,gl.FLOAT,gl.FALSE,5*4,0)\n"
"	gl.EnableVertexAttribArray(p:attrib(\"a_vertex\"))\n"
"		\n"
"	gl.VertexAttribPointer(p:attrib(\"a_texcoord\"),2,gl.FLOAT,gl.FALSE,5*4,3*4)\n"
"	gl.EnableVertexAttribArray(p:attrib(\"a_texcoord\"))\n"
"	\n"
"	gl.BindTexture(gl.TEXTURE_2D,sheet.img.id)\n"
"	gl.Uniform4f(p:uniform(\"color\"), gl.cache.color )\n"
"	gl.core.DrawArrays(gl.TRIANGLE_STRIP,(i-1)*4,4)\n"
"\n"
"	if px then\n"
"		gl.PopMatrix()\n"
"	end\n"
"	\n"
"--	gl.fix.cache.UseProgram=p[0]\n"
"\n"
"	return sheet\n"
"\n"
"end\n"
"\n"
"	\n"
"	return sheets\n"
"end\n"
"\n"
"",

"wetgenes.simpxml","--\r\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\r\n"
"-- This file is distributed under the terms of the MIT license.\r\n"
"-- http://en.wikipedia.org/wiki/MIT_License\r\n"
"-- Please ping me if you use it for anything cool...\r\n"
"--\r\n"
"\r\n"
"local table=table\r\n"
"local string=string\r\n"
"\r\n"
"local ipairs=ipairs\r\n"
"local pairs=pairs\r\n"
"\r\n"
"local type=type\r\n"
"\r\n"
"local print=log or print\r\n"
"local assert=assert\r\n"
"\r\n"
"module(...)\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- some old simple xml parsing code, found here and fixed up a little :)\r\n"
"--\r\n"
"-- http://lua-users.org/lists/lua-l/2002-06/msg00040.html\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- auxiliar function to parse tag attributes\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function parse_args(s,label)\r\n"
"  local arg = {}\r\n"
"  arg[0]=label\r\n"
"  string.gsub(s, \"([%w_]+)%s*=%s*([\\\"'])(.-)%2\", function (w, _, a)\r\n"
"    arg[string.lower(w)] = a\r\n"
"  end)\r\n"
"  return arg\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- string \"s\" is a string with XML marks. This function parses the string\r\n"
"-- and returns the resulting tree.\r\n"
"--\r\n"
"-- simple but will parse small basic data xml files just fine and thats what im using it for\r\n"
"--\r\n"
"-- it is however very easy to produce a valid xml file that will break this...\r\n"
"-- but, as long as you are just using tags/data then this is fine\r\n"
"--\r\n"
"-- by putting the tag name in [0] we can use the string namespace for all attributes\r\n"
"-- and can iterate over the table entries 1+ in a normal way\r\n"
"--\r\n"
"-- [0] == tag name\r\n"
"-- [1++] == contained strings or tables (sub tags)\r\n"
"-- [stringnames] == attributes IE all string keys\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function parse(s)\r\n"
"  local stack = {}\r\n"
"  local top = {}\r\n"
"  table.insert(stack, top)\r\n"
"  local i = 1\r\n"
"\r\n"
"local ret_stack=2 -- we start by assuming we will be skipping a header\r\n"
"\r\n"
"  local warnings\r\n"
"  local warn=function(s)\r\n"
"	if not warnings then warnings={} end\r\n"
"	warnings[#warnings+1]=s\r\n"
"  end\r\n"
"\r\n"
"\r\n"
"\r\n"
"	local j2\r\n"
"-- find header\r\n"
"  local ni,j,c,label,args, empty = string.find(s, \"<%?(%/?)([%w_]+)(.-)(%/?)%?>\")\r\n"
"  \r\n"
"  if not ni then -- ignore missing <? tag header at start\r\n"
"	ret_stack=1\r\n"
"	ni,j,c,label,args, empty = string.find(s, \"<(%/?)([%w_]+)(.-)(%/?)>\")\r\n"
"  end\r\n"
"  label=(label or \"?\"):lower()\r\n"
"  \r\n"
"  while ni do\r\n"
"--print(ni,j,c,label,args,empty)\r\n"
"    local text = string.sub(s, i, ni-1)\r\n"
"\r\n"
"--print(text)\r\n"
"    \r\n"
"    if not string.find(text, \"^%s*$\") then -- if not just white space\r\n"
"      table.insert(top, text)\r\n"
"    end\r\n"
"    if empty == \"/\" then  -- empty element tag\r\n"
"      table.insert(top, parse_args(args,label) )\r\n"
"    elseif c == \"xml\" then   -- top tag\r\n"
"      top = parse_args(args,label)\r\n"
"      table.insert(stack, top)   -- new level\r\n"
"    elseif c == \"\" then   -- start tag\r\n"
"      top = parse_args(args,label)\r\n"
"      table.insert(stack, top)   -- new level\r\n"
"    else  -- end tag\r\n"
"		local autoclose=true -- autoclose\r\n"
"		while autoclose do\r\n"
"		  local toclose = table.remove(stack)  -- remove top\r\n"
"		  top = stack[#stack]\r\n"
"		  if #stack < 1 then\r\n"
"			warn(\"Tag <\"..label..\"> not matched \")\r\n"
"		  else\r\n"
"			  if toclose[0] ~= label then\r\n"
"				warn(\"Tag <\"..(toclose[0] or \"?\")..\"> doesnt match <\"..(label or \"?\")..\">.\")\r\n"
"				else\r\n"
"				autoclose=false\r\n"
"			  end\r\n"
"		  end\r\n"
"		  table.insert(top, toclose)\r\n"
"		end\r\n"
"    end \r\n"
"    i = j+1\r\n"
"\r\n"
"-- catch cdata in tag\r\n"
"    ni,j2,text = string.find(s, \"^%<%!%[CDATA%[(.-)%]%]%>\", i)\r\n"
"    if ni then\r\n"
"--print(text)\r\n"
"		table.insert(top, text) -- just insert the content\r\n"
"		j=j2\r\n"
"		i = j+1\r\n"
"	end\r\n"
"    \r\n"
"    \r\n"
"    ni,j,c,label,args, empty = string.find(s, \"<(%/?)([%w_]+)(.-)(%/?)>\", i)\r\n"
"    label=(label or \"?\"):lower()\r\n"
"  end\r\n"
"  local text = string.sub(s, i)\r\n"
"  if not string.find(text, \"^%s*$\") then\r\n"
"    table.insert(stack[#stack], text)\r\n"
"  end\r\n"
"  return stack[ret_stack],warnings\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert everything within this chunk, back to a html string\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function unparse(parent,opts)\r\n"
"	opts=opts or {tabjoin=true}\r\n"
"\r\n"
"	local tabjoin=opts.tabjoin -- only one of these recursive calls should have this flag\r\n"
"	if tabjoin then opts.tabjoin=false end -- so disable it\r\n"
"	\r\n"
"	local out=function(s) opts.out[#opts.out+1]=s end\r\n"
"	local att=function(t)\r\n"
"		local at={}\r\n"
"		for i,v in pairs(t) do\r\n"
"			local t=type(i)\r\n"
"			if t==\"string\" then\r\n"
"				at[#at+1]=i..\"=\"..\"\\\"\"..v..\"\\\"\"\r\n"
"			end\r\n"
"		end\r\n"
"		if at[1] then\r\n"
"			return \" \"..table.concat(at,\" \")..\" \"\r\n"
"		else\r\n"
"			return \"\"\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	if not opts.out then opts.out={} end\r\n"
"\r\n"
"	for i,v in ipairs(parent) do\r\n"
"		local t=type(v)\r\n"
"		if t==\"string\" then\r\n"
"			out(v)\r\n"
"		elseif t==\"table\" then\r\n"
"			if v[0] then\r\n"
"				if v[1] then -- stuff within this tag\r\n"
"					out(\"<\"..v[0]..att(v)..\">\")\r\n"
"						unparse(v,opts)\r\n"
"					out(\"</\"..v[0]..\">\")\r\n"
"				else -- an empty tag\r\n"
"					out(\"<\"..v[0]..att(v)..\"/>\")\r\n"
"				end\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	if tabjoin then -- reenable flag before returning\r\n"
"		opts.tabjoin=true\r\n"
"		return table.concat(opts.out)\r\n"
"	else\r\n"
"		return opts\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- get/set the attr tag of the given type (deals with silly case problems)\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function attr(parent,name,set)\r\n"
"\r\n"
"	name=string.lower(name)\r\n"
"\r\n"
"	if set then parent[name]=set end\r\n"
"\r\n"
"	return parent[name]\r\n"
"--[[\r\n"
"\r\n"
"	for n,v in pairs(parent) do\r\n"
"		if type(n)==\"string\" and string.lower(n)==name then\r\n"
"			if set then parent[n]=set end\r\n"
"			return v\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	return nil\r\n"
"]]\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find the first child tag of the given type, this does not recurse\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function child(parent,name)\r\n"
"\r\n"
"	name=string.lower(name)\r\n"
"\r\n"
"	for i,v in ipairs(parent) do\r\n"
"		if type(v)==\"table\" and v[0] and string.lower(v[0])==name then return v end\r\n"
"	end\r\n"
"	\r\n"
"	return nil\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find all the children tag of the given type, this does not recurse\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function childs(parent,name)\r\n"
"\r\n"
"	name=string.lower(name)\r\n"
"	\r\n"
"	local t={}\r\n"
"	\r\n"
"	for i,v in ipairs(parent) do\r\n"
"		if type(v)==\"table\" and v[0] and string.lower(v[0])==name then t[#t+1]=v end\r\n"
"	end\r\n"
"	\r\n"
"	return t\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find the first descendent tag of the given type, this does recurse\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function descendent(parent,name)\r\n"
"\r\n"
"	name=string.lower(name)\r\n"
"\r\n"
"	for i,v in ipairs(parent) do\r\n"
"		if type(v)==\"table\" and v[0] and string.lower(v[0])==name then return v end\r\n"
"	end\r\n"
"	\r\n"
"	for i,v in ipairs(parent) do -- recurse\r\n"
"		local ret\r\n"
"		if type(v)==\"table\" then ret=descendent(v,name) end\r\n"
"		if ret then return ret end\r\n"
"	end\r\n"
"	\r\n"
"	return nil\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find **all** the descendent tags of the given type, this does recurse\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function descendents(parent,name,opts)\r\n"
"	opts=opts or {}\r\n"
"	opts.out=opts.out or {}\r\n"
"	\r\n"
"	local out=function(s) opts.out[#opts.out+1]=s end\r\n"
"	\r\n"
"	name=string.lower(name)\r\n"
"\r\n"
"	for i,v in ipairs(parent) do -- this level\r\n"
"		if type(v)==\"table\" and v[0] and string.lower(v[0])==name then out(v) end\r\n"
"	end\r\n"
"	\r\n"
"	for i,v in ipairs(parent) do -- recurse\r\n"
"		if type(v)==\"table\" then descendents(v,name,opts) end\r\n"
"	end\r\n"
"	\r\n"
"	return opts.out -- maybe an empty output\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find the first descendent tag of the given class, this does recurse\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function class(parent,name)\r\n"
"\r\n"
"	name=string.lower(name)\r\n"
"\r\n"
"	for i,v in ipairs(parent) do\r\n"
"		if type(v)==\"table\" then\r\n"
"			if attr(v,\"class\") then\r\n"
"--print( attr(v,\"class\") ..\"\\n"
"\" )\r\n"
"				if string.lower(attr(v,\"class\"))==name then return v end\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	for i,v in ipairs(parent) do -- recurse\r\n"
"		local ret\r\n"
"		if type(v)==\"table\" then ret=class(v,name) end\r\n"
"		if ret then return ret end\r\n"
"	end\r\n"
"	\r\n"
"	return nil\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find **all** the descendent tags of the given class, this does recurse\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function classes(parent,name,opts)\r\n"
"	opts=opts or {}\r\n"
"	opts.out=opts.out or {}\r\n"
"	\r\n"
"	local out=function(s) opts.out[#opts.out+1]=s end\r\n"
"	\r\n"
"	name=string.lower(name)\r\n"
"\r\n"
"	for i,v in ipairs(parent) do -- this level\r\n"
"		if type(v)==\"table\" then\r\n"
"			if attr(v,\"class\") then\r\n"
"				if string.lower(attr(v,\"class\"))==name then out(v) end\r\n"
"			end\r\n"
"		end\r\n"
"		if type(v)==\"table\" and attr(v,\"class\") and string.lower(attr(v,\"class\"))==name then out(v) end\r\n"
"	end\r\n"
"	\r\n"
"	for i,v in ipairs(parent) do -- recurse\r\n"
"		if type(v)==\"table\" then classes(v,name,opts) end\r\n"
"	end\r\n"
"	\r\n"
"	return opts.out -- maybe an empty output\r\n"
"\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.grd","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- the core module previously lived in \"grd\" now it is in \"wetgenes.grd.core\" with this wrapper code\n"
"\n"
"local grd={}\n"
"\n"
"local core=require(\"wetgenes.grd.core\")\n"
"\n"
"\n"
"local base={}\n"
"local meta={}\n"
"meta.__index=base\n"
"\n"
"setmetatable(grd,meta)\n"
"\n"
"-- copypasta from GRD header\n"
"local import=[[\n"
"\n"
"//\n"
"// Only have popular/usefull formats as basic types that can be used internaly\n"
"//\n"
"// data is always in ARGB order in memory but these are little endian, hence the BGRA (u32) default \n"
"//\n"
"// these are all signed values and fit in 16bits\n"
"//\n"
"\n"
"#define	GRD_FMT_NONE								0x0000\n"
"\n"
"// basic formats, most internal manipulations will only work on GRD_FMT_U8_ARGB\n"
"// also you may need to convert to ARGB or RGB or INDEXED before saving and from after loading\n"
"// I'm trying to avoid diferent byte order to keep it simple, so ARGB **memory** order default\n"
"\n"
"// u32[1] or u8[4] ARGB per pixel, so thats a U32-BGRA (in little endian)\n"
"#define	GRD_FMT_U8_ARGB								0x0001\n"
"	\n"
"// A is the same as in ARGB but ( RGB=RGB*A )\n"
"#define	GRD_FMT_U8_ARGB_PREMULT						0x0002\n"
"\n"
"// bit swizzzzzzzzled for gles prefered order\n"
"#define	GRD_FMT_U8_RGBA								0x0003\n"
"#define	GRD_FMT_U8_RGBA_PREMULT						0x0004\n"
"\n"
"// u16[1] per pixel, 1 bit alpha , 5 bits red , 5 bits green , 5 bits blue\n"
"#define	GRD_FMT_U16_ARGB_1555						0x0021	\n"
"// again premult makes more sense\n"
"#define	GRD_FMT_U16_ARGB_1555_PREMULT				0x0022\n"
"\n"
"// u16[1] per pixel, 4 bit alpha , 4 bits red , 4 bits green , 4 bits blue\n"
"#define	GRD_FMT_U16_RGBA_4444						0x0023\n"
"// again premult makes more sense\n"
"#define	GRD_FMT_U16_RGBA_4444_PREMULT				0x0024\n"
"\n"
"// u16[1] an output display 16bit format for gles\n"
"#define	GRD_FMT_U16_RGB_565							0x0025\n"
"\n"
"\n"
"// I think it makes sense to keep all floating point values as premultiplied alpha?\n"
"// a 1.0 in here is the same as a 255 in U8 format\n"
"\n"
"// f16[4] per pixel\n"
"#define	GRD_FMT_F16_ARGB_PREMULT					0x0041\n"
"// f32[4] per pixel\n"
"#define	GRD_FMT_F32_ARGB_PREMULT					0x0062\n"
"// f64[4] per pixel\n"
"#define	GRD_FMT_F64_ARGB_PREMULT					0x0083\n"
"\n"
"// u8[3]  per pixel, probably just normal palette information\n"
"#define	GRD_FMT_U8_RGB								0x00a1\n"
"\n"
"// u8[1]  per pixel, forced U8 Indexed input\n"
"#define	GRD_FMT_U8_INDEXED							0x00c1\n"
"\n"
"// u8[1]  per pixel, forced U8 gray scale (treat as indexed)\n"
"#define	GRD_FMT_U8_LUMINANCE						0x00e1\n"
"#define	GRD_FMT_U8_ALPHA							0x00e2\n"
"\n"
"\n"
"// more formats, not to be used when mucking about with data\n"
"// these are hints for textures rather than specific formats and don't guarantee any number of bits\n"
"// in fact the texture may even use a simple lossy compressed format if enabled\n"
"// basically it is none of your concern, if you intend to do anything with the dat convert it to one of the\n"
"// basic formats\n"
"\n"
"// just RGB , probably u32 or u16(565)\n"
"#define	GRD_FMT_HINT_NO_ALPHA						0x0101\n"
"\n"
"// and RGB  , probably u32 or u16(1555)\n"
"#define	GRD_FMT_HINT_ALPHA_1BIT						0x0102\n"
"\n"
"// and RGB  , probably u32 or u16(4444)\n"
"#define	GRD_FMT_HINT_ALPHA							0x0103\n"
"\n"
"// no RGB   , probably u8\n"
"#define	GRD_FMT_HINT_ONLY_ALPHA						0x0104\n"
"\n"
"// we want to save or load as a png									\n"
"#define	GRD_FMT_HINT_PNG							0x0105\n"
"\n"
"// we want to save or load as a jpg									\n"
"#define	GRD_FMT_HINT_JPG							0x0106\n"
"	\n"
"// maximum GRD_FMT value		\n"
"#define	GRD_FMT_MAX									0x0107\n"
"\n"
"]]\n"
"-- parse the above string for constants, makes updates as easy as a cutnpaste from original source code\n"
"\n"
"grd.defs={}\n"
"\n"
"for l in import:gmatch(\"([^\\n"
"]*)\") do\n"
"	local define,value\n"
"	local state=\"start\"\n"
"	for w in l:gmatch(\"([^%s]+)\") do\n"
"		if state==\"start\" then\n"
"			if w==\"#define\" then\n"
"				state=\"define\"\n"
"			else\n"
"				break\n"
"			end\n"
"		elseif state==\"define\" then\n"
"			define=w\n"
"			state=\"value\"\n"
"		elseif state==\"value\" then\n"
"			value=w\n"
"				if define:sub(1,4)==\"GRD_\" then -- sanity check\n"
"					define=define:sub(5)\n"
"					\n"
"					if value:sub(1,4)==\"GRD_\" then -- allow lookback\n"
"						value=grd.defs[value:sub(5)]\n"
"					end\n"
"					\n"
"					grd.defs[define]=tonumber(value)\n"
"\n"
"					if define:sub(1,4)==\"FMT_\" then -- allow even shorter names\n"
"						grd.defs[define:sub(5)]=tonumber(value)\n"
"					end\n"
"					\n"
"				end\n"
"			break\n"
"		else\n"
"			break\n"
"		end\n"
"	end\n"
"end\n"
"import=nil -- free it just because\n"
"\n"
"grd.nums={}\n"
"\n"
"for i,v in pairs(grd.defs) do -- copy vals into base for shorthand grd.FALSE style use\n"
"	base[i]=v\n"
"	grd.nums[v]=i -- and reverse lookup\n"
"end\n"
"\n"
"function grd.numtostring(num)\n"
"	return grd.nums[num]\n"
"end\n"
"function grd.stringtonum(str)\n"
"	return grd.defs[str] \n"
"end\n"
"\n"
"-- many options\n"
"-- grd.create(g) -- duplicate\n"
"-- grd.create(fmt,w,h,d) -- a new blank image of given dimensions\n"
"-- grd.create(filename,opts) -- load image\n"
"-- grd.create() -- a blank image of 0 dimensions\n"
"grd.create=function(...)\n"
"	local args={...}\n"
"	local g={}\n"
"	setmetatable(g,meta)\n"
"	\n"
"	if type(args[1]) == \"table\" then -- duplicate\n"
"	\n"
"--		local g2=args[1]\n"
"--		g[0]=core.create(g2[0])\n"
"	\n"
"	elseif type(args[2]) == \"number\" then -- a new blank image of given dimensions\n"
"	\n"
"		local fmt=args[1]\n"
"		local w,h,d=args[2],args[3],args[4]\n"
"		if type(fmt) == \"string\" then\n"
"			fmt=grd.stringtonum(args[1])\n"
"		end\n"
"		g[0]=core.create(fmt,w,h,d)\n"
"\n"
"	elseif type(args[1]) == \"string\" then -- load image\n"
"	\n"
"		local filename=args[1]\n"
"		local fmt=args[2]\n"
"		g[0]=core.create()\n"
"		g:load_file(filename,fmt)\n"
"	\n"
"	elseif type(args[1]) == \"userdata\" then -- just wrap the table\n"
"\n"
"		g[0]=args[1]\n"
"\n"
"	else -- a blank image of 0 dimensions\n"
"\n"
"		g[0]=core.create()\n"
"	\n"
"	end\n"
"	\n"
"	\n"
"	core.info(g[0],g)\n"
"	return g\n"
"end\n"
"\n"
"base.destroy=function(g)\n"
"	return core.destroy(g[0])\n"
"end\n"
"\n"
"\n"
"base.reset=function(g)\n"
"	local r=core.reset(g[0])\n"
"	core.info(g[0],g)\n"
"	return r and g\n"
"end\n"
"\n"
"base.load_file=function(g,filename,fmt)\n"
"	return base.load(g,{filename=filename,fmt=fmt})\n"
"end\n"
"\n"
"base.load_data=function(g,data,fmt)\n"
"	return base.load(g,{data=data,fmt=fmt})\n"
"end\n"
"\n"
"base.load=function(g,opts)\n"
"	if opts.fmt==\"jpg\" then\n"
"		opts.fmt=grd.FMT_HINT_JPG\n"
"	end\n"
"	if opts.fmt==\"png\" then\n"
"		opts.fmt=grd.FMT_HINT_PNG\n"
"	end\n"
"	local r=core.load(g[0],opts)\n"
"	core.info(g[0],g)\n"
"	return r and g\n"
"end\n"
"\n"
"base.save=function(g,filename,opts)\n"
"	local r=core.save(g[0],filename,opts)\n"
"	core.info(g[0],g)\n"
"	return r and g\n"
"end\n"
"\n"
"base.duplicate=function(g)\n"
"	local r=core.duplicate(g[0])\n"
"	return grd.create(r)\n"
"end\n"
"\n"
"base.duplicate_convert=function(g,fmt)\n"
"	if type(fmt) == \"string\" then\n"
"		fmt=grd.stringtonum(fmt)\n"
"	end\n"
"	local r=core.duplicate_convert(g[0],fmt)\n"
"	if r==g[0] then r=core.duplicate(g[0]) end -- force duplication\n"
"	return grd.create(r)\n"
"end\n"
"\n"
"base.convert=function(g,fmt)\n"
"	if type(fmt) == \"string\" then\n"
"		fmt=grd.stringtonum(fmt)\n"
"	end\n"
"	local r,e=core.convert(g[0],fmt)\n"
"	core.info(g[0],g)\n"
"	return (r and g),e\n"
"end\n"
"\n"
"base.quant=function(g,num)\n"
"	local r=core.quant(g[0],num)\n"
"	core.info(g[0],g)\n"
"	return r and g\n"
"end\n"
"\n"
"base.pixels=function(g,...)\n"
"	local r=core.pixels(g[0],...)\n"
"	core.info(g[0],g)\n"
"	return r\n"
"end\n"
"\n"
"base.palette=function(g,...)\n"
"	local r=core.palette(g[0],...)\n"
"	core.info(g[0],g)\n"
"	return r\n"
"end\n"
"\n"
"base.resize=function(g,...)\n"
"	local r=core.resize(g[0],...)\n"
"	core.info(g[0],g)\n"
"	return r and g\n"
"end\n"
"base.scale=function(g,...)\n"
"	local r=core.scale(g[0],...)\n"
"	core.info(g[0],g)\n"
"	return r and g\n"
"end\n"
"\n"
"base.flipy=function(g,...)\n"
"	local r=core.flipy(g[0],...)\n"
"	core.info(g[0],g)\n"
"	return r and g\n"
"end\n"
"\n"
"base.shrink=function(g,...)\n"
"	local r=core.shrink(g[0],...)\n"
"	core.info(g[0],g)\n"
"	return r and g\n"
"end\n"
"\n"
"base.info=function(g,...)\n"
"	core.info(g[0],g)\n"
"	return g\n"
"end\n"
"\n"
"base.blit=function(ga,gb,x,y,cx,cy,cw,ch)\n"
"\n"
"	if cx then -- autoclip\n"
"		if cx<0 then cw=cw+cx cx=0 end\n"
"		if cy<0 then ch=ch+cy cy=0 end\n"
"		if (cx+cw)>gb.width  then cw=gb.width -cx end\n"
"		if (cy+ch)>gb.height then ch=gb.height-cy end\n"
"	else -- auto build\n"
"		cx=0\n"
"		cy=0\n"
"		cw=gb.width\n"
"		ch=gb.height\n"
"	end\n"
"	\n"
"	if x<0 then cx=cx-x cw=cw+x x=0 end\n"
"	if y<0 then cy=cy-y ch=ch+y y=0 end	\n"
"	if (x+cw)>ga.width  then cw=ga.width -x end\n"
"	if (y+ch)>ga.height then ch=ga.height-y end\n"
"\n"
"	if cw<=0 or ch<=0 then return true end -- nothing to draw\n"
"\n"
"	local r=core.blit(ga[0],gb[0],x,y,cx,cy,cw,ch)\n"
"	\n"
"	return r\n"
"end\n"
"\n"
"return grd\n"
"",

"wetgenes.www.any.img","if ngx then\r	return require(\"wetgenes.www.ngx.img\")\relse\r	return require(\"wetgenes.www.gae.img\")\rend\r",

"wetgenes.gamecake.spew.geom","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local pack=require(\"wetgenes.pack\")\n"
"local wwin=require(\"wetgenes.win\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"local tardis=require(\"wetgenes.tardis\")	-- matrix/vector math\n"
"\n"
"local function dprint(a) print(wstr.dump(a)) end\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"M.bake=function(oven,geom)\n"
"	geom=geom or {}\n"
"	geom.modname=M.modname\n"
"\n"
"	local cake=oven.cake\n"
"	local canvas=cake.canvas\n"
"	local font=canvas.font\n"
"	local flat=canvas.flat\n"
"	\n"
"		\n"
"	-- scale the geom\n"
"	geom.adjust_scale=function(it,s)\n"
"		s=s or 1\n"
"		local vs=it.verts\n"
"		for i=1,#vs do local v=vs[i]\n"
"			v[1]=v[1]*s\n"
"			v[2]=v[2]*s\n"
"			v[3]=v[3]*s\n"
"		end\n"
"	end\n"
"\n"
"	-- allocate and upload the geom to opengl buffers\n"
"	geom.predraw=function(it,progname)\n"
"\n"
"		if not it.predrawn then\n"
"			local orders={}\n"
"			orders[3]={ {3,3,2,1,1}			,	{1,1,2,3,3}		}\n"
"			orders[4]={ {3,3,4,2,1,1}		,	{1,1,2,4,3,3}	}\n"
"			orders[5]={ {4,4,3,5,2,1,1}		,	{1,1,2,5,3,4,4}	}\n"
"\n"
"			local t={}\n"
"			local f=1\n"
"			for i,p in ipairs(it.polys) do\n"
"	--			local c=cs[1+(i%#cs)]\n"
"				local o=orders[#p][1+f%2]\n"
"				for _,i in ipairs(o) do\n"
"					local idx=p[i]\n"
"					local v=it.verts[idx]\n"
"					t[#t+1]=v[1]\n"
"					t[#t+1]=v[2]\n"
"					t[#t+1]=v[3]\n"
"\n"
"					t[#t+1]=v[4] or 0\n"
"					t[#t+1]=v[5] or 0\n"
"					t[#t+1]=v[6] or 0\n"
"\n"
"					t[#t+1]=v[7] or 0\n"
"					t[#t+1]=v[8] or 0\n"
"\n"
"					f=f+1\n"
"				end\n"
"			end\n"
"			it.predrawn=flat.tristrip_predraw({fmt=\"xyznrmuv\",data=t,progname=progname,vb=true})\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"	-- draw the geom (upload first, mkay)\n"
"	geom.draw=function(it,progname)\n"
"		geom.predraw(it,progname)\n"
"		it.predrawn.draw()\n"
"	end	\n"
"	\n"
"	-- build the edges\n"
"	geom.build_edges=function(it)\n"
"		local es={}\n"
"		it.edges_map=es\n"
"		for ip,vp in ipairs(it.polys) do\n"
"			local hvp=#vp\n"
"			for i1=1,hvp do\n"
"				local i2=i1+1\n"
"				if i2>hvp then i2=1 end -- wrap \n"
"				local v1=vp[i1]\n"
"				local v2=vp[i2]\n"
"				if v2>v1 then v1,v2=v2,v1 end -- sort order\n"
"				es[v1]=es[v1] or {}\n"
"				es[v1][v2]=es[v1][v2] or {}\n"
"				es[v1][v2][ip]=i1 -- what polys it links too and by what vertexs\n"
"			end\n"
"		end\n"
"		\n"
"		it.edges={}\n"
"		for i1,v in pairs(es) do\n"
"			for i2,b in pairs(v) do\n"
"				it.edges[#it.edges+1]={i1,i2} -- each edge will only get added once\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"-- uses first 3 verts, does not fix the length\n"
"	geom.get_poly_normal=function(it,p)\n"
"	\n"
"		local v1=it.verts[ p[1] ]\n"
"		local v2=it.verts[ p[2] ]\n"
"		local v3=it.verts[ p[3] ]\n"
"		local va={}\n"
"		local vb={}\n"
"		va[1]=v1[1]-v2[1]\n"
"		va[2]=v1[2]-v2[2]\n"
"		va[3]=v1[3]-v2[3]\n"
"		vb[1]=v3[1]-v2[1]\n"
"		vb[2]=v3[2]-v2[2]\n"
"		vb[3]=v3[3]-v2[3]\n"
"		\n"
"		-- face normal\n"
"		local vn={}\n"
"		vn[1]=va[2]*vb[3] - va[3]*vb[2]\n"
"		vn[2]=va[3]*vb[1] - va[1]*vb[3]\n"
"		vn[3]=va[1]*vb[2] - va[2]*vb[1]\n"
"		\n"
"		return vn\n"
"	end\n"
"\n"
"	geom.normalize=function(v)\n"
"		local dd=v[1]*v[1] + v[2]*v[2] + v[3]*v[3]\n"
"		local d=math.sqrt(dd)\n"
"		if d<(1/65536) then d=1 end\n"
"		v[1]=v[1]/d\n"
"		v[2]=v[2]/d\n"
"		v[3]=v[3]/d\n"
"		return v\n"
"	end\n"
"\n"
"\n"
"	geom.face_square_uvs=function(it)\n"
"		local t={\n"
"			{0,0},\n"
"			{1,0},\n"
"			{1,1},\n"
"			{0,1},\n"
"		}\n"
"		for i,v in pairs(it.verts) do\n"
"			local idx=((v[8]-1)%4)+1\n"
"			v[7]=t[idx][1]\n"
"			v[8]=t[idx][2]\n"
"		end\n"
"	end\n"
"\n"
"	geom.flip=function(it)\n"
"\n"
"		for i,p in pairs(it.polys) do geom.poly_flip(it,p) end\n"
"		for i,v in pairs(it.verts) do geom.vert_flip(it,v) end\n"
"	end\n"
"		\n"
"	geom.vert_flip=function(it,v)\n"
"		if v[4] then\n"
"			v[4]=-v[4]\n"
"			v[5]=-v[5]\n"
"			v[6]=-v[6]\n"
"		end\n"
"	end\n"
"\n"
"	geom.poly_flip=function(it,p)\n"
"	\n"
"		local n={}\n"
"		for i=#p,1,-1 do\n"
"			n[#n+1]=p[i]\n"
"		end\n"
"		for i=1,#n do\n"
"			p[i]=n[i]\n"
"		end\n"
"\n"
"	end\n"
"\n"
"	geom.fix_poly_order=function(it,p)\n"
"	\n"
"		local v2=it.verts[ p[2] ]\n"
"		local vn=geom.get_poly_normal(it,p)\n"
"		\n"
"		local d = vn[1]*v2[1] + vn[2]*v2[2] + vn[3]*v2[3]\n"
"		\n"
"		if d>0 then -- invert poly order\n"
"			geom.poly_flip(it,p)\n"
"		end\n"
"	end\n"
"\n"
"	-- bevil a base object, s is how much each face is scaled, so 7/8 is a nice bevel\n"
"	geom.apply_bevel=function(it,s)\n"
"	\n"
"		geom.build_edges(it)\n"
"\n"
"		local vs={}\n"
"		local function vcopy(i)\n"
"			local n={} for a,b in ipairs(it.verts[i]) do n[a]=b end\n"
"			vs[#vs+1]=n -- new vertex\n"
"			return #vs -- new vertex id\n"
"		end\n"
"		for ip,vp in ipairs(it.polys) do\n"
"			local n=geom.normalize( geom.get_poly_normal(it,vp) )\n"
"			for i=1,#vp do\n"
"				vp[i]=vcopy(vp[i])\n"
"				local v=vs[ vp[i] ]\n"
"				v[4]=n[1]\n"
"				v[5]=n[2]\n"
"				v[6]=n[3]\n"
"				v[7]=ip\n"
"				v[8]=i\n"
"			end\n"
"\n"
"		end\n"
"		it.verts=vs\n"
"\n"
"		for ip,vp in ipairs(it.polys) do\n"
"			local vc={0,0,0} -- calculate center of face\n"
"			local ic=0\n"
"			for i,v in ipairs(vp) do local vv=it.verts[v]\n"
"				vc[1]=vc[1]+vv[1]\n"
"				vc[2]=vc[2]+vv[2]\n"
"				vc[3]=vc[3]+vv[3]\n"
"				ic=ic+1\n"
"			end\n"
"			vc[1]=vc[1]/ic\n"
"			vc[2]=vc[2]/ic\n"
"			vc[3]=vc[3]/ic\n"
"			for i,v in ipairs(vp) do local vv=it.verts[v]\n"
"				vv[1]=vc[1] + ((vv[1]-vc[1])*s) -- scale face around center\n"
"				vv[2]=vc[2] + ((vv[2]-vc[2])*s) -- each vertex will be unique to each face\n"
"				vv[3]=vc[3] + ((vv[3]-vc[3])*s)\n"
"			end\n"
"		end\n"
"\n"
"		-- add in poly where the old edges used to be\n"
"		local js={}\n"
"		local es=it.edges_map\n"
"		for i,e in pairs(it.edges) do\n"
"			local p1,v1\n"
"			local p2,v2\n"
"			for ip,iv in pairs( es[ e[1] ][ e[2] ]) do\n"
"				if p1 then p2=ip v2=iv else p1=ip v1=iv end\n"
"			end\n"
"			p1=it.polys[p1] -- lookup polys, will have new vertex ids\n"
"			p2=it.polys[p2] -- build new join poly using these new vertex ids\n"
"			local p={}\n"
"			p[1] = p1[v1]\n"
"			p[3] = p2[v2]\n"
"			v1=v1+1 if v1>#p1 then v1=1 end\n"
"			v2=v2+1 if v2>#p2 then v2=1 end\n"
"			p[2] = p1[v1]\n"
"			p[4] = p2[v2]\n"
"			js[#js+1]={p[1],p[4]}\n"
"			js[#js+1]={p[2],p[3]}\n"
"\n"
"			geom.fix_poly_order(it,p)\n"
"			it.polys[#it.polys+1]=p -- add join poly\n"
"		end\n"
"		\n"
"\n"
"		local function dojoin(v2,v1) -- insert v1 into v1\n"
"			if v1[1] == v2[1] then\n"
"				for i=2,#v1 do\n"
"					table.insert(v2,1,v1[i])\n"
"				end\n"
"			elseif v1[#v1] == v2[1] then\n"
"				for i=#v1-1,1,-1 do\n"
"					table.insert(v2,1,v1[i])\n"
"				end\n"
"			elseif v1[1] == v2[#v2] then\n"
"				for i=2,#v1 do\n"
"					table.insert(v2,v1[i])\n"
"				end\n"
"			elseif v1[#v1] == v2[#v2] then\n"
"				for i=#v1-1,1,-1 do\n"
"					table.insert(v2,v1[i])\n"
"				end\n"
"			end\n"
"\n"
"		end\n"
"		\n"
"		for i1,v1 in pairs(js) do\n"
"--			if #v1 == 2 then -- unjoined\n"
"				for i2,v2 in pairs(js) do\n"
"					if v1~=v2 then -- do not join to self\n"
"						if v2[#v2] == v1[1] then\n"
"							dojoin(v2,v1)\n"
"							js[i1]=nil -- joined\n"
"							break\n"
"						elseif v2[#v2] == v1[#v1] then\n"
"							dojoin(v2,v1)\n"
"							js[i1]=nil -- joined\n"
"							break\n"
"						elseif v2[1] == v1[1] then\n"
"							dojoin(v2,v1)\n"
"							js[i1]=nil -- joined\n"
"							break\n"
"						elseif v2[1] == v1[#v1] then\n"
"							dojoin(v2,v1)\n"
"							js[i1]=nil -- joined\n"
"							break\n"
"						end\n"
"					end\n"
"				end\n"
"--			end\n"
"		end\n"
"		\n"
"		for i,v in pairs(js) do -- add pollys\n"
"			v[#v]=nil\n"
"			it.polys[#it.polys+1]=v\n"
"			geom.fix_poly_order(it,v)\n"
"		end\n"
"			\n"
"		for i,p in pairs(it.polys) do\n"
"			geom.fix_poly_order(it,p)\n"
"		end\n"
"			\n"
"	end\n"
"\n"
"\n"
"	geom.tetrahedron=function(it)\n"
"		it=it or {}\n"
"		\n"
"		it.verts={\n"
"				{ 0.5, 0.5, 0.5},\n"
"				{-0.5, 0.5,-0.5},\n"
"				{ 0.5,-0.5,-0.5},\n"
"				{-0.5,-0.5, 0.5},\n"
"			}\n"
"			\n"
"		it.polys={\n"
"				{1,2,3},\n"
"				{2,4,3},\n"
"				{1,3,4},\n"
"				{1,4,2},\n"
"			}\n"
"			\n"
"--		it.strips={1,2,3,4,1,2}\n"
"		\n"
"		for i,p in pairs(it.polys) do geom.fix_poly_order(it,p) end\n"
"		return it\n"
"	end\n"
"\n"
"	geom.octahedron=function(it)\n"
"		it=it or {}\n"
"		\n"
"		local a=1/(2*math.sqrt(2))\n"
"		local b=1/2\n"
"		\n"
"		it.verts={\n"
"				{ a, 0, a},\n"
"				{ a, 0,-a},\n"
"				{-a, 0, a},\n"
"				{-a, 0,-a},\n"
"				{ 0, b, 0},\n"
"				{ 0,-b, 0},\n"
"			}\n"
"			\n"
"		it.polys={\n"
"				{3,4,5},\n"
"				{4,2,5},\n"
"				{2,1,5},\n"
"				{1,3,5},\n"
"				{2,4,6},\n"
"				{4,3,6},\n"
"				{1,2,6},\n"
"				{3,1,6},\n"
"			}\n"
"			\n"
"--		it.strips={}\n"
"		\n"
"		for i,p in pairs(it.polys) do geom.fix_poly_order(it,p) end\n"
"		return it\n"
"	end\n"
"	\n"
"	geom.hexahedron=function(it)\n"
"		it=it or {}\n"
"		\n"
"		it.verts={\n"
"				{ 0.5, 0.5, 0.5},\n"
"				{ 0.5, 0.5,-0.5},\n"
"				{ 0.5,-0.5, 0.5},\n"
"				{ 0.5,-0.5,-0.5},\n"
"				{-0.5, 0.5, 0.5},\n"
"				{-0.5, 0.5,-0.5},\n"
"				{-0.5,-0.5, 0.5},\n"
"				{-0.5,-0.5,-0.5},\n"
"			}\n"
"			\n"
"		it.polys={\n"
"				{8,4,3,7},\n"
"				{8,7,5,6},\n"
"				{7,3,1,5},\n"
"				{6,5,1,2},\n"
"				{4,2,1,3},\n"
"				{8,6,2,4},\n"
"			}\n"
"			\n"
"--		it.strips={}\n"
"		\n"
"		for i,p in pairs(it.polys) do geom.fix_poly_order(it,p) end\n"
"		return it\n"
"	end\n"
"\n"
"	geom.icosahedron=function(it)\n"
"		it=it or {}\n"
"		\n"
"		local a=1/2\n"
"		local b=1/(1+math.sqrt(5))\n"
"		\n"
"		it.verts={\n"
"				{ 0, b, a}, -- 1\n"
"				{ 0, b,-a}, -- 2\n"
"				{ 0,-b, a}, -- 3\n"
"				{ 0,-b,-a}, -- 4\n"
"				{ a, 0, b}, -- 5\n"
"				{ a, 0,-b}, -- 6\n"
"				{-a, 0, b}, -- 7\n"
"				{-a, 0,-b}, -- 8\n"
"				{ b, a, 0}, -- 9\n"
"				{ b,-a, 0}, --10\n"
"				{-b, a, 0}, --11\n"
"				{-b,-a, 0}, --12\n"
"			}\n"
"			\n"
"		it.polys={\n"
"				{2,9,11},\n"
"				{1,11,9},\n"
"				{1,3,7},\n"
"				{1,5,3},\n"
"				{2,4,6},\n"
"				{2,8,4},\n"
"				{3,10,12},\n"
"				{4,12,10},\n"
"				{11,7,8},\n"
"				{12,8,7},\n"
"				{9,6,5},\n"
"				{10,5,6},\n"
"				{1,7,11},\n"
"				{1,9,5},\n"
"				{2,11,8},\n"
"				{2,6,9},\n"
"				{4,8,12},\n"
"				{4,10,6},\n"
"				{3,12,7},\n"
"				{3,5,10}, \n"
" 			}\n"
"			\n"
"--		it.strips={}\n"
"		\n"
"		for i,p in pairs(it.polys) do geom.fix_poly_order(it,p) end\n"
"		return it\n"
"	end\n"
"\n"
"	geom.dodecahedron=function(it)\n"
"		it=it or {}\n"
"		\n"
"		local phi=(1+math.sqrt(5))/2\n"
"		local a=1/2\n"
"		local b=(1/phi)/2\n"
"		local c=(2-phi)/2\n"
"		\n"
"		it.verts={\n"
"				{ 0, a, c}, -- 1\n"
"				{ 0, a,-c}, -- 2\n"
"				{ 0,-a, c}, -- 3\n"
"				{ 0,-a,-c}, -- 4\n"
"				{ c, 0, a}, -- 5\n"
"				{ c, 0,-a}, -- 6\n"
"				{-c, 0, a}, -- 7\n"
"				{-c, 0,-a}, -- 8\n"
"				{ a, c, 0}, -- 9\n"
"				{ a,-c, 0}, --10\n"
"				{-a, c, 0}, --11\n"
"				{-a,-c, 0}, --12\n"
"				{ b, b, b}, --13\n"
"				{ b, b,-b}, --14\n"
"				{ b,-b, b}, --15\n"
"				{ b,-b,-b}, --16\n"
"				{-b, b, b}, --17\n"
"				{-b, b,-b}, --18\n"
"				{-b,-b, b}, --19\n"
"				{-b,-b,-b}, --20\n"
"			}\n"
"			\n"
"		it.polys={\n"
"			{5,7,17,1,13},\n"
"			{7,5,15,3,19},\n"
"			{6,8,20,4,16},\n"
"			{8,6,14,2,18},\n"
"			{14,9,13,1,2},\n"
"			{17,11,18,2,1},\n"
"			{20,12,19,3,4},\n"
"			{15,10,16,4,3},\n"
"			{9,10,15,5,13},\n"
"			{10,9,14,6,16},\n"
"			{11,12,20,8,18},\n"
"			{12,11,17,7,19},\n"
"		}\n"
"			\n"
"--		it.strips={}\n"
"		\n"
"		for i,p in pairs(it.polys) do geom.fix_poly_order(it,p) end\n"
"		return it\n"
"	end\n"
"\n"
"	return geom\n"
"end\n"
"\n"
"",

"wetgenes.fenestra.widget.textedit","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"-- widget class string\r\n"
"-- a one line string buffer that can be edited\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.textedit\")\r\n"
"\r\n"
"local widget_data=require(\"fenestra.widget.data\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"\r\n"
"--	local it=widget.string\r\n"
"\r\n"
"-- call here so we can use any state changes immediatly	\r\n"
"	local ret=widget.meta.mouse(widget,act,x,y,key)\r\n"
"	\r\n"
"	if widget.master.active==widget then\r\n"
"	\r\n"
"		widget.master.focus=widget\r\n"
"		\r\n"
"		if act==\"down\" then\r\n"
"			local dx=x-((widget.pxd or 0)+(widget.text_x or 0))\r\n"
"--print(dx)\r\n"
"			if dx<0 then -- catch lessthan\r\n"
"				widget.data.str_idx=0\r\n"
"			else\r\n"
"				widget.data.str_idx=widget.master.font.which(dx,widget.data.str)\r\n"
"				if widget.data.str_idx<0 then widget.data.str_idx=#widget.data.str end -- catch morethan\r\n"
"			end\r\n"
"\r\n"
"			widget.master.throb=255\r\n"
"			widget:set_dirty()\r\n"
"\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	return ret\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"--	local it=widget.string\r\n"
"	local master=widget.master\r\n"
"	\r\n"
"	local changed=false\r\n"
"\r\n"
"--print(\"gotkey\",ascii)\r\n"
"	\r\n"
"	if act==\"down\" or act==\"repeat\" then\r\n"
"	\r\n"
"		if key==\"left\" then\r\n"
"\r\n"
"			widget.data.str_idx=widget.data.str_idx-1\r\n"
"			if widget.data.str_idx<0 then widget.data.str_idx=0 end\r\n"
"			\r\n"
"			master.throb=255\r\n"
"			changed=true\r\n"
"						\r\n"
"		elseif key==\"right\" then\r\n"
"	\r\n"
"			widget.data.str_idx=widget.data.str_idx+1\r\n"
"			if widget.data.str_idx>#widget.data.str then widget.data.str_idx=#widget.data.str end\r\n"
"			\r\n"
"			master.throb=255\r\n"
"			changed=true\r\n"
"			\r\n"
"		elseif key==\"home\" then\r\n"
"		\r\n"
"			widget.data.str_idx=0\r\n"
"			changed=true\r\n"
"		\r\n"
"		elseif key==\"end\" then\r\n"
"		\r\n"
"			widget.data.str_idx=#widget.data.str\r\n"
"			changed=true\r\n"
"		\r\n"
"		elseif key==\"backspace\" then\r\n"
"	\r\n"
"			if widget.data.str_idx >= #widget.data.str then -- at end\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(1,-2)\r\n"
"				widget.data.str_idx=#widget.data.str\r\n"
"				\r\n"
"				changed=true\r\n"
"			\r\n"
"			elseif widget.data.str_idx < 1 then -- at start\r\n"
"			\r\n"
"			elseif widget.data.str_idx == 1 then -- near start\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(2)\r\n"
"				widget.data.str_idx=widget.data.str_idx-1\r\n"
"			\r\n"
"				changed=true\r\n"
"\r\n"
"			else -- somewhere in the line\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(1,widget.data.str_idx-1) .. widget.data.str:sub(widget.data.str_idx+1)\r\n"
"				widget.data.str_idx=widget.data.str_idx-1\r\n"
"				\r\n"
"				changed=true\r\n"
"\r\n"
"			end\r\n"
"			\r\n"
"			master.throb=255\r\n"
"			\r\n"
"		elseif key==\"delete\" then\r\n"
"	\r\n"
"			if widget.data.str_idx >= #widget.data.str then -- at end\r\n"
"			\r\n"
"			elseif widget.data.str_idx < 1 then -- at start\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(2)\r\n"
"				widget.data.str_idx=0\r\n"
"			\r\n"
"				changed=true\r\n"
"\r\n"
"			else -- somewhere in the line\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(1,widget.data.str_idx) .. widget.data.str:sub(widget.data.str_idx+2)\r\n"
"				widget.data.str_idx=widget.data.str_idx\r\n"
"				\r\n"
"				changed=true\r\n"
"\r\n"
"			end\r\n"
"			\r\n"
"			master.throb=255\r\n"
"			\r\n"
"		elseif key==\"enter\" or key==\"return\" then\r\n"
"		\r\n"
"			if act==\"down\" then -- ignore repeats on enter key\r\n"
"			\r\n"
"				if widget.data.str and widget.onenter then -- callback?\r\n"
"				\r\n"
"					widget:call_hook(\"click\")\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"				changed=true\r\n"
"			end\r\n"
"			\r\n"
"--		elseif key==\"up\" then\r\n"
"--		elseif key==\"down\" then\r\n"
"		\r\n"
"		elseif ascii~=\"\" then -- not a blank string\r\n"
"			local c=string.byte(ascii)\r\n"
"			\r\n"
"			if c>=32 and c<128 then\r\n"
"			\r\n"
"				if widget.data.str_idx >= #widget.data.str then -- put at end\r\n"
"				\r\n"
"					widget.data.str=widget.data.str..ascii\r\n"
"					widget.data.str_idx=#widget.data.str\r\n"
"					\r\n"
"				elseif widget.data.str_idx < 1 then -- put at start\r\n"
"				\r\n"
"					widget.data.str=ascii..widget.data.str\r\n"
"					widget.data.str_idx=1\r\n"
"					\r\n"
"				else -- need to insert into line\r\n"
"				\r\n"
"					widget.data.str=widget.data.str:sub(1,widget.data.str_idx) .. ascii .. widget.data.str:sub(widget.data.str_idx+1)\r\n"
"					widget.data.str_idx=widget.data.str_idx+1\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"				master.throb=255\r\n"
"				\r\n"
"				changed=true\r\n"
"\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	if changed then\r\n"
"		widget.text=widget.data.str\r\n"
"		\r\n"
"		widget:call_hook(\"update\")\r\n"
"		widget:set_dirty()\r\n"
"	end\r\n"
"	\r\n"
"	return true\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"\r\n"
"	if widget.text ~= widget.data.str then\r\n"
"		widget.text = widget.data.str\r\n"
"		widget:set_dirty()\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.string=it\r\n"
"	widget.class=\"textedit\"\r\n"
"	\r\n"
"	widget.data=widget.data or widget_data.new_data({})\r\n"
"	\r\n"
"--	widget.data.str=\"\"\r\n"
"--	widget.data.str_idx=0\r\n"
"	\r\n"
"--	widget.key=key\r\n"
"	widget.update=update\r\n"
"\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"",

"wetgenes.tube.youtube","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"-- An attempt to turn youtube IDs into links to video files.\n"
"-- This may break if youtube decides to prevent this sort of activity\n"
"\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"module(\"wetgenes.tube.youtube\")\n"
"\n"
"\n"
"-- overload this function if we are running in a strange environment\n"
"-- notice the require, which means socket.http is not a forced dependency\n"
"function get_url(url)\n"
"\n"
"local http=require(\"socket.http\")\n"
"\n"
"local body, headers, code = http.request(url)\n"
"\n"
"local ret={}\n"
"\n"
"	ret.body=body\n"
"	ret.headers=headers\n"
"	ret.code=code\n"
"	\n"
"	return ret\n"
"\n"
"end\n"
"\n"
"\n"
"function url_split(s)\n"
"	local ands=wstr.split(s,\"&\")\n"
"	local vals={}\n"
"	for i,v in ipairs(ands) do\n"
"		local aa=wstr.split(v,\"=\")\n"
"		vals[ wstr.url_decode(aa[1]) ]=wstr.url_decode(aa[2])\n"
"	end\n"
"	return vals\n"
"end\n"
"\n"
"function get_video_info(id)\n"
"\n"
"	local url=\"http://www.youtube.com/get_video_info?video_id=\"..id..\"&ps=default&eurl=&gl=US&hl=en\"\n"
"	local ret=get_url(url)\n"
"	\n"
"	local vals=url_split(ret.body)\n"
"	\n"
"	vals.fmts={}\n"
"	local ps=wstr.split(vals.url_encoded_fmt_stream_map,\",\")\n"
"	for i,v in ipairs(ps) do\n"
"		vals.fmts[i]=url_split(v)\n"
"	end\n"
"	\n"
"	vals.url_encoded_fmt_stream_map=nil -- kill the original fmt string\n"
"	\n"
"	return vals\n"
"end\n"
"\n"
"\n"
"\n"
"-- return info about a youtube ID, most importantly a URL to stream it from\n"
"-- this cleans up the data from get_video_info\n"
"function info(id)\n"
"	local tab\n"
"	\n"
"	tab=get_video_info(id)\n"
"	\n"
"	return tab\n"
"end\n"
"\n"
"\n"
"-- Test a file?\n"
"--[[\n"
"local t=info(\"SmI9-fQKOIA\")\n"
"print(wstr.dump(t))\n"
"local url\n"
"for i,v in ipairs(t.fmts) do\n"
"	if v.itag==\"43\" then url=v.url end\n"
"end\n"
"\n"
"print(url)\n"
"\n"
"local fp=io.open(\"dumb.web\",\"w\")\n"
"fp:write( get_url(url).body )\n"
"fp:close()\n"
"]]\n"
"",

"wetgenes.cgilua.mysqljson","\r\n"
"-- handle mostly opaque data stored in a mysql database\r\n"
"-- json is the easy/suported data format across various \"web\" languages i use ( as2/as3/jscript/lua/php )\r\n"
"-- so the data is serialised in json format\r\n"
"\r\n"
"local tonumber=tonumber\r\n"
"\r\n"
"\r\n"
"local sql=require(\"wetgenes.cgilua.mysql\")\r\n"
"local json=require(\"wetgenes.json\")\r\n"
"\r\n"
"\r\n"
"local cgi = wetgenes.cgilua or require(\"wetgenes.cgilua\")\r\n"
"local cfg = cfg\r\n"
"\r\n"
"\r\n"
"local cgilua=cgilua\r\n"
"\r\n"
"local os=os\r\n"
"\r\n"
"\r\n"
"\r\n"
"local dbg=dbg or function(s) cgilua.errorlog(s) end\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"wetgenes.cgilua.mysqljson\")\r\n"
"\r\n"
"\r\n"
"base_sqltable={\r\n"
"	--	name		type			NULL	KEY,	default		extra\r\n"
"	{	\"id\",		\"bigint(20)\",	\"NO\",	\"PRI\",	nil,		\"auto_increment\"	}, -- unique object ID\r\n"
"	{	\"last\",		\"bigint(20)\",	\"NO\",	\"MUL\",	nil,		nil					}, -- last updated time\r\n"
"	{	\"latch\",	\"int(11)\",		\"NO\",	\"MUL\",	nil,		nil					}, -- a \"lock\" counter\r\n"
"	{	\"json\",		\"text\",			\"NO\",	nil,	nil,		nil					}, -- serialised data\r\n"
"}\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- create a data table\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function create_table(tabname)\r\n"
"\r\n"
"	sql.table_create(tabname,base_sqltable)\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- create a new item, you will need to call put, before it is actually created in the database\r\n"
"-- and of course the put may fail\r\n"
"-- set the id to 0 if you want to get an auto inc id\r\n"
"-- you may also create an item with a user id and perform a get rather than a put\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function create(tabname,id)\r\n"
"\r\n"
"local it={}\r\n"
"\r\n"
"	it.tabname=tabname\r\n"
"	it.id=id or 0\r\n"
"	it.last=os.time()\r\n"
"	it.latch=0\r\n"
"	it.data={}\r\n"
"	it.dirty=false\r\n"
"	it.json=json.Encode(it.data)\r\n"
"	\r\n"
"	return it\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- write data to database\r\n"
"-- this function may FAIL :)\r\n"
"-- need to take apropriate action if it does\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function put(it)\r\n"
"\r\n"
"	it.json=json.Encode(it.data) -- encode data, ready for send\r\n"
"	\r\n"
"	if it.id==0 or it.latch==0 then -- first write, so create a new ID\r\n"
"	\r\n"
"		local tab={}\r\n"
"		local t=os.time()\r\n"
"		local l=1\r\n"
"		\r\n"
"		tab.last=t\r\n"
"		tab.latch=l\r\n"
"		tab.json=it.json\r\n"
"		\r\n"
"		if it.id==0 then -- do not care about id\r\n"
"		\r\n"
"			local ret=sql.do_insert(it.tabname,tab)\r\n"
"			\r\n"
"			if ret==0 then return false end\r\n"
"			\r\n"
"			it.id=ret\r\n"
"		\r\n"
"		else -- we wish to create a fixed id\r\n"
"		\r\n"
"			tab.id=it.id\r\n"
"			local ret=sql.do_insert(it.tabname,tab)\r\n"
"			\r\n"
"			if ret~=1 then return false end\r\n"
"		end\r\n"
"	\r\n"
"		return true\r\n"
"			\r\n"
"	else -- update an existing item\r\n"
"	\r\n"
"		local tab={}\r\n"
"		local t=os.time()\r\n"
"		local l=it.latch+1\r\n"
"		\r\n"
"		tab.last=t\r\n"
"		tab.latch=l\r\n"
"		tab.json=it.json\r\n"
"		\r\n"
"		local ret=sql.do_update(it.tabname,tab,\" id=\"..it.id..\" AND latch=\"..it.latch)\r\n"
"		\r\n"
"		if ret==1 then -- updated OK\r\n"
"		\r\n"
"			it.latch=l\r\n"
"			it.last=t\r\n"
"		\r\n"
"			return true\r\n"
"		else\r\n"
"		\r\n"
"			it.dirty=true -- flag data as dirty\r\n"
"		\r\n"
"			return false\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	return false\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- get data from database using id\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function get(it)\r\n"
"\r\n"
"	local res=sql.execute([[\r\n"
"			SELECT *\r\n"
"			FROM ]]..it.tabname..[[\r\n"
"			WHERE id=]]..it.id..[[ ]])\r\n"
"			\r\n"
"	local tab=sql.named(res,1)\r\n"
"	\r\n"
"	if not tab then return false end\r\n"
"	\r\n"
"	it.last=tonumber(tab.last)\r\n"
"	it.latch=tonumber(tab.latch)\r\n"
"	it.json=tab.json\r\n"
"	\r\n"
"	it.data=json.Decode(it.json) or {} -- decode data so we may edit it\r\n"
"	\r\n"
"	it.dirty=false\r\n"
"	\r\n"
"	return true\r\n"
"\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.www.ngx.fetch","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"local ngx=require(\"ngx\")\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"--local socket=require(\"socket\")\n"
"--local http=require(\"socket.http\")\n"
"--local ltn12=require(\"ltn12\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.fetch\"]=_M\n"
"\n"
"--[[\n"
"\n"
"local function create()\n"
"\n"
"--log(\"CREATE\")\n"
"	local p={}\n"
"	local tcp=ngx.socket.tcp()\n"
"\n"
"	p.accept=function(_,...)\n"
"--log(\"accept\")\n"
"--log(...)\n"
"		return tcp:accept(...)\n"
"	end\n"
"\n"
"	p.bind=function(_,...)\n"
"--log(\"bind\")\n"
"--log(...)\n"
"		return tcp:bind(...)\n"
"	end\n"
"\n"
"	p.close=function(_,...)\n"
"--log(\"close\")\n"
"--log(...)\n"
"		return tcp:close(...)\n"
"	end\n"
"	\n"
"	p.connect=function(_,...)\n"
"--log(\"connect\")\n"
"--log(...)\n"
"		tcp:connect(...)\n"
"		return true\n"
"	end\n"
"\n"
"	p.getpeername=function(_,...)\n"
"--log(\"getpeername\")\n"
"--log(...)\n"
"		return tcp:getpeername(...)\n"
"	end\n"
"\n"
"	p.getsockname=function(_,...)\n"
"--log(\"getsockname\")\n"
"--log(...)\n"
"		return tcp:getsockname(...)\n"
"	end\n"
"\n"
"	p.getstats=function(_,...)\n"
"--log(\"getstats\")\n"
"--log(...)\n"
"		return tcp:getstats(...)\n"
"	end\n"
"\n"
"	p.listen=function(_,...)\n"
"--log(\"listen\")\n"
"--log(...)\n"
"		return tcp:listen(...)\n"
"	end\n"
"\n"
"	p.receive=function(_,...)\n"
"--log(\"receive\")\n"
"--log(...)\n"
"		local r=tcp:receive(...)\n"
"		return r\n"
"	end\n"
"\n"
"	p.send=function(_,...)\n"
"--log(\"send\")\n"
"--log(...)\n"
"		return tcp:send(...)\n"
"	end\n"
"\n"
"	p.setoption=function(_,...)\n"
"--log(\"setoption\")\n"
"--log(...)\n"
"		return tcp:setoption(...)\n"
"	end\n"
"\n"
"	p.setstats=function(_,...)\n"
"--log(\"setstats\")\n"
"--log(...)\n"
"		return tcp:setstats(...)\n"
"	end\n"
"\n"
"	p.settimeout=function(_,n)\n"
"--log(\"settimeout\")\n"
"--log(n)\n"
"		tcp:settimeout(n*1000)\n"
"		return true\n"
"	end\n"
"\n"
"	p.shutdown=function(_,...)\n"
"--log(\"shutdown\")\n"
"--log(...)\n"
"		return tcp:shutdown(...)\n"
"	end\n"
"\n"
"--log(wstr.dump(p))\n"
"\n"
"	return p\n"
"end\n"
"\n"
"]]\n"
"\n"
"function countzero()\n"
"	count=0\n"
"	api_time=0\n"
"end\n"
"countzero()\n"
"\n"
"local kind_props={}	-- default global props mapped to kinds\n"
"\n"
"local start_time -- handle simple api benchmarking of some calls\n"
"local function apis()\n"
"	start_time=os.time()\n"
"end\n"
"local function apie(...)\n"
"	api_time=api_time+os.time()-start_time\n"
"	return ...\n"
"end\n"
"\n"
"--[[\n"
"function get(url)\n"
"	log(\"fetch.get:\")\n"
"	apis()\n"
"	count=count+1\n"
"	\n"
"	local res = ngx.location.capture(\"/@fetch/\"..url)\n"
"\n"
"	ret={}\n"
"	ret.code=res.status\n"
"	ret.headers=res.header\n"
"	ret.body=res.body\n"
"\n"
"log(wstr.serialize(ret))\n"
"	\n"
"	apie()\n"
"	return ret\n"
"end\n"
"]]\n"
"\n"
"--[[\n"
"\n"
"function post(url,headers,body)\n"
"--	log(\"fetch.post:\"..url)\n"
"	apis()\n"
"	count=count+1\n"
"\n"
"	local res_body={}\n"
"\n"
"\n"
"	local suc, code , rheaders = assert(socket.http.request{\n"
"		create=create,\n"
"		url=url,\n"
"		method=\"POST\",\n"
"		headers=headers,\n"
"		source = ltn12.source.string(body),\n"
"		sink = ltn12.sink.table(res_body),\n"
"	})\n"
"	\n"
"--	log(\"Received \"..suc..\" \"..code..\"\\n"
"\") -- wstr.serialize(headers)\n"
"--	table.foreach(res_body,print)\n"
"	local ret={}\n"
"	ret.body=table.concat(res_body)\n"
"	ret.code=code\n"
"	ret.headers=rheaders\n"
"\n"
"	apie()\n"
"	return ret\n"
"end\n"
"\n"
"\n"
"\n"
"function get(url,headers,body)\n"
"	log(\"fetch.get:\"..url)\n"
"	log(wstr.dump(headers))\n"
"	log(wstr.dump(body))\n"
"	apis()\n"
"	count=count+1\n"
"\n"
"	local res_body={}\n"
"\n"
"	body=body or \"\"\n"
"	headers=headers or {\n"
"		[\"User-Agent\"]=\"Mozilla/5.0 (Windows NT 5.1; rv:8.0) Gecko/20100101 Firefox/8.0\",\n"
"		[\"Content-Length\"] = #body,\n"
"		[\"Referer\"]=url,\n"
"	}\n"
"\n"
"	local suc, code , rheaders = assert(socket.http.request{\n"
"		create=create,\n"
"		url=url,\n"
"		method=\"GET\",\n"
"		headers=headers,\n"
"--		source = ltn12.source.string(body),\n"
"		sink = ltn12.sink.table(res_body),\n"
"	})\n"
"	\n"
"--	log(\"Received \"..tostring(suc)..\" \"..tostring(code)..\"\\n"
"\") -- wstr.serialize(headers)\n"
"--	table.foreach(res_body,print)\n"
"	local ret={}\n"
"	ret.body=table.concat(res_body)\n"
"	ret.code=code\n"
"	ret.headers=rheaders\n"
"	log(\"Received \"..tostring(ret.body)..\"\\n"
"\")\n"
"\n"
"	apie()\n"
"	return ret\n"
"end\n"
"]]\n"
"\n"
"\n"
"function get(url,headers,body)\n"
"--	log(\"NEWfetch.get:\"..url)\n"
"\n"
"local ret\n"
"\n"
"	for i=1,10 do -- limit redirects\n"
"\n"
"--	log(\"NEWfetch.get:\"..url)\n"
"\n"
"		ret=ngx.location.capture(\"/_proxy\",{\n"
"			method=ngx.HTTP_GET,\n"
"			body=body,\n"
"			ctx={ headers = headers },\n"
"			vars={ _url = url },\n"
"		})\n"
"		ret.code=ret.status ret.status=nil -- rename status to code\n"
"		ret.mimetype=ret.header[\"Content-Type\"]\n"
"		\n"
"		if ret.code>=300 and ret.code<400 then -- follow redirects\n"
"		\n"
"			url=ret.header.Location\n"
"			\n"
"		else\n"
"			break			\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"--	log(\"NEWReceived \"..tostring(ret.body)..\"\\n"
"\")\n"
"\n"
"	return ret\n"
"end\n"
"\n"
"\n"
"function post(url,headers,body)\n"
"--	log(\"NEWfetch.post:\"..url)\n"
"\n"
"\n"
"	local ret=ngx.location.capture(\"/_proxy\",{\n"
"		method=ngx.HTTP_POST,\n"
"		body=body,\n"
"		ctx={ headers = headers },\n"
"		vars={ _url = url },\n"
"	})\n"
"	ret.code=ret.status ret.status=nil -- rename status to code\n"
"	ret.mimetype=ret.header[\"Content-Type\"]\n"
"\n"
"--	log(\"NEWReceived \"..tostring(ret.body)..\"\\n"
"\")\n"
"\n"
"	return ret\n"
"end\n"
"\n"
"",

"wetgenes.bake.gamecake","\r\n"
"local require=require\r\n"
"\r\n"
"local ipairs=ipairs\r\n"
"\r\n"
"module(...)\r\n"
"\r\n"
"function build(tab)\r\n"
"\r\n"
"	local bake=require(\"wetgenes.bake\")\r\n"
"	local bakejs=require(\"wetgenes.bake.js\")\r\n"
"\r\n"
"	-- where we are building from\r\n"
"	bake.cd_base	=	bake.cd_base or bake.get_cd()\r\n"
"	-- where we are building to\r\n"
"	bake.cd_out		=	bake.cd_out or 'out'\r\n"
"\r\n"
"	bake.files_min_js=bake.files_min_js or {}\r\n"
"	bake.files_min_js[ #bake.files_min_js + 1 ]=\"gamecake\"\r\n"
"\r\n"
"	local files_gamecake={}\r\n"
"	local r=bake.findfiles{basedir=\"../../js/gamecake/src\",dir=\"\",filter=\"%.js$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		files_gamecake[#files_gamecake+1]=v\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/js/gamecake/\"..v)\r\n"
"	end\r\n"
"\r\n"
"	bake.files_pp=bake.files_pp or {}\r\n"
"	for i,v in ipairs(files_gamecake) do\r\n"
"		bake.files_pp[ #bake.files_pp +1]={ \"../../js/gamecake/src\"..v , bake.cd_out..'/js/gamecake'..v }\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\"../../js/gamecake/jslib\",dir=\"\",filter=\"%.js$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/jslib\"..v)\r\n"
"		bake.copyfile(\"../../js/gamecake/jslib\"..v,bake.cd_out..\"/jslib\"..v)\r\n"
"	end\r\n"
"\r\n"
"	local r=bake.findfiles{basedir=\"../../js/gamecake/art\",dir=\"\",filter=\"%.swf$\"}\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		bake.create_dir_for_file(bake.cd_out..\"/art\"..v)\r\n"
"		bake.copyfile(\"../../js/gamecake/art\"..v,bake.cd_out..\"/art\"..v)\r\n"
"	end\r\n"
"\r\n"
"-- the main action happens here\r\n"
"	bakejs.build(tab)\r\n"
"\r\n"
"end\r\n"
"",

"wetgenes.fenestra.widget.button","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.button\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"\r\n"
"	if widget.data then\r\n"
"		widget.text=widget.data:get_string()\r\n"
"	end\r\n"
"\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.button=it\r\n"
"	widget.class=\"button\"\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.draw=draw\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"",

"wetgenes.fenestra.widget.file","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"-- a scrolling area, the widget is biger than display area but scroll bars allow you to see it all\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.file\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"	widget.class=\"file\"\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.draw=draw\r\n"
"\r\n"
"-- auto add the draging button as a child\r\n"
"--[[\r\n"
"	local ss=16\r\n"
"	if widget.hx<ss*2 then ss=widget.hx/2 end\r\n"
"	if widget.hy<ss*2 then ss=widget.hy/2 end\r\n"
"	\r\n"
"	widget.pan=		widget:add({class=\"pan\",	hx=widget.hx-ss,	hy=widget.hy-ss,	})\r\n"
"	widget.slidey=	widget:add({class=\"slide\",	hx=ss,				hy=widget.hy-ss,	px=widget.hx-ss,	py=0,\r\n"
"		datx={max=0},daty={max=1},color=0xffffffff})\r\n"
"	widget.slidex=	widget:add({class=\"slide\",	hx=widget.hx-ss,	hy=ss,           	px=0,           	py=widget.hy-ss,\r\n"
"		datx={max=1},daty={max=0},color=0xffffffff})\r\n"
"]]\r\n"
"	return widget\r\n"
"end\r\n"
"",

"wetgenes.gamecake.widgets.pan","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"-- an fbo cached area, that is an area which should always be drawn to a special buffer\r\n"
"-- and then the special buffer should be displayed\r\n"
"\r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,wpan)\r\n"
"wpan=wpan or {}\r\n"
"\r\n"
"function wpan.mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wpan.key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wpan.update(widget)\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function wpan.draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wpan.setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.pan=it\r\n"
"	widget.class=\"pan\"\r\n"
"	\r\n"
"	widget.pan_px=0\r\n"
"	widget.pan_py=0\r\n"
"	\r\n"
"	widget.key=wpan.key\r\n"
"	widget.mouse=wpan.mouse\r\n"
"	widget.update=wpan.update\r\n"
"	widget.draw=wpan.draw\r\n"
"	\r\n"
"--	widget.fbo=_G.win.fbo(0,0,0)\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"\r\n"
"return wpan\r\n"
"end\r\n"
"",

"wetgenes.fenestra.widget.data","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"--\r\n"
"-- handle widgets data values\r\n"
"--\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.data\")\r\n"
"\r\n"
"local call_hook=function(dat,hook)\r\n"
"	local hooks=dat.hooks\r\n"
"	local type_hooks=type(hooks)\r\n"
"	if type_hooks==\"function\" then -- master function\r\n"
"		return hooks(hook,dat)\r\n"
"	elseif type_hooks==\"table\" and hooks[hook] then -- or table of functions\r\n"
"		return hooks[hook](dat)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"-- set number (may trigger hook)\r\n"
"local data_value=function(dat,val)\r\n"
"	if dat.class==\"number\" then\r\n"
"		if val then val=tonumber(val) end -- auto convert from string\r\n"
"		if val and val~=dat.num then -- change value\r\n"
"			if dat.min and dat.num<dat.min then dat.num=dat.min end\r\n"
"			if dat.max and dat.num>dat.max then dat.num=dat.max end\r\n"
"			dat.str=dat:get_string() -- cache on change\r\n"
"			dat:call_hook(\"value\") -- call value hook, which may choose to mod the num some more...\r\n"
"		end\r\n"
"		return dat.num\r\n"
"	else\r\n"
"		if val and val~=dat.str then -- change value\r\n"
"			dat.str=val\r\n"
"			dat:call_hook(\"value\") -- call value hook, which may choose to mod the num some more...\r\n"
"		end\r\n"
"		return dat.str\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"-- a string to put in the handle\r\n"
"local data_get_string=function(dat)\r\n"
"	if dat.class==\"number\" then return tostring(dat.num) end\r\n"
"	return dat.str\r\n"
"end\r\n"
"\r\n"
"-- how wide or tall should the handle be given the size of the parent?\r\n"
"local data_get_size=function(dat,w)\r\n"
"	local ret=16\r\n"
"	if dat.min==dat.max then\r\n"
"		ret=w					-- fullsize\r\n"
"	elseif dat.size==0 then\r\n"
"		ret=w/4					-- some random room to scroll\r\n"
"	else\r\n"
"		ret=w*dat.size			-- use the given size\r\n"
"	end\r\n"
"	if ret<16 then ret=16 end\r\n"
"	if ret>w then ret=w end\r\n"
"	return ret\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-- get display pos, given the size of the parent and our size?\r\n"
"local data_get_pos=function(dat,psiz,bsiz)\r\n"
"	if dat.step==0 then -- no snap\r\n"
"		return ((dat.num-dat.min)/(dat.max-dat.min))\r\n"
"	else\r\n"
"		return ((dat.num-dat.min)/(dat.max-dat.min))\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"-- given the parents size and our relative position/size within it\r\n"
"-- update dat.num and return a new position (for snapping)\r\n"
"local data_snap=function(dat,psiz,bsiz,bpos)\r\n"
"	if dat.step==0 then -- no snap\r\n"
"		if dat.max==dat.min then dat:value(dat.min) return 0 end -- do not move\r\n"
"		\r\n"
"		local f=bpos/(psiz-bsiz)\r\n"
"		dat:value(dat.min+((dat.max-dat.min)*f))\r\n"
"		\r\n"
"		return bpos\r\n"
"		\r\n"
"	else\r\n"
"	\r\n"
"		if dat.max==dat.min then dat:value(dat.min) return 0 end -- do not move\r\n"
"		\r\n"
"		local f=bpos/(psiz-bsiz)\r\n"
"		local n=math.floor(0.5+(((dat.max-dat.min)*f)/dat.step))\r\n"
"\r\n"
"		dat:value(dat.min+(n*dat.step))\r\n"
"		\r\n"
"		return math.floor((psiz-bsiz)*((dat.num-dat.min)/(dat.max-dat.min)))\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function new_data(dat)\r\n"
"\r\n"
"	local dat=dat or {} -- probably use what is passed in only fill in more values\r\n"
"--	dat.widget=it.widget\r\n"
"--	dat.it=it\r\n"
"--	dat.id=id\r\n"
"\r\n"
"	dat.class=dat.class or \"number\" -- could also be a \"string\"\r\n"
"\r\n"
"-- make default values and ranges for every possible class\r\n"
"-- this is very heavy data...\r\n"
"\r\n"
"	dat.lst=dat.lst or {}\r\n"
"\r\n"
"	dat.str=dat.str or \"\"\r\n"
"	dat.str_idx=dat.str_idx or 0\r\n"
"\r\n"
"	dat.num=dat.num or 0\r\n"
"	dat.min=dat.min or 0 -- not negative by default\r\n"
"	dat.max=dat.max or (2^48) -- a big old number\r\n"
"	dat.size=dat.size or 0 -- if 0 then button is auto sized to some value\r\n"
"	dat.step=dat.step or 0 -- if 0 then there is no quantization\r\n"
"	\r\n"
"	\r\n"
"-- setup callback functions\r\n"
"\r\n"
"	dat.call_hook=call_hook\r\n"
"\r\n"
"	dat.get_string=data_get_string -- should be moved into value() ?\r\n"
"	dat.get_size=data_get_size\r\n"
"	dat.get_pos=data_get_pos\r\n"
"	\r\n"
"-- get or set the value\r\n"
"	dat.value=data_value\r\n"
"\r\n"
"-- work out snapping for scroll bars	\r\n"
"	dat.snap=data_snap\r\n"
"\r\n"
"	dat:value(dat,dat.num) -- triger value changed/set callbacks\r\n"
"	\r\n"
"	return dat\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"\r\n"
"",

"alc","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local alc={}\n"
"\n"
"local core=require(\"alc.core\")\n"
"\n"
"local base={}\n"
"local meta={}\n"
"meta.__index=base\n"
"\n"
"setmetatable(alc,meta)\n"
"\n"
"-- copypasta from ALC header\n"
"local import=[[\n"
"/* Enumerant values begin at column 50. No tabs. */\n"
"\n"
"/* Boolean False. */\n"
"#define ALC_FALSE                                0\n"
"\n"
"/* Boolean True. */\n"
"#define ALC_TRUE                                 1\n"
"\n"
"/**\n"
" * followed by <int> Hz\n"
" */\n"
"#define ALC_FREQUENCY                            0x1007\n"
"\n"
"/**\n"
" * followed by <int> Hz\n"
" */\n"
"#define ALC_REFRESH                              0x1008\n"
"\n"
"/**\n"
" * followed by AL_TRUE, AL_FALSE\n"
" */\n"
"#define ALC_SYNC                                 0x1009\n"
"\n"
"/**\n"
" * followed by <int> Num of requested Mono (3D) Sources\n"
" */\n"
"#define ALC_MONO_SOURCES                         0x1010\n"
"\n"
"/**\n"
" * followed by <int> Num of requested Stereo Sources\n"
" */\n"
"#define ALC_STEREO_SOURCES                       0x1011\n"
"\n"
"/**\n"
" * errors\n"
" */\n"
"\n"
"/**\n"
" * No error\n"
" */\n"
"#define ALC_NO_ERROR                             ALC_FALSE\n"
"\n"
"/**\n"
" * No device\n"
" */\n"
"#define ALC_INVALID_DEVICE                       0xA001\n"
"\n"
"/**\n"
" * invalid context ID\n"
" */\n"
"#define ALC_INVALID_CONTEXT                      0xA002\n"
"\n"
"/**\n"
" * bad enum\n"
" */\n"
"#define ALC_INVALID_ENUM                         0xA003\n"
"\n"
"/**\n"
" * bad value\n"
" */\n"
"#define ALC_INVALID_VALUE                        0xA004\n"
"\n"
"/**\n"
" * Out of memory.\n"
" */\n"
"#define ALC_OUT_OF_MEMORY                        0xA005\n"
"\n"
"\n"
"/**\n"
" * The Specifier string for default device\n"
" */\n"
"#define ALC_DEFAULT_DEVICE_SPECIFIER             0x1004\n"
"#define ALC_DEVICE_SPECIFIER                     0x1005\n"
"#define ALC_EXTENSIONS                           0x1006\n"
"\n"
"#define ALC_MAJOR_VERSION                        0x1000\n"
"#define ALC_MINOR_VERSION                        0x1001\n"
"\n"
"#define ALC_ATTRIBUTES_SIZE                      0x1002\n"
"#define ALC_ALL_ATTRIBUTES                       0x1003\n"
"\n"
"\n"
"/**\n"
" * Capture extension\n"
" */\n"
"#define ALC_EXT_CAPTURE 1\n"
"#define ALC_CAPTURE_DEVICE_SPECIFIER             0x310\n"
"#define ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER     0x311\n"
"#define ALC_CAPTURE_SAMPLES                      0x312\n"
"\n"
"\n"
"/**\n"
" * ALC_ENUMERATE_ALL_EXT enums\n"
" */\n"
"#define ALC_ENUMERATE_ALL_EXT 1\n"
"#define ALC_DEFAULT_ALL_DEVICES_SPECIFIER        0x1012\n"
"#define ALC_ALL_DEVICES_SPECIFIER                0x1013\n"
"\n"
"]]\n"
"-- parse the above string for constants, makes updates as easy as a cutnpaste from original source code\n"
"\n"
"alc.defs={}\n"
"\n"
"for l in import:gmatch(\"([^\\n"
"]*)\") do\n"
"	local define,value\n"
"	local state=\"start\"\n"
"	for w in l:gmatch(\"([^%s]+)\") do\n"
"		if state==\"start\" then\n"
"			if w==\"#define\" then\n"
"				state=\"define\"\n"
"			else\n"
"				break\n"
"			end\n"
"		elseif state==\"define\" then\n"
"			define=w\n"
"			state=\"value\"\n"
"		elseif state==\"value\" then\n"
"			value=w\n"
"				if define:sub(1,4)==\"ALC_\" then -- sanity check\n"
"					define=define:sub(5)\n"
"					\n"
"					if value:sub(1,4)==\"ALC_\" then -- allow lookback\n"
"						value=alc.defs[value:sub(5)]\n"
"					end\n"
"					\n"
"					alc.defs[define]=tonumber(value)\n"
"				end\n"
"			break\n"
"		else\n"
"			break\n"
"		end\n"
"	end\n"
"end\n"
"import=nil -- free it just because\n"
"\n"
"for i,v in pairs(alc.defs) do -- copy vals into base for shorthand al.FALSE use\n"
"	base[i]=v\n"
"	base[v]=i\n"
"end\n"
"\n"
"\n"
"function alc.GetError(...)\n"
"	return core.GetError(...)\n"
"end\n"
"\n"
"function alc.OpenDevice(...)\n"
"	return core.OpenDevice(...)\n"
"end\n"
"function alc.CloseDevice(...)\n"
"	return core.CloseDevice(...)\n"
"end\n"
"\n"
"function alc.CreateContext(...)\n"
"	return core.CreateContext(...)\n"
"end\n"
"function alc.DestroyContext(...)\n"
"	return core.DestroyContext(...)\n"
"end\n"
"\n"
"function alc.MakeContextCurrent(...)\n"
"	return core.MakeContextCurrent(...)\n"
"end\n"
"\n"
"--TODO: include device and context options\n"
"function alc.setup(opts)\n"
"	opts=opts or {}\n"
"	local dc={}\n"
"	dc.alc=alc\n"
"	dc.opts=opts\n"
"	dc.device=alc.OpenDevice()\n"
"	dc.context=alc.CreateContext(dc.device)\n"
"	dc.clean=alc.clean\n"
"	alc.MakeContextCurrent(dc.context)\n"
"	return dc\n"
"end\n"
"\n"
"function alc.clean(dc)\n"
"-- cleanup must happen in this order\n"
"	alc.MakeContextCurrent()\n"
"	if dc.context then dc.context=alc.DestroyContext(dc.context) end\n"
"	if dc.device then dc.device=alc.CloseDevice(dc.device) end\n"
"	return dc\n"
"end\n"
"\n"
"return alc\n"
"",

"wetgenes.cgilua.mysql","\r\n"
"--\r\n"
"-- Mysql helper functions\r\n"
"--\r\n"
"\r\n"
"\r\n"
"local type,ipairs,pairs,tonumber=type,ipairs,pairs,tonumber\r\n"
"\r\n"
"local string=string\r\n"
"\r\n"
"local cgilua=cgilua\r\n"
"\r\n"
"local cfg = cfg\r\n"
"\r\n"
"\r\n"
"local luasql = require(\"luasql.mysql\")\r\n"
"local sql = luasql.mysql()\r\n"
"\r\n"
"local dbg=dbg or function(s) cgilua.errorlog(s) end\r\n"
"\r\n"
"module(\"wetgenes.cgilua.mysql\")\r\n"
"\r\n"
"query_count=0\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function setup()\r\n"
"	clean()\r\n"
"	\r\n"
"local err\r\n"
"\r\n"
"	con,err=sql:connect(cfg.mysql_database,cfg.mysql_username,cfg.mysql_password,cfg.mysql_hostname)\r\n"
"	\r\n"
"	if not con then\r\n"
"	\r\n"
"		dbg(\"\\n"
"\"..\"Failed to connect to mysql\"..(err or \"unknown\")..\"\\n"
"\") -- print error\r\n"
"		\r\n"
"		return nil\r\n"
"	end\r\n"
"	\r\n"
"	cgilua.addclosefunction( clean )\r\n"
"\r\n"
"	return _M\r\n"
"end\r\n"
"function clean()\r\n"
"	if con then con:close() end\r\n"
"	con=nil\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert a string into a hex string\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function str_to_hex(s)\r\n"
"	return string.gsub(s, \".\", function (c)\r\n"
"		return string.format(\"%02x\", string.byte(c))\r\n"
"	end)\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- escape a string for mysql, convert to a (possibly large) number in hex\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function mysql_escape(s)\r\n"
"	return \"0x\"..str_to_hex(s)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"--[[\r\n"
"+------------+----------+------+-----+---------+----------------+\r\n"
"| Field      | Type     | Null | Key | Default | Extra          |\r\n"
"+------------+----------+------+-----+---------+----------------+\r\n"
"| Id         | int(11)  | NO   | PRI | NULL    | auto_increment |\r\n"
"| Name       | char(35) | NO   |     |         |                |\r\n"
"| Country    | char(3)  | NO   | UNI |         |                |\r\n"
"| District   | char(20) | YES  | MUL |         |                |\r\n"
"| Population | int(11)  | NO   |     | 0       |                |\r\n"
"+------------+----------+------+-----+---------+----------------+\r\n"
"]]\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- mysql table creation system\r\n"
"--\r\n"
"-- check if a table exists, if it doesnt then just create it\r\n"
"--\r\n"
"-- then check each column, any column that doesnt exist but should is then added\r\n"
"--\r\n"
"-- name is the name of the table\r\n"
"-- cols, consists of the result you would expect from a SHOW COLUMNS FROM query\r\n"
"-- any descrepencies will be reported,\r\n"
"-- see above for example showing columns output\r\n"
"--\r\n"
"-- extra is other mysql key creation to put onto the end of the initial table creation\r\n"
"-- any post creation optimisation will have to happen by hand, maintaining the table columns consistency is the important bit\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function table_create(name,cols,extra)\r\n"
"\r\n"
"local cur,err\r\n"
"local q\r\n"
"\r\n"
"-- build table creation string\r\n"
"\r\n"
"	q=\"\"\r\n"
"	q=q..[[ CREATE TABLE IF NOT EXISTS `]]..name..[[` ( ]]..\"\\n"
"\"\r\n"
"	\r\n"
"	for i,v in ipairs(cols) do\r\n"
"	\r\n"
"		local l\r\n"
"		\r\n"
"		if i==1 then l=\"\" else l=\",\\n"
"\" end\r\n"
"		\r\n"
"		l=l..[[ `]]..v[1]..[[` ]]..v[2]\r\n"
"		\r\n"
"		if v[3]==\"NO\" then l=l..\" NOT NULL\" end\r\n"
"		if v[5] then l=l..\" DEFAULT \"..v[5] end\r\n"
"		if v[6] then l=l..\" \"..v[6] end\r\n"
"		\r\n"
"		q=q..l\r\n"
"	\r\n"
"	end\r\n"
"		\r\n"
"	for i,v in ipairs(cols) do -- add extra key optimizations to the table\r\n"
"	\r\n"
"		if v[4] then\r\n"
"		\r\n"
"			local l=\",\\n"
"\"\r\n"
"			\r\n"
"			if v[4]==\"PRI\" then\r\n"
"			\r\n"
"				l=l..[[ PRIMARY KEY (`]]..v[1]..[[`) ]]\r\n"
"			\r\n"
"			elseif v[4]==\"MUL\" then\r\n"
"			\r\n"
"				l=l..[[ KEY `]]..v[1]..[[` (`]]..v[1]..[[`) ]]\r\n"
"				\r\n"
"			elseif v[4]==\"UNI\" then\r\n"
"			\r\n"
"				l=l..[[ UNIQUE KEY `]]..v[1]..[[` (`]]..v[1]..[[`) ]]\r\n"
"			\r\n"
"			end\r\n"
"			\r\n"
"			q=q..l\r\n"
"			\r\n"
"		end\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	if extra then -- include extra table creation lines for keys etc\r\n"
"	\r\n"
"		q=q..\",\\n"
" \"..extra\r\n"
"	\r\n"
"	end\r\n"
"		\r\n"
"	q=q..[[ ) ]]..\"\\n"
"\"\r\n"
"\r\n"
"--dbg(\"**Preparing table \" ..name..\"\\n"
"\")\r\n"
"--dbg(q)\r\n"
"\r\n"
"	cur,err=con:execute(q)\r\n"
"	if not cur and err then dbg(\"\\n"
"\"..err..\"\\n"
"\") end\r\n"
"	\r\n"
"	cur,err=con:execute(\"SHOW COLUMNS FROM \"..name)\r\n"
"	if not cur and err then dbg(\"\\n"
"\"..err..\"\\n"
"\") end\r\n"
"	\r\n"
"	local i=1\r\n"
"	local r\r\n"
"	local tab={}\r\n"
"\r\n"
"	repeat\r\n"
"	\r\n"
"		r=cur:fetch({})\r\n"
"		tab[i]=r\r\n"
"		i=i+1\r\n"
"	\r\n"
"	until not r\r\n"
"	\r\n"
"--dbg(\"**Checking table \" ..name..\"\\n"
"\")\r\n"
"	for i,v in ipairs(tab) do\r\n"
"	\r\n"
"		local s\r\n"
"		for ii,vv in ipairs(v) do\r\n"
"			if s then s=s..\"\\t\"..vv else s=vv end\r\n"
"		end\r\n"
"	\r\n"
"--		dbg( s..\"\\n"
"\" )\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"--dbg(\"**Created table \" ..name..\"\\n"
"\")\r\n"
"\r\n"
"	if cur then cur:close() end\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- perform the sql queery\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function execute(q,flags)\r\n"
"\r\n"
"local cur,ret,err\r\n"
"local lastid,lastcur\r\n"
"\r\n"
"	\r\n"
"query_count=query_count+1\r\n"
"	cur,err=con:execute(q)\r\n"
"	\r\n"
"	if not cur and err then -- indicate failure\r\n"
"	\r\n"
"		dbg(\"\\n"
"\"..err..\"\\n"
"\") -- print error\r\n"
"		\r\n"
"		return nil\r\n"
"	end\r\n"
"	\r\n"
"	if type(cur)==\"number\" then -- a single number return value\r\n"
"	\r\n"
"		if flags==\"lastid\" and (cur~=0) then -- get last id\r\n"
"		\r\n"
"			lastcur,err=con:execute(\"SELECT LAST_INSERT_ID()\")\r\n"
"			\r\n"
"			if not lastcur and err then -- indicate failure\r\n"
"			\r\n"
"				dbg(\"\\n"
"\"..err..\"\\n"
"\") -- print error\r\n"
"				\r\n"
"				lastid=0\r\n"
"				\r\n"
"			else\r\n"
"			\r\n"
"				lastid=lastcur:fetch({})[1]\r\n"
"				\r\n"
"				lastid=tonumber(lastid)\r\n"
"				\r\n"
"				if lastcur then lastcur:close() end\r\n"
"				\r\n"
"--				dbg(\"\\n"
" LASTID = \"..lastid..\"\\n"
"\") -- print error\r\n"
"			end\r\n"
"			\r\n"
"			return lastid\r\n"
"		end\r\n"
"	\r\n"
"		return cur\r\n"
"	end\r\n"
"	\r\n"
"	ret={}\r\n"
"	\r\n"
"	ret.names=cur:getcolnames()\r\n"
"	ret.types=cur:getcoltypes()\r\n"
"	\r\n"
"	local i=1\r\n"
"	local r\r\n"
"	\r\n"
"	repeat\r\n"
"	\r\n"
"		r=cur:fetch({})\r\n"
"		ret[i]=r\r\n"
"		i=i+1\r\n"
"	\r\n"
"	until not r\r\n"
"		\r\n"
"	if cur then cur:close() end\r\n"
"	return ret\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- fill up a table with named results\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function named(tab,idx)\r\n"
"\r\n"
"	if (not tab) or (not tab[idx]) then return nil end\r\n"
"\r\n"
"local ret={}\r\n"
"\r\n"
"	for i,v in ipairs(tab.names) do\r\n"
"		ret[v]=tab[idx][i]\r\n"
"	end\r\n"
"\r\n"
"	return ret\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- insert or update data on clash, similar format to the lanes returned info\r\n"
"-- this function doesnt do anything it just builds a queery string that will\r\n"
"--\r\n"
"-- name == table name\r\n"
"-- row == data to insert\r\n"
"--\r\n"
"-- row.names == table of named columns\r\n"
"-- row[1] == table of data (strings need to have already been fixed/escaped)\r\n"
"--\r\n"
"-- this is a single insert or update, so there is only one row\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function make_set(name,row)\r\n"
"\r\n"
"local q=\"INSERT INTO \"..name..\" SET \"\r\n"
"\r\n"
"	for i,v in ipairs(row.names) do\r\n"
"	\r\n"
"		local sep=\", \\n"
"\" if i==1 then sep=\" \\n"
"\" end\r\n"
"		\r\n"
"		q=q..sep..v..\"=\"..row[1][i]..\" \"\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	q=q..\"\\n"
" ON DUPLICATE KEY UPDATE \"\r\n"
"\r\n"
"	for i,v in ipairs(row.names) do\r\n"
"	\r\n"
"		local sep=\", \\n"
"\" if i==1 then sep=\" \\n"
"\" end\r\n"
"		\r\n"
"		q=q..sep..v..\"=\"..row[1][i]..\" \"\r\n"
"	\r\n"
"	end\r\n"
"		\r\n"
"	return q\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- insert only, similar format to the lanes returned info\r\n"
"-- this function doesnt do anything it just builds a queery string that will\r\n"
"--\r\n"
"-- name == table name\r\n"
"-- row == data to insert\r\n"
"--\r\n"
"-- row.names == table of named columns\r\n"
"-- row[1] == table of data (strings need to have already been fixed/escaped)\r\n"
"--\r\n"
"-- this is a single insert or update, so there is only one row\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function make_insert(name,row)\r\n"
"\r\n"
"local q=\"INSERT INTO \"..name..\" SET \"\r\n"
"\r\n"
"	for i,v in ipairs(row.names) do\r\n"
"	\r\n"
"		local sep=\", \\n"
"\" if i==1 then sep=\" \\n"
"\" end\r\n"
"		\r\n"
"		q=q..sep..v..\"=\"..row[1][i]..\" \"\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	q=q..\"\\n"
"\"\r\n"
"		\r\n"
"	return q\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- update only, similar format to the lanes returned info\r\n"
"-- this function doesnt do anything it just builds a queery string that will\r\n"
"--\r\n"
"-- name == table name\r\n"
"-- row == data to insert\r\n"
"-- where == where to update\r\n"
"--\r\n"
"-- row.names == table of named columns\r\n"
"-- row[1] == table of data (strings need to have already been fixed/escaped)\r\n"
"--\r\n"
"-- this is a single insert or update, so there is only one row\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function make_update(name,row,where)\r\n"
"\r\n"
"local q=\"UPDATE \"..name..\" SET \"\r\n"
"\r\n"
"	for i,v in ipairs(row.names) do\r\n"
"	\r\n"
"		local sep=\", \\n"
"\" if i==1 then sep=\" \\n"
"\" end\r\n"
"		\r\n"
"		q=q..sep..v..\"=\"..row[1][i]..\" \"\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	q=q..\"\\n"
" WHERE \"..where\r\n"
"		\r\n"
"	return q\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- convert a table into a row set\r\n"
"--\r\n"
"-- returns row where\r\n"
"--\r\n"
"-- row.names == table of named columns\r\n"
"-- row[1] == table of data with strings fixed/escaped\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function tab_to_row(dat)\r\n"
"\r\n"
"	local idx=1\r\n"
"	local row={}\r\n"
"	row.names={}\r\n"
"	row[1]={}\r\n"
"	\r\n"
"	for n,v in pairs(dat) do -- build and fixup mysql data\r\n"
"	\r\n"
"		row.names[idx]=n\r\n"
"		\r\n"
"		if type(v)==\"string\" then\r\n"
"		\r\n"
"			if v==\"\" then\r\n"
"			\r\n"
"				row[1][idx]=\"DEFAULT\"\r\n"
"				\r\n"
"			else\r\n"
"		\r\n"
"				row[1][idx]=mysql_escape(v)\r\n"
"			\r\n"
"			end\r\n"
"			\r\n"
"		else\r\n"
"		\r\n"
"			row[1][idx]=v\r\n"
"		\r\n"
"		end\r\n"
"		\r\n"
"		idx=idx+1\r\n"
"	\r\n"
"	end\r\n"
"		\r\n"
"	return row\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- create and perform a blocking data insert or update\r\n"
"--\r\n"
"-- just pass in a tab and it will build and execute a sql query to add or change that data\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function do_set(name,tab)\r\n"
"\r\n"
"	return execute( make_set(name,tab_to_row(tab)) , \"lastid\" )\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- create and perform a blocking data insert\r\n"
"--\r\n"
"-- just pass in a tab and it will build and execute a sql query to add or change that data\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function do_insert(name,tab)\r\n"
"\r\n"
"	return execute( make_insert(name,tab_to_row(tab)) , \"lastid\" )\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- create and perform a blocking data update\r\n"
"--\r\n"
"-- just pass in a tab and it will build and execute a sql query to add or change that data\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"function do_update(name,tab,where)\r\n"
"\r\n"
"	return execute( make_update(name,tab_to_row(tab),where) )\r\n"
"	\r\n"
"end\r\n"
"",

"wetgenes.fenestra.widget.slide","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"-- two basic widgets merged together to give a simple slide or scrollbar \r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.slide\")\r\n"
"\r\n"
"local widget_data=require(\"fenestra.widget.data\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"--	local it=widget.slide\r\n"
"\r\n"
"\r\n"
"	widget:snap()\r\n"
"\r\n"
"--	it.drag.text=it.datx:get_string()\r\n"
"	\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function layout(widget)\r\n"
"\r\n"
"	widget.drag.hx=widget.datx:get_size(widget.hx)\r\n"
"	widget.drag.hy=widget.daty:get_size(widget.hy)\r\n"
"\r\n"
"	widget.meta.layout(widget)	\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"function slide_snap(it)\r\n"
"\r\n"
"-- auto snap positions when draged\r\n"
"	it.drag.px=it.datx:snap( it.hx , it.drag.hx , it.drag.px )\r\n"
"	it.drag.pxd=it.pxd+it.drag.px\r\n"
"	\r\n"
"-- upside down y so need to twiddle it, pyr is \"the right way up\"\r\n"
"	it.drag.py=it.daty:snap( it.hy , it.drag.hy , it.drag.py )\r\n"
"	it.drag.pyd=it.pyd-it.drag.py\r\n"
"	\r\n"
"end\r\n"
"	\r\n"
"function setup(widget,def)\r\n"
"--	local it={} -- our main data so as not to clobber widget values\r\n"
"--	it.widget=widget\r\n"
"--	widget.slide=it\r\n"
"	widget.class=\"slide\"\r\n"
"	\r\n"
"	widget.snap=slide_snap\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.layout=layout\r\n"
"	\r\n"
"--setup constraints in x and y \r\n"
"	widget.datx=widget_data.new_data(def.datx)\r\n"
"	widget.daty=widget_data.new_data(def.daty)\r\n"
"\r\n"
"-- auto add the draging button as a child\r\n"
"	widget.drag=widget:add({class=\"drag\",color=0xffffffff,hy=widget.daty:get_size(widget.hy),hx=widget.datx:get_size(widget.hx),pxf=widget.datx:get_pos(),pyf=widget.daty:get_pos(),data=widget.data})\r\n"
"	\r\n"
"	return widget\r\n"
"end\r\n"
"",

"wetgenes.fenestra.widget.scroll","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"-- a scrolling area, the widget is biger than display area but scroll bars allow you to see it all\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.scroll\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"\r\n"
"	local pan=widget.pan\r\n"
"	\r\n"
"	local pan_px=-widget.datx.num\r\n"
"	local pan_py=widget.daty.num\r\n"
"	\r\n"
"	if pan_px~=pan.pan_px or pan_py~=pan.pan_py then\r\n"
"	\r\n"
"		pan.pan_px=pan_px\r\n"
"		pan.pan_py=pan_py\r\n"
"		\r\n"
"		pan:set_dirty()\r\n"
"	end\r\n"
"\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function draw(widget)\r\n"
"\r\n"
"--	local it=widget.scroll\r\n"
"	\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"function layout(widget)\r\n"
"\r\n"
"--	local it=widget.scroll\r\n"
"	\r\n"
"	widget.meta.layout(widget.pan)\r\n"
"\r\n"
"	widget.datx.max=widget.pan.hx-widget.pan.sx\r\n"
"	if widget.datx.max<0 then widget.datx.max=0 end\r\n"
"	widget.datx.size=widget.pan.sx/widget.pan.hx\r\n"
"	\r\n"
"	widget.daty.max=widget.pan.hy-widget.pan.sy\r\n"
"	if widget.daty.max<0 then widget.daty.max=0 end\r\n"
"	widget.daty.size=widget.pan.sy/widget.pan.hy\r\n"
"	\r\n"
"	widget.meta.layout(widget)\r\n"
"end\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.scroll=it\r\n"
"	widget.class=\"scroll\"\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.layout=layout\r\n"
"	widget.draw=draw\r\n"
"\r\n"
"-- auto add the draging button as a child\r\n"
"	local ss=16\r\n"
"	if widget.hx<ss*2 then ss=widget.hx/2 end\r\n"
"	if widget.hy<ss*2 then ss=widget.hy/2 end\r\n"
"	\r\n"
"	widget.datx={max=1}\r\n"
"	widget.daty={max=1}\r\n"
"	\r\n"
"	widget.pan=		widget:add({class=\"pan\",	hx=widget.hx-ss,	hy=widget.hy-ss,	})\r\n"
"	widget.slidey=	widget:add({class=\"slide\",	hx=ss,				hy=widget.hy-ss,	px=widget.hx-ss,	py=0,\r\n"
"		datx={max=0},daty=widget.daty,color=0xffffffff})\r\n"
"	widget.slidex=	widget:add({class=\"slide\",	hx=widget.hx-ss,	hy=ss,           	px=0,           	py=widget.hy-ss,\r\n"
"		datx=widget.datx,daty={max=0},color=0xffffffff})\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"",

"wetgenes.fenestra.widget.pan","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"-- an fbo cached area, that is an area which should always be drawn to a special buffer\r\n"
"-- and then the special buffer should be displayed\r\n"
"\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.pan\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.pan=it\r\n"
"	widget.class=\"pan\"\r\n"
"	\r\n"
"	widget.pan_px=0\r\n"
"	widget.pan_py=0\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.draw=draw\r\n"
"	\r\n"
"	widget.fbo=_G.win.fbo(0,0,0)\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"",

"wetgenes.fenestra.console","\r\n"
"\r\n"
"local hex=function(str) return tonumber(str,16) end\r\n"
"\r\n"
"local string=string\r\n"
"local table=table\r\n"
"local ipairs=ipairs\r\n"
"local math=math\r\n"
"local loadstring=loadstring\r\n"
"local pcall=pcall\r\n"
"\r\n"
"-- imported global functions\r\n"
"local sub = string.sub\r\n"
"local match = string.match\r\n"
"local find = string.find\r\n"
"local push = table.insert\r\n"
"local pop = table.remove\r\n"
"local append = table.insert\r\n"
"local concat = table.concat\r\n"
"local floor = math.floor\r\n"
"local write = io.write\r\n"
"local read = io.read\r\n"
"local type = type\r\n"
"local setfenv = setfenv\r\n"
"local tostring=tostring\r\n"
"local pairs=pairs\r\n"
"local ipairs=ipairs\r\n"
"local unpack=unpack\r\n"
"local require=require\r\n"
"\r\n"
"local _G = _G\r\n"
"\r\n"
"module(\"fenestra.console\")\r\n"
"local fenestra_buffedit=require(\"fenestra.buffedit\")\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- split a string into a table\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"local function split(div,str)\r\n"
"\r\n"
"  if (div=='') or not div then error(\"div expected\", 2) end\r\n"
"  if (str=='') or not str then error(\"str expected\", 2) end\r\n"
"  \r\n"
"  local pos,arr = 0,{}\r\n"
"  \r\n"
"  -- for each divider found\r\n"
"  for st,sp in function() return string.find(str,div,pos,false) end do\r\n"
"	table.insert(arr,sub(str,pos,st-1)) -- Attach chars left of current divider\r\n"
"	pos = sp + 1 -- Jump past current divider\r\n"
"  end\r\n"
"  \r\n"
"  if pos~=0 then\r\n"
"	table.insert(arr,sub(str,pos)) -- Attach chars right of last divider\r\n"
"  else\r\n"
"	table.insert(arr,str) -- return entire string\r\n"
"  end\r\n"
"  \r\n"
"  \r\n"
"  return arr\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"function setup(fenestra)\r\n"
"\r\n"
"	local function print(...)\r\n"
"		fenestra._g.print(...)\r\n"
"	end\r\n"
"\r\n"
"	local ogl=fenestra.ogl\r\n"
"\r\n"
"	local it={}\r\n"
"	\r\n"
"	it.buff=fenestra_buffedit.create() -- create buff edit\r\n"
"	it.buff.enter=function(_,line) it.dump_eval(line) end\r\n"
"	\r\n"
"	it.lines={}\r\n"
"	it.lines_display={}\r\n"
"	\r\n"
"	it.x=0\r\n"
"	it.y=0\r\n"
"	it.y_show=8*8\r\n"
"	\r\n"
"	it.show=false\r\n"
"\r\n"
"	function it.clean()\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"	-- print out lua data in a somewhat sensible way, returns a string\r\n"
"	it.dump_limit = 20\r\n"
"	it.dump_depth = 7\r\n"
"	it.dump_stack = {}\r\n"
"\r\n"
"	it.call = {} -- name -> function : functions that should be easily to call on the console command line\r\n"
"	\r\n"
"	it.call.help=function()\r\n"
"		local t={}\r\n"
"		for n,f in pairs(it.call) do\r\n"
"			t[#t+1]=n\r\n"
"		end\r\n"
"		return table.concat(t,\" \")\r\n"
"	end\r\n"
"	\r\n"
"	function it.dump_table(tbl,delim)\r\n"
"		local n = #tbl\r\n"
"		local res = ''\r\n"
"		local k = 0\r\n"
"		-- very important to avoid disgracing ourselves with circular referencs...\r\n"
"		if #it.dump_stack > it.dump_depth then\r\n"
"			return \"...\"\r\n"
"		end\r\n"
"		for i,t in ipairs(it.dump_stack) do\r\n"
"			if tbl == t then\r\n"
"				return \"<self>\"\r\n"
"			end\r\n"
"		end\r\n"
"		push(it.dump_stack,tbl)\r\n"
"		\r\n"
"		for key,v in pairs(tbl) do\r\n"
"			if type(key) == 'number' then\r\n"
"				key = '['..tostring(key)..']'\r\n"
"			else\r\n"
"				key = tostring(key)\r\n"
"			end\r\n"
"			res = res..delim..key..'='..it.dump_string(v)\r\n"
"			k = k + 1\r\n"
"			if k > it.dump_limit then\r\n"
"				res = res..\" ... \"\r\n"
"				break\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"		pop(it.dump_stack)\r\n"
"		return sub(res,2)\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"\r\n"
"	function it.dump_string(val)\r\n"
"		local tp = type(val)\r\n"
"		if tp == 'function' then\r\n"
"			return tostring(val)\r\n"
"		elseif tp == 'table' then\r\n"
"			if val.__tostring  then\r\n"
"				return tostring(val)\r\n"
"			else\r\n"
"				return '{'..it.dump_table(val,',\\n"
"')..'}'\r\n"
"			end\r\n"
"		elseif tp == 'string' then\r\n"
"			return val--\"'\"..val..\"'\"\r\n"
"		elseif tp == 'number' then\r\n"
"			return tostring(val)\r\n"
"		else\r\n"
"			return tostring(val)\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"-- based on ilua.lua\r\n"
"	function it.dump_eval(line)\r\n"
"	\r\n"
"		local function compile(line)\r\n"
"			local f,err = loadstring(line,'local')\r\n"
"			return err,f\r\n"
"		end\r\n"
"		\r\n"
"		\r\n"
"		local err,chunk\r\n"
"		local ret={}\r\n"
"		local args={}\r\n"
"		\r\n"
"		\r\n"
"		if line~=\"\" then args=split(\"%s\",line) end -- split input on whitespace\r\n"
"		\r\n"
"		if args[1] then\r\n"
"		\r\n"
"			function lookup(tab,name)\r\n"
"				local names=split(\"%.\",name)\r\n"
"				for i,v in ipairs(names) do\r\n"
"--				print(i..\" \"..v)\r\n"
"					if type(tab)==\"table\" then\r\n"
"						tab=tab[v]\r\n"
"					else\r\n"
"						tab=nil\r\n"
"					end\r\n"
"				end\r\n"
"				return tab\r\n"
"			end\r\n"
"			\r\n"
"			chunk=lookup(it.call,args[1]) -- check special console functions\r\n"
"			\r\n"
"			if chunk and type(chunk)==\"function\" then -- must be a function\r\n"
"			\r\n"
"				table.remove(args,1) -- remove the function name\r\n"
"			\r\n"
"				setfenv(chunk,fenestra._g) -- call with master environment?\r\n"
"			else\r\n"
"			\r\n"
"				chunk=lookup(fenestra._g,args[1]) -- check for functions in master environment\r\n"
"				\r\n"
"				if chunk and type(chunk)==\"function\" then -- must be a function\r\n"
"				\r\n"
"					table.remove(args,1) -- remove the function name\r\n"
"				\r\n"
"				else\r\n"
"					chunk=nil\r\n"
"				end\r\n"
"				\r\n"
"				-- do not try and change the fenv of a function in the main envronment...\r\n"
"			\r\n"
"			end\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"		if not chunk then\r\n"
"		\r\n"
"			args={} -- no arguments\r\n"
"			\r\n"
"			-- is it an expression?\r\n"
"			err,chunk = compile('print('..line..')')\r\n"
"			if err then\r\n"
"				-- otherwise, a statement?\r\n"
"				err,chunk = compile(line)\r\n"
"			end\r\n"
"			\r\n"
"			if chunk then\r\n"
"				setfenv(chunk,fenestra._g) -- compile in master environment will have an overloaded print\r\n"
"			end\r\n"
"		end\r\n"
"\r\n"
"		-- if compiled ok, then evaluate the chunk\r\n"
"		if not err and chunk then\r\n"
"		\r\n"
"			ret = { pcall(chunk,unpack(args)) }\r\n"
"			\r\n"
"			if not ret[1] then\r\n"
"				err=ret[2]\r\n"
"				ret={}\r\n"
"			else\r\n"
"				table.remove(ret,1)\r\n"
"			end\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"		-- if there was any error, print it out\r\n"
"		if err then\r\n"
"			fenestra._g.print(err)\r\n"
"		else\r\n"
"			for i,v in ipairs(ret) do\r\n"
"				fenestra._g.print(v)\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	function it.update()\r\n"
"	\r\n"
"		it.buff:update()\r\n"
"		\r\n"
"		if it.show then\r\n"
"			if it.y~=it.y_show then\r\n"
"			\r\n"
"				local d=(it.y_show-it.y)/4\r\n"
"				if d>0 then d=math.ceil(d) else d=math.floor(d) end\r\n"
"				it.y= math.floor( it.y + d )\r\n"
"			\r\n"
"			end\r\n"
"		else\r\n"
"			if it.y~=0 then\r\n"
"			\r\n"
"				local d=(0-it.y)/4\r\n"
"				if d>0 then d=math.ceil(d) else d=math.floor(d) end\r\n"
"				it.y= math.floor( it.y + d )\r\n"
"			\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	function it.draw()\r\n"
"	\r\n"
"		fenestra.debug_begin()\r\n"
"		\r\n"
"		local w=fenestra.get(\"width\")\r\n"
"		local h=it.y\r\n"
"		fenestra.debug_polygon_begin()\r\n"
"		fenestra.debug_polygon_vertex(0,0,hex\"ee00cc00\")\r\n"
"		fenestra.debug_polygon_vertex(w,0,hex\"ee00cc00\")\r\n"
"		fenestra.debug_polygon_vertex(w,h,hex\"ee004400\")\r\n"
"		fenestra.debug_polygon_vertex(0,h,hex\"ee004400\")\r\n"
"		fenestra.debug_polygon_end()\r\n"
"		\r\n"
"--		fenestra.debug_rect(0,0,fenestra.get(\"width\"),it.y,hex\"8800ff00\")\r\n"
"		\r\n"
"		local i=#it.lines\r\n"
"		local y=it.y-16\r\n"
"		while y>-8 and i>0 do\r\n"
"		\r\n"
"			fenestra.debug_print({x=0,y=y,size=8,color=hex\"ff00ff00\",s=it.lines[i]})\r\n"
"			\r\n"
"			y=y-8\r\n"
"			i=i-1\r\n"
"		end\r\n"
"		\r\n"
"		if it.show_hud then\r\n"
"			for i,v in ipairs(it.lines_display) do\r\n"
"			\r\n"
"				fenestra.debug_print({x=0,y=it.y+i*8-8,size=8,color=hex\"ffffffff\",s=v})\r\n"
"			\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"		fenestra.debug_print({x=0,y=it.y-8,size=8,color=hex\"ff00ff00\",s=\">\"..it.buff.line})\r\n"
"\r\n"
"		fenestra.debug_rect((it.buff.line_idx+1)*8,it.y-8,(it.buff.line_idx+2)*8,it.y,hex\"00ff00\"+it.buff.throb*256*256*256)\r\n"
"\r\n"
"		fenestra.debug_end()\r\n"
"\r\n"
"		it.lines_display={}\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"	function it.print(s)\r\n"
"	\r\n"
"		s=it.dump_string(s)\r\n"
"	\r\n"
"		table.insert(it.lines,s)\r\n"
"		\r\n"
"		while #it.lines > 64 do\r\n"
"		\r\n"
"			table.remove(it.lines,1)\r\n"
"		\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	function it.display(s)\r\n"
"	\r\n"
"		s=it.dump_string(s)\r\n"
"		\r\n"
"		table.insert(it.lines_display,s)\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	function it.mouse(act,x,y,key)\r\n"
"--		print(act..\" \"..x..\",\"..y..\" \"..key)\r\n"
"	end\r\n"
"	\r\n"
"	function it.keypress(ascii,key,act)\r\n"
"\r\n"
"		if act==\"down\" then\r\n"
"--			fenestra._g.print(ascii..\" \"..(key or \"\"))\r\n"
"		end\r\n"
"\r\n"
"		if act==\"down\" and ascii==\"`\" then\r\n"
"		\r\n"
"			if it.show then\r\n"
"			\r\n"
"				it.show=false\r\n"
"				it.show_hud=false\r\n"
"				\r\n"
"			elseif it.show_hud then\r\n"
"			\r\n"
"				it.show=true			\r\n"
"				throb=255\r\n"
"			else\r\n"
"				it.show_hud=true\r\n"
"			end\r\n"
"\r\n"
"			return true\r\n"
"		end\r\n"
"			\r\n"
"		if it.show then\r\n"
"		\r\n"
"			if act==\"down\" or act==\"repeat\" then\r\n"
"					\r\n"
"				if key==\"page up\" or key==\"prior\" then\r\n"
"				\r\n"
"					it.y_show=it.y_show-8\r\n"
"				\r\n"
"				elseif key==\"page down\" or key==\"next\" then\r\n"
"				\r\n"
"					it.y_show=it.y_show+8\r\n"
"\r\n"
"				end\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"			return it.buff:keypress(ascii,key,act)\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"-- overload print function in the given (global) tab\r\n"
"-- returns a function to undo this act (however this function may fail...)\r\n"
"	function it.replace_print(g)\r\n"
"	\r\n"
"		local print_old=g.print\r\n"
"		it.print_old=g.print\r\n"
"		local print_new=function(...)\r\n"
"		\r\n"
"			local t={}\r\n"
"			for i,v in ipairs({...}) do\r\n"
"				table.insert(t, it.dump_string(v) )\r\n"
"			end\r\n"
"			if not t[1] then t[1]=\"nil\" end\r\n"
"			\r\n"
"			it.print( unpack(t) )\r\n"
"			if print_old then\r\n"
"				print_old( unpack(t) )\r\n"
"			end\r\n"
"		end\r\n"
"		g.print=print_new\r\n"
"		\r\n"
"		return function()\r\n"
"			if g.print==print_new then -- only change back if noone else changed it\r\n"
"				g.print=print_old\r\n"
"				return true\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	\r\n"
"	return it\r\n"
"end\r\n"
"",

"wetgenes.fenestra.widget.drag","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"module(\"fenestra.widget.drag\")\r\n"
"\r\n"
"\r\n"
"function mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(widget)\r\n"
"\r\n"
"	if widget.data then\r\n"
"		widget.text=widget.data:get_string()\r\n"
"	end\r\n"
"\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.drag=it\r\n"
"	widget.class=\"drag\"\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.draw=draw\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"",

"wetgenes.fenestra.data","\r\n"
"\r\n"
"local hex=function(str) return tonumber(str,16) end\r\n"
"\r\n"
"local io=io\r\n"
"local string=string\r\n"
"local table=table\r\n"
"local ipairs=ipairs\r\n"
"local math=math\r\n"
"local loadstring=loadstring\r\n"
"local pcall=pcall\r\n"
"\r\n"
"-- imported global functions\r\n"
"local sub = string.sub\r\n"
"local match = string.match\r\n"
"local find = string.find\r\n"
"local push = table.insert\r\n"
"local pop = table.remove\r\n"
"local append = table.insert\r\n"
"local concat = table.concat\r\n"
"local floor = math.floor\r\n"
"local write = io.write\r\n"
"local read = io.read\r\n"
"local type = type\r\n"
"local setfenv = setfenv\r\n"
"local tostring=tostring\r\n"
"local pairs=pairs\r\n"
"local ipairs=ipairs\r\n"
"local unpack=unpack\r\n"
"\r\n"
"local _G = _G\r\n"
"\r\n"
"local apps=apps\r\n"
"local wldir=apps.dir or \"\"\r\n"
"\r\n"
"module(\"fenestra.data\")\r\n"
"\r\n"
"\r\n"
"\r\n"
"function setup(fenestra)\r\n"
"\r\n"
"	local print=fenestra._g.print\r\n"
"	\r\n"
"	local it={}\r\n"
"	\r\n"
"	function it.clean()\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"	function it.load(fname)\r\n"
"\r\n"
"		local fp=io.open(wldir..fname,\"rb\")\r\n"
"		local dat=fp:read(\"*all\")\r\n"
"		fp:close();\r\n"
"		\r\n"
"		\r\n"
"		return fenestra.load(dat)\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"	return it\r\n"
"end\r\n"
"",

"wetgenes.gamecake.spew.recaps","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"M.bake=function(oven,recaps)\r\n"
"\r\n"
"	recaps=recaps or {} \r\n"
"	\r\n"
"	local cake=oven.cake\r\n"
"	local canvas=cake.canvas\r\n"
"	\r\n"
"	local keys=oven.rebake(\"wetgenes.gamecake.spew.keys\")\r\n"
"\r\n"
"\r\n"
"	function recaps.setup(max_up)\r\n"
"		max_up=max_up or 1\r\n"
"		recaps.up={}\r\n"
"		for i=1,max_up do\r\n"
"			recaps.up[i]=recaps.create() -- 1up 2up etc\r\n"
"		end\r\n"
"		return recaps -- so setup is chainable with a bake\r\n"
"	end\r\n"
"\r\n"
"	function recaps.step()\r\n"
"		for i,v in ipairs(recaps.up or {}) do\r\n"
"			v.step()\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	function recaps.get(nam,idx)\r\n"
"		local idx=idx or 1\r\n"
"		local recap=recaps.up and recaps.up[idx]\r\n"
"		if recap then return recap.get(nam) end\r\n"
"	end\r\n"
"	\r\n"
"-- create a new recap table, then we can load or save this data to or from our server\r\n"
"	function recaps.create(idx)\r\n"
"		local recap={}\r\n"
"		recap.idx=idx\r\n"
"		\r\n"
"\r\n"
"		function recap.reset(flow)\r\n"
"			recap.flow=flow or \"none\" -- do not play or record by default\r\n"
"			recap.last={}\r\n"
"			recap.now={}\r\n"
"			recap.autoclear={}\r\n"
"			recap.stream={} -- a stream of change \"table\"s or \"number\" frame skips\r\n"
"			recap.frame=0\r\n"
"			recap.read=0\r\n"
"			recap.wait=0\r\n"
"		end\r\n"
"		\r\n"
"		function recap.set(nam,dat) -- set the volatile data,this gets copied into last before it should be used\r\n"
"			recap.now[nam]=dat\r\n"
"		end\r\n"
"		function recap.pulse(nam,dat) -- set the volatile data but *only* for one frame\r\n"
"			recap.now[nam]=dat\r\n"
"			recap.autoclear[nam]=true\r\n"
"		end\r\n"
"		function recap.now(nam) -- return now or last frame data whatever \"volatile\" data we have\r\n"
"			local v=recap.now[nam]\r\n"
"			if type(v)==\"nil\" then v=recap.last[nam] end -- now probably only contains recent changes\r\n"
"			return v\r\n"
"		end\r\n"
"		function recap.get(nam) -- return last \"valid\" frame data not current \"volatile\" frame data\r\n"
"			return recap.last[nam]\r\n"
"		end\r\n"
"		\r\n"
"-- use this to set button flags, that may trigger a set/clr extra pulse state\r\n"
"		function recap.but(nam,v)\r\n"
"			local l=recap.now[nam]\r\n"
"			if type(l)==\"nil\" then l=recap.last[nam] end -- now probably only contains recent changes\r\n"
"			if v then -- set\r\n"
"				if not l then -- change?\r\n"
"					recap.set(nam,true)\r\n"
"					recap.pulse(nam..\"_set\",true)\r\n"
"				end\r\n"
"			else -- clr\r\n"
"				if l then -- change?\r\n"
"					recap.set(nam,false)\r\n"
"					recap.pulse(nam..\"_clr\",true)\r\n"
"				end\r\n"
"			end\r\n"
"		end\r\n"
"\r\n"
"\r\n"
"		function recap.step()\r\n"
"			\r\n"
"			if recap.flow==\"record\" then\r\n"
"				local change\r\n"
"				for n,v in pairs(recap.now) do\r\n"
"					if recap.last[n]~=v then -- changes\r\n"
"						change=change or {}\r\n"
"						change[n]=v\r\n"
"						recap.last[n]=v\r\n"
"						recap.now[n]=nil -- from now on we get the value from the last table\r\n"
"					end\r\n"
"				end\r\n"
"				if change then\r\n"
"					table.insert(recap.stream,change) -- change something\r\n"
"				else\r\n"
"					if type(recap.stream[#recap.stream])==\"number\" then\r\n"
"						recap.stream[#recap.stream] = recap.stream[#recap.stream] + 1 -- keep on changing nothing\r\n"
"					else\r\n"
"						table.insert(recap.stream,1) -- change nothing\r\n"
"					end\r\n"
"				end\r\n"
"				\r\n"
"			elseif recap.flow==\"play\" then -- grab from the stream\r\n"
"			\r\n"
"				if recap.wait>0 then\r\n"
"				\r\n"
"					recap.wait=recap.wait-1\r\n"
"					\r\n"
"				else\r\n"
"				\r\n"
"					recap.read=recap.read+1\r\n"
"					\r\n"
"					local t=recap.stream[recap.read]\r\n"
"					local tt=type(t)\r\n"
"					\r\n"
"					if tt==\"number\" then\r\n"
"					\r\n"
"						recap.wait=t-1\r\n"
"\r\n"
"					elseif tt==\"table\"then\r\n"
"					\r\n"
"						for n,v in pairs(t) do\r\n"
"							recap.last[n]=v\r\n"
"							recap.now[n]=v\r\n"
"						end\r\n"
"					\r\n"
"					end\r\n"
"				end\r\n"
"			\r\n"
"			else -- default of do not record do not play just be\r\n"
"			\r\n"
"				for n,v in pairs(recap.now) do\r\n"
"					recap.last[n]=v\r\n"
"					recap.now[n]=nil\r\n"
"				end\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"			if recap.flow~=\"play\" then\r\n"
"				for n,b in pairs(recap.autoclear) do -- auto clear volatile button pulse states\r\n"
"					recap.now[n]=false\r\n"
"					recap.autoclear[n]=nil\r\n"
"				end\r\n"
"			end\r\n"
"			\r\n"
"			recap.frame=recap.frame+1 -- advance frame counter\r\n"
"		end\r\n"
"		\r\n"
"		recap.reset()\r\n"
"\r\n"
"		return recap\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"	return recaps\r\n"
"end\r\n"
"",

"wetgenes.gamecake.spew.about.wetiso","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local pack=require(\"wetgenes.pack\")\n"
"local wwin=require(\"wetgenes.win\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"local tardis=require(\"wetgenes.tardis\")	-- matrix/vector math\n"
"\n"
"local tcore=require(\"wetgenes.tardis.core\")\n"
"\n"
"-- This curve used here is the curvy part of splines.\n"
"-- input 0 to 1 and output 0 to 1 smoothing into and from the 0 and 1  (like a sinwave going from -1 to +1)\n"
"local function spine(a)\n"
"	local aa=a*a\n"
"	return ((aa+(aa*2))-((aa*a)*2))\n"
"end\n"
"-- input 0 to 1 and output 0 to 1 to 0 so it loops smoothly\n"
"local function spine2(n)\n"
"	local n,a=math.modf(n) -- just want the fractional part\n"
"	a=a*2\n"
"	if a>1 then a=2-a end\n"
"	local aa=a*a\n"
"	return ((aa+(aa*2))-((aa*a)*2))\n"
"end\n"
"\n"
"\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"function M.bake(oven,about)\n"
"	about=about or {}\n"
"\n"
"	local gl=oven.gl\n"
"	local cake=oven.cake\n"
"	\n"
"	local sounds=cake.sounds\n"
"	local canvas=cake.canvas\n"
"	local fbs=cake.framebuffers\n"
"	\n"
"	local flat=canvas.flat\n"
"	local font=canvas.font\n"
"	\n"
"	local wetiso=oven.rebake(\"wetgenes.gamecake.spew.geom_wetiso\")\n"
"	local geom=oven.rebake(\"wetgenes.gamecake.spew.geom\")\n"
"\n"
"\n"
"	local opts={\n"
"		width=640,\n"
"		height=480,\n"
"	}\n"
"	\n"
"	about.layout=cake.layouts.create{}\n"
"	\n"
"	about.setup=function()\n"
"\n"
"		if oven.last and oven.last~=about then about.exit=oven.last end -- remeber where we came from\n"
"\n"
"		wetiso.setup()\n"
"		\n"
"		if about.playtune then\n"
"			about.playtune()\n"
"		end\n"
"\n"
"		about.t=0\n"
"		\n"
"	end\n"
"	\n"
"	about.clean=function()\n"
"	end\n"
"	\n"
"	about.update=function()\n"
"		about.t=about.t+1\n"
"	end\n"
"	\n"
"	about.draw=function()\n"
"\n"
"		about.layout.apply(opts.width,opts.height,1/4,opts.width*4,\"clip\")\n"
"\n"
"		canvas.gl_default() -- reset gl state\n"
"\n"
"		gl.ClearColor(gl.C4(0x0000))\n"
"		gl.Clear(gl.COLOR_BUFFER_BIT)--+gl.DEPTH_BUFFER_BIT)\n"
"\n"
"		gl.PushMatrix()\n"
"\n"
"			gl.Translate(320,240,0)\n"
"			gl.Scale(320,320,320)\n"
"			gl.Rotate(about.t,0,-1,0)\n"
"			gl.Rotate(about.t/8,1,0,0)\n"
"			gl.Enable(gl.CULL_FACE)\n"
"			gl.Color(0,0.25,0.75,1)\n"
"			wetiso.draw()\n"
"			gl.Disable(gl.CULL_FACE)\n"
"		\n"
"		gl.PopMatrix()\n"
"\n"
"	end\n"
"\n"
"	function about.msg(m)\n"
"	\n"
"		if m.class==\"key\" or m.class==\"mouse\" or m.class==\"joykey\" then\n"
"			if m.action==-1 then\n"
"				if about.exitname then\n"
"					oven.next=oven.rebake(about.exitname)\n"
"				else\n"
"					if about.exit then oven.next=about.exit end\n"
"				end\n"
"			end\n"
"		end\n"
"\n"
"	end\n"
"\n"
"	return about\n"
"end\n"
"",

"wetgenes.fenestra.wrap","\r\n"
"\r\n"
"local print=print\r\n"
"\r\n"
"local core = require(\"fenestra.core\")\r\n"
"local console = require(\"fenestra.console\")\r\n"
"local data = require(\"fenestra.data\")\r\n"
"local avatar = require(\"fenestra.avatar\")\r\n"
"local font = require(\"fenestra.font\")\r\n"
"local widget = require(\"fenestra.widget\")\r\n"
"\r\n"
"local gl=require(\"gl\")\r\n"
"\r\n"
"module(\"fenestra.wrap\")\r\n"
"\r\n"
"--\r\n"
"-- Call win to get a unique table full of functions associated\r\n"
"-- with lots of tasty up values for easy use\r\n"
"--\r\n"
"-- local win=require(\"fenestra.wrap\").win()\r\n"
"--\r\n"
"function win(opts)\r\n"
"opts=opts or {}\r\n"
"\r\n"
"local win={}\r\n"
"\r\n"
"	function win.setup(g)\r\n"
"	\r\n"
"		win._g=g -- the global table\r\n"
"		win.into_hwnd=opts.into_hwnd\r\n"
"\r\n"
"-- open window of this height		\r\n"
"		win.width=opts.width\r\n"
"		win.height=opts.height\r\n"
"\r\n"
"		win.core = core.setup(win)\r\n"
"		\r\n"
"		win.core_data = core.data.setup(win.core)\r\n"
"		\r\n"
"		win.data = data.setup(win)\r\n"
"		\r\n"
"		win.core_ogl = core.ogl.setup(win.core)\r\n"
"		\r\n"
"		win.console = console.setup(win)		\r\n"
"		win.restore_print=win.console.replace_print(g)\r\n"
"		\r\n"
"		win.avatar = avatar.setup(win)\r\n"
"		\r\n"
"		win.font_base=font.setup(win,\"base\")\r\n"
"		win.font_sans=font.setup(win,\"sans\")\r\n"
"		win.font_debug=win.font_base -- old name, do not use...\r\n"
"		\r\n"
"		win.widget=widget.setup(win,{font=win.font_sans})\r\n"
"		\r\n"
"		return win\r\n"
"	end\r\n"
"\r\n"
"	function win.clean()\r\n"
"		\r\n"
"		win.widget.clean()\r\n"
"		\r\n"
"		win.font_sans.clean()\r\n"
"		win.font_base.clean()\r\n"
"\r\n"
"		win.avatar.clean()\r\n"
"		\r\n"
"		win.restore_print()\r\n"
"		win.console.clean()\r\n"
"		\r\n"
"		core.ogl.clean(win.core_ogl)\r\n"
"		\r\n"
"		win.data.clean()\r\n"
"		\r\n"
"		core.data.clean(win.core_data)\r\n"
"		\r\n"
"		core.clean(win.core)\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	function win.xox(xox_info)\r\n"
"\r\n"
"		local core=win.xox_setup(xox_info)\r\n"
"		local xox=win.xox_get(core)\r\n"
"		xox.info=xox_info\r\n"
"		xox.core=core\r\n"
"		\r\n"
"		function xox.clean()\r\n"
"			return win.xox_clean(core)\r\n"
"		end\r\n"
"		\r\n"
"		function xox.draw()\r\n"
"			return win.xox_draw(core)\r\n"
"		end\r\n"
"\r\n"
"		function xox.set()\r\n"
"			return win.xox_set(core,xox)\r\n"
"		end\r\n"
"		\r\n"
"		return xox\r\n"
"	end\r\n"
"	\r\n"
"	function win.xsx(xsx_info)\r\n"
"\r\n"
"		local core=win.xsx_setup(xsx_info)\r\n"
"		local xsx=win.xsx_get(core)\r\n"
"		xsx.info=xsx_info\r\n"
"		xsx.core=core\r\n"
"		\r\n"
"		function xsx.clean()\r\n"
"			return win.xsx_clean(core)\r\n"
"		end\r\n"
"		\r\n"
"		function xsx.draw(f)\r\n"
"			return win.xsx_draw(core,f)\r\n"
"		end\r\n"
"		\r\n"
"		function xsx.set()\r\n"
"			return win.xsx_set(core,xsx)\r\n"
"		end\r\n"
"		\r\n"
"		return xsx\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"	function win.fbo(width,height,depth)\r\n"
"	\r\n"
"		depth=depth or 0\r\n"
"		\r\n"
"		local core=win.fbo_setup(width,height,depth)\r\n"
"		local fbo={}\r\n"
"		fbo.core=core\r\n"
"		fbo.width=width\r\n"
"		fbo.height=height\r\n"
"		fbo.depth=depth\r\n"
"		\r\n"
"		function fbo.clean(fbo)\r\n"
"			return win.fbo_clean(core)\r\n"
"		end\r\n"
"		\r\n"
"		function fbo.bind(fbo)\r\n"
"			return win.fbo_bind(core)\r\n"
"		end\r\n"
"\r\n"
"		function fbo.texture(fbo)\r\n"
"			return win.fbo_texture(core)\r\n"
"		end\r\n"
"\r\n"
"		function fbo.draw(fbo)\r\n"
"			win.fbo_texture(core)\r\n"
"			gl.Disable(gl.CULL_FACE)\r\n"
"			gl.Enable(gl.TEXTURE_2D)\r\n"
"			gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR)\r\n"
"			gl.BlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA) --fbo has premultipliedalpha\r\n"
"			gl.Begin(gl.QUADS)\r\n"
"				gl.Color({1,1,1,1})\r\n"
"				gl.TexCoord(0, 0) gl.Vertex(fbo.width*-0.5, fbo.height*-0.5)\r\n"
"				gl.TexCoord(1, 0) gl.Vertex(fbo.width* 0.5, fbo.height*-0.5)\r\n"
"				gl.TexCoord(1, 1) gl.Vertex(fbo.width* 0.5, fbo.height* 0.5)\r\n"
"				gl.TexCoord(0, 1) gl.Vertex(fbo.width*-0.5, fbo.height* 0.5)\r\n"
"			gl.End()\r\n"
"		end\r\n"
"\r\n"
"		return fbo\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	function win.tex(grd) -- this takes a texture copy of the given grd\r\n"
"	\r\n"
"		local core=win.tex_setup(grd[0])\r\n"
"		local tex={}\r\n"
"		tex.core=core\r\n"
"		tex.width=grd.width\r\n"
"		tex.height=grd.height\r\n"
"		tex.depth=grd.depth\r\n"
"		\r\n"
"		grd=nil -- do not keep any references\r\n"
"		\r\n"
"		function tex.clean(tex)\r\n"
"			return win.tex_clean(core)\r\n"
"		end\r\n"
"		\r\n"
"		function tex.bind(tex)\r\n"
"			return win.tex_bind(core)\r\n"
"		end\r\n"
"\r\n"
"		function tex.draw(tex,opts)\r\n"
"			opts=opts or {}\r\n"
"			win.tex_bind(core)\r\n"
"			gl.Disable(gl.CULL_FACE)\r\n"
"			gl.Enable(gl.TEXTURE_2D)\r\n"
"			gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,opts.max or gl.LINEAR)\r\n"
"			gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,opts.min or gl.LINEAR)\r\n"
"			gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)\r\n"
"			gl.Begin(gl.QUADS)\r\n"
"				gl.Color({1,1,1,1})\r\n"
"				gl.TexCoord(0, 0) gl.Vertex(0.5+tex.width*-0.5, 0.5+tex.height* 0.5)\r\n"
"				gl.TexCoord(1, 0) gl.Vertex(0.5+tex.width* 0.5, 0.5+tex.height* 0.5)\r\n"
"				gl.TexCoord(1, 1) gl.Vertex(0.5+tex.width* 0.5, 0.5+tex.height*-0.5)\r\n"
"				gl.TexCoord(0, 1) gl.Vertex(0.5+tex.width*-0.5, 0.5+tex.height*-0.5)\r\n"
"			gl.End()\r\n"
"		end\r\n"
"\r\n"
"		return tex\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	\r\n"
"-- return window x,y pos transformed into the viewspace of project23d if you provided h/w to that function\r\n"
"	function win.mouse23d(w,h,x,y)\r\n"
"	\r\n"
"		local hx=win.width/2\r\n"
"		local hy=win.height/2\r\n"
"\r\n"
"		local tx,ty\r\n"
"		\r\n"
"		if win.height/(win.width or 1) > (h/w) then -- deal with new \"smart\" viewport sizeing\r\n"
"		\r\n"
"			tx=(w/ 2)*(x-hx)/hx\r\n"
"			ty=(w/-2)*(hy-y)/hx\r\n"
"			\r\n"
"		else\r\n"
"		\r\n"
"			tx=(h/ 2)*(x-hx)/hy\r\n"
"			ty=(h/-2)*(hy-y)/hy\r\n"
"\r\n"
"		end\r\n"
"\r\n"
"		return tx,ty\r\n"
"	end\r\n"
"\r\n"
"function win.choose_file(...)			return core.choose_file(				win.core,		...) end\r\n"
"\r\n"
"-- default key and mouse functions just send data to the debug console	\r\n"
"function win.keypress(...)				return win.console.keypress(							...) end\r\n"
"function win.mouse(...)					return win.console.mouse(								...) end\r\n"
"\r\n"
"function win.msg(...)					return core.msg(						win.core,		...) end\r\n"
"function win.time(...)					return core.time(						win.core,		...) end\r\n"
"\r\n"
"function win.getwin(...)				return core.getwin(						win.core,		...) end\r\n"
"function win.setwin(...)				return core.setwin(						win.core,		...) end\r\n"
"\r\n"
"function win.get(...)					return core.ogl.get(					win.core_ogl,	...) end\r\n"
"function win.set(...)					return core.ogl.set(					win.core_ogl,	...) end\r\n"
"function win.begin(...)					return core.ogl.begin(					win.core_ogl,	...) end\r\n"
"function win.clip2d(...)				return core.ogl.clip2d(					win.core_ogl,	...) end\r\n"
"function win.project23d(...)			return core.ogl.project23d(				win.core_ogl,	...) end\r\n"
"function win.swap(...)					return core.ogl.swap(					win.core_ogl,	...) end\r\n"
"\r\n"
"function win.target(...)				return core.ogl.target(					win.core_ogl,	...) end\r\n"
"function win.readpixels(...)			return core.ogl.readpixels(				win.core_ogl,	...) end\r\n"
"\r\n"
"\r\n"
"function win.debug_begin(...)			return core.ogl.debug_begin(			win.core_ogl,	...) end\r\n"
"function win.debug_end(...)				return core.ogl.debug_end(				win.core_ogl,	...) end\r\n"
"function win.debug_print(...)			return core.ogl.debug_print(			win.core_ogl,	...) end\r\n"
"function win.debug_print_alt(...)		return core.ogl.debug_print_alt(		win.core_ogl,	...) end\r\n"
"function win.debug_rect(...)			return core.ogl.debug_rect(				win.core_ogl,	...) end\r\n"
"function win.debug_polygon_begin(...)	return core.ogl.debug_polygon_begin(	win.core_ogl,	...) end\r\n"
"function win.debug_polygon_vertex(...)	return core.ogl.debug_polygon_vertex(	win.core_ogl,	...) end\r\n"
"function win.debug_polygon_end(...)		return core.ogl.debug_polygon_end(		win.core_ogl,	...) end\r\n"
"\r\n"
"\r\n"
"function win.flat_begin(...)			return core.ogl.flat_begin(				win.core_ogl,	...) end\r\n"
"function win.flat_end(...)				return core.ogl.flat_end(				win.core_ogl,	...) end\r\n"
"function win.flat_font(...)				return core.ogl.flat_font(				win.core_ogl,	...) end\r\n"
"function win.flat_print(...)			return core.ogl.flat_print(				win.core_ogl,	...) end\r\n"
"function win.flat_measure(...)			return core.ogl.flat_measure(			win.core_ogl,	...) end\r\n"
"function win.flat_which(...)			return core.ogl.flat_which(				win.core_ogl,	...) end\r\n"
"function win.flat_fits(...)				return core.ogl.flat_fits(				win.core_ogl,	...) end\r\n"
"function win.flat_rect(...)				return core.ogl.debug_rect(				win.core_ogl,	...) end\r\n"
"function win.flat_polygon_begin(...)	return core.ogl.debug_polygon_begin(	win.core_ogl,	...) end\r\n"
"function win.flat_polygon_vertex(...)	return core.ogl.debug_polygon_vertex(	win.core_ogl,	...) end\r\n"
"function win.flat_polygon_end(...)		return core.ogl.debug_polygon_end(		win.core_ogl,	...) end\r\n"
"\r\n"
"\r\n"
"function win.draw_cube(...)				return core.ogl.draw_cube(				win.core_ogl,	...) end\r\n"
"\r\n"
"function win.xox_setup(...)				return core.ogl.xox_setup(				win.core_ogl,	...) end\r\n"
"function win.xox_clean(...)				return core.ogl.xox_clean(				win.core_ogl,	...) end\r\n"
"function win.xox_draw(...)				return core.ogl.xox_draw(				win.core_ogl,	...) end\r\n"
"function win.xox_get(...)				return core.ogl.xox_get(				win.core_ogl,	...) end\r\n"
"function win.xox_set(...)				return core.ogl.xox_set(				win.core_ogl,	...) end\r\n"
"\r\n"
"function win.xsx_setup(...)				return core.ogl.xsx_setup(				win.core_ogl,	...) end\r\n"
"function win.xsx_clean(...)				return core.ogl.xsx_clean(				win.core_ogl,	...) end\r\n"
"function win.xsx_draw(...)				return core.ogl.xsx_draw(				win.core_ogl,	...) end\r\n"
"function win.xsx_get(...)				return core.ogl.xsx_get(				win.core_ogl,	...) end\r\n"
"function win.xsx_set(...)				return core.ogl.xsx_set(				win.core_ogl,	...) end\r\n"
"\r\n"
"function win.fbo_setup(...)				return core.ogl.fbo_setup(				win.core_ogl,	...) end\r\n"
"function win.fbo_clean(...)				return core.ogl.fbo_clean(				win.core_ogl,	...) end\r\n"
"function win.fbo_bind(...)				return core.ogl.fbo_bind(				win.core_ogl,	...) end\r\n"
"function win.fbo_texture(...)			return core.ogl.fbo_texture(			win.core_ogl,	...) end\r\n"
"\r\n"
"function win.tex_setup(...)				return core.ogl.tex_setup(				win.core_ogl,	...) end\r\n"
"function win.tex_clean(...)				return core.ogl.tex_clean(				win.core_ogl,	...) end\r\n"
"function win.tex_bind(...)				return core.ogl.tex_bind(				win.core_ogl,	...) end\r\n"
"\r\n"
"function win.load(...)					return core.data.load(					win.core_data,	...) end\r\n"
"	\r\n"
"	return win\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.fenestra.avatar","\r\n"
"local bit=require('bit')\r\n"
"\r\n"
"\r\n"
"-- very simple xml parsing into a table\r\n"
"local sxml=require(\"simpxml\")\r\n"
"\r\n"
"local string=string\r\n"
"local table=table\r\n"
"local ipairs=ipairs\r\n"
"local math=math\r\n"
"local loadstring=loadstring\r\n"
"local pcall=pcall\r\n"
"local error=error\r\n"
"local io=io\r\n"
"local type=type\r\n"
"local tonumber=tonumber\r\n"
"\r\n"
"-- imported global functions\r\n"
"local sub = string.sub\r\n"
"local match = string.match\r\n"
"local find = string.find\r\n"
"local push = table.insert\r\n"
"local pop = table.remove\r\n"
"local append = table.insert\r\n"
"local concat = table.concat\r\n"
"local floor = math.floor\r\n"
"local write = io.write\r\n"
"local read = io.read\r\n"
"local type = type\r\n"
"local setfenv = setfenv\r\n"
"local tostring=tostring\r\n"
"local pairs=pairs\r\n"
"local ipairs=ipairs\r\n"
"local unpack=unpack\r\n"
"\r\n"
"local _G = _G\r\n"
"\r\n"
"local apps=apps\r\n"
"local wldir=apps.dir or \"\"\r\n"
"\r\n"
"module(\"fenestra.avatar\")\r\n"
"\r\n"
"--\r\n"
"-- avatar part group information\r\n"
"--\r\n"
"-- group is where the object is located, IE head\r\n"
"-- then look up the actual xox filename using the easy name used on a soul \r\n"
"-- finally you now have a chunk of data that describes this xox\r\n"
"--\r\n"
"xox_groups={\r\n"
"\r\n"
"inmouth =\r\n"
"{ \r\n"
"	joint					= { xox=	\"inmouth_joint\"			; boi=1; grl=1; active=1; };\r\n"
"	fag						= { xox=	\"inmouth_fag\"			; boi=1; grl=1; active=1; };\r\n"
"	pipe					= { xox=	\"inmouth_pipe\"			; boi=1; grl=1; active=1; };\r\n"
"	cigar					= { xox=	\"inmouth_cigar\"			; boi=1; grl=1; active=1; };\r\n"
"	sushi_nigiri			= { xox=	\"inmouth_sushi_nigiri\"	; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"inhand =\r\n"
"{ \r\n"
"	dagger					= { xox=	\"item_dagger_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	hammer					= { xox=	\"item_hammer_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	pistol					= { xox=	\"item_pistol_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	joint					= { xox=	\"item_joint_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	fag						= { xox=	\"item_fag_fist\"				; boi=1; grl=1; active=1; };\r\n"
"	joint					= { xox=	\"item_joint_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	pipe					= { xox=	\"item_pipe_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	cigar					= { xox=	\"item_cigar_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	bottle					= { xox=	\"item_bottle_fist\"			; boi=1; grl=1; active=1; };\r\n"
"	bottle_smashed			= { xox=	\"item_bottle_smashed_fist\"	; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"beard =\r\n"
"{ \r\n"
"	default					= { xox=	\"beard_circle\"			; boi=1; grl=0; active=1; };\r\n"
"	circle					= { xox=	\"beard_circle\"			; boi=1; grl=0; active=1; };\r\n"
"	circle_point			= { xox=	\"beard_circle_point\"	; boi=1; grl=0; active=1; };\r\n"
"	tash					= { xox=	\"beard_tash\"			; boi=1; grl=0; active=1; };\r\n"
"	whiskers				= { xox=	\"beard_whiskers\"		; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"body =\r\n"
"{ \r\n"
"	\r\n"
"	bare					= { xox=	\"body_bare\"				; boi=1; grl=0; active=1; };\r\n"
"	bare_boobs				= { xox=	\"body_bare_boobs\"		; boi=0; grl=1; active=1; };\r\n"
"	\r\n"
"	robox					= { xox=	\"body_robox\"			; boi=0; grl=0; active=1; };\r\n"
"	\r\n"
"	bodess					= { xox=	\"body_bodess\"			; boi=0; grl=1; active=1; };\r\n"
"	\r\n"
"	tshirt					= { xox=	\"body_tshirt\"			; boi=1; grl=0; active=1; };\r\n"
"	tshirt_boobs			= { xox=	\"body_tshirt_boobs\"		; boi=0; grl=1; active=1; };\r\n"
"	tshirt_boobs_low		= { xox=	\"body_tshirt_boobs_low\"	; boi=0; grl=1; active=1; };\r\n"
"	\r\n"
"	coat					= { xox=	\"body_coat\"				; boi=1; grl=0; active=1; };\r\n"
"	overalls				= { xox=	\"body_overalls\"			; boi=1; grl=0; active=1; };\r\n"
"	vest					= { xox=	\"body_vest\"				; boi=1; grl=0; active=1; };\r\n"
"	vest_boobs				= { xox=	\"body_vest_boobs\"		; boi=0; grl=1; active=1; };\r\n"
"	\r\n"
"	tie						= { xox=	\"body_tie\"				; boi=1; grl=0; active=1; };\r\n"
"	tie_boobs				= { xox=	\"body_tie_boobs\"		; boi=0; grl=1; active=1; };\r\n"
"\r\n"
"	default					= { xox=	\"body\"					; boi=1; grl=0; active=1; };\r\n"
"	bare_boobs_small		= { xox=	\"body_bare_boobsa\"		; boi=0; grl=1; active=0; };\r\n"
"	bare_boobs_medium		= { xox=	\"body_bare_boobsc\"		; boi=0; grl=1; active=0; };\r\n"
"	bare_boobs_large		= { xox=	\"body_bare_boobse\"		; boi=0; grl=1; active=0; };\r\n"
"	bare_chest				= { xox=	\"body_bare_chest\"		; boi=1; grl=0; active=0; };\r\n"
"	bare_gut				= { xox=	\"body_bare_gut\"			; boi=1; grl=0; active=0; };\r\n"
"	bodess_medium			= { xox=	\"body_bodessc\"			; boi=0; grl=1; active=0; };\r\n"
"	bodess_large			= { xox=	\"body_bodesse\"			; boi=0; grl=1; active=0; };\r\n"
"	tshirt_boobs_small		= { xox=	\"body_tshirt_boobsa\"	; boi=0; grl=1; active=0; };\r\n"
"	tshirt_boobs_medium		= { xox=	\"body_tshirt_boobsc\"	; boi=0; grl=1; active=0; };\r\n"
"	tshirt_boobs_large		= { xox=	\"body_tshirt_boobse\"	; boi=0; grl=1; active=0; };\r\n"
"	tshirt_chest			= { xox=	\"body_tshirt_chest\"		; boi=1; grl=0; active=0; };\r\n"
"	tshirt_gut				= { xox=	\"body_tshirt_gut\"		; boi=1; grl=0; active=0; };\r\n"
"	tshirt_lowcut_large		= { xox=	\"body_tshirt_lowcute\"	; boi=0; grl=3; active=0; };\r\n"
"	tshirt_skinny			= { xox=	\"body_tshirt_skinny\"	; boi=1; grl=0; active=0; };\r\n"
"	\r\n"
"},\r\n"
"\r\n"
"tail =\r\n"
"{ \r\n"
"	default					= { xox=	\"tail\"					; boi=1; grl=1; active=1; };\r\n"
"	bunny					= { xox=	\"tail_bunny\"			; boi=0; grl=1; active=1; };\r\n"
"	devil					= { xox=	\"tail_devil\"			; boi=0; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"ear =\r\n"
"{ \r\n"
"	default					= { xox=	\"ear\"					; boi=1; grl=1; active=1; };\r\n"
"	big						= { xox=	\"ear_big\"				; boi=1; grl=1; active=1; };\r\n"
"	big_sticky				= { xox=	\"ear_big_sticky\"		; boi=1; grl=1; active=1; };\r\n"
"	robox					= { xox=	\"ear_robox\"				; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"eye =\r\n"
"{ \r\n"
"	default					= { xox=	\"eye\"					; boi=1; grl=1; active=1; };\r\n"
"	bigbrow					= { xox=	\"eye_bigbrow\"			; boi=1; grl=1; active=1; };\r\n"
"	brow					= { xox=	\"eye_brow\"				; boi=0; grl=0; active=1; };\r\n"
"	tribrow					= { xox=	\"eye_tribrow\"			; boi=1; grl=1; active=1; };\r\n"
"	robox					= { xox=	\"eye_robox\"				; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"eyeball =\r\n"
"{ \r\n"
"	default					= { xox=	\"eyeball\"				; boi=5; grl=5; active=1; };\r\n"
"	diamond					= { xox=	\"eyeball_cat\"			; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"foot =\r\n"
"{ \r\n"
"	default					= { xox=	\"foot\"					; boi=1; grl=1; active=1; };\r\n"
"	bare					= { xox=	\"foot_bare\"				; boi=1; grl=1; active=1; };\r\n"
"	boot					= { xox=	\"foot_boot\"				; boi=1; grl=1; active=1; };\r\n"
"	flipflop				= { xox=	\"foot_flipflop\"			; boi=1; grl=1; active=1; };\r\n"
"	slipper					= { xox=	\"foot_slipper\"			; boi=1; grl=1; active=1; };\r\n"
"	heel					= { xox=	\"foot_heel\"				; boi=0; grl=1; active=1; };\r\n"
"	shoe					= { xox=	\"foot_shoe\"				; boi=1; grl=1; active=1; };\r\n"
"	hoof					= { xox=	\"foot_hoof\"				; boi=0; grl=0; active=1; };\r\n"
"	robox					= { xox=	\"foot_robox\"			; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"hair =\r\n"
"{ \r\n"
"	topspiked_short			= { xox=	\"hair_topspiked_short\"		; boi=1; grl=1; active=1; };\r\n"
"	peak					= { xox=	\"hair_peak\"					; boi=1; grl=1; active=1; };\r\n"
"	\r\n"
"	bob						= { xox=	\"hair_bob\"					; boi=1; grl=1; active=1; };\r\n"
"	goth_long				= { xox=	\"hair_goth_long\"			; boi=1; grl=1; active=1; };\r\n"
"	spikey_short			= { xox=	\"hair_spikey_short\"			; boi=1; grl=1; active=1; };\r\n"
"	trihawk_short			= { xox=	\"hair_trihawk_short\"		; boi=1; grl=1; active=1; };\r\n"
"	trihawk_hi				= { xox=	\"hair_trihawk_hi\"			; boi=1; grl=1; active=1; };\r\n"
"	hedgehog				= { xox=	\"hair_hedgehog\"				; boi=1; grl=1; active=1; };\r\n"
"	afro					= { xox=	\"hair_afro\"					; boi=1; grl=1; active=1; };\r\n"
"	afro_tall				= { xox=	\"hair_afro_tall\"			; boi=1; grl=1; active=1; };\r\n"
"		\r\n"
"	quiff					= { xox=	\"hair_quiff\"				; boi=1; grl=1; active=1; };\r\n"
"	curl_left				= { xox=	\"hair_curl_left\"			; boi=1; grl=1; active=1; };\r\n"
"	curl_right				= { xox=	\"hair_curl_right\"			; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"hair_base =\r\n"
"{ \r\n"
"	default					= { xox=	\"hair\"						; boi=1; grl=1; active=1; };\r\n"
"	bowl					= { xox=	\"hair_bowl\"					; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"hair_xtra =\r\n"
"{ \r\n"
"	ponytail				= { xox=	\"hair_ponytail\"				; boi=1; grl=1; active=1; };\r\n"
"	pigtails				= { xox=	\"hair_pigtails\"				; boi=1; grl=1; active=1; };\r\n"
"	long					= { xox=	\"hair_long\"					; boi=1; grl=1; active=1; };\r\n"
"	bunches					= { xox=	\"hair_bunches\"				; boi=1; grl=1; active=1; };\r\n"
"	bang					= { xox=	\"hair_bang_base\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_zigs				= { xox=	\"hair_bang_zigs\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_goff				= { xox=	\"hair_bang_goff\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_sidel				= { xox=	\"hair_bang_sidel\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_sider				= { xox=	\"hair_bang_sider\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_emol				= { xox=	\"hair_bang_emol\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_emor				= { xox=	\"hair_bang_emor\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_nerd				= { xox=	\"hair_bang_nerd\"			; boi=1; grl=1; active=1; };\r\n"
"	bang_hugh				= { xox=	\"hair_bang_hugh\"			; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"hat =\r\n"
"{ \r\n"
"	baseball				= { xox=	\"hat_baseball\"				; boi=1; grl=1; active=1; };\r\n"
"	pirate					= { xox=	\"hat_pirate\"				; boi=1; grl=1; active=1; };\r\n"
"	kerchief				= { xox=	\"hat_kerchief\"				; boi=1; grl=1; active=1; };\r\n"
"	bunny_ears				= { xox=	\"hat_bunny_ears\"			; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"hand =\r\n"
"{ \r\n"
"	default					= { xox=	\"hand\"					; boi=1; grl=1; active=1; };\r\n"
"	foot					= { xox=	\"hand_foot\"				; boi=0; grl=0; active=1; };\r\n"
"	hoof					= { xox=	\"hand_hoof\"				; boi=0; grl=0; active=1; };\r\n"
"	robox					= { xox=	\"hand_robox\"			; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"head =\r\n"
"{ \r\n"
"	default					= { xox=	\"head\"					; boi=1; grl=1; active=1; };\r\n"
"	cheekbones				= { xox=	\"head_cheakbones\"		; boi=1; grl=1; active=0; };\r\n"
"	chub					= { xox=	\"head_chub\"				; boi=1; grl=1; active=0; };\r\n"
"	thin					= { xox=	\"head_thin\"				; boi=1; grl=1; active=0; };\r\n"
"	skull					= { xox=	\"head_skull\"			; boi=0; grl=0; active=1; };\r\n"
"	robox					= { xox=	\"head_robox\"			; boi=0; grl=0; active=1; };\r\n"
"	chinless				= { xox=	\"head_chinless\"			; boi=0; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"mouth =\r\n"
"{ \r\n"
"	default					= { xox=	\"mouth\"					; boi=1; grl=1; active=1; };\r\n"
"	bow						= { xox=	\"mouth_bow\"				; boi=1; grl=1; active=1; };\r\n"
"	bow_fat					= { xox=	\"mouth_bow_fat\"			; boi=1; grl=1; active=1; };\r\n"
"	bow_thin				= { xox=	\"mouth_bow_thin\"		; boi=1; grl=1; active=1; };\r\n"
"	fat						= { xox=	\"mouth_fat\"				; boi=1; grl=1; active=1; };\r\n"
"	thin					= { xox=	\"mouth_thin\"			; boi=1; grl=1; active=1; };\r\n"
"	beak					= { xox=	\"mouth_beak\"			; boi=0; grl=0; active=1; };\r\n"
"	squid					= { xox=	\"mouth_squid\"			; boi=0; grl=0; active=1; };\r\n"
"	jaw						= { xox=	\"mouth_jaw\"				; boi=0; grl=0; active=1; };\r\n"
"	robox					= { xox=	\"mouth_robox\"			; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"nose =\r\n"
"{ \r\n"
"	default					= { xox=	\"nose\"					; boi=1; grl=1; active=1; };\r\n"
"	small					= { xox=	\"nose_small\"			; boi=1; grl=1; active=1; };\r\n"
"	small_up				= { xox=	\"nose_small_up\"			; boi=1; grl=1; active=1; };\r\n"
"	snub					= { xox=	\"nose_snub\"				; boi=1; grl=1; active=1; };\r\n"
"	wide					= { xox=	\"nose_wide\"				; boi=1; grl=1; active=1; };\r\n"
"	wide_up					= { xox=	\"nose_wide_up\"			; boi=1; grl=1; active=1; };\r\n"
"	clown					= { xox=	\"nose_clown\"			; boi=0; grl=0; active=1; };\r\n"
"	snout					= { xox=	\"nose_snout\"			; boi=0; grl=0; active=1; };\r\n"
"	robox					= { xox=	\"nose_robox\"			; boi=0; grl=0; active=1; };\r\n"
"},\r\n"
"\r\n"
"\r\n"
"specs =\r\n"
"{ \r\n"
"	default					= { xox=	\"specs\"					; boi=1; grl=1; active=1; };\r\n"
"	round					= { xox=	\"specs_round\"			; boi=1; grl=1; active=1; };\r\n"
"	eyepatch_left			= { xox=	\"specs_eyepatch_left\"	; boi=1; grl=1; active=1; };\r\n"
"	eyepatch_right			= { xox=	\"specs_eyepatch_right\"	; boi=1; grl=1; active=1; };\r\n"
"},\r\n"
"\r\n"
"}\r\n"
"for g,t in pairs(xox_groups) do\r\n"
"	for n,v in pairs(t) do\r\n"
"		v.group=g\r\n"
"		v.name=n\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- split a string into a table\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"local function split(div,str)\r\n"
"\r\n"
"  if (div=='') or not div then error(\"div expected\", 2) end\r\n"
"  if (str=='') or not str then error(\"str expected\", 2) end\r\n"
"  \r\n"
"  local pos,arr = 0,{}\r\n"
"  \r\n"
"  -- for each divider found\r\n"
"  for st,sp in function() return string.find(str,div,pos,false) end do\r\n"
"	table.insert(arr,sub(str,pos,st-1)) -- Attach chars left of current divider\r\n"
"	pos = sp + 1 -- Jump past current divider\r\n"
"  end\r\n"
"  \r\n"
"  if pos~=0 then\r\n"
"	table.insert(arr,sub(str,pos)) -- Attach chars right of last divider\r\n"
"  else\r\n"
"	table.insert(arr,str) -- return entire string\r\n"
"  end\r\n"
"  \r\n"
"  \r\n"
"  return arr\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-----------------------------------------------------------------------------\r\n"
"--\r\n"
"-- find the basename from a filename\r\n"
"--\r\n"
"-----------------------------------------------------------------------------\r\n"
"local function get_basename(name)\r\n"
"\r\n"
"	local a1=split(\"%/\",name)\r\n"
"	local a2=split(\"%.\",a1[#a1])\r\n"
"	local a3=split(\"%_\",a2[1])\r\n"
"	local s=a3[1]\r\n"
"	\r\n"
"	if s==\"left\" or s==\"right\" then s=a3[2] end\r\n"
"	\r\n"
"	return s\r\n"
"end\r\n"
"\r\n"
"function setup(win)\r\n"
"\r\n"
"	local function print(...)\r\n"
"		win._g.print(...)\r\n"
"	end\r\n"
"\r\n"
"	local ogl=win.ogl\r\n"
"\r\n"
"	local it={}\r\n"
"	\r\n"
"	it.basename_map={\r\n"
"		[	\"body\"			]	=	\"body\"				,\r\n"
"		[	\"head\"			]	=	\"head\"				,\r\n"
"		[	\"foot\"			]	=	\"left_foot\"			,\r\n"
"		[	\"foot_flip\"		]	=	\"right_foot\"		,\r\n"
"		[	\"hair\"			]	=	\"hair\"				,\r\n"
"		[	\"ear\"			]	=	\"left_ear\"			,\r\n"
"		[	\"ear_flip\"		]	=	\"right_ear\"			,\r\n"
"		[	\"nose\"			]	=	\"nose\"				,\r\n"
"		[	\"mouth\"			]	=	\"mouth\"				,\r\n"
"		[	\"eye\"			]	=	\"left_eye\"			,\r\n"
"		[	\"eye_flip\"		]	=	\"right_eye\"			,\r\n"
"		[	\"tail\"			]	=	\"tail\"				,\r\n"
"		[	\"hand\"			]	=	\"left_hand\"			,\r\n"
"		[	\"hand_flip\" 	]	=	\"right_hand\"		,\r\n"
"		[	\"eyeball\"		]	=	\"left_eyeball\"		,\r\n"
"		[	\"eyeball_flip\"	]	=	\"right_eyeball\"		,\r\n"
"	}\r\n"
"	\r\n"
"	it.bodyparts={\r\n"
"		body				={\"body\"},\r\n"
"		head				={\"head\"},\r\n"
"		left_foot			={\"foot\"},\r\n"
"		right_foot			={\"foot\"},\r\n"
"		hair				={\"hair\"},\r\n"
"		left_ear			={\"ear\"},\r\n"
"		right_ear			={\"ear\"},\r\n"
"		nose				={\"nose\"},\r\n"
"		mouth				={\"mouth\"},\r\n"
"		left_eye			={\"eye\"},\r\n"
"		right_eye			={\"eye\"},\r\n"
"		tail				={\"tail\"},\r\n"
"		left_hand			={\"hand\"},\r\n"
"		right_hand			={\"hand\"},\r\n"
"		left_eyeball		={\"eyeball\"},\r\n"
"		right_eyeball		={\"eyeball\"},\r\n"
"	}\r\n"
"	\r\n"
"	function it.clean()\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"--\r\n"
"-- Load avatar parts into an xsx for display\r\n"
"--	\r\n"
"	function it.map_xsx(xsx,soul)\r\n"
"	\r\n"
"\r\n"
"		for i,v in ipairs(xsx.items) do\r\n"
"		\r\n"
"			local name=get_basename(v.name)\r\n"
"			local flip=((v.flags%2)==1)\r\n"
"			if flip then name=name..\"_flip\" end\r\n"
"			\r\n"
"			local name=it.basename_map[name]\r\n"
"			\r\n"
"--			print(name or i)\r\n"
"			\r\n"
"			if name then\r\n"
"				local part=soul.vanilla.parts[name]\r\n"
"				if part then\r\n"
"					v.fname=v.fname or {}\r\n"
"					v.data=v.data or {}\r\n"
"					v.soulinfo=v.soulinfo or {}\r\n"
"					\r\n"
"					v.size[1]=part.xsize or 1 -- v.size[1]\r\n"
"					v.size[2]=part.ysize or 1 -- v.size[2]\r\n"
"					v.size[3]=part.zsize or 1 -- v.size[3]\r\n"
"					\r\n"
"					v.morphs[1]=part.morph0 or 0\r\n"
"					v.morphs[2]=part.morph1 or 0\r\n"
"					v.morphs[3]=part.morph2 or 0\r\n"
"					v.morphs[4]=part.morph3 or 0\r\n"
"					\r\n"
"					v.pos[1]=part.xpos or 0 -- v.size[1]\r\n"
"					v.pos[2]=part.ypos or 0 -- v.size[2]\r\n"
"					v.pos[3]=part.zpos or 0 -- v.size[3]\r\n"
"					\r\n"
"					for i=1,4 do\r\n"
"					\r\n"
"						v.soulinfo[i]=part[i]\r\n"
"							\r\n"
"						if part[i] and part[i].xox_info and part[i].xox_info.xox then\r\n"
"					\r\n"
"							local fname=\"data/avatar/xox/\"..part[i].xox_info.xox..\".xox\"\r\n"
"							\r\n"
"							if v.fname[i]~=fname then\r\n"
"							\r\n"
"								if v[i] then v[i].clean() end\r\n"
"								\r\n"
"								v.data[i]=win.data.load(fname)\r\n"
"								v[i]=win.xox(v.data[i])\r\n"
"								v.fname[i]=fname\r\n"
"								\r\n"
"							end\r\n"
"							\r\n"
"							if v[i] then\r\n"
"								for i,v in ipairs(v[i].surfaces or {}) do\r\n"
"								\r\n"
"									local surf=soul.vanilla.surfaces[v.name]\r\n"
"									if surf then\r\n"
"										v.argb =surf.argb  or v.argb\r\n"
"										v.spec =surf.spec  or v.spec\r\n"
"										v.gloss=surf.gloss or v.gloss\r\n"
"									end\r\n"
"--print(\"surf:\"..v.name..\" \"..v.spec..\" \"..v.gloss)\r\n"
"								\r\n"
"								end\r\n"
"								\r\n"
"								v[i].set()\r\n"
"							end\r\n"
"							\r\n"
"							\r\n"
"						else\r\n"
"							if v[i] then v[i].clean() end\r\n"
"							v[i]=nil\r\n"
"							v.fname[i]=nil\r\n"
"							v.data[i]=nil\r\n"
"						end\r\n"
"					end\r\n"
"					\r\n"
"				end\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"		xsx.set()\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"--\r\n"
"-- Load an avatars soul (xml file)\r\n"
"--	\r\n"
"	function it.load_soul(filename,d)\r\n"
"	\r\n"
"		local soul={}\r\n"
"		if not d then -- did not pass in data, read it from a file\r\n"
"--print(\"soul : \"..filename)\r\n"
"			local fp=io.open(filename,\"r\")\r\n"
"			d=fp:read(\"*a\")\r\n"
"			fp:close()\r\n"
"		end\r\n"
"		\r\n"
"		local tab=sxml.parse(d)\r\n"
"--print(sxml.tree_to_string(tab))\r\n"
"		local t=tab\r\n"
"		\r\n"
"		local function isa(t,s)\r\n"
"			if type(t)~=\"table\" then return false end\r\n"
"			if t[0]==s then return true end\r\n"
"			return false\r\n"
"		end\r\n"
"		\r\n"
"		local function fromhex(s)\r\n"
"			if s then\r\n"
"				if s:sub(1,2)==\"0x\" then\r\n"
"					return tonumber(s:sub(3),16)\r\n"
"				else\r\n"
"					return tonumber(s,16)\r\n"
"				end\r\n"
"			end\r\n"
"			return nil\r\n"
"		end\r\n"
"		local function fromnum(s)\r\n"
"			if s then return tonumber(s) end\r\n"
"			return nil\r\n"
"		end\r\n"
"		\r\n"
"		t=sxml.child(t,\"soul\")\r\n"
"		for i,v in ipairs(t) do\r\n"
"		\r\n"
"			if isa(v,\"flavour\") then -- for each flavour\r\n"
"			\r\n"
"				local dat={}\r\n"
"				soul[v.name]=dat\r\n"
"				dat.parts={}\r\n"
"				dat.surfaces={}\r\n"
"			\r\n"
"				for i,v in ipairs(v) do\r\n"
"				\r\n"
"					if isa(v,\"part\") then -- for each part\r\n"
"					\r\n"
"						local p={}\r\n"
"						dat.parts[v.name]=p\r\n"
"						\r\n"
"						for i,v in pairs(v) do\r\n"
"							if type(i)==\"string\" then -- set all attribs\r\n"
"								if i~=\"name\" then\r\n"
"									p[i]=v\r\n"
"								end\r\n"
"							end\r\n"
"						end\r\n"
"						\r\n"
"						local idx=1\r\n"
"						for i,v in ipairs(v) do\r\n"
"							if type(v)==\"table\" and v[0]==\"object\" then -- an object\r\n"
"								local o={}\r\n"
"								p[idx]=o\r\n"
"								\r\n"
"								for i,v in pairs(v) do\r\n"
"									if type(i)==\"string\" then -- set all attribs\r\n"
"										o[i]=v\r\n"
"									end\r\n"
"								end\r\n"
"								\r\n"
"								o.xox_info=xox_groups[ o.group ]\r\n"
"								if o.xox_info then\r\n"
"									o.xox_info=o.xox_info[ o.name ]\r\n"
"								end\r\n"
"								\r\n"
"								\r\n"
"								idx=idx+1\r\n"
"								if idx>4 then break end\r\n"
"							end\r\n"
"						end\r\n"
"						\r\n"
"						p.xpos=fromnum(p.xpos)\r\n"
"						p.ypos=fromnum(p.ypos)\r\n"
"						p.zpos=fromnum(p.zpos)\r\n"
"						\r\n"
"						p.xsize=fromnum(p.xsize)\r\n"
"						p.ysize=fromnum(p.ysize)\r\n"
"						p.zsize=fromnum(p.zsize)\r\n"
"						\r\n"
"						p.morph0=fromnum(p.morph0)\r\n"
"						p.morph1=fromnum(p.morph1)\r\n"
"						p.morph2=fromnum(p.morph2)\r\n"
"						p.morph3=fromnum(p.morph3)\r\n"
"\r\n"
"					\r\n"
"					elseif isa(v,\"surface\") then -- for each surface\r\n"
"					\r\n"
"						local p={}\r\n"
"						dat.surfaces[v.name]=p\r\n"
"						\r\n"
"						for i,v in pairs(v) do\r\n"
"							if type(i)==\"string\" then -- set all attribs\r\n"
"								if i~=\"name\" then\r\n"
"									p[i]=v\r\n"
"								end\r\n"
"							end\r\n"
"						end\r\n"
"						\r\n"
"						p.argb=bit.bor(fromhex(p.argb),0xff000000)\r\n"
"						p.spec=bit.bor(fromhex(p.spec),0xff000000)\r\n"
"						p.gloss=2+(tonumber(p.gloss)*126) -- make 0 a \"good gloss number\"\r\n"
"						\r\n"
"					end\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"--		print(soul)\r\n"
"\r\n"
"\r\n"
"-- whoops spilling\r\n"
"		soul.vanilla=soul.vanilla or soul.vanila\r\n"
"		soul.vanila=nil\r\n"
"-- whoops spilling\r\n"
"\r\n"
"		return soul\r\n"
"	end\r\n"
"	\r\n"
"--\r\n"
"-- Save an avatars soul (xml file)\r\n"
"--	\r\n"
"	function it.save_soul(soul,filename)\r\n"
"	\r\n"
"		local tree={}\r\n"
"		tree[1]={[0]=\"soul\",version=\"1.0\"}\r\n"
"		for i,v in pairs(soul) do\r\n"
"			local t=tree[1]\r\n"
"			t[#t+1]={[0]=\"flavour\",name=i}\r\n"
"			t=t[#t]\r\n"
"			for i,v in pairs(v.parts) do\r\n"
"				t[#t+1]={[0]=\"part\",name=i}\r\n"
"				local p=t[#t]\r\n"
"				for ii,vv in pairs(v) do\r\n"
"					if type(ii)==\"string\" then\r\n"
"						p[ii]=tostring(vv)\r\n"
"					end\r\n"
"				end\r\n"
"				for i=1,4 do\r\n"
"					p[#p+1]={[0]=\"object\"}\r\n"
"					local o=p[#p]\r\n"
"					for ii,vv in pairs(v[i] or {}) do\r\n"
"						if type(ii)==\"string\" and type(vv)~=\"table\" then\r\n"
"							o[ii]=tostring(vv)\r\n"
"						end\r\n"
"					end\r\n"
"				end\r\n"
"			end\r\n"
"			for i,v in pairs(v.surfaces) do\r\n"
"				t[#t+1]={[0]=\"surface\",name=i}\r\n"
"				local s=t[#t]\r\n"
"				for ii,vv in pairs(v) do\r\n"
"					if type(ii)==\"string\" then\r\n"
"						s[ii]=tostring(vv)\r\n"
"					end\r\n"
"				end\r\n"
"				if s.argb then s.argb=string.format(\"0x%08x\",s.argb) end -- use hex\r\n"
"				if s.spec then s.spec=string.format(\"0x%08x\",s.spec) end -- use hex\r\n"
"				if s.gloss then s.gloss=(s.gloss-2)/126 end -- slight number fiddle, sorry\r\n"
"			end\r\n"
"		end\r\n"
"	\r\n"
"		local fp=io.open(filename,\"w\")\r\n"
"		if not fp then return false,\"open failed\" end\r\n"
"		fp:write(\r\n"
"		sxml.tree_to_string(tree))\r\n"
"		fp:close()\r\n"
"		\r\n"
"		return true\r\n"
"	end\r\n"
"	\r\n"
"	return it\r\n"
"end\r\n"
"",

"wetgenes.string","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"\n"
"local string=string\n"
"local table=table\n"
"local math=math\n"
"\n"
"local type=type\n"
"local pairs=pairs\n"
"local ipairs=ipairs\n"
"local tostring=tostring\n"
"local setmetatable=setmetatable\n"
"local error=error\n"
"local tonumber=tonumber\n"
"\n"
"local log=print\n"
"\n"
"--\n"
"-- Some useful string functions.\n"
"--\n"
"\n"
"local wstr={ modname=(...) } ; package.loaded[wstr.modname]=wstr\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split a string into a table, flag enables pattern match on true\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.str_split = function(div,str,flag)\n"
"\n"
"	if (str=='') then return {\"\"} end\n"
"	\n"
"	if (div=='') or not div then error(\"div expected\", 2) end\n"
"	if (str=='') or not str then error(\"str expected\", 2) end\n"
"\n"
"	local pos,arr = 0,{}\n"
"\n"
"	-- for each divider found\n"
"	for st,sp in function() return string.find(str,div,pos,not flag) end do\n"
"		table.insert(arr,string.sub(str,pos,st-1)) -- Attach chars left of current divider\n"
"		pos = sp + 1 -- Jump past current divider\n"
"	end\n"
"\n"
"	if pos~=0 then\n"
"		table.insert(arr,string.sub(str,pos)) -- Attach chars right of last divider\n"
"	else\n"
"		table.insert(arr,str) -- return entire string\n"
"	end\n"
"\n"
"\n"
"	return arr\n"
"end\n"
"--  yeah the above is bad and should be turned into this\n"
"wstr.split = function (str,div,flag) return wstr.str_split(div,str,flag) end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- serialize a simple table to a lua string that would hopefully recreate said table if executed\n"
"--\n"
"-- returns a string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.serialize = function(o,opts)\n"
"opts=opts or {}\n"
"opts.done=opts.done or {} -- only do tables once\n"
"\n"
"opts.indent=opts.indent or \"\"\n"
"opts.newline=opts.newline or ( opts.compact and \"\" or \"\\n"
"\" )\n"
"\n"
"local fout=opts.fout\n"
"\n"
"	if not fout then -- call with a new function to build and return a string\n"
"		local ret={}\n"
"		opts.fout=function(...)\n"
"			for i,v in ipairs({...}) do ret[#ret+1]=v end\n"
"		end\n"
"		wstr.serialize(o,opts)		\n"
"		return table.concat(ret)\n"
"	end\n"
"\n"
"	if type(o) == \"number\" then\n"
"	\n"
"		return fout(o)\n"
"		\n"
"	elseif type(o) == \"boolean\" then\n"
"	\n"
"		if o then return fout(\"true\") else return fout(\"false\") end\n"
"		\n"
"	elseif type(o) == \"string\" then\n"
"	\n"
"		return fout(string.format(\"%q\", o))\n"
"		\n"
"	elseif type(o) == \"table\" then\n"
"	\n"
"		\n"
"		if opts.done[o] and opts.no_duplicates then\n"
"			fout(opts.indent,\"\\n"
"\",opts.indent,\"{--[[DUPLICATE]]}\",opts.newline)\n"
"			return\n"
"		else\n"
"		\n"
"			fout(opts.newline,opts.indent,\"{\",opts.newline)\n"
"\n"
"			if opts.pretty then\n"
"				opts.indent=opts.indent..\" \"\n"
"			end\n"
"			\n"
"			opts.done[o]=true\n"
"			\n"
"			local maxi=0\n"
"			\n"
"			for k,v in ipairs(o) do -- dump number keys in order\n"
"				fout(opts.indent)\n"
"				wstr.serialize(v,opts)\n"
"				fout(\",\",opts.newline)\n"
"				maxi=k -- remember top\n"
"			end\n"
"			\n"
"			for k,v in pairs(o) do\n"
"				if (type(k)~=\"number\") or (k<1) or (k>maxi) or (math.floor(k)~=k) then -- skip what we already dumped\n"
"					fout(opts.indent,\"[\")\n"
"					wstr.serialize(k,opts)\n"
"					fout(\"]=\")\n"
"					wstr.serialize(v,opts)\n"
"					fout(\",\",opts.newline)\n"
"				end\n"
"			end\n"
"			\n"
"			if opts.pretty then\n"
"				opts.indent=opts.indent:sub(1,-2)\n"
"			end\n"
"			fout(opts.indent,\"}\",opts.newline)\n"
"			return\n"
"		end\n"
"	elseif type(o) == \"nil\" then	\n"
"		return fout(\"nil\")\n"
"	else\n"
"		error(\"cannot serialize a \" .. type(o))\n"
"	end\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- dump a table to a lua string for debuging output, \n"
"--\n"
"-- returns a string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.dump = function(o,opts)\n"
"opts=opts or {}\n"
"opts.done=opts.done or {} -- only do tables once\n"
"opts.names=opts.names or {\"this\"}\n"
"\n"
"opts.indent=opts.indent or \"\"\n"
"opts.newline=opts.newline or ( opts.compact and \"\" or \"\\n"
"\" )\n"
"\n"
"local fout=opts.fout\n"
"\n"
"	if not fout then -- call with a new function to build and return a string\n"
"		local ret={}\n"
"		opts.fout=function(...)\n"
"			for i,v in ipairs({...}) do ret[#ret+1]=v end\n"
"		end\n"
"		wstr.dump(o,opts)		\n"
"		return table.concat(ret)\n"
"	end\n"
"\n"
"	if type(o) == \"number\" then\n"
"	\n"
"		return fout(o)\n"
"		\n"
"	elseif type(o) == \"boolean\" then\n"
"	\n"
"		if o then return fout(\"true\") else return fout(\"false\") end\n"
"		\n"
"	elseif type(o) == \"string\" then\n"
"	\n"
"		return fout(string.format(\"%q\", o))\n"
"		\n"
"	elseif type(o) == \"table\" then\n"
"	\n"
"		\n"
"		if opts.done[o] then\n"
"			fout(\"(\",opts.done[o],\")\")\n"
"			return\n"
"		else\n"
"		\n"
"			fout(opts.newline,opts.indent,\"{\",opts.newline)\n"
"\n"
"			opts.indent=opts.indent..\" \"\n"
"			\n"
"			opts.done[o]=table.concat(opts.names,\".\")\n"
"			\n"
"			local maxi=0\n"
"			\n"
"			for k,v in ipairs(o) do -- dump number keys in order\n"
"				table.insert(opts.names,tostring(k))\n"
"				fout(opts.indent)\n"
"				wstr.dump(v,opts)\n"
"				fout(\",\",opts.newline)\n"
"				maxi=k -- remember top\n"
"				table.remove(opts.names)\n"
"			end\n"
"			\n"
"			for k,v in pairs(o) do\n"
"				if (type(k)~=\"number\") or (k<1) or (k>maxi) or (math.floor(k)~=k) then -- skip what we already dumped\n"
"					table.insert(opts.names,tostring(k))\n"
"					fout(opts.indent,\"[\")\n"
"					wstr.dump(k,opts)\n"
"					fout(\"]=\")\n"
"					wstr.dump(v,opts)\n"
"					fout(\",\",opts.newline)\n"
"					table.remove(opts.names)\n"
"				end\n"
"			end\n"
"			\n"
"			opts.indent=opts.indent:sub(1,-2)\n"
"			\n"
"			fout(opts.indent,\"}\",opts.newline)\n"
"			return\n"
"		end\n"
"	elseif type(o) == \"nil\" then	\n"
"		return fout(\"nil\")\n"
"	else\n"
"		return fout(\"function(\"..type(o)..\")end\")\n"
"	end\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- append english number postfix, 1st 2nd 3rd 4th etc\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.str_insert_number_commas = function (n)\n"
"\n"
"	local s=tostring(math.floor(n))\n"
"	local t={}\n"
"	\n"
"	while #s > 3 do\n"
"		table.insert(t,1,s:sub(-3))\n"
"		s=s:sub(1,-4)\n"
"	end\n"
"	table.insert(t,1,s)\n"
"\n"
"	return table.concat(t,\",\")\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- append english number postfix, 1st 2nd 3rd 4th etc\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.str_append_english_number_postfix = function(n)\n"
"\n"
"	local ith=n%10\n"
"	if n>10 and n<20 then ith=4 end -- teens are all \"th\"\n"
"\n"
"	if     ith==1 then return n..\"st\"\n"
"	elseif ith==2 then return n..\"nd\"\n"
"	elseif ith==3 then return n..\"rd\" end\n"
"\n"
"	return n..\"th\"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- join a table of things into an english list with commas and an \"and\" at the end\n"
"-- returns nil if the table is empty\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.str_join_english_list = function(t)\n"
"\n"
"local s\n"
"\n"
"	for i,v in ipairs(t) do\n"
"	\n"
"		if not s then -- first\n"
"		\n"
"			s=v\n"
"			\n"
"		elseif t[i+1]==nil then -- last\n"
"		\n"
"			s=s..\" and \"..v\n"
"			\n"
"		else -- middle\n"
"		\n"
"			s=s..\", \"..v\n"
"			\n"
"		end\n"
"	\n"
"	end\n"
"\n"
"	return s\n"
"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert a string into a hex string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.str_to_hex = function(s)\n"
"	return string.gsub(s, \".\", function (c)\n"
"		return string.format(\"%02x\", string.byte(c))\n"
"	end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace any %xx with the intended char, eg \"%20\" becomes a \" \"\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.url_decode = function (str)\n"
"    return string.gsub(str, \"%%(%x%x)\", function(hex)\n"
"        return string.char(tonumber(hex, 16))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace % , & , # , ' , \" and = chars with %xx codes\n"
"-- this is the bare minimum we need to escape so as not to confuse things\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.url_encode = function(str)\n"
"    return string.gsub(str, \"([&=%%#'\\\"])\", function(c)\n"
"        return string.format(\"%%%02X\", string.byte(c))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- a one way action that replaces anything that is not a-z or 0-9 with _\n"
"-- and converts the entire string to lowercase\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.alpha_munge = function(str)\n"
"    return string.gsub(string.lower(str), \"([^a-z0-9])\", function(c)\n"
"        return \"_\"\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- trime whitespace from ends of string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.trim = function(s)\n"
"  return (s:gsub(\"^%s*(.-)%s*$\", \"%1\"))\n"
"end\n"
"wstr.trim_start = function(s)\n"
"  return (s:gsub(\"^%s*(.-)\", \"%1\"))\n"
"end\n"
"wstr.trim_end = function(s)\n"
"  return (s:gsub(\"(.-)%s*$\", \"%1\"))\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split on \\n"
", each line also includes its own \\n"
"\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.split_lines = function(text)\n"
"	local separator = \"\\n"
"\"\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start,true)\n"
"	\n"
"	while split_start do\n"
"		table.insert(parts, text:sub(start, split_end))\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start,true)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	\n"
"	return parts\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split on whitespace, throw away all whitespace return only the words\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.split_words = function(text,split)\n"
"	local separator = split or \"%s+\"\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	\n"
"	while split_start do\n"
"		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	\n"
"	return parts\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split on transition to or from whitespace, include this white space in the table result\n"
"--\n"
"-- such that a concat on the result would be a perfect reproduction of the original\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.split_whitespace = function(text)\n"
"	local separator = \"%s+\"\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	\n"
"	while split_start do\n"
"		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end		-- the word\n"
"		table.insert(parts, text:sub(split_start, split_end))	-- the white space\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	\n"
"	return parts\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split a string in two on first = \n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.split_equal = function(text)\n"
"	local separator = \"=\"\n"
"	\n"
"	local parts = {}\n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start,true)\n"
"	\n"
"	if split_start and split_start>1 and split_end<#text then -- data either side of seperator\n"
"	\n"
"		return text:sub(1,split_start-1) , text:sub(split_end+1)\n"
"		\n"
"	end\n"
"	\n"
"	return nil\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- private replace utility function\n"
"-- look up string a inside data d and return the string we found\n"
"-- if we dont find anything then we return nil\n"
"--\n"
"-- if we try to look up a table containing a plate field\n"
"-- then that plate name will be used to format that table content as {it.nameofvar}\n"
"-- if that table contains a [1] then it will be treated as an array of data\n"
"-- and looped over to produce a result.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.table_lookup=function(a,d) -- look up a in table d\n"
"\n"
"	local t=d[a] -- as string\n"
"\n"
"	if not t then -- try as number?\n"
"		local n=tonumber(a)\n"
"		if n then\n"
"			t=d[n]\n"
"		end\n"
"	end\n"
"\n"
"	if t then return t end\n"
"	\n"
"	local a1,a2=string.find(a, \"%.\") -- try and split on first \".\"\n"
"	if not a1 then return nil end -- didnt find a dot so return nil\n"
"	\n"
"	a1=string.sub(a,1,a1-1) -- the bit before the .\n"
"	a2=string.sub(a,a2+1) -- the bit after the .\n"
"	\n"
"	local dd=d[a1] -- use the bit before the dot to find the sub table\n"
"	\n"
"	if not dd then -- try as number?\n"
"		local n=tonumber(a1)\n"
"		if n then\n"
"			dd=d[n]\n"
"		end\n"
"	end\n"
"	\n"
"	if type(dd)==\"table\" then -- check we got a table\n"
"		return wstr.table_lookup(a2,dd) -- tail call this function\n"
"	end\n"
"	\n"
"end\n"
"\n"
"wstr.replace_lookup=function(a,d) -- look up a in table d\n"
"	local t=wstr.table_lookup(a,d)\n"
"	if t then\n"
"		if type(t)==\"table\" then -- if a table then\n"
"			if t[1] then -- a list of stuff\n"
"				if t.plate then -- how to format\n"
"					local tt={}\n"
"					local it=d.it\n"
"					local i=1\n"
"					while t[i] do -- cant use ipairs or # as this data may only exist via the metatabel\n"
"						d.it=t[i]\n"
"						tt[#tt+1]=wstr.macro_replace(d[t.plate] or t.plate,d)\n"
"						i=i+1\n"
"					end\n"
"					d.it=it\n"
"					return table.concat(tt)\n"
"				end\n"
"			else -- just one thing\n"
"				if t.plate then -- how to format\n"
"					local it=d.it\n"
"					d.it=t\n"
"					local tt=wstr.macro_replace(d[t.plate] or t.plate,d)\n"
"					d.it=it\n"
"					return tt\n"
"				end\n"
"			end\n"
"			return nil -- no not expand\n"
"		end\n"
"		return tostring(t) -- simple find, make sure we return a string\n"
"	end\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace {tags} in the string with data provided\n"
"-- allow sub table look up with a.b notation in the name\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.replace=function(a,d)\n"
"\n"
"return (string.gsub( a , \"{([%w%._%-]-)}\" , function(a) -- find only words and \"._-!\" tightly encased in {}\n"
"-- this means that almost all legal use of {} in javascript will not match at all.\n"
"-- Even when it does (probably as a \"{}\") then it is unlikley to accidently find anything in the d table\n"
"-- so the text will just be returned as is.\n"
"-- So it may not be safe, but it is simple to understand and perfecty fine under most use cases.\n"
"\n"
"	return wstr.replace_lookup(a,d) or (\"{\"..a..\"}\")\n"
"	\n"
"end )) -- note gsub is in brackes so we just get its first return value\n"
"\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- like replace but allows for simple creation of temporary substitutions\n"
"-- this enables very simple macro expansion\n"
"-- so {var=}value{=var} would set var to value\n"
"-- and that value would last for the rest of the chunk\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.macro_replace_once = function(text,old_d,opts)\n"
"	opts=opts or {}\n"
"	local opts_clean=opts.clean\n"
"	local opts_htmldbg=opts.dbg_html_comments\n"
"\n"
"	local d={} -- we can store temporary vars in here\n"
"	if old_d then setmetatable(d,{__index=old_d})	end -- wrap original d to protect it\n"
"	\n"
"	\n"
"	local ret={}\n"
"	\n"
"	local separator = \"{[%w%._%-=]-}\"\n"
"	\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	\n"
"	while split_start do\n"
"		if split_start>1 then table.insert(parts, text:sub(start, split_start-1)) end		-- part1\n"
"		table.insert(parts, text:sub(split_start, split_end))	-- part2\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"\n"
"	local count=0\n"
"	local capt=nil\n"
"	\n"
"\n"
"-- step through	\n"
"	for i=1,#parts do local v=parts[i]\n"
"		local tag=nil\n"
"		local dat=nil\n"
"		local skip_capt=nil\n"
"		if string.len(v)>=3 then -- must be at least this long\n"
"			local fc=v:sub(1,1) -- first char\n"
"			local lc=v:sub(-1) -- last char\n"
"			if fc==\"{\" and lc==\"}\" then -- special part\n"
"				tag=v:sub(2,#v-1)\n"
"				local fc=tag:sub(1,1) -- first char\n"
"				local lc=tag:sub(-1) -- last char\n"
"				\n"
"				if lc==\"=\" then -- start of capture\n"
"					if capt==nil then\n"
"						capt=tag:sub(1,-2)\n"
"						d[capt]=\"\"\n"
"						skip_capt=true\n"
"						if opts_clean then\n"
"							dat=\"\"\n"
"						end\n"
"					end\n"
"				elseif fc==\"=\" then -- end of capture\n"
"					if capt==tag:sub(2) then -- must match\n"
"						capt=nil\n"
"						if opts_clean then dat=\"\" end\n"
"					end\n"
"				else -- normal lookup\n"
"					dat=wstr.replace_lookup(tag,d)\n"
"				end\n"
"			end\n"
"		end\n"
"		local s\n"
"		if dat then\n"
"			count=count+1\n"
"			if opts_htmldbg and tag then\n"
"				s=\"<!--{ \"..tag..\" }-->\\n"
"\"..dat\n"
"			else\n"
"				s=dat\n"
"			end\n"
"		else\n"
"			s=v\n"
"		end\n"
"		\n"
"		if not skip_capt then\n"
"			if capt then -- record capture\n"
"				d[capt]=d[capt]..s\n"
"				if opts_clean then s=\"\" end\n"
"			end\n"
"		end\n"
"		\n"
"		ret[#ret+1]=s\n"
"	end\n"
"\n"
"	return table.concat(ret,\"\"),count\n"
"end\n"
"\n"
"wstr.macro_replace = function(a,d,opts)\n"
"\n"
"local opts=opts or {} --{dbg_html_comments=true} to include html dbg, this will break some macro use inside javascript or html attributes so is off by default turn on to dbg\n"
"	\n"
"	local ret=a\n"
"	local count=0\n"
"\n"
"	opts.clean=false\n"
"	for i=1,100 do -- maximum recursion\n"
"	\n"
"		ret,count=wstr.macro_replace_once(ret,d,opts)\n"
"		\n"
"		if count==0 then break end -- nothing left to replace\n"
"		\n"
"	end\n"
"	opts.clean=true\n"
"	ret=wstr.macro_replace_once(ret,{},opts) -- finally remove temporary chunks\n"
"	return ret\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- wrap a string to a given width, merging all whitespace to spaces but keeping line breaks\n"
"-- return a table of lines\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"wstr.smart_wrap=function(s,w)\n"
"	local ls=wstr.split_whitespace(s)\n"
"	local t={}\n"
"	\n"
"	local wide=0\n"
"	local line={}\n"
"	\n"
"	local function newline()\n"
"		t[#t+1]=table.concat(line,\" \") or \"\"\n"
"		wide=0\n"
"		line={}\n"
"	end\n"
"	\n"
"	for i,v in ipairs(ls) do\n"
"	\n"
"		if v:find(\"%s\") then -- just white space\n"
"		\n"
"			for i,v in string.gfind(v,\"\\n"
"\") do -- keep newlines\n"
"				newline()\n"
"			end\n"
"		\n"
"		else -- a normal word\n"
"		\n"
"			if #line>0 then wide=wide+1 end\n"
"\n"
"			if wide + #v > w then -- split\n"
"				newline()\n"
"			end\n"
"			\n"
"			line[#line+1]=v\n"
"			wide=wide+#v\n"
"			\n"
"		end\n"
"	end\n"
"	if wide~=0 then newline() end -- final newline\n"
"	\n"
"	return t\n"
"end\n"
"",

"wetgenes.sod","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local sod={}\n"
"\n"
"local core=require(\"wetgenes.sod.core\")\n"
"\n"
"local meta={__index=sod}\n"
"\n"
"sod.create=function()\n"
"\n"
"	local sd={}\n"
"	setmetatable(sd,meta)\n"
"	\n"
"	sd[0]=assert( core.create() )\n"
"	\n"
"	core.info(sd[0],sd)\n"
"	return sd\n"
"end\n"
"\n"
"sod.destroy=function(sd)\n"
"	core.destroy(sd[0])\n"
"end\n"
"\n"
"\n"
"sod.load=function(sd,name)\n"
"	assert(core.load_file(sd[0],name))\n"
"	core.info(sd[0],sd)\n"
"	return sd\n"
"end\n"
"\n"
"sod.load_file=function(sd,name)\n"
"	assert(core.load_file(sd[0],name))\n"
"	core.info(sd[0],sd)\n"
"	return sd\n"
"end\n"
"\n"
"sod.load_data=function(sd,data)\n"
"	assert(core.load_data(sd[0],data))\n"
"	core.info(sd[0],sd)\n"
"	return sd\n"
"end\n"
"\n"
"sod.dynap_st16=core.dynap_st16\n"
"\n"
"return sod\n"
"",

"wetgenes.www.ngx.log","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local ngx=require(\"ngx\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.log\"]=_M\n"
"\n"
"\n"
"function log(...)\n"
"\n"
"-- only error seems to work?\n"
"\n"
"	if (...) then\n"
"		return ngx.log(ngx.NOTICE,...)\n"
"	end\n"
"--	return core.log(a,b)\n"
"\n"
"end\n"
"",

"wetgenes.gamecake.mods.console","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"local gcinfo=gcinfo\r\n"
"\r\n"
"local hex=function(str) return tonumber(str,16) end\r\n"
"\r\n"
"local pack=require(\"wetgenes.pack\")\r\n"
"\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"local tardis=require(\"wetgenes.tardis\")	-- matrix/vector math\r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"local buffedit=require(\"wetgenes.gamecake.mods.console.buffedit\")\r\n"
"\r\n"
"\r\n"
"function M.bake(oven,console)\r\n"
"\r\n"
"	console=console or {}\r\n"
"\r\n"
"	-- print out lua data in a somewhat sensible way, returns a string\r\n"
"	console.dump_limit = 20\r\n"
"	console.dump_depth = 7\r\n"
"	console.dump_stack = {}\r\n"
"\r\n"
"	console.call = {} -- name -> function : functions that should be easily to call on the console command line\r\n"
"\r\n"
"	local gl=oven.gl\r\n"
"	local cake=oven.cake\r\n"
"	local canvas=cake.canvas\r\n"
"	local layout=cake.layouts.create{} -- fullscreen\r\n"
"\r\n"
"	local win=oven.win\r\n"
"	local font=canvas.font\r\n"
"	local flat=canvas.flat\r\n"
"\r\n"
"\r\n"
"	function console.setup()\r\n"
"		console.replace_print(_G)\r\n"
"	\r\n"
"		oven.cake.fonts.loads({1}) -- load builtin font number 1 a basic 8x8 font\r\n"
"\r\n"
"		console.buff=buffedit.create() -- create buff edit\r\n"
"		console.buff.enter=function(_,line) console.dump_eval(line) end\r\n"
"		\r\n"
"		console.lines={}\r\n"
"		console.lines_display={}\r\n"
"		\r\n"
"		console.x=0\r\n"
"		console.y=0\r\n"
"		console.y_show=8*8\r\n"
"		\r\n"
"		console.show=false\r\n"
"--		console.show_hud=true\r\n"
"		console.show_hud=false\r\n"
"\r\n"
"--		console.show=true\r\n"
"--		console.show_hud=true\r\n"
"		\r\n"
"		console.setup_done=true\r\n"
"--print(\"console setup\")\r\n"
"	end\r\n"
"\r\n"
"	function console.clean()\r\n"
"	\r\n"
"		console.setup_done=false\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"	\r\n"
"	console.call.help=function()\r\n"
"		local t={}\r\n"
"		for n,f in pairs(console.call) do\r\n"
"			t[#t+1]=n\r\n"
"		end\r\n"
"		return table.concat(t,\" \")\r\n"
"	end\r\n"
"	\r\n"
"\r\n"
"-- based on ilua.lua\r\n"
"	function console.dump_eval(line)\r\n"
"	\r\n"
"		local function compile(line)\r\n"
"			local f,err = loadstring(line,'local')\r\n"
"			return err,f\r\n"
"		end\r\n"
"		\r\n"
"		\r\n"
"		local err,chunk\r\n"
"		local ret={}\r\n"
"		local args={}\r\n"
"		\r\n"
"		\r\n"
"		if line~=\"\" then args=wstr.split(\"%s\",line) end -- split input on whitespace\r\n"
"		\r\n"
"		if args[1] then\r\n"
"		\r\n"
"			local function lookup(tab,name)\r\n"
"				local names=wstr.split(\"%.\",name)\r\n"
"				for i,v in ipairs(names) do\r\n"
"--				print(i..\" \"..v)\r\n"
"					if type(tab)==\"table\" then\r\n"
"						tab=tab[v]\r\n"
"					else\r\n"
"						tab=nil\r\n"
"					end\r\n"
"				end\r\n"
"				return tab\r\n"
"			end\r\n"
"			\r\n"
"			chunk=lookup(console.call,args[1]) -- check special console functions\r\n"
"			\r\n"
"			if chunk and type(chunk)==\"function\" then -- must be a function\r\n"
"			\r\n"
"				table.remove(args,1) -- remove the function name\r\n"
"			\r\n"
"				setfenv(chunk,_G) -- call with master environment?\r\n"
"			else\r\n"
"			\r\n"
"				chunk=lookup(_G,args[1]) -- check for functions in master environment\r\n"
"				\r\n"
"				if chunk and type(chunk)==\"function\" then -- must be a function\r\n"
"				\r\n"
"					table.remove(args,1) -- remove the function name\r\n"
"				\r\n"
"				else\r\n"
"					chunk=nil\r\n"
"				end\r\n"
"				\r\n"
"				-- do not try and change the fenv of a function in the main envronment...\r\n"
"			\r\n"
"			end\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"		if not chunk then\r\n"
"		\r\n"
"			args={} -- no arguments\r\n"
"			\r\n"
"			-- is it an expression?\r\n"
"			err,chunk = compile('return '..line..' ')\r\n"
"			if err then\r\n"
"				-- otherwise, a statement?\r\n"
"				err,chunk = compile(line)\r\n"
"			end\r\n"
"			\r\n"
"			if chunk then\r\n"
"				setfenv(chunk,_G) -- compile in master environment will have an overloaded print\r\n"
"			end\r\n"
"		end\r\n"
"\r\n"
"		-- if compiled ok, then evaluate the chunk\r\n"
"		if not err and chunk then\r\n"
"		\r\n"
"			ret = { pcall(chunk,unpack(args)) }\r\n"
"			\r\n"
"			if not ret[1] then\r\n"
"				err=ret[2]\r\n"
"				ret={}\r\n"
"			else\r\n"
"				table.remove(ret,1)\r\n"
"			end\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"		-- if there was any error, print it out\r\n"
"		if err then\r\n"
"			_G.print(err)\r\n"
"		else\r\n"
"			if ret[1] then\r\n"
"				_G.print(unpack(ret))\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	function console.update()\r\n"
"	\r\n"
"		console.buff:update()\r\n"
"		\r\n"
"		if console.show then\r\n"
"			if console.y~=console.y_show then\r\n"
"			\r\n"
"				local d=(console.y_show-console.y)/4\r\n"
"				if d>0 then d=math.ceil(d) else d=math.floor(d) end\r\n"
"				console.y= math.floor( console.y + d )\r\n"
"			\r\n"
"			end\r\n"
"		else\r\n"
"			if console.y~=0 then\r\n"
"			\r\n"
"				local d=(0-console.y)/4\r\n"
"				if d>0 then d=math.ceil(d) else d=math.floor(d) end\r\n"
"				console.y= math.floor( console.y + d )\r\n"
"			\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	function console.draw()\r\n"
"	\r\n"
"font.vbs_idx=1\r\n"
"\r\n"
"\r\n"
"\r\n"
"		if oven.times and oven.win then -- simple benchmarking\r\n"
"		\r\n"
"			local t=oven.win.time()\r\n"
"\r\n"
"		-- count frames	\r\n"
"			if (not console.fps) or t-console.fps_last >= 1 then -- update with average value once a sec\r\n"
"			\r\n"
"				console.fps=console.fps_count or 0\r\n"
"				console.fps_count=0\r\n"
"				console.fps_last=t\r\n"
"			\r\n"
"			end\r\n"
"			\r\n"
"			oven.times.update.done()\r\n"
"			oven.times.draw.done()\r\n"
"\r\n"
"			local gci=gcinfo()\r\n"
"			local s=string.format(\"fps=%2d %02d/%02d %5.2fm vb=%d tx=%d fb=%d gl=%d\",\r\n"
"				console.fps,\r\n"
"				(oven.times.update.time*1000),\r\n"
"				(oven.times.draw.time*1000),\r\n"
"				gci/1024,\r\n"
"				gl.counts.buffers,\r\n"
"				gl.counts.textures,\r\n"
"				gl.counts.framebuffers,\r\n"
"				gl.counts.calls\r\n"
"				)\r\n"
"			gl.counts.calls=0 -- reset number of gl calls, so we display number of calls per frame.\r\n"
"\r\n"
"-- print info as we are			\r\n"
"			if gl.patch_functions_method==\"disable\" then\r\n"
"				print(s)\r\n"
"			end\r\n"
"							\r\n"
"			console.display(s)\r\n"
"\r\n"
"			console.fps_count=console.fps_count+1\r\n"
"		end\r\n"
"\r\n"
"		layout.apply()\r\n"
"		\r\n"
"--		oven.win:info()\r\n"
"\r\n"
"--		layout.viewport() -- did our window change?\r\n"
"--		layout.project23d(layout.w,layout.h,1/4,layout.h*4)\r\n"
"		\r\n"
"--		canvas.gl_default() -- reset gl state\r\n"
"\r\n"
"\r\n"
"--		gl.ClearColor(0,0,0,0)\r\n"
"--		gl.Clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT)\r\n"
"\r\n"
"--		gl.MatrixMode(gl.PROJECTION)\r\n"
"--		gl.LoadMatrix( layout.pmtx )\r\n"
"\r\n"
"--		gl.MatrixMode(gl.MODELVIEW)\r\n"
"--		gl.LoadIdentity()\r\n"
"--		gl.Translate(-layout.w/2,-layout.h/2,-layout.h) -- top/left 1unit==1pixel\r\n"
"\r\n"
"		gl.PushMatrix()\r\n"
"\r\n"
"\r\n"
"		font.set(cake.fonts.get(1))\r\n"
"		font.set_size(8,0)\r\n"
"		\r\n"
"		if console.y > 0 then\r\n"
"		\r\n"
"			gl.Color(pack.argb4_pmf4(0xc040))\r\n"
"			flat.quad(0,0,layout.w,console.y)\r\n"
"\r\n"
"			gl.Color(pack.argb4_pmf4(0xf4f4))\r\n"
"\r\n"
"\r\n"
"			local i=#console.lines\r\n"
"			local y=console.y-16\r\n"
"			while y>-8 and i>0 do\r\n"
"			\r\n"
"				font.set_xy(0,y)\r\n"
"				font.draw(console.lines[i])\r\n"
"				\r\n"
"				y=y-8\r\n"
"				i=i-1\r\n"
"			end\r\n"
"					\r\n"
"			font.set_xy(0,console.y-8)\r\n"
"			font.draw(\">\"..console.buff.line)\r\n"
"\r\n"
"			if console.buff.throb > 128 then\r\n"
"				font.set_xy((console.buff.line_idx+1)*8,console.y-8)\r\n"
"				font.draw(\"_\")\r\n"
"			end\r\n"
"\r\n"
"		end\r\n"
"\r\n"
"\r\n"
"		if console.show_hud then\r\n"
"			if console.flick then\r\n"
"--				console.flick=false\r\n"
"				gl.Color(pack.argb4_pmf4(0xffff))\r\n"
"			else\r\n"
"				console.flick=true\r\n"
"				gl.Color(pack.argb4_pmf4(0xf000))\r\n"
"			end\r\n"
"			for i,v in ipairs(console.lines_display) do\r\n"
"			\r\n"
"				font.set_xy(1,1+console.y+i*8-8)\r\n"
"				gl.Color(pack.argb4_pmf4(0xf000))\r\n"
"				font.draw(v)\r\n"
"\r\n"
"				font.set_xy(0,console.y+i*8-8)\r\n"
"				gl.Color(pack.argb4_pmf4(0xffff))\r\n"
"				font.draw(v)\r\n"
"\r\n"
"			end\r\n"
"		end\r\n"
"\r\n"
"\r\n"
"		console.lines_display={}\r\n"
"\r\n"
"\r\n"
"		gl.PopMatrix()\r\n"
"\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"	function console.print(s)\r\n"
"	\r\n"
"		if not console.lines then return end -- not setup yet\r\n"
"	\r\n"
"		if type(s)~=\"string\" then s=wstr.dump(s) end\r\n"
"	\r\n"
"		table.insert(console.lines,s)\r\n"
"		\r\n"
"		while #console.lines > 64 do\r\n"
"		\r\n"
"			table.remove(console.lines,1)\r\n"
"		\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	function console.display(s)\r\n"
"	\r\n"
"		if type(s)~=\"string\" then s=wstr.dump(s) end\r\n"
"		\r\n"
"		table.insert(console.lines_display,s)\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	function console.mouse(act,x,y,key)\r\n"
"--		print(act..\" \"..x..\",\"..y..\" \"..key)\r\n"
"	end\r\n"
"	\r\n"
"	function console.msg(m)\r\n"
"		if m.class==\"key\" then\r\n"
"			if console.keypress(m.ascii,m.keyname,m.action) then return nil end\r\n"
"--		elseif m.class==\"mouse\" then\r\n"
"--			console.keypress(m.action,m.x,m.y,m.keycode)\r\n"
"		end\r\n"
"		\r\n"
"		return m\r\n"
"	end\r\n"
"\r\n"
"	function console.keypress(ascii,key,act)\r\n"
"--		if act==1 then\r\n"
"--			_G.print(ascii..\" \"..(key or \"\"))\r\n"
"--		end\r\n"
"\r\n"
"--print(\"conkey\",key)\r\n"
"		if key==\"`\" then -- terrible name for the ` key?\r\n"
"		\r\n"
"			if act==-1 then\r\n"
"				if console.show then\r\n"
"				\r\n"
"					console.show=false\r\n"
"					console.show_hud=false\r\n"
"					\r\n"
"				elseif console.show_hud then\r\n"
"				\r\n"
"					console.show=true			\r\n"
"					console.buff.throb=255\r\n"
"				else\r\n"
"					console.show_hud=true\r\n"
"				end\r\n"
"			end\r\n"
"\r\n"
"			return true\r\n"
"		end\r\n"
"			\r\n"
"		if console.show then\r\n"
"		\r\n"
"			if act==1 or act==0 then\r\n"
"					\r\n"
"				if key==\"page up\" or key==\"prior\" then\r\n"
"				\r\n"
"					console.y_show=console.y_show-8\r\n"
"				\r\n"
"				elseif key==\"page down\" or key==\"next\" then\r\n"
"				\r\n"
"					console.y_show=console.y_show+8\r\n"
"\r\n"
"				end\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"			return console.buff:keypress(ascii,key,act)\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"-- overload print function in the given (global) tab\r\n"
"-- returns a function to undo this act (however this function may fail...)\r\n"
"	function console.replace_print(g)\r\n"
"	\r\n"
"		local print_old=g.print\r\n"
"		console.print_old=g.print\r\n"
"		local print_new=function(...)\r\n"
"		\r\n"
"			local t={}\r\n"
"			for i,v in ipairs({...}) do\r\n"
"				if type(v)~=\"string\" then v=wstr.dump(s) end\r\n"
"				table.insert(t,v)\r\n"
"			end\r\n"
"--			if not t[1] then t[1]=\"nil\" end\r\n"
"			\r\n"
"			console.print( table.concat(t,\"\\t\") )\r\n"
"			if print_old then\r\n"
"				print_old( ... )\r\n"
"			end\r\n"
"		end\r\n"
"		g.print=print_new\r\n"
"		\r\n"
"		return function()\r\n"
"			if g.print==print_new then -- only change back if noone else changed it\r\n"
"				g.print=print_old\r\n"
"				return true\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	\r\n"
"	return console\r\n"
"end\r\n"
"",

"wetgenes.gamecake.mods.layout","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"local gcinfo=gcinfo\r\n"
"\r\n"
"local hex=function(str) return tonumber(str,16) end\r\n"
"\r\n"
"local pack=require(\"wetgenes.pack\")\r\n"
"local wzips=require(\"wetgenes.zips\")\r\n"
"\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"local tardis=require(\"wetgenes.tardis\")	-- matrix/vector math\r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,layout)\r\n"
"\r\n"
"	layout=layout or {}\r\n"
"\r\n"
"-- \"main\" , \"main+chat\" , \"main+chat+keys\" ,  \"main+keys\" \r\n"
"	layout.mode=\"main\"\r\n"
"--	layout.mode=\"main+chat+keys\"\r\n"
"\r\n"
"-- info about some of the areas we offer\r\n"
"\r\n"
"	local cake=oven.cake\r\n"
"	local layouts=cake.layouts\r\n"
"\r\n"
"\r\n"
"	layout.main=layouts.create{}  -- where you should put your main view\r\n"
"	layout.keys=layouts.create{}  -- a place to type on devices without a keyboard\r\n"
"	layout.chat=layouts.create{}  -- a place to view what other people type\r\n"
"\r\n"
"	function layout.cycle_mode()\r\n"
"		if layout.mode==\"main\" then\r\n"
"			if oven.mods[\"wetgenes.gamecake.mods.chat\"] then\r\n"
"				layout.mode=\"main+chat\"\r\n"
"			elseif oven.mods[\"wetgenes.gamecake.mods.keys\"] then\r\n"
"				layout.mode=\"main+keys\"\r\n"
"			end\r\n"
"		elseif layout.mode==\"main+chat\" then\r\n"
"			if oven.mods[\"wetgenes.gamecake.mods.keys\"] then\r\n"
"				layout.mode=\"main+chat+keys\"\r\n"
"			else\r\n"
"				layout.mode=\"main\"\r\n"
"			end\r\n"
"		elseif layout.mode==\"main+chat+keys\" then\r\n"
"			layout.mode=\"main+keys\"\r\n"
"		else\r\n"
"			layout.mode=\"main\"\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	function layout.setup()\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	function layout.clean()\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	\r\n"
"\r\n"
"	function layout.update()\r\n"
"\r\n"
"		oven.win:info()\r\n"
"		\r\n"
"		local w=oven.win.width\r\n"
"		local h=oven.win.height\r\n"
"				\r\n"
"		layout.main.active=false\r\n"
"		layout.keys.active=false\r\n"
"		layout.chat.active=false\r\n"
"		\r\n"
"		local port=true -- portrait mode?\r\n"
"		if w>=h then port=false end -- landscape mode\r\n"
"\r\n"
"		if			layout.mode==\"main\" then\r\n"
"		\r\n"
"			layout.main.active=true\r\n"
"			layout.main.x=0\r\n"
"			layout.main.y=0\r\n"
"			layout.main.w=w\r\n"
"			layout.main.h=h\r\n"
"\r\n"
"		elseif		layout.mode==\"main+chat\" then\r\n"
"		\r\n"
"			if port then\r\n"
"			\r\n"
"				layout.chat.active=true\r\n"
"				layout.chat.x=0\r\n"
"				layout.chat.y=0\r\n"
"				layout.chat.w=w\r\n"
"				layout.chat.h=math.floor(h/2)\r\n"
"				\r\n"
"				layout.main.active=true\r\n"
"				layout.main.x=0\r\n"
"				layout.main.y=layout.chat.h\r\n"
"				layout.main.w=w\r\n"
"				layout.main.h=h-layout.chat.h\r\n"
"\r\n"
"			else\r\n"
"			\r\n"
"				layout.main.active=true\r\n"
"				layout.main.x=0\r\n"
"				layout.main.y=0\r\n"
"				layout.main.w=math.floor(w*2/3)\r\n"
"				layout.main.h=h\r\n"
"				\r\n"
"				layout.chat.active=true\r\n"
"				layout.chat.x=layout.main.w\r\n"
"				layout.chat.y=0\r\n"
"				layout.chat.w=w-layout.main.w\r\n"
"				layout.chat.h=h\r\n"
"\r\n"
"			end\r\n"
"		\r\n"
"		elseif		layout.mode==\"main+chat+keys\" then\r\n"
"\r\n"
"			if port then\r\n"
"			\r\n"
"				layout.chat.active=true\r\n"
"				layout.chat.x=0\r\n"
"				layout.chat.y=0\r\n"
"				layout.chat.w=w\r\n"
"				layout.chat.h=math.floor(h/3)\r\n"
"				\r\n"
"				layout.main.active=true\r\n"
"				layout.main.x=0\r\n"
"				layout.main.y=layout.chat.h\r\n"
"				layout.main.w=w\r\n"
"				layout.main.h=math.floor(h/3)\r\n"
"\r\n"
"				layout.keys.active=true\r\n"
"				layout.keys.x=0\r\n"
"				layout.keys.y=layout.chat.h + layout.main.h\r\n"
"				layout.keys.w=w\r\n"
"				layout.keys.h=h - layout.main.h - layout.chat.h\r\n"
"\r\n"
"			else\r\n"
"			\r\n"
"				layout.main.active=true\r\n"
"				layout.main.x=0\r\n"
"				layout.main.y=0\r\n"
"				layout.main.w=math.floor(w*2/3)\r\n"
"				layout.main.h=math.floor(h*2/3)\r\n"
"				\r\n"
"				layout.chat.active=true\r\n"
"				layout.chat.x=layout.main.w\r\n"
"				layout.chat.y=0\r\n"
"				layout.chat.w=w-layout.main.w\r\n"
"				layout.chat.h=h\r\n"
"\r\n"
"				layout.keys.active=true\r\n"
"				layout.keys.x=0\r\n"
"				layout.keys.y=layout.main.h\r\n"
"				layout.keys.w=layout.main.w\r\n"
"				layout.keys.h=h - layout.main.h\r\n"
"\r\n"
"			end\r\n"
"		\r\n"
"		elseif		layout.mode==\"main+keys\" then\r\n"
"			\r\n"
"			layout.main.active=true\r\n"
"			layout.main.x=0\r\n"
"			layout.main.y=0\r\n"
"			layout.main.w=w\r\n"
"			layout.main.h=math.floor(h*2/3)\r\n"
"			\r\n"
"			layout.keys.active=true\r\n"
"			layout.keys.x=0\r\n"
"			layout.keys.y=layout.main.h\r\n"
"			layout.keys.w=w\r\n"
"			layout.keys.h=h-layout.main.h\r\n"
"			\r\n"
"		end\r\n"
"				\r\n"
"	end\r\n"
"	\r\n"
"	function layout.draw() -- we dont need to draw but we will update again\r\n"
"	\r\n"
"		layout.update()\r\n"
"		\r\n"
"	end\r\n"
"		\r\n"
"--	function layout.msg(m)\r\n"
"--		return m\r\n"
"--	end\r\n"
"\r\n"
"	return layout\r\n"
"end\r\n"
"",

"wetgenes.gamecake.spew.settings","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"local wwin=require(\"wetgenes.win\") -- system independent helpers\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"local wsbox=require(\"wetgenes.sandbox\")\r\n"
"local snames=require(\"wetgenes.gamecake.spew.names\")\r\n"
"local lfs ; pcall( function() lfs=require(\"lfs\") end ) -- may not have a filesystem\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"M.bake=function(oven,settings)\r\n"
"\r\n"
"	settings=settings or {}\r\n"
"\r\n"
"\r\n"
"	settings.filename=wwin.files_prefix..\"settings.lua\"\r\n"
"	\r\n"
"	local cake=oven.cake\r\n"
"	local canvas=cake.canvas\r\n"
"\r\n"
"	local sgui=oven.rebake(\"wetgenes.gamecake.spew.gui\")\r\n"
"	\r\n"
"	local sounds=oven.rebake(\"wetgenes.gamecake.sounds\")\r\n"
"	\r\n"
"	local p\r\n"
"	local ss={}\r\n"
"	\r\n"
"-- check profile data is valid\r\n"
"	function settings.check()\r\n"
"	end\r\n"
"\r\n"
"-- initialise profile data\r\n"
"	function settings.init()\r\n"
"		ss={}\r\n"
"		ss.vol_music=10/11\r\n"
"		ss.vol_sfx=10/11\r\n"
"	end\r\n"
"	\r\n"
"-- load all profile data\r\n"
"	function settings.load()\r\n"
"		if lfs then\r\n"
"print(\"Loading \"..settings.filename)\r\n"
"			local fp=io.open(settings.filename,\"r\")\r\n"
"			if fp then\r\n"
"				local s=fp:read(\"*all\")\r\n"
"				ss=wsbox.lson(s) -- safeish\r\n"
"				fp:close()\r\n"
"				settings.check()\r\n"
"				for name,value in pairs(ss) do\r\n"
"					settings.apply(name,value)\r\n"
"				end\r\n"
"				return true\r\n"
"			end\r\n"
"		end\r\n"
"		return false\r\n"
"	end\r\n"
"	\r\n"
"-- save all profile data\r\n"
"	function settings.save()\r\n"
"		if lfs then\r\n"
"print(\"Saving \"..settings.filename)\r\n"
"			local fp=io.open(settings.filename,\"w\")\r\n"
"			fp:write(wstr.serialize(ss))\r\n"
"			fp:close()\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"-- set a value in the current profile\r\n"
"	function settings.set(name,value)\r\n"
"		if ss[name]~=value then\r\n"
"			ss[name]=value\r\n"
"			settings.apply(name,value)\r\n"
"			settings.save()\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"-- apply this setting to the engine\r\n"
"	function settings.apply(name,value)\r\n"
"			if     name==\"vol_music\" then\r\n"
"				sounds.vol_stream=value\r\n"
"			elseif name==\"vol_sfx\"   then\r\n"
"				sounds.vol_beep=value\r\n"
"			end\r\n"
"	end\r\n"
"	\r\n"
"-- get a value from the current profile\r\n"
"	function settings.get(name)\r\n"
"		return ss[name]\r\n"
"	end\r\n"
"\r\n"
"-- set a score in the current profile\r\n"
"	function settings.set_score(name,score)\r\n"
"		local scores=p[scores] or {}\r\n"
"		p[scores]=scores\r\n"
"		scores[#scores+1]=score\r\n"
"		settings.save()\r\n"
"	end\r\n"
"\r\n"
"--make sure we have a dir to load/save settings into\r\n"
"if lfs then\r\n"
"	lfs.mkdir(wwin.files_prefix:sub(1,-2)) -- skip trailing slash\r\n"
"end\r\n"
"\r\n"
"-- try autoload\r\n"
"if not settings.load() then\r\n"
"-- or create and save a default file\r\n"
"	settings.init()\r\n"
"	settings.save()\r\n"
"end\r\n"
"\r\n"
"	return settings\r\n"
"end\r\n"
"",

"wetgenes.gamecake.widgets.textedit","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"-- widget class string\r\n"
"-- a one line string buffer that can be edited\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,wtextedit)\r\n"
"wtextedit=wtextedit or {}\r\n"
"\r\n"
"local cake=oven.cake\r\n"
"\r\n"
"local widget_data=oven.rebake(\"wetgenes.gamecake.widgets.data\")\r\n"
"\r\n"
"\r\n"
"function wtextedit.mouse(widget,act,x,y,key)\r\n"
"\r\n"
"--	local it=widget.string\r\n"
"\r\n"
"-- call here so we can use any state changes immediatly	\r\n"
"	local ret=widget.meta.mouse(widget,act,x,y,key)\r\n"
"	\r\n"
"	if widget.master.active==widget then\r\n"
"	\r\n"
"		widget.master.focus=widget\r\n"
"		\r\n"
"		if act==1 then\r\n"
"			local dx=x-((widget.pxd or 0)+(widget.text_x or 0))\r\n"
"--print(dx)\r\n"
"			if dx<0 then -- catch lessthan\r\n"
"				widget.data.str_idx=0\r\n"
"			else\r\n"
"				local f=widget.font or widget.master.font or 1\r\n"
"				local font=cake.fonts.get(f)\r\n"
"\r\n"
"				widget.data.str_idx=0 -- font.which(dx,widget.data.str) // TODO: fix position under mouse\r\n"
"				\r\n"
"				if widget.data.str_idx<0 then widget.data.str_idx=#widget.data.str end -- catch morethan\r\n"
"			end\r\n"
"\r\n"
"			widget.master.throb=255\r\n"
"			widget:set_dirty()\r\n"
"\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	return ret\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wtextedit.key(widget,ascii,key,act)\r\n"
"--	local it=widget.string\r\n"
"	local master=widget.master\r\n"
"	\r\n"
"	local changed=false\r\n"
"\r\n"
"--print(\"gotkey\",ascii,act)\r\n"
"	\r\n"
"	\r\n"
"	if act==-1 then\r\n"
"\r\n"
"		if key==\"enter\" or key==\"return\" then\r\n"
"		\r\n"
"			if widget.data.str and widget.onenter then -- callback?\r\n"
"			\r\n"
"				widget:call_hook(\"click\")\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"			master.focus=nil\r\n"
"\r\n"
"			changed=true\r\n"
"		end\r\n"
"\r\n"
"	elseif act==1 or act==0 then\r\n"
"	\r\n"
"		if key==\"left\" then\r\n"
"\r\n"
"			widget.data.str_idx=widget.data.str_idx-1\r\n"
"			if widget.data.str_idx<0 then widget.data.str_idx=0 end\r\n"
"			\r\n"
"			master.throb=255\r\n"
"			changed=true\r\n"
"						\r\n"
"		elseif key==\"right\" then\r\n"
"	\r\n"
"			widget.data.str_idx=widget.data.str_idx+1\r\n"
"			if widget.data.str_idx>#widget.data.str then widget.data.str_idx=#widget.data.str end\r\n"
"			\r\n"
"			master.throb=255\r\n"
"			changed=true\r\n"
"			\r\n"
"		elseif key==\"home\" then\r\n"
"		\r\n"
"			widget.data.str_idx=0\r\n"
"			changed=true\r\n"
"		\r\n"
"		elseif key==\"end\" then\r\n"
"		\r\n"
"			widget.data.str_idx=#widget.data.str\r\n"
"			changed=true\r\n"
"		\r\n"
"		elseif key==\"back\" then\r\n"
"	\r\n"
"			if widget.data.str_idx >= #widget.data.str then -- at end\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(1,-2)\r\n"
"				widget.data.str_idx=#widget.data.str\r\n"
"				\r\n"
"				changed=true\r\n"
"			\r\n"
"			elseif widget.data.str_idx < 1 then -- at start\r\n"
"			\r\n"
"			elseif widget.data.str_idx == 1 then -- near start\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(2)\r\n"
"				widget.data.str_idx=widget.data.str_idx-1\r\n"
"			\r\n"
"				changed=true\r\n"
"\r\n"
"			else -- somewhere in the line\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(1,widget.data.str_idx-1) .. widget.data.str:sub(widget.data.str_idx+1)\r\n"
"				widget.data.str_idx=widget.data.str_idx-1\r\n"
"				\r\n"
"				changed=true\r\n"
"\r\n"
"			end\r\n"
"			\r\n"
"			master.throb=255\r\n"
"			\r\n"
"		elseif key==\"delete\" then\r\n"
"	\r\n"
"			if widget.data.str_idx >= #widget.data.str then -- at end\r\n"
"			\r\n"
"			elseif widget.data.str_idx < 1 then -- at start\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(2)\r\n"
"				widget.data.str_idx=0\r\n"
"			\r\n"
"				changed=true\r\n"
"\r\n"
"			else -- somewhere in the line\r\n"
"			\r\n"
"				widget.data.str=widget.data.str:sub(1,widget.data.str_idx) .. widget.data.str:sub(widget.data.str_idx+2)\r\n"
"				widget.data.str_idx=widget.data.str_idx\r\n"
"				\r\n"
"				changed=true\r\n"
"\r\n"
"			end\r\n"
"			\r\n"
"			master.throb=255\r\n"
"						\r\n"
"--		elseif key==\"up\" then\r\n"
"--		elseif key==\"down\" then\r\n"
"		\r\n"
"		elseif ascii~=\"\" then -- not a blank string\r\n"
"			local c=string.byte(ascii)\r\n"
"			\r\n"
"			if c>=32 and c<128 then\r\n"
"			\r\n"
"				if widget.data.str_idx >= #widget.data.str then -- put at end\r\n"
"				\r\n"
"					widget.data.str=widget.data.str..ascii\r\n"
"					widget.data.str_idx=#widget.data.str\r\n"
"					\r\n"
"				elseif widget.data.str_idx < 1 then -- put at start\r\n"
"				\r\n"
"					widget.data.str=ascii..widget.data.str\r\n"
"					widget.data.str_idx=1\r\n"
"					\r\n"
"				else -- need to insert into line\r\n"
"				\r\n"
"					widget.data.str=widget.data.str:sub(1,widget.data.str_idx) .. ascii .. widget.data.str:sub(widget.data.str_idx+1)\r\n"
"					widget.data.str_idx=widget.data.str_idx+1\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"				master.throb=255\r\n"
"				\r\n"
"				changed=true\r\n"
"\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	if changed then\r\n"
"		widget.text=widget.data.str\r\n"
"		\r\n"
"		widget:call_hook(\"update\")\r\n"
"		widget:set_dirty()\r\n"
"	end\r\n"
"	\r\n"
"	return true\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wtextedit.update(widget)\r\n"
"\r\n"
"	if widget.text ~= widget.data.str then\r\n"
"		widget.text = widget.data.str\r\n"
"		widget:set_dirty()\r\n"
"	end\r\n"
"\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wtextedit.setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.string=it\r\n"
"	widget.class=\"textedit\"\r\n"
"	\r\n"
"	widget.data=widget.data or widget_data.new_data({})\r\n"
"	\r\n"
"--	widget.data.str=\"\"\r\n"
"--	widget.data.str_idx=0\r\n"
"	\r\n"
"--	widget.key=key\r\n"
"	widget.update=wtextedit.update\r\n"
"\r\n"
"	widget.key=wtextedit.key\r\n"
"	widget.mouse=wtextedit.mouse\r\n"
"	\r\n"
"	widget.can_focus=true\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"\r\n"
"return wtextedit\r\n"
"end\r\n"
"",

"wetgenes.www.ngx.cache","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"local wbox=require(\"wetgenes.sandbox\")\n"
"\n"
"local ngx=ngx\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.cache\"]=_M\n"
"\n"
"--hax={}\n"
"\n"
"function check_mc()\n"
"	if ngx.ctx.mc then return ngx.ctx.mc end\n"
"	\n"
"	ngx.ctx.mc=require(\"wetgenes.www.ngx.memcache\").Connect() -- every request needs a new connection...\n"
"\n"
"	ngx.ctx.mc:set_encode(function(s) local r=wstr.serialize(s) return r end) -- so we may store tables\n"
"	ngx.ctx.mc:set_decode(function(s) return wbox.lson(s) end)\n"
"	\n"
"	return ngx.ctx.mc\n"
"end\n"
"\n"
"function countzero()\n"
"	count=0\n"
"	count_got=0\n"
"	api_time=0\n"
"\n"
"end\n"
"countzero()\n"
"\n"
"local start_time -- handle simple api benchmarking of some calls\n"
"local function apis()\n"
"	start_time=os.time()\n"
"end\n"
"local function apie(...)\n"
"	api_time=api_time+os.time()-start_time\n"
"	return ...\n"
"end\n"
"\n"
"local function getvhost(srv)\n"
"	local vhost=\"data\"\n"
"	if ngx and ngx.ctx and ngx.ctx.vhost then\n"
"		vhost=ngx.ctx.vhost\n"
"	end\n"
"	return vhost\n"
"end\n"
"\n"
"function clear(srv)\n"
"	apis()\n"
"	local mc=check_mc()\n"
"	\n"
"	mc:flush_all()\n"
"--	ngx.shared.cache:flush_all()\n"
"\n"
"	apie()\n"
"end\n"
"\n"
"\n"
"function del(srv,id)\n"
"	apis()\n"
"	local mc=check_mc()\n"
"\n"
"	local k=getvhost(srv)..\"&\"..id\n"
"	\n"
"	mc:delete(k)\n"
"--	ngx.shared.cache:delete(k)\n"
"\n"
"	apie()\n"
"end\n"
"\n"
"function put(srv,id,v,ttl,opts)\n"
"--	log(\"cache.put:\",id)\n"
"	apis()\n"
"	local mc=check_mc()\n"
"	\n"
"	local k=getvhost(srv)..\"&\"..id\n"
"	\n"
"	ttl=ttl or 60*5\n"
"	\n"
"--[[\n"
"	if type(v)==\"number\" then\n"
"		--as is\n"
"	else \n"
"		v=wstr.serialize(v)\n"
"	end\n"
"]]\n"
"\n"
"	if opts==\"ADD_ONLY_IF_NOT_PRESENT\" then\n"
"	\n"
"		mc:add(k,v,ttl)\n"
"--		ngx.shared.cache:add(k,v,ttl)\n"
"		\n"
"	else -- normal set\n"
"	\n"
"		mc:set(k,v,ttl)\n"
"--		ngx.shared.cache:set(k,v,ttl)\n"
"		\n"
"	end\n"
"\n"
"	\n"
"	apie()\n"
"end\n"
"\n"
"function get(srv,id)\n"
"	apis()\n"
"	local mc=check_mc()\n"
"	count=count+1\n"
"\n"
"	local k = getvhost(srv)..\"&\"..id\n"
"	local r = mc:get(k)\n"
"--	local r = ngx.shared.cache:get(k)\n"
"\n"
"	if r then count_got=count_got+1 end\n"
"	\n"
"--[[\n"
"	if type(r)==\"string\" then -- need to unserialise the data\n"
"		r=wbox.lson(r)\n"
"	end\n"
"]]\n"
"	apie()\n"
"	return r\n"
"end\n"
"\n"
"function inc(srv,id,num,start)\n"
"	apis()\n"
"	local mc=check_mc()\n"
"\n"
"	local k=getvhost(srv)..\"&\"..id\n"
"\n"
"\n"
"	r=mc:incr(k,num)\n"
"--	r=ngx.shared.cache:incr(k,num)\n"
"	if not r then\n"
"		r=start\n"
"		mc:set(k,num)\n"
"--		ngx.shared.cache:set(k,num)\n"
"	end\n"
"\n"
"	apie()\n"
"	return r\n"
"end\n"
"\n"
"",

"wetgenes.gamecake.mods.escmenu","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"local gcinfo=gcinfo\r\n"
"\r\n"
"local hex=function(str) return tonumber(str,16) end\r\n"
"\r\n"
"local pack=require(\"wetgenes.pack\")\r\n"
"local wzips=require(\"wetgenes.zips\")\r\n"
"\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"local tardis=require(\"wetgenes.tardis\")	-- matrix/vector math\r\n"
"\r\n"
"local win=require(\"wetgenes.win\")\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,escmenu)\r\n"
"\r\n"
"	escmenu=escmenu or {}\r\n"
"	\r\n"
"	local opts={\r\n"
"		width=480,\r\n"
"		height=480,\r\n"
"	}\r\n"
"\r\n"
"	local gl=oven.gl\r\n"
"	local cake=oven.cake\r\n"
"	local canvas=cake.canvas\r\n"
"	local layout=cake.layouts.create{}\r\n"
"\r\n"
"	function escmenu.setup()\r\n"
"	\r\n"
"		oven.cake.fonts.loads({1}) -- always load builtin font number 1 a basic 8x8 font		\r\n"
"		opts.font=1\r\n"
"		\r\n"
"		if wzips.exists(\"data/fonts/Vera.ttf\") then -- we got us better font to use :)\r\n"
"			oven.cake.fonts.loads({\"Vera\"})\r\n"
"			opts.font=\"Vera\"\r\n"
"		end\r\n"
"\r\n"
"\r\n"
"		escmenu.show=false\r\n"
"\r\n"
"		escmenu.master=oven.rebake(\"wetgenes.gamecake.widgets\").setup({})\r\n"
"		\r\n"
"		if wzips.exists(\"data/wskins/soapbar/button.png\") then -- we got us better skin to use :)\r\n"
"			oven.rebake(\"wetgenes.gamecake.widgets.skin\").load(\"soapbar\")\r\n"
"		end\r\n"
"\r\n"
"		local hooks={}\r\n"
"		function hooks.click(widget)\r\n"
"			local id=widget.id\r\n"
"--	print(widget.id)\r\n"
"			if id==\"layout\" then\r\n"
"				local mlayout=oven.mods[\"wetgenes.gamecake.mods.layout\"]\r\n"
"				if mlayout then\r\n"
"					mlayout.cycle_mode()\r\n"
"					escmenu.layout_widget.text=\"Layout: \"..mlayout.mode\r\n"
"				end\r\n"
"			elseif id==\"continue\" then\r\n"
"			\r\n"
"				escmenu.show=false\r\n"
"				\r\n"
"			elseif id==\"restart\" then\r\n"
"			\r\n"
"				oven.next=oven.now\r\n"
"				escmenu.show=false\r\n"
"				\r\n"
"			elseif id==\"quit\" then\r\n"
"			\r\n"
"				oven.next=true\r\n"
"				escmenu.show=false\r\n"
"				\r\n"
"			end\r\n"
"		end\r\n"
"		local top=escmenu.master:add({hx=480,hy=480,class=\"fill\",font=opts.font,text_size=32})\r\n"
"		top:add({hx=480,hy=80})\r\n"
"		\r\n"
"		local mlayout=oven.mods[\"wetgenes.gamecake.mods.layout\"]\r\n"
"		if mlayout then		\r\n"
"			escmenu.layout_widget=top:add({hx=480,hy=80,text=\"Layout: \"..mlayout.mode,color=0xffcccccc,id=\"layout\",hooks=hooks,text_size=32})\r\n"
"		else\r\n"
"			top:add({hx=480,hy=40})\r\n"
"		end\r\n"
"		\r\n"
"		top:add({hx=480,hy=80,text=\"Continue\",color=0xff44ff44,id=\"continue\",hooks=hooks})\r\n"
"		top:add({hx=480,hy=80,text=\"Restart\",color=0xffffff44,id=\"restart\",hooks=hooks})\r\n"
"		top:add({hx=480,hy=80,text=\"Quit\",color=0xffff4444,id=\"quit\",hooks=hooks})\r\n"
"		if not mlayout then		\r\n"
"			top:add({hx=480,hy=40})\r\n"
"		end\r\n"
"		top:add({hx=480,hy=80})\r\n"
"		\r\n"
"		escmenu.master:layout()\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	function escmenu.clean()\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	\r\n"
"\r\n"
"	function escmenu.update()\r\n"
"	\r\n"
"		if escmenu.show then\r\n"
"\r\n"
"			escmenu.master:update()\r\n"
"		\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	function escmenu.draw()\r\n"
"	\r\n"
"		local cake=oven.cake\r\n"
"--		local gl=cake.gl\r\n"
"--		local canvas=oven.canvas\r\n"
"		local font=canvas.font\r\n"
"\r\n"
"		if escmenu.show then\r\n"
"\r\n"
"		layout.viewport() -- did our window change?\r\n"
"		layout.project23d(opts.width,opts.height,1/4,opts.height*4)\r\n"
"		canvas.gl_default() -- reset gl state\r\n"
"\r\n"
"\r\n"
"		gl.MatrixMode(gl.PROJECTION)\r\n"
"		gl.LoadMatrix( layout.pmtx )\r\n"
"\r\n"
"		gl.MatrixMode(gl.MODELVIEW)\r\n"
"		gl.LoadIdentity()\r\n"
"		gl.Translate(-opts.width/2,-opts.height/2,-opts.height*2) -- top left corner is origin\r\n"
"		gl.PushMatrix()\r\n"
"\r\n"
"		escmenu.master:draw()\r\n"
"			\r\n"
"		gl.PopMatrix()\r\n"
"\r\n"
"		end\r\n"
"\r\n"
"		\r\n"
"	end\r\n"
"		\r\n"
"	function escmenu.msg(m)\r\n"
"		if escmenu.show then\r\n"
"			if m.class==\"key\" or m.class==\"mouse\" or m.class==\"joykey\" or m.class==\"joystick\" then\r\n"
"\r\n"
"				if m.xraw and m.yraw then	-- we need to fix raw x,y numbers\r\n"
"					m.x,m.y=layout.xyscale(m.xraw,m.yraw)	-- local coords, 0,0 is center of screen\r\n"
"					m.x=m.x+(opts.width/2)\r\n"
"					m.y=m.y+(opts.height/2)\r\n"
"				end\r\n"
"\r\n"
"				if m.class==\"key\" and m.action==-1 and m.keyname==\"escape\" then\r\n"
"					escmenu.show=not escmenu.show\r\n"
"					return nil\r\n"
"				end\r\n"
"				\r\n"
"				if ( m.class==\"joykey\" and m.action==-1 and (m.keycode==4 or m.keycode==0) ) then -- back button\r\n"
"					escmenu.show=not escmenu.show\r\n"
"					return nil\r\n"
"				end\r\n"
"\r\n"
"				escmenu.master:msg(m)\r\n"
"\r\n"
"				return nil\r\n"
"			end\r\n"
"		else\r\n"
"			if ( m.class==\"joykey\" and m.action==-1 and m.keycode==0 ) then -- back button\r\n"
"				escmenu.show=not escmenu.show\r\n"
"				return nil\r\n"
"			end\r\n"
"		end\r\n"
"		if ( m.class==\"key\" and m.keyname==\"escape\" ) then\r\n"
"			if m.action==-1 then\r\n"
"				escmenu.show=not escmenu.show\r\n"
"			end\r\n"
"			return nil\r\n"
"		end\r\n"
"		return m\r\n"
"	end\r\n"
"\r\n"
"	return escmenu\r\n"
"end\r\n"
"",

"wetgenes.gamecake.widgets.data","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"--\r\n"
"-- handle widgets data values\r\n"
"--\r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,wdata)\r\n"
"wdata=wdata or {}\r\n"
"\r\n"
"\r\n"
"wdata.call_hook=function(dat,hook)\r\n"
"	local hooks=dat.hooks\r\n"
"	local type_hooks=type(hooks)\r\n"
"	if type_hooks==\"function\" then -- master function\r\n"
"		return hooks(hook,dat)\r\n"
"	elseif type_hooks==\"table\" and hooks[hook] then -- or table of functions\r\n"
"		return hooks[hook](dat)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"-- set number (may trigger hook)\r\n"
"wdata.data_value=function(dat,val,force)\r\n"
"	if dat.class==\"number\" then\r\n"
"		if val then val=tonumber(val) end -- auto convert from string\r\n"
"		if ( val and val~=dat.num ) or force then -- change value\r\n"
"			dat.num=val\r\n"
"			if dat.min and dat.num<dat.min then dat.num=dat.min end\r\n"
"			if dat.max and dat.num>dat.max then dat.num=dat.max end\r\n"
"			dat.str=dat:get_string() -- cache on change\r\n"
"			dat:call_hook(\"value\") -- call value hook, which may choose to mod the num some more...\r\n"
"		end\r\n"
"		return dat.num\r\n"
"	else\r\n"
"		if (val and val~=dat.str ) or force  then -- change value\r\n"
"			dat.str=val\r\n"
"			dat:call_hook(\"value\") -- call value hook, which may choose to mod the num some more...\r\n"
"		end\r\n"
"		return dat.str\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"-- adjust number (may trigger hook)\r\n"
"wdata.data_inc=function(dat,step)\r\n"
"	step=step or dat.step\r\n"
"	if step==0 then step=1 end\r\n"
"	dat:value(dat.num+step)\r\n"
"end\r\n"
"-- adjust number (may trigger hook)\r\n"
"wdata.data_dec=function(dat,step)\r\n"
"	step=step or dat.step\r\n"
"	if step==0 then step=1 end\r\n"
"	dat:value(dat.num-step)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"-- a string to put in the handle\r\n"
"wdata.data_get_string=function(dat)\r\n"
"	if dat.class==\"number\" then return tostring(dat.num) end\r\n"
"	return dat.str\r\n"
"end\r\n"
"\r\n"
"-- how wide or tall should the handle be given the size of the parent?\r\n"
"wdata.data_get_size=function(dat,w)\r\n"
"	local ret=16\r\n"
"	if dat.min==dat.max then\r\n"
"		ret=w					-- fullsize\r\n"
"	elseif dat.size==0 then\r\n"
"		ret=w/4					-- some random room to scroll\r\n"
"	else\r\n"
"		ret=w*dat.size			-- use the given size\r\n"
"	end\r\n"
"	if ret<16 then ret=16 end\r\n"
"	if ret>w then ret=w end\r\n"
"	return ret\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-- get display pos, given the size of the parent and our size?\r\n"
"wdata.data_get_pos=function(dat,psiz,bsiz)\r\n"
"	if dat.step==0 then -- no snap\r\n"
"		return ((dat.num-dat.min)/(dat.max-dat.min))*(psiz-bsiz)\r\n"
"	else\r\n"
"		return ((dat.num-dat.min)/(dat.max-dat.min))*(psiz-bsiz)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"-- given the parents size and our relative position/size within it\r\n"
"-- update dat.num and return a new position (for snapping)\r\n"
"wdata.data_snap=function(dat,psiz,bsiz,bpos)\r\n"
"\r\n"
"--print(\"minmax\",dat.min,dat.max)\r\n"
"\r\n"
"	if dat.step==0 then -- no snap\r\n"
"		if dat.max==dat.min then dat:value(dat.min) return 0 end -- do not move\r\n"
"\r\n"
"		local f=bpos/(psiz-bsiz)\r\n"
"		dat:value(dat.min+((dat.max-dat.min)*f))\r\n"
"		\r\n"
"		return bpos\r\n"
"		\r\n"
"	else\r\n"
"	\r\n"
"		if dat.max==dat.min then dat:value(dat.min) return 0 end -- do not move\r\n"
"		\r\n"
"		local f=bpos/(psiz-bsiz)\r\n"
"		local n=math.floor(0.5+(((dat.max-dat.min)*f)/dat.step))\r\n"
"\r\n"
"		dat:value(dat.min+(n*dat.step))\r\n"
"		\r\n"
"		return math.floor((psiz-bsiz)*((dat.num-dat.min)/(dat.max-dat.min)))\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wdata.new_data(dat)\r\n"
"\r\n"
"	local dat=dat or {} -- probably use what is passed in only fill in more values\r\n"
"\r\n"
"	dat.class=dat.class or \"number\" -- could also be a \"string\"\r\n"
"\r\n"
"-- make default values and ranges for every possible class\r\n"
"-- this is very heavy data...\r\n"
"\r\n"
"	dat.lst=dat.lst or {}\r\n"
"\r\n"
"	dat.str_idx=dat.str_idx or 0\r\n"
"\r\n"
"	dat.min=dat.min or 0 -- not negative by default\r\n"
"	dat.max=dat.max or (2^48) -- a big old number\r\n"
"	dat.size=dat.size or 0 -- if 0 then button is auto sized to some value\r\n"
"	dat.step=dat.step or 0 -- if 0 then there is no quantization\r\n"
"	\r\n"
"	\r\n"
"-- setup callback functions\r\n"
"\r\n"
"	dat.call_hook=wdata.call_hook\r\n"
"\r\n"
"	dat.get_string=wdata.data_get_string -- should be moved into value() ?\r\n"
"	dat.get_size=wdata.data_get_size\r\n"
"	dat.get_pos=wdata.data_get_pos\r\n"
"	\r\n"
"-- get or set the value\r\n"
"	dat.value=wdata.data_value\r\n"
"	dat.inc=wdata.data_inc\r\n"
"	dat.dec=wdata.data_dec\r\n"
"\r\n"
"-- work out snapping for scroll bars	\r\n"
"	dat.snap=wdata.data_snap\r\n"
"\r\n"
"	dat.num=dat.num or 0\r\n"
"	dat.str=dat.str or \"\"\r\n"
"\r\n"
"--	if dat.class==\"number\" then\r\n"
"--		dat:value(dat.num,true) -- triger value changed/set callbacks?\r\n"
"--	else\r\n"
"--		dat:value(dat.str,true) -- triger value changed/set callbacks\r\n"
"--	end\r\n"
"	\r\n"
"	return dat\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"return wdata\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.gamecake.widgets.slide","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"-- two basic widgets merged together to give a simple slide or scrollbar \r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,wslide)\r\n"
"wslide=wslide or {}\r\n"
"\r\n"
"local widget_data=oven.rebake(\"wetgenes.gamecake.widgets.data\")\r\n"
"\r\n"
"\r\n"
"function wslide.mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	if act==1 and widget.master.over==widget then\r\n"
"--print(x,y,widget.drag.px,widget.drag.py)\r\n"
"		if x<widget.drag.px then widget:key(\"\",\"left\",1) return\r\n"
"		elseif x>widget.drag.px then widget:key(\"\",\"right\",1) return\r\n"
"		elseif y<widget.drag.py then widget:key(\"\",\"up\",1) return\r\n"
"		elseif y>widget.drag.py then widget:key(\"\",\"down\",1) return\r\n"
"		end\r\n"
"	end\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wslide.key(widget,ascii,key,act)\r\n"
"\r\n"
"	if key==\"enter\" or key==\"return\" or key==\"space\" then\r\n"
"		\r\n"
"		if act==-1 then -- ignore repeats on enter key\r\n"
"			widget:call_hook(\"click\")				\r\n"
"			widget.master.focus=nil\r\n"
"		end\r\n"
"			\r\n"
"	elseif key==\"left\" then\r\n"
"		if act==1 then -- ignore repeats on enter key\r\n"
"			widget.datx:dec()\r\n"
"			widget.drag.px=widget.datx:get_pos(widget.hx,widget.drag.hx)\r\n"
"			widget:snap()\r\n"
"		end\r\n"
"	elseif key==\"right\" then\r\n"
"		if act==1 then -- ignore repeats on enter key\r\n"
"			widget.datx:inc()\r\n"
"			widget.drag.px=widget.datx:get_pos(widget.hx,widget.drag.hx)\r\n"
"			widget:snap()\r\n"
"		end\r\n"
"	elseif key==\"up\" then\r\n"
"		if act==1 then -- ignore repeats on enter key\r\n"
"			widget.daty:dec()\r\n"
"			widget.drag.py=widget.daty:get_pos(widget.hy,widget.drag.hy)\r\n"
"			widget:snap()\r\n"
"		end\r\n"
"	elseif key==\"down\" then\r\n"
"		if act==1 then -- ignore repeats on enter key\r\n"
"			widget.daty:inc()\r\n"
"			widget.drag.py=widget.daty:get_pos(widget.hy,widget.drag.hy)\r\n"
"			widget:snap()\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	return true\r\n"
"\r\n"
"--	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wslide.update(widget)\r\n"
"--	local it=widget.slide\r\n"
"\r\n"
"\r\n"
"	widget:snap()\r\n"
"\r\n"
"--	it.drag.text=it.datx:get_string()\r\n"
"	\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function wslide.layout(widget)\r\n"
"\r\n"
"	widget.drag.hx=widget.datx:get_size(widget.hx)\r\n"
"	widget.drag.hy=widget.daty:get_size(widget.hy)\r\n"
"\r\n"
"	widget.meta.layout(widget)	\r\n"
"	\r\n"
"end\r\n"
"\r\n"
"function wslide.slide_snap(it)\r\n"
"\r\n"
"	it.drag.hx=it.datx:get_size(it.hx)\r\n"
"	it.drag.hy=it.daty:get_size(it.hy)\r\n"
"\r\n"
"-- auto snap positions when draged\r\n"
"	it.drag.px=it.datx:snap( it.hx , it.drag.hx , it.drag.px )\r\n"
"	it.drag.pxd=it.pxd+it.drag.px\r\n"
"	\r\n"
"-- y is now the right way up\r\n"
"	it.drag.py=it.daty:snap( it.hy , it.drag.hy , it.drag.py )\r\n"
"	it.drag.pyd=it.pyd+it.drag.py\r\n"
"	\r\n"
"end\r\n"
"	\r\n"
"function wslide.setup(widget,def)\r\n"
"--	local it={} -- our main data so as not to clobber widget values\r\n"
"--	it.widget=widget\r\n"
"--	widget.slide=it\r\n"
"	widget.class=\"slide\"\r\n"
"	\r\n"
"	widget.snap=wslide.slide_snap\r\n"
"	\r\n"
"	widget.key=wslide.key\r\n"
"	widget.mouse=wslide.mouse\r\n"
"	widget.update=wslide.update\r\n"
"	widget.layout=wslide.layout\r\n"
"	\r\n"
"--setup constraints in x and y \r\n"
"	widget.datx=def.datx or widget_data.new_data({max=0})\r\n"
"	widget.daty=def.daty or widget_data.new_data({max=0})\r\n"
"	widget.data=def.data -- or def.datx or def.daty\r\n"
"	\r\n"
"	widget.style=def.style or \"indent\"\r\n"
"\r\n"
"-- auto add the draging button as a child\r\n"
"	widget.drag=widget:add({style=\"button\",class=\"drag\",color=widget.color,solid=true,\r\n"
"		data=widget.data})\r\n"
"\r\n"
"-- set size and position of child\r\n"
"	widget.drag.hx=widget.datx:get_size(widget.hx)\r\n"
"	widget.drag.hy=widget.daty:get_size(widget.hy)\r\n"
"	widget.drag.px=widget.datx:get_pos(widget.hx,widget.drag.hx)\r\n"
"	widget.drag.py=widget.daty:get_pos(widget.hy,widget.drag.hy)\r\n"
"	widget:snap()\r\n"
"\r\n"
"	widget.can_focus=true\r\n"
"	\r\n"
"	return widget\r\n"
"end\r\n"
"\r\n"
"return wslide\r\n"
"end\r\n"
"",

"wetgenes.gamecake.widgets.meta","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- generic default widget functions\n"
"\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"function M.bake(oven,wmeta)\n"
"wmeta=wmeta or {}\n"
"\n"
"local framebuffers=oven.rebake(\"wetgenes.gamecake.framebuffers\")\n"
"\n"
"\n"
"-- available widget classes\n"
"wmeta.classes={\n"
"\n"
"-- base classes\n"
"\n"
"	[\"master\"]=oven.rebake(\"wetgenes.gamecake.widgets.master\"),\n"
"	[\"button\"]=oven.rebake(\"wetgenes.gamecake.widgets.button\"),\n"
"	[\"drag\"]=oven.rebake(\"wetgenes.gamecake.widgets.drag\"),\n"
"	[\"text\"]=oven.rebake(\"wetgenes.gamecake.widgets.text\"),\n"
"	[\"textedit\"]=oven.rebake(\"wetgenes.gamecake.widgets.textedit\"),\n"
"\n"
"--classes built out of the base classes\n"
"\n"
"	[\"pan\"]=oven.rebake(\"wetgenes.gamecake.widgets.pan\"),\n"
"	[\"slide\"]=oven.rebake(\"wetgenes.gamecake.widgets.slide\"),\n"
"\n"
"	[\"scroll\"]=oven.rebake(\"wetgenes.gamecake.widgets.scroll\"),\n"
"\n"
"}\n"
"\n"
"--\n"
"-- add meta functions\n"
"--\n"
"function wmeta.setup(def)\n"
"\n"
"--	local master=def.master\n"
"	local meta=def.meta\n"
"	local win=def.win\n"
"\n"
"-- set a dirty flag on this and all parents, this has a smart break, as if a child is dirty\n"
"-- then its parent must also be\n"
"-- the dirty flag is cleared on draw\n"
"	function meta.set_dirty(widget)\n"
"		widget.dirty=true\n"
"		while (widget.parent ~= widget) and not widget.parent.dirty do\n"
"			widget=widget.parent\n"
"			widget.dirty=true\n"
"		end\n"
"	end\n"
"\n"
"	function meta.call_hook(widget,hook,dat)\n"
"		local hooks=widget.hooks or widget.master.hooks\n"
"		local type_hooks=type(hooks)\n"
"		if type_hooks==\"function\" then -- master function\n"
"			hooks(hook,widget,dat)\n"
"		elseif type_hooks==\"table\" and hooks[hook] then -- or table of functions\n"
"			hooks[hook](widget,dat)\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- add a new widget as a child to this one\n"
"--\n"
"	function meta.add(parent,...)		\n"
"		local ret\n"
"		for i,def in pairs{...} do\n"
"			local widget={}\n"
"			setmetatable(widget,meta)\n"
"			table.insert(parent,widget)\n"
"			widget.parent=parent\n"
"			widget.master=parent.master\n"
"			widget:setup(def)\n"
"			widget.meta=meta\n"
"			ret=ret or widget\n"
"		end\n"
"		return ret -- return the first widget added\n"
"	end\n"
"	\n"
"--\n"
"-- remove from parent\n"
"--\n"
"	function meta.remove(widget)\n"
"	\n"
"		if widget.parent then\n"
"			for i,v in ipairs(widget.parent) do\n"
"				if v==widget then\n"
"					table.remove(widget.parent,i)\n"
"				end\n"
"			end\n"
"			widget.parent=nil\n"
"		end\n"
"		\n"
"	end	\n"
"--\n"
"-- add a previosuly created widget as a child to this widget\n"
"-- the widget will be forcibly removed...\n"
"--\n"
"	function meta.insert(parent,widget)\n"
"	\n"
"		meta.remove(widget) -- make sure we dont end up in two parents\n"
"		\n"
"		table.insert(parent,widget)\n"
"		widget.parent=parent\n"
"		widget.master=parent.master\n"
"		\n"
"		return widget\n"
"	end\n"
"\n"
"--\n"
"-- initial setup\n"
"--def\n"
"	function meta.setup(widget,def)\n"
"	\n"
"		widget.state=\"none\"\n"
"		\n"
"		widget.meta=meta\n"
"		\n"
"		widget.draw=def.draw -- custom render, probably best to wrap with a widget:draw_base(function)\n"
"		\n"
"		widget.data=def.data -- this widget is synced with this data\n"
"		\n"
"		widget.class=def.class\n"
"		widget.highlight=def.highlight\n"
"		\n"
"		widget.id=def.id\n"
"		widget.user=def.user -- any user data you wish to associate with this widget (we will ignore it)\n"
"		widget.hooks=def.hooks\n"
"\n"
"		widget.clip=def.clip -- use viewport clipping to prevent drawing outside of the area\n"
"\n"
"		widget.sx=def.sx or 1 -- display scale (of children)\n"
"		widget.sy=def.sy or 1\n"
"		widget.pa=def.pa or 0 -- display rotation angle (of children)\n"
"		\n"
"		\n"
"		widget.px=def.px or 0 -- relative to parent, pixel position\n"
"		widget.py=def.py or 0\n"
"\n"
"		widget.hx=def.hx or 0 -- absolute pixel size of widget\n"
"		widget.hy=def.hy or 0\n"
"		\n"
"\n"
"		-- turn this into a matrix? so we can rotate and stuff\n"
"		widget.pxd=def.pxd or 0 -- INTERNAL absolute pixel display position ( generated from px,py )\n"
"		widget.pyd=def.pyd or 0\n"
"\n"
"\n"
"		widget.color=def.color\n"
"		\n"
"		\n"
"		widget.font=def.font or widget.parent.font --  use this font if set or inherit value from parent\n"
"		\n"
"		widget.text_color=def.text_color or widget.parent.text_color or 0xff000000 -- black text\n"
"		widget.text_color_over=def.text_color_over -- if set, switch text color on hover\n"
"		widget.text_color_shadow=def.text_color_shadow  -- may need a shadow\n"
"		widget.text_size=def.text_size\n"
"		widget.text_align=def.text_align -- default is \"center\", and \"wrap\" will wrap the text\n"
"		\n"
"\n"
"		widget.sheet=def.sheet -- display this sheet (by name) on the button\n"
"		widget.sheet_id=def.sheet_id\n"
"		widget.sheet_px=def.sheet_px\n"
"		widget.sheet_py=def.sheet_py\n"
"		widget.sheet_hx=def.sheet_hx\n"
"		widget.sheet_hy=def.sheet_hy\n"
"\n"
"		widget.text=def.text -- display this text on the button\n"
"		widget.style=def.style -- style the button this way\n"
"\n"
"\n"
"		\n"
"		if widget.hooks then widget.solid=true end\n"
"		widget.solid=widget.solid or def.solid\n"
"		\n"
"		if widget.class and wmeta.classes[widget.class] then -- got a class, call its setup, its setup can override other functions\n"
"			wmeta.classes[widget.class].setup(widget,def)\n"
"		end\n"
"		\n"
"		if widget.master.ids and widget.id then widget.master.ids[widget.id]=widget end -- lookup by id\n"
"		\n"
"		if def.fbo then -- an fbo buffer has been requested (can speed rendering up)\n"
"			widget.fbo=framebuffers.create(0,0,0)\n"
"		end\n"
"		\n"
"		widget:set_dirty()\n"
"		\n"
"		return widget\n"
"	end\n"
"--\n"
"-- and final cleanup\n"
"--\n"
"	function meta.clean(widget)\n"
"		widget:set_dirty()\n"
"		if widget.master.ids and widget.id then widget.master.ids[widget.id]=nil end -- remove id lookup\n"
"		if widget.fbo then widget.fbo:clean() end\n"
"		return widget\n"
"	end\n"
"\n"
"\n"
"-- get a member from this or parents... widget\n"
"	function meta.bubble(widget,name)\n"
"		local w=widget\n"
"		repeat\n"
"			if w[name] then return w[name] end\n"
"			w=w.parent\n"
"		until not w\n"
"	end\n"
"\n"
"--\n"
"-- live adjustment\n"
"--\n"
"	function meta.get(widget,val,...)\n"
"	\n"
"		if val==\"slide\" then\n"
"		\n"
"--			local x=(widget.pxd-widget.parent.pxd) / (widget.parent.hx-widget.hx)\n"
"--			local y=(widget.pyd-widget.parent.pyd) / (widget.parent.hy-widget.hy)\n"
"			local x=(widget.px) / (widget.parent.hx-widget.hx)\n"
"			local y=(widget.py) / (widget.parent.hy-widget.hy)\n"
"			\n"
"			\n"
"			return x,y\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	function meta.set(widget,val,...)\n"
"	local t={...}\n"
"	\n"
"		if val==\"slide\" then\n"
"			for i,v in ipairs(widget) do\n"
"			\n"
"				local pxf=0\n"
"				local pyf=0\n"
"				if type(t[1])==\"table\" then\n"
"					pxf=t[1][1] or v.pxf or 0\n"
"					pyf=t[1][2] or v.pyf or 0\n"
"				else\n"
"					pxf=t[1] or v.pxf or 0\n"
"					pyf=t[2] or v.pyf or 0\n"
"				end\n"
"\n"
"				\n"
"--print(\"SET\",v.pxf,v.pyf)\n"
"\n"
"				v.px=(widget.hx-v.hx)*pxf -- local position relative to parents size\n"
"				v.py=(widget.hy-v.hy)*pyf\n"
"				\n"
"				v.pxd=widget.pxd+v.px -- absolute\n"
"				v.pyd=widget.pyd+v.py\n"
"				\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"--\n"
"-- handle key input\n"
"--\n"
"	function meta.key(widget,ascii,key,act)\n"
"	end\n"
"	\n"
"--\n"
"-- handle mouse input\n"
"--\n"
"	function meta.mouse(widget,act,x,y,key)\n"
"	\n"
"--print(x..\",\"..y..\" : \"..widget.px..\",\"..widget.py)\n"
"\n"
"		if widget.pan_px then x=x+widget.pan_px end\n"
"		if widget.pan_py then y=y+widget.pan_py end\n"
"\n"
"		if widget.solid and x>=widget.pxd and x<widget.pxd+widget.hx and y>=widget.pyd and y<widget.pyd+widget.hy then\n"
"		\n"
"			if act==1 then\n"
"-- only set if null or our parent...\n"
"--print(widget,widget.class)\n"
"--print(\"active\",widget,widget and widget.class,\n"
"--widget and widget.parent,widget and widget.parent.class)\n"
"				if not widget.master.active or widget.master.active==widget.parent then\n"
"					widget.master.active=widget\n"
"					widget.master.active_x=x-widget.pxd\n"
"					widget.master.active_y=y-widget.pyd\n"
"				end\n"
"			end\n"
"			if act==-1 then\n"
"				if not widget.master.dragging() or widget.master.active==widget then\n"
"--				if widget.master.active and widget.master.active==widget then -- widget clicked\n"
"					widget:call_hook(\"click\")\n"
"				end\n"
"			end\n"
"\n"
"			if not widget.master.dragging() or widget.master.active==widget then\n"
"--			if not widget.master.active or widget.master.active==widget then -- over widget\n"
"				widget.master.over=widget\n"
"			end\n"
"		else\n"
"		\n"
"			if widget.master.over==widget then\n"
"				widget.master.over=nil\n"
"			end\n"
"		end\n"
"	\n"
"		for i,v in ipairs(widget) do\n"
"			v:mouse(act,x,y,key)\n"
"		end\n"
"	end\n"
"	\n"
"--\n"
"-- update this widget and its sub widgets\n"
"--\n"
"	function meta.update(widget)\n"
"	\n"
"		if widget.anim then\n"
"			widget.anim:update()\n"
"		end\n"
"\n"
"--[[\n"
"-- cached parent world scale\n"
"		if widget.parent~=widget then\n"
"			widget.p_sx=widget.parent.w_sx\n"
"			widget.p_sy=widget.parent.w_sy\n"
"		else\n"
"			widget.p_sx=1\n"
"			widget.p_sy=1\n"
"		end\n"
"\n"
"-- cache widget world scale\n"
"		widget.w_sx=widget.sx*widget.p_sx\n"
"		widget.w_sy=widget.sy*widget.p_sy\n"
"]]\n"
"	\n"
"		for i,v in ipairs(widget) do\n"
"			v:update()\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- remove all children of this widget\n"
"--\n"
"	function meta.remove_all(widget)\n"
"	\n"
"		local len=#widget\n"
"		for i=1,len do\n"
"			widget[i]=nil\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- clean and remove all children of this widget\n"
"--\n"
"	function meta.clean_all(widget)\n"
"	\n"
"		for i,v in ipairs(widget) do\n"
"			v:clean_all()\n"
"		end\n"
"		\n"
"		local len=#widget\n"
"		for i=1,len do\n"
"			widget[i]:clean()\n"
"			widget[i]=nil\n"
"		end\n"
"	end\n"
"\n"
"--\n"
"-- Call this function for all descendents, recursivly\n"
"--\n"
"	function meta.call_descendents(widget,func)\n"
"		for i,v in ipairs(widget) do\n"
"			meta.call_descendents(v,func)\n"
"			func(v)\n"
"		end\n"
"	end\n"
"\n"
"-- more setup, moved to other files\n"
"	oven.rebake(\"wetgenes.gamecake.widgets.meta_layout\").setup(def)\n"
"\n"
"end\n"
"\n"
"\n"
"return wmeta\n"
"end\n"
"",

"socket","-----------------------------------------------------------------------------\n"
"-- LuaSocket helper module\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: socket.lua,v 1.22 2005/11/22 08:33:29 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Mega hack. Don't try to do this at home.\n"
"-----------------------------------------------------------------------------\n"
"local coroutine = require(\"coroutine\")\n"
"local table = require(\"table\")\n"
"local type=type\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local string = require(\"string\")\n"
"local math = require(\"math\")\n"
"local socket = require(\"socket.core\")\n"
"module(\"socket\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Mega hack. Don't try to do this at home.\n"
"-----------------------------------------------------------------------------\n"
"-- we can't yield across calls to protect, so we rewrite it with coxpcall\n"
"-- make sure you don't require any module that uses socket.protect before\n"
"-- loading our hack\n"
"function socket.protect(f)\n"
"  return function(...)\n"
"	local arg={...}\n"
"    local co = coroutine.create(f)\n"
"    while true do\n"
"      local results = {coroutine.resume(co, base.unpack(arg))}\n"
"      local status = table.remove(results, 1)\n"
"      if not status then\n"
"        if type(results[1]) == 'table' then\n"
"          return nil, results[1][1]\n"
"        else base.error(results[1]) end\n"
"      end\n"
"      if coroutine.status(co) == \"suspended\" then\n"
"        arg = {coroutine.yield(base.unpack(results))}\n"
"      else\n"
"        return base.unpack(results)\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Exported auxiliar functions\n"
"-----------------------------------------------------------------------------\n"
"function connect(address, port, laddress, lport)\n"
"    local sock, err = socket.tcp()\n"
"    if not sock then return nil, err end\n"
"    if laddress then\n"
"        local res, err = sock:bind(laddress, lport, -1)\n"
"        if not res then return nil, err end\n"
"    end\n"
"    local res, err = sock:connect(address, port)\n"
"    if not res then return nil, err end\n"
"    return sock\n"
"end\n"
"\n"
"function bind(host, port, backlog)\n"
"    local sock, err = socket.tcp()\n"
"    if not sock then return nil, err end\n"
"    sock:setoption(\"reuseaddr\", true)\n"
"    local res, err = sock:bind(host, port)\n"
"    if not res then return nil, err end\n"
"    res, err = sock:listen(backlog)\n"
"    if not res then return nil, err end\n"
"    return sock\n"
"end\n"
"\n"
"try = newtry()\n"
"\n"
"function choose(table)\n"
"    return function(name, opt1, opt2)\n"
"        if base.type(name) ~= \"string\" then\n"
"            name, opt1, opt2 = \"default\", name, opt1\n"
"        end\n"
"        local f = table[name or \"nil\"]\n"
"        if not f then base.error(\"unknown key (\".. base.tostring(name) ..\")\", 3)\n"
"        else return f(opt1, opt2) end\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Socket sources and sinks, conforming to LTN12\n"
"-----------------------------------------------------------------------------\n"
"-- create namespaces inside LuaSocket namespace\n"
"sourcet = {}\n"
"sinkt = {}\n"
"\n"
"BLOCKSIZE = 2048\n"
"\n"
"sinkt[\"close-when-done\"] = function(sock)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function(self, chunk, err)\n"
"            if not chunk then\n"
"                sock:close()\n"
"                return 1\n"
"            else return sock:send(chunk) end\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"sinkt[\"keep-open\"] = function(sock)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function(self, chunk, err)\n"
"            if chunk then return sock:send(chunk)\n"
"            else return 1 end\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"sinkt[\"default\"] = sinkt[\"keep-open\"]\n"
"\n"
"sink = choose(sinkt)\n"
"\n"
"sourcet[\"by-length\"] = function(sock, length)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function()\n"
"            if length <= 0 then return nil end\n"
"            local size = math.min(socket.BLOCKSIZE, length)\n"
"            local chunk, err = sock:receive(size)\n"
"            if err then return nil, err end\n"
"            length = length - string.len(chunk)\n"
"            return chunk\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"sourcet[\"until-closed\"] = function(sock)\n"
"    local done\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function()\n"
"            if done then return nil end\n"
"            local chunk, err, partial = sock:receive(socket.BLOCKSIZE)\n"
"            if not err then return chunk\n"
"            elseif err == \"closed\" then\n"
"                sock:close()\n"
"                done = 1\n"
"                return partial\n"
"            else return nil, err end\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"\n"
"sourcet[\"default\"] = sourcet[\"until-closed\"]\n"
"\n"
"source = choose(sourcet)\n"
"\n"
"",

"wetgenes.www.ngx.srv","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local ngx=require(\"ngx\")\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.srv\"]=_M\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- build a new srv structure for this request\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function new()\n"
"	srv={}\n"
"	\n"
"	srv.put=function(...)\n"
"		ngx.print(...)\n"
"	end\n"
"	\n"
"	srv.exit=function(n)\n"
"		ngx.exit(n)\n"
"		return n\n"
"	end\n"
"	\n"
"	srv.set_header=function(n,v)\n"
"--		log(\"srv.set_header:\",n,\"=\",v)\n"
"		ngx.header[n] = v;\n"
"	end\n"
"	\n"
"	srv.set_mimetype=function(v)	\n"
"		srv.set_header(\"content_type\",v)\n"
"		srv.redirect=function(url) -- must hack redirects from now on\n"
"				ngx.print(\"<script type=\\\"text/javascript\\\"> window.location = \\\"\"..url..\"\\\"; </script>\")\n"
"		end\n"
"			\n"
"--		log(\"srv.set_mimetype:\",v)\n"
"	end\n"
"	\n"
"	srv.set_cookie=function(t)\n"
"--		log(\"srv.set_cookie:\",t.name,\"=\",t.value)		\n"
"		ngx.header[\"Set-Cookie\"]=t.name..\"=\"..t.value..\"; Domain=\"..t.domain..\"; Path=\"..t.path..\";  Expires=\"..ngx.cookie_time(t.live)\n"
"	end\n"
"\n"
"	srv.redirect=function(url)\n"
"--		log(\"srv.redirect:\",url)\n"
"		return ngx.redirect(url)\n"
"	end\n"
"\n"
"	srv.reloadcache=function(...)\n"
"--		log(\"srv.reloadcache:\",...)\n"
"\n"
"--update options as we probably just edited them\n"
"		local ae_opts=require(\"wetgenes.www.any.opts\")\n"
"		local opts=require(\"opts\")\n"
"\n"
"		local v=opts.vhosts[srv.vhost] or opts\n"
"		v.lua = ae_opts.get_dat(\"lua\") -- this needs to be per vhost\n"
"		if v.lua then\n"
"			local f=loadstring(v.lua)\n"
"			if f then\n"
"				setfenv(f,v)\n"
"				pcall( f )\n"
"			end\n"
"		end\n"
"\n"
"	end\n"
"\n"
"	srv.cache={} -- a very local cache\n"
"	\n"
"	srv.method=ngx.var.request_method -- probably GET or POST\n"
"	\n"
"	srv.ip=ngx.var.remote_addr -- users IP\n"
"	\n"
"\n"
"\n"
"	local scheme=ngx.var.scheme			-- http or https\n"
"	local domain=ngx.var.host\n"
"	local port=ngx.var.server_port\n"
"	local uri=ngx.var.uri				-- begins with /\n"
"	\n"
"	if port and port~=\"80\" then\n"
"	\n"
"		srv.url=scheme..\"://\"..domain..\":\"..port..uri -- the url requested (not including any query string)\n"
"\n"
"	else\n"
"\n"
"		srv.url=scheme..\"://\"..domain..uri -- the url requested (not including any query string)\n"
"\n"
"	end\n"
"	\n"
"	srv.query=ngx.var.args -- the query string\n"
"--log(srv.query)\n"
"	\n"
"	srv.qurl=srv.url\n"
"	if srv.query and srv.query~=\"\" then srv.qurl=srv.qurl..\"?\"..srv.query end\n"
"	\n"
"	srv.headers={}\n"
"	for n,v in pairs( ngx.req.get_headers() ) do\n"
"		srv.headers[string.lower(n)]=v -- force all lowercase\n"
"	end\n"
"	\n"
"--print(\"HEADERS\",wstr.dump(ngx.req.get_headers()))\n"
"\n"
"	srv.cookies={}\n"
"	local cs\n"
"	if type(srv.headers.cookie)==\"string\" then\n"
"		cs=wstr.split(srv.headers.cookie,\";\")\n"
"	else\n"
"		cs=srv.headers.cookie\n"
"	end\n"
"--	log(srv.headers.cookie)\n"
"	for i,s in ipairs(cs or {}) do\n"
"		local n,v=wstr.split_equal(wstr.trim(s))\n"
"		srv.cookies[n]=v\n"
"	end\n"
"\n"
"	local body	-- pulling the body in is slightly complex\n"
"	ngx.req.read_body()\n"
"	local fn=ngx.req.get_body_file()\n"
"	if fn then\n"
"		local fp=io.open(fn,\"r\")\n"
"		body=fp:read(\"*a\")\n"
"		fp:close()\n"
"	else\n"
"		body=ngx.req.get_body_data()\n"
"	end\n"
"\n"
"	srv.body=body -- hand the body to the maincode (if we have a body) (probably incoming json)\n"
"	\n"
"	srv.posts={}\n"
"	srv.uploads={}\n"
"	\n"
"	local content_type=srv.headers[\"content-type\"]\n"
"--log(wstr.serialize(srv.headers))\n"
"	\n"
"	if not content_type then --nothing?\n"
"	\n"
"\n"
"	elseif string.find(content_type, \"x-www-form-urlencoded\", 1, true) then\n"
"	\n"
"		srv.posts=ngx.req.get_post_args()\n"
"	\n"
"	elseif string.find(content_type, \"multipart/form-data\", 1, true) then\n"
"	\n"
"		local _,_,boundary = string.find (content_type, \"boundary%=(.-)$\")\n"
"	  \n"
"		boundary=\"--\"..boundary\n"
"\n"
"		local parts=wstr.split(body,boundary)\n"
"	  \n"
"		for i,v in ipairs(parts) do\n"
"		\n"
"			local _,header_end=string.find(v, \"\\r\\n"
"\\r\\n"
"\") -- this terminates the header\n"
"			\n"
"			if header_end then -- and we can ignore this chunk if it has no header\n"
"			\n"
"				local header_str=v:sub(1,header_end)\n"
"				local data\n"
"				if v:sub(-2)==\"\\r\\n"
"\" then -- check and\n"
"					data=v:sub(header_end+1,-3) -- kill crlf data tail\n"
"				else\n"
"					data=v:sub(header_end+1)\n"
"				end\n"
"				local headers={}\n"
"				for i,v in ipairs( wstr.split(header_str,\"\\r\\n"
"\") ) do\n"
"					local aa=wstr.split(v,\":\")\n"
"					if aa[1] and aa[2] then\n"
"						headers[ wstr.trim(aa[1]) ] = aa[2]\n"
"					end\n"
"				end\n"
"				\n"
"				local attrs={}\n"
"				if headers[\"Content-Disposition\"] then\n"
"					string.gsub(headers[\"Content-Disposition\"], ';%s*([^%s=]+)=\"(.-)\"',\n"
"						function(attr, val)\n"
"							attrs[attr] = val\n"
"						end)\n"
"				end\n"
"				\n"
"				if attrs.name then\n"
"					if attrs.filename then -- this be an uploaded file.\n"
"						srv.uploads[attrs.name]={data=data,size=#data,name=attrs.filename,type=headers[\"Content-Type\"]}\n"
"					else\n"
"						srv.posts[attrs.name]=data\n"
"					end\n"
"				end\n"
"			end\n"
"		end\n"
"	end\n"
"\n"
"	srv.gets=ngx.req.get_uri_args()\n"
"\n"
"--print(\"UPLOADS\",wstr.dump(srv.uploads))\n"
"--print(\"POSTS\",wstr.dump(srv.posts))\n"
"--print(\"GETS\",wstr.dump(srv.gets))\n"
"\n"
"	srv.vars={}\n"
"	for key, val in pairs( srv.posts ) do\n"
"		srv.vars[key]=val\n"
"	end\n"
"	for key, val in pairs( srv.gets ) do\n"
"		srv.vars[key]=val\n"
"	end\n"
"\n"
"	return srv\n"
"end\n"
"",

"wetgenes.gamecake.mods.snaps","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"local gcinfo=gcinfo\r\n"
"\r\n"
"local hex=function(str) return tonumber(str,16) end\r\n"
"\r\n"
"local pack=require(\"wetgenes.pack\")\r\n"
"local wzips=require(\"wetgenes.zips\")\r\n"
"\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"local tardis=require(\"wetgenes.tardis\")	-- matrix/vector math\r\n"
"\r\n"
"local win=require(\"wetgenes.win\")\r\n"
"\r\n"
"local wgrd   =require(\"wetgenes.grd\")\r\n"
"local lfs ; (function() pcall( function() lfs=require(\"lfs\") end ) end)()\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,snaps)\r\n"
"\r\n"
"	snaps=snaps or {}\r\n"
"	\r\n"
"	local gl=oven.gl\r\n"
"	local cake=oven.cake\r\n"
"	local canvas=cake.canvas\r\n"
"	local layout=cake.layouts.create{}\r\n"
"\r\n"
"	function snaps.setup()\r\n"
"		if not lfs then return end\r\n"
"\r\n"
"		lfs.mkdir(win.files_prefix..\"snaps\")\r\n"
"	end\r\n"
"\r\n"
"	function snaps.clean()\r\n"
"	end\r\n"
"	\r\n"
"	function snaps.update()\r\n"
"	end\r\n"
"	\r\n"
"	function snaps.draw()\r\n"
"	end\r\n"
"		\r\n"
"	function snaps.msg(m)\r\n"
"		if not lfs then return m end\r\n"
"\r\n"
"		if m.class==\"key\" and m.keyname==\"f12\" and m.action==1 then\r\n"
"			local name=os.date(\"%Y%m%d_%H%M%S\")\r\n"
"print(\"Snaps \"..name)\r\n"
"			local g=wgrd.create( wgrd.FMT_U8_RGBA_PREMULT , oven.win.width , oven.win.height , 1 )\r\n"
"			gl.ReadPixels(0,0,oven.win.width,oven.win.height,gl.RGBA,gl.UNSIGNED_BYTE,g.data)\r\n"
"			g:convert( wgrd.FMT_U8_ARGB ) -- save code expects this format\r\n"
"			g:flipy() -- open gl is upside down\r\n"
"			g:save(win.files_prefix..\"snaps/\"..name..\".png\")\r\n"
"			return nil\r\n"
"		end\r\n"
"		return m\r\n"
"	end\r\n"
"\r\n"
"	return snaps\r\n"
"end\r\n"
"",

"wetgenes.www.any","\rmodule(...)\r",

"wetgenes.nacl","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local nacl={}\n"
"\n"
"local core=require(\"wetgenes.nacl.core\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"\n"
"nacl.PP_INPUTEVENT_TYPE={\n"
"[-1]=\"UNDEFINED\",\n"
"[0]=\"MOUSEDOWN\",\n"
"\"MOUSEUP\",\n"
"\"MOUSEMOVE\",\n"
"\"MOUSEENTER\",\n"
"\"MOUSELEAVE\",\n"
"\"WHEEL\",\n"
"\"RAWKEYDOWN\",\n"
"\"KEYDOWN\",\n"
"\"KEYUP\",\n"
"\"CHAR\",\n"
"\"CONTEXTMENU\",\n"
"\"IME_COMPOSITION_START\",\n"
"\"IME_COMPOSITION_UPDATE\",\n"
"\"IME_COMPOSITION_END\",\n"
"\"IME_TEXT\",\n"
"} for i=0,#nacl.PP_INPUTEVENT_TYPE do nacl.PP_INPUTEVENT_TYPE[ nacl.PP_INPUTEVENT_TYPE[i] ]=i end\n"
"\n"
"--\n"
"-- finally export any remaining core functions\n"
"--\n"
"for n,v in pairs(core) do -- check the core\n"
"	if type(v)==\"function\" then -- only functions\n"
"		if not nacl[n] then -- only if not prewrapped\n"
"			nacl[n]=v\n"
"		end\n"
"	end\n"
"\n"
"end\n"
"\n"
"return nacl\n"
"\n"
"",

"wetgenes.gamecake.gles","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- this contains mild emulation of the old gl fixed pipeline, such that we can run some code in gles2 and above\n"
"\n"
"local tardis=require(\"wetgenes.tardis\")\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"function M.bake(oven,gles)\n"
"\n"
"	if not oven.gl then -- need a gles2 wrapped in glescode\n"
"	\n"
"		oven.gl=require(\"glescode\").create( require(\"gles\").gles2 )\n"
"		\n"
"		oven.gl.GetExtensions()\n"
"		\n"
"	end\n"
"\n"
"	local gl=oven.gl\n"
"	\n"
"\n"
"-- if there is no normal then assume \"special z mode\"\n"
"-- where the z component is treated as 0 for vire transform\n"
"-- but added on at the end, for 2d z \"polygon offset\" hacks\n"
"\n"
"	gl.shaders.v_pos_tex={\n"
"	source=gl.defines.shaderprefix..[[\n"
"\n"
"uniform mat4 modelview;\n"
"uniform mat4 projection;\n"
"uniform vec4 color;\n"
"\n"
"attribute vec3 a_vertex;\n"
"attribute vec2 a_texcoord;\n"
"\n"
"varying vec2  v_texcoord;\n"
"varying vec4  v_color;\n"
" \n"
"void main()\n"
"{\n"
"    gl_Position = projection * modelview * vec4(a_vertex.xy, 0.0 , 1.0);\n"
"    gl_Position.z+=a_vertex.z;\n"
"	v_texcoord=a_texcoord;\n"
"	v_color=color;\n"
"}\n"
"\n"
"	]]\n"
"}\n"
"\n"
"	gl.shaders.v_pos_tex_color={\n"
"	source=gl.defines.shaderprefix..[[\n"
"\n"
"uniform mat4 modelview;\n"
"uniform mat4 projection;\n"
"uniform vec4 color;\n"
"\n"
"attribute vec3 a_vertex;\n"
"attribute vec2 a_texcoord;\n"
"attribute vec4 a_color;\n"
"\n"
"varying vec2  v_texcoord;\n"
"varying vec4  v_color;\n"
" \n"
"void main()\n"
"{\n"
"    gl_Position = projection * modelview * vec4(a_vertex.xy, 0.0 , 1.0);\n"
"    gl_Position.z+=a_vertex.z;\n"
"	v_texcoord=a_texcoord;\n"
"	v_color=a_color*color;\n"
"}\n"
"\n"
"	]]\n"
"}\n"
"\n"
"	gl.shaders.v_pos={\n"
"	source=gl.defines.shaderprefix..[[\n"
"\n"
"uniform mat4 modelview;\n"
"uniform mat4 projection;\n"
"uniform vec4 color;\n"
"\n"
"attribute vec3 a_vertex;\n"
"\n"
"varying vec4  v_color;\n"
" \n"
"void main()\n"
"{\n"
"    gl_Position = projection * modelview * vec4(a_vertex.xy, 0.0 , 1.0);\n"
"    gl_Position.z+=a_vertex.z;\n"
"	v_color=color;\n"
"}\n"
"\n"
"	]]\n"
"}\n"
"\n"
"\n"
"	gl.shaders.v_pos_color={\n"
"	source=gl.defines.shaderprefix..[[\n"
"\n"
"uniform mat4 modelview;\n"
"uniform mat4 projection;\n"
"uniform vec4 color;\n"
"\n"
"attribute vec3 a_vertex;\n"
"attribute vec4 a_color;\n"
"\n"
"varying vec4  v_color;\n"
" \n"
"void main()\n"
"{\n"
"    gl_Position = projection * modelview * vec4(a_vertex.xy, 0.0 , 1.0);\n"
"    gl_Position.z+=a_vertex.z;\n"
"	v_color=a_color*color;\n"
"}\n"
"\n"
"	]]\n"
"}\n"
"\n"
"	gl.shaders.f_tex={\n"
"	source=gl.defines.shaderprefix..[[\n"
"\n"
"uniform sampler2D tex;\n"
"\n"
"varying vec2  v_texcoord;\n"
"varying vec4  v_color;\n"
"\n"
"void main(void)\n"
"{\n"
"	gl_FragColor=texture2D(tex, v_texcoord) * v_color ;\n"
"}\n"
"\n"
"	]]\n"
"}\n"
"	gl.shaders.f_tex_discard={\n"
"	source=gl.defines.shaderprefix..[[\n"
"\n"
"uniform sampler2D tex;\n"
"\n"
"varying vec2  v_texcoord;\n"
"varying vec4  v_color;\n"
"\n"
"void main(void)\n"
"{\n"
"	gl_FragColor=texture2D(tex, v_texcoord) * v_color ;\n"
"	if((gl_FragColor.a)<0.25) discard;\n"
"}\n"
"\n"
"	]]\n"
"}\n"
"\n"
"	gl.shaders.f_color={\n"
"	source=gl.defines.shaderprefix..[[\n"
"\n"
"varying vec4  v_color;\n"
"\n"
"void main(void)\n"
"{\n"
"	gl_FragColor=v_color ;\n"
"}\n"
"\n"
"	]]\n"
"}\n"
"	gl.shaders.f_color_discard={\n"
"	source=gl.defines.shaderprefix..[[\n"
"\n"
"varying vec4  v_color;\n"
"\n"
"void main(void)\n"
"{\n"
"	gl_FragColor=v_color ;\n"
"	if((gl_FragColor.a)<0.25) discard;\n"
"}\n"
"\n"
"	]]\n"
"}\n"
"	gl.shaders.v_pos_normal={\n"
"	source=gl.defines.shaderprefix..[[\n"
"\n"
"uniform mat4 modelview;\n"
"uniform mat4 projection;\n"
"uniform vec4 color;\n"
"\n"
"attribute vec3 a_vertex;\n"
"attribute vec3 a_normal;\n"
"\n"
"varying vec4  v_color;\n"
"varying vec3  v_normal;\n"
"varying vec3  v_pos;\n"
" \n"
"void main()\n"
"{\n"
"    gl_Position = projection * modelview * vec4(a_vertex, 1.0);\n"
"    v_normal = normalize( mat3( modelview ) * a_normal );\n"
"	v_color=color;\n"
"}\n"
"\n"
"	]]\n"
"}\n"
"\n"
"	gl.shaders.v_pos_normal_tex={\n"
"	source=gl.defines.shaderprefix..[[\n"
"\n"
"uniform mat4 modelview;\n"
"uniform mat4 projection;\n"
"uniform vec4 color;\n"
"\n"
"attribute vec3 a_vertex;\n"
"attribute vec3 a_normal;\n"
"attribute vec2 a_texcoord;\n"
"\n"
"varying vec4  v_color;\n"
"varying vec3  v_normal;\n"
"varying vec3  v_pos;\n"
"varying vec2  v_texcoord;\n"
" \n"
"void main()\n"
"{\n"
"    gl_Position = projection * modelview * vec4(a_vertex, 1.0);\n"
"    v_normal = normalize( mat3( modelview ) * a_normal );\n"
"	v_texcoord=a_texcoord;\n"
"	v_color=color;\n"
"}\n"
"\n"
"	]]\n"
"}\n"
"\n"
"	gl.shaders.f_phong={\n"
"	source=gl.defines.shaderprefix..[[\n"
"\n"
"varying vec4  v_color;\n"
"varying vec3  v_normal;\n"
"varying vec3  v_pos;\n"
"\n"
"\n"
"vec3 d=vec3(0,0,-1);\n"
"\n"
"void main(void)\n"
"{\n"
"	vec3 n=normalize(v_normal);\n"
"	gl_FragColor= v_color*max( -n.z, 0.25 );\n"
"}\n"
"\n"
"	]]\n"
"}\n"
"\n"
"	gl.programs.pos_normal={\n"
"		vshaders={\"v_pos_normal\"},\n"
"		fshaders={\"f_phong\"},\n"
"	}\n"
"	gl.programs.pos_color={\n"
"		vshaders={\"v_pos_color\"},\n"
"		fshaders={\"f_color\"},\n"
"	}\n"
"	gl.programs.pos_color_discard={\n"
"		vshaders={\"v_pos_color\"},\n"
"		fshaders={\"f_color_discard\"},\n"
"	}\n"
"	gl.programs.pos_tex={\n"
"		vshaders={\"v_pos_tex\"},\n"
"		fshaders={\"f_tex\"},\n"
"	}\n"
"	gl.programs.pos_tex_discard={\n"
"		vshaders={\"v_pos_tex\"},\n"
"		fshaders={\"f_tex_discard\"},\n"
"	}\n"
"	gl.programs.pos_tex_color={\n"
"		vshaders={\"v_pos_tex_color\"},\n"
"		fshaders={\"f_tex\"},\n"
"	}\n"
"	gl.programs.pos_tex_color_discard={\n"
"		vshaders={\"v_pos_tex_color\"},\n"
"		fshaders={\"f_tex_discard\"},\n"
"	}\n"
"	gl.programs.pos={\n"
"		vshaders={\"v_pos\"},\n"
"		fshaders={\"f_color\"},\n"
"	}\n"
"	gl.programs.pos_discard={\n"
"		vshaders={\"v_pos\"},\n"
"		fshaders={\"f_color_discard\"},\n"
"	}\n"
"\n"
"-- we have mostly squirted extra stuff into oven.gl\n"
"\n"
"	return gles\n"
"\n"
"end\n"
"",

"wetgenes.gamecake.mods.keys","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"local gcinfo=gcinfo\r\n"
"\r\n"
"local hex=function(str) return tonumber(str,16) end\r\n"
"\r\n"
"local pack=require(\"wetgenes.pack\")\r\n"
"local wzips=require(\"wetgenes.zips\")\r\n"
"\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"local tardis=require(\"wetgenes.tardis\")	-- matrix/vector math\r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"\r\n"
"local import=[[\r\n"
"\r\n"
"#define VK_LBUTTON	1\r\n"
"#define VK_RBUTTON	2\r\n"
"#define VK_CANCEL	3\r\n"
"#define VK_MBUTTON	4\r\n"
"#if (_WIN32_WINNT >= 0x0500)\r\n"
"#define VK_XBUTTON1	5\r\n"
"#define VK_XBUTTON2	6\r\n"
"#endif\r\n"
"#define VK_BACK	8\r\n"
"#define VK_TAB	9\r\n"
"\r\n"
"#define VK_ENTER	10\r\n"
"\r\n"
"#define VK_CLEAR	12\r\n"
"#define VK_RETURN	13\r\n"
"#define VK_SHIFT	16\r\n"
"#define VK_CONTROL	17\r\n"
"#define VK_MENU	18\r\n"
"#define VK_PAUSE	19\r\n"
"#define VK_CAPITAL	20\r\n"
"#define VK_KANA	0x15\r\n"
"#define VK_HANGEUL	0x15\r\n"
"#define VK_HANGUL	0x15\r\n"
"#define VK_JUNJA	0x17\r\n"
"#define VK_FINAL	0x18\r\n"
"#define VK_HANJA	0x19\r\n"
"#define VK_KANJI	0x19\r\n"
"#define VK_ESCAPE	0x1B\r\n"
"#define VK_CONVERT	0x1C\r\n"
"#define VK_NONCONVERT	0x1D\r\n"
"#define VK_ACCEPT	0x1E\r\n"
"#define VK_MODECHANGE	0x1F\r\n"
"#define VK_SPACE	32\r\n"
"#define VK_PRIOR	33\r\n"
"#define VK_NEXT	34\r\n"
"#define VK_END	35\r\n"
"#define VK_HOME	36\r\n"
"#define VK_LEFT	37\r\n"
"#define VK_UP	38\r\n"
"#define VK_RIGHT	39\r\n"
"#define VK_DOWN	40\r\n"
"#define VK_SELECT	41\r\n"
"#define VK_PRINT	42\r\n"
"#define VK_EXECUTE	43\r\n"
"#define VK_SNAPSHOT	44\r\n"
"#define VK_INSERT	45\r\n"
"#define VK_DELETE	46\r\n"
"#define VK_HELP	47\r\n"
"#define VK_LWIN	0x5B\r\n"
"#define VK_RWIN	0x5C\r\n"
"#define VK_APPS	0x5D\r\n"
"#define VK_SLEEP	0x5F\r\n"
"#define VK_NUMPAD0	0x60\r\n"
"#define VK_NUMPAD1	0x61\r\n"
"#define VK_NUMPAD2	0x62\r\n"
"#define VK_NUMPAD3	0x63\r\n"
"#define VK_NUMPAD4	0x64\r\n"
"#define VK_NUMPAD5	0x65\r\n"
"#define VK_NUMPAD6	0x66\r\n"
"#define VK_NUMPAD7	0x67\r\n"
"#define VK_NUMPAD8	0x68\r\n"
"#define VK_NUMPAD9	0x69\r\n"
"#define VK_MULTIPLY	0x6A\r\n"
"#define VK_ADD	0x6B\r\n"
"#define VK_SEPARATOR	0x6C\r\n"
"#define VK_SUBTRACT	0x6D\r\n"
"#define VK_DECIMAL	0x6E\r\n"
"#define VK_DIVIDE	0x6F\r\n"
"#define VK_F1	0x70\r\n"
"#define VK_F2	0x71\r\n"
"#define VK_F3	0x72\r\n"
"#define VK_F4	0x73\r\n"
"#define VK_F5	0x74\r\n"
"#define VK_F6	0x75\r\n"
"#define VK_F7	0x76\r\n"
"#define VK_F8	0x77\r\n"
"#define VK_F9	0x78\r\n"
"#define VK_F10	0x79\r\n"
"#define VK_F11	0x7A\r\n"
"#define VK_F12	0x7B\r\n"
"#define VK_F13	0x7C\r\n"
"#define VK_F14	0x7D\r\n"
"#define VK_F15	0x7E\r\n"
"#define VK_F16	0x7F\r\n"
"#define VK_F17	0x80\r\n"
"#define VK_F18	0x81\r\n"
"#define VK_F19	0x82\r\n"
"#define VK_F20	0x83\r\n"
"#define VK_F21	0x84\r\n"
"#define VK_F22	0x85\r\n"
"#define VK_F23	0x86\r\n"
"#define VK_F24	0x87\r\n"
"#define VK_NUMLOCK	0x90\r\n"
"#define VK_SCROLL	0x91\r\n"
"#define VK_LSHIFT	0xA0\r\n"
"#define VK_RSHIFT	0xA1\r\n"
"#define VK_LCONTROL	0xA2\r\n"
"#define VK_RCONTROL	0xA3\r\n"
"#define VK_LMENU	0xA4\r\n"
"#define VK_RMENU	0xA5\r\n"
"#if (_WIN32_WINNT >= 0x0500)\r\n"
"#define VK_BROWSER_BACK	0xA6\r\n"
"#define VK_BROWSER_FORWARD	0xA7\r\n"
"#define VK_BROWSER_REFRESH	0xA8\r\n"
"#define VK_BROWSER_STOP	0xA9\r\n"
"#define VK_BROWSER_SEARCH	0xAA\r\n"
"#define VK_BROWSER_FAVORITES	0xAB\r\n"
"#define VK_BROWSER_HOME	0xAC\r\n"
"#define VK_VOLUME_MUTE	0xAD\r\n"
"#define VK_VOLUME_DOWN	0xAE\r\n"
"#define VK_VOLUME_UP	0xAF\r\n"
"#define VK_MEDIA_NEXT_TRACK	0xB0\r\n"
"#define VK_MEDIA_PREV_TRACK	0xB1\r\n"
"#define VK_MEDIA_STOP	0xB2\r\n"
"#define VK_MEDIA_PLAY_PAUSE	0xB3\r\n"
"#define VK_LAUNCH_MAIL	0xB4\r\n"
"#define VK_LAUNCH_MEDIA_SELECT	0xB5\r\n"
"#define VK_LAUNCH_APP1	0xB6\r\n"
"#define VK_LAUNCH_APP2	0xB7\r\n"
"#endif\r\n"
"#define VK_OEM_1	0xBA\r\n"
"#if (_WIN32_WINNT >= 0x0500)\r\n"
"#define VK_OEM_PLUS	0xBB\r\n"
"#define VK_OEM_COMMA	0xBC\r\n"
"#define VK_OEM_MINUS	0xBD\r\n"
"#define VK_OEM_PERIOD	0xBE\r\n"
"#endif\r\n"
"#define VK_OEM_2	0xBF\r\n"
"#define VK_OEM_3	0xC0\r\n"
"#define VK_OEM_4	0xDB\r\n"
"#define VK_OEM_5	0xDC\r\n"
"#define VK_OEM_6	0xDD\r\n"
"#define VK_OEM_7	0xDE\r\n"
"#define VK_OEM_8	0xDF\r\n"
"#if (_WIN32_WINNT >= 0x0500)\r\n"
"#define VK_OEM_102	0xE2\r\n"
"#endif\r\n"
"#define VK_PROCESSKEY	0xE5\r\n"
"#if (_WIN32_WINNT >= 0x0500)\r\n"
"#define VK_PACKET	0xE7\r\n"
"#endif\r\n"
"#define VK_ATTN	0xF6\r\n"
"#define VK_CRSEL	0xF7\r\n"
"#define VK_EXSEL	0xF8\r\n"
"#define VK_EREOF	0xF9\r\n"
"#define VK_PLAY	0xFA\r\n"
"#define VK_ZOOM	0xFB\r\n"
"#define VK_NONAME	0xFC\r\n"
"#define VK_PA1	0xFD\r\n"
"#define VK_OEM_CLEAR	0xFE\r\n"
"\r\n"
"#define VK_0 0x30\r\n"
"#define VK_1 0x31\r\n"
"#define VK_2 0x32\r\n"
"#define VK_3 0x33\r\n"
"#define VK_4 0x34\r\n"
"#define VK_5 0x35\r\n"
"#define VK_6 0x36\r\n"
"#define VK_7 0x37\r\n"
"#define VK_8 0x38\r\n"
"#define VK_9 0x39\r\n"
"\r\n"
"#define VK_A 0x41\r\n"
"#define VK_B 0x42\r\n"
"#define VK_C 0x43\r\n"
"#define VK_D 0x44\r\n"
"#define VK_E 0x45\r\n"
"#define VK_F 0x46\r\n"
"#define VK_G 0x47\r\n"
"#define VK_H 0x48\r\n"
"#define VK_I 0x49\r\n"
"#define VK_J 0x4A\r\n"
"#define VK_K 0x4B\r\n"
"#define VK_L 0x4C\r\n"
"#define VK_M 0x4D\r\n"
"#define VK_N 0x4E\r\n"
"#define VK_O 0x4F\r\n"
"#define VK_P 0x50\r\n"
"#define VK_Q 0x51\r\n"
"#define VK_R 0x52\r\n"
"#define VK_S 0x53\r\n"
"#define VK_T 0x54\r\n"
"#define VK_U 0x55\r\n"
"#define VK_V 0x56\r\n"
"#define VK_W 0x57\r\n"
"#define VK_X 0x58\r\n"
"#define VK_Y 0x59\r\n"
"#define VK_Z 0x5A\r\n"
"\r\n"
"]]\r\n"
"\r\n"
"local vkeys={}\r\n"
"local VK=vkeys\r\n"
"\r\n"
"for l in import:gmatch(\"([^\\n"
"]*)\") do\r\n"
"	local define,value\r\n"
"	local state=\"start\"\r\n"
"	for w in l:gmatch(\"([^%s]+)\") do\r\n"
"		if state==\"start\" then\r\n"
"			if w==\"#define\" then\r\n"
"				state=\"define\"\r\n"
"			else\r\n"
"				break\r\n"
"			end\r\n"
"		elseif state==\"define\" then\r\n"
"			define=w\r\n"
"			state=\"value\"\r\n"
"		elseif state==\"value\" then\r\n"
"			value=w\r\n"
"				if define:sub(1,3)==\"VK_\" then -- sanity check\r\n"
"					define=define:sub(4)\r\n"
"					\r\n"
"					if value:sub(1,3)==\"VK_\" then -- allow lookback\r\n"
"						value=vkeys[value:sub(4)]\r\n"
"					end\r\n"
"					\r\n"
"					vkeys[define]=tonumber(value)\r\n"
"				end\r\n"
"			break\r\n"
"		else\r\n"
"			break\r\n"
"		end\r\n"
"	end\r\n"
"end\r\n"
"local nkeys={}\r\n"
"for v,n in pairs(vkeys) do\r\n"
"	nkeys[n]=v\r\n"
"end\r\n"
"\r\n"
"import=nil -- free it just because\r\n"
"\r\n"
"-- basic american keyboard mappings\r\n"
"local map_vkeys={\r\n"
"\r\n"
"[0x29]=VK.OEM_3, -- tilde\r\n"
"[0x02]=VK[\"1\"],\r\n"
"[0x03]=VK[\"2\"],\r\n"
"[0x04]=VK[\"3\"],\r\n"
"[0x05]=VK[\"4\"],\r\n"
"[0x06]=VK[\"5\"],\r\n"
"[0x07]=VK[\"6\"],\r\n"
"[0x08]=VK[\"7\"],\r\n"
"[0x09]=VK[\"8\"],\r\n"
"[0x0a]=VK[\"9\"],\r\n"
"[0x0b]=VK[\"0\"],\r\n"
"[0x0c]=VK.OEM_MINUS, -- -\r\n"
"[0x0d]=VK.OEM_PLUS,  -- =\r\n"
"[0x10]=VK.Q,\r\n"
"[0x11]=VK.W,\r\n"
"[0x12]=VK.E,\r\n"
"[0x13]=VK.R,\r\n"
"[0x14]=VK.T,\r\n"
"[0x15]=VK.Y,\r\n"
"[0x16]=VK.U,\r\n"
"[0x17]=VK.I,\r\n"
"[0x18]=VK.O,\r\n"
"[0x19]=VK.P,\r\n"
"[0x1a]=VK.OEM_4,\r\n"
"[0x1b]=VK.OEM_6,\r\n"
"[0x2b]=VK.OEM_5,\r\n"
"[0x1e]=VK.A,\r\n"
"[0x1f]=VK.S,\r\n"
"[0x20]=VK.D,\r\n"
"[0x21]=VK.F,\r\n"
"[0x22]=VK.G,\r\n"
"[0x23]=VK.H,\r\n"
"[0x24]=VK.J,\r\n"
"[0x25]=VK.K,\r\n"
"[0x26]=VK.L,\r\n"
"[0x27]=VK.OEM_1,\r\n"
"[0x28]=VK.OEM_7,\r\n"
"[0x2c]=VK.Z,\r\n"
"[0x2d]=VK.X,\r\n"
"[0x2e]=VK.C,\r\n"
"[0x2f]=VK.V,\r\n"
"[0x30]=VK.B,\r\n"
"[0x31]=VK.N,\r\n"
"[0x32]=VK.M,\r\n"
"[0x33]=VK.OEM_COMMA,\r\n"
"[0x34]=VK.OEM_PERIOD,\r\n"
"[0x35]=VK.OEM_2,\r\n"
"[0x56]=VK.OEM_102,\r\n"
"[0x53]=VK.DECIMAL,\r\n"
"\r\n"
"[0x01]=VK.ESCAPE,\r\n"
"[0x0e]=VK.BACK,\r\n"
"[0x0f]=VK.TAB,\r\n"
"[0x1c]=VK.ENTER,\r\n"
"[0x1d]=VK.LCTRL,\r\n"
"[0x2a]=VK.LSHIFT,\r\n"
"[0x36]=VK.RSHIFT,\r\n"
"[0x37]=VK.MULTIPLY,\r\n"
"[0x38]=VK.LALT,\r\n"
"[0x39]=VK.SPACE,\r\n"
"[0x3a]=VK.CAPITAL,\r\n"
"[0x3b]=VK.F1,\r\n"
"[0x3c]=VK.F2,\r\n"
"[0x3d]=VK.F3,\r\n"
"[0x3e]=VK.F4,\r\n"
"[0x3f]=VK.F5,\r\n"
"[0x40]=VK.F6,\r\n"
"[0x41]=VK.F7,\r\n"
"[0x42]=VK.F8,\r\n"
"[0x43]=VK.F9,\r\n"
"[0x44]=VK.F10,\r\n"
"[0x45]=VK.PAUSE,\r\n"
"[0x46]=VK.SCROLL,\r\n"
"[0x47]=VK.NUMPAD7,\r\n"
"[0x48]=VK.NUMPAD8,\r\n"
"[0x49]=VK.NUMPAD9,\r\n"
"[0x4a]=VK.SUBTRACT,\r\n"
"[0x4b]=VK.NUMPAD4,\r\n"
"[0x4c]=VK.NUMPAD5,\r\n"
"[0x4d]=VK.NUMPAD6,\r\n"
"[0x4e]=VK.ADD,\r\n"
"[0x4f]=VK.NUMPAD1,\r\n"
"[0x50]=VK.NUMPAD2,\r\n"
"[0x51]=VK.NUMPAD3,\r\n"
"[0x52]=VK.NUMPAD0,\r\n"
"[0x53]=VK.DELETE,\r\n"
"--[0x54]=VK.Sys Req,\r\n"
"[0x57]=VK.F11,\r\n"
"[0x58]=VK.F12,\r\n"
"[0x61]=VK.RCTRL,\r\n"
"[0x64]=VK.RALT,\r\n"
"[0x7c]=VK.F13,\r\n"
"[0x7d]=VK.F14,\r\n"
"[0x7e]=VK.F15,\r\n"
"[0x7f]=VK.F16,\r\n"
"[0x80]=VK.F17,\r\n"
"[0x81]=VK.F18,\r\n"
"[0x82]=VK.F19,\r\n"
"[0x83]=VK.F20,\r\n"
"[0x84]=VK.F21,\r\n"
"[0x85]=VK.F22,\r\n"
"[0x86]=VK.F23,\r\n"
"[0x87]=VK.F24,\r\n"
"\r\n"
"[28]=VK.RETURN,\r\n"
"[96]=VK.ENTER,\r\n"
"[111]=VK.DELETE,\r\n"
"[103]=VK.UP,\r\n"
"[108]=VK.DOWN,\r\n"
"[105]=VK.LEFT,\r\n"
"[106]=VK.RIGHT,\r\n"
"\r\n"
"\r\n"
"--125 left windows\r\n"
"--127 right menu\r\n"
"\r\n"
"}\r\n"
"\r\n"
"local map_ascii={\r\n"
"\r\n"
"[VK.A]={\"a\",\"A\",\"A\"},\r\n"
"[VK.B]={\"b\",\"B\",\"B\"},\r\n"
"[VK.C]={\"c\",\"C\",\"C\"},\r\n"
"[VK.D]={\"d\",\"D\",\"D\"},\r\n"
"[VK.E]={\"e\",\"E\",\"E\"},\r\n"
"[VK.F]={\"f\",\"F\",\"F\"},\r\n"
"[VK.G]={\"g\",\"G\",\"G\"},\r\n"
"[VK.H]={\"h\",\"H\",\"H\"},\r\n"
"[VK.I]={\"i\",\"I\",\"I\"},\r\n"
"[VK.J]={\"j\",\"J\",\"J\"},\r\n"
"[VK.K]={\"k\",\"K\",\"K\"},\r\n"
"[VK.L]={\"l\",\"L\",\"L\"},\r\n"
"[VK.M]={\"m\",\"M\",\"M\"},\r\n"
"[VK.N]={\"n\",\"N\",\"N\"},\r\n"
"[VK.O]={\"o\",\"O\",\"O\"},\r\n"
"[VK.P]={\"p\",\"P\",\"P\"},\r\n"
"[VK.Q]={\"q\",\"Q\",\"Q\"},\r\n"
"[VK.R]={\"r\",\"R\",\"R\"},\r\n"
"[VK.S]={\"s\",\"S\",\"S\"},\r\n"
"[VK.T]={\"t\",\"T\",\"T\"},\r\n"
"[VK.U]={\"u\",\"U\",\"U\"},\r\n"
"[VK.V]={\"v\",\"V\",\"V\"},\r\n"
"[VK.W]={\"w\",\"W\",\"W\"},\r\n"
"[VK.X]={\"x\",\"X\",\"X\"},\r\n"
"[VK.Y]={\"y\",\"Y\",\"Y\"},\r\n"
"[VK.Z]={\"z\",\"Z\",\"Z\"},\r\n"
"\r\n"
"[ VK[\"1\"] ]={\"1\",\"!\"},\r\n"
"[ VK[\"2\"] ]={\"2\",\"@\"},\r\n"
"[ VK[\"3\"] ]={\"3\",\"#\"},\r\n"
"[ VK[\"4\"] ]={\"4\",\"$\"},\r\n"
"[ VK[\"5\"] ]={\"5\",\"%\"},\r\n"
"[ VK[\"6\"] ]={\"6\",\"^\"},\r\n"
"[ VK[\"7\"] ]={\"7\",\"&\"},\r\n"
"[ VK[\"8\"] ]={\"8\",\"*\"},\r\n"
"[ VK[\"9\"] ]={\"9\",\"(\"},\r\n"
"[ VK[\"0\"] ]={\"0\",\")\"},\r\n"
"\r\n"
"[VK.OEM_MINUS]={\"-\",\"_\"},\r\n"
"[VK.OEM_PLUS]={\"=\",\"+\"},\r\n"
"\r\n"
"[VK.TAB]={\"\\t\",\"\\t\"},\r\n"
"\r\n"
"[VK.OEM_4]={\"[\",\"{\"},\r\n"
"[VK.OEM_6]={\"]\",\"}\"},\r\n"
"\r\n"
"[VK.OEM_1]={\";\",\":\"},\r\n"
"[VK.OEM_7]={\"'\",\"\\\"\"},\r\n"
"[VK.OEM_5]={\"\\\\\",\"|\"},\r\n"
"\r\n"
"[VK.OEM_102]={\"<\",\">\"},\r\n"
"\r\n"
"[VK.OEM_COMMA]={\",\",\"<\"},\r\n"
"[VK.OEM_PERIOD]={\".\",\">\"},\r\n"
"[VK.OEM_2]={\"/\",\"?\"},\r\n"
"\r\n"
"[VK.SPACE]={\" \",\" \"},\r\n"
"\r\n"
"}\r\n"
"\r\n"
"\r\n"
"\r\n"
"function M.bake(oven,keys)\r\n"
"\r\n"
"	keys=keys or {}\r\n"
"\r\n"
"	local win=oven.win\r\n"
"	local cake=oven.cake\r\n"
"	local canvas=cake.canvas\r\n"
"	local layout=oven.rebake(\"wetgenes.gamecake.mods.layout\").keys\r\n"
"\r\n"
"	if win.flavour==\"raspi\" then\r\n"
"		keys.posix=true -- auto translate posix msgs\r\n"
"	end\r\n"
"\r\n"
"	keys.caps=false\r\n"
"	keys.shift=false\r\n"
"\r\n"
"-- push a keyboard widget into a master\r\n"
"	function keys.setup_keyboard_widgets(master)\r\n"
"		local shift=false\r\n"
"		local top\r\n"
"		local hooks={}\r\n"
"		function hooks.click(widget)\r\n"
"--	print(widget.id)\r\n"
"			local ascii=widget.text\r\n"
"			local code=0\r\n"
"			local name=\"\"\r\n"
"			\r\n"
"			if ascii==\"<\" then\r\n"
"				ascii=\"\"\r\n"
"				code=0\r\n"
"				name=\"back\"\r\n"
"			elseif ascii==\">\" then\r\n"
"				ascii=\"\"\r\n"
"				code=0\r\n"
"				name=\"delete\"\r\n"
"			elseif ascii==\"^\" then -- toggle caps\r\n"
"			\r\n"
"				shift=not shift\r\n"
"			\r\n"
"				for i,t in ipairs(top) do -- each row of keys\r\n"
"					for i,v in ipairs(t) do -- each key\r\n"
"					\r\n"
"						local otext=v.text\r\n"
"						local ntext\r\n"
"						if otext then\r\n"
"							if shift then\r\n"
"								ntext=string.upper(otext)\r\n"
"							else\r\n"
"								ntext=string.lower(otext)\r\n"
"							end\r\n"
"							if otext~=ntext then\r\n"
"								v.text=ntext\r\n"
"								v:set_dirty()\r\n"
"							end\r\n"
"						end\r\n"
"					end\r\n"
"				end\r\n"
"				\r\n"
"				return\r\n"
"\r\n"
"			end\r\n"
"			\r\n"
"			local mstack=oven.win.msgstack\r\n"
"			mstack[#mstack+1]={\r\n"
"				time=os.time(),\r\n"
"				class=\"key\",\r\n"
"				action=1,\r\n"
"				ascii=ascii,\r\n"
"				keycode=code,\r\n"
"				keyname=name,\r\n"
"			}\r\n"
"			mstack[#mstack+1]={\r\n"
"				time=os.time(),\r\n"
"				class=\"key\",\r\n"
"				action=-1,\r\n"
"				ascii=ascii,\r\n"
"				keycode=code,\r\n"
"				keyname=name,\r\n"
"			}\r\n"
"			\r\n"
"		end\r\n"
"\r\n"
"		master:clean_all()\r\n"
"		master.ids={}\r\n"
"\r\n"
"		top=master:add({hx=320,hy=160,class=\"fill\",fbo=true})\r\n"
"\r\n"
"		local function key_line(ks)\r\n"
"			local t=top:add({hx=320,hy=32,class=\"fill\"})\r\n"
"			for i=1,#ks do\r\n"
"				local k=ks:sub(i,i)\r\n"
"				t:add({hx=320/10,hy=32,color=0xffcccccc,text=k,id=\"key\",hooks=hooks})\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"		key_line(\"1234567890\")\r\n"
"		key_line(\"qwertyuiop\")\r\n"
"		key_line(\"asdfghjkl \")\r\n"
"		key_line(\"^zxcvbnm:#\")\r\n"
"		key_line(\"<    _,./>\")\r\n"
"					\r\n"
"	end\r\n"
"\r\n"
"	function keys.setup()\r\n"
"	\r\n"
"\r\n"
"		keys.master=oven.rebake(\"wetgenes.gamecake.widgets\").setup({font=\"Vera\",text_size=24})\r\n"
"		\r\n"
"		keys.setup_keyboard_widgets(keys.master)\r\n"
"	\r\n"
"		keys.master:layout()\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	function keys.clean()\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	\r\n"
"\r\n"
"	function keys.update()\r\n"
"	\r\n"
"		if layout.active then\r\n"
"\r\n"
"\r\n"
"			if keys.top.hx~=layout.w or keys.top.hy~=layout.h then -- change rez\r\n"
"				keys.top.hx=layout.w\r\n"
"				keys.top.hy=layout.h\r\n"
"				\r\n"
"				keys.master.text_size=math.floor(layout.h/6)\r\n"
"				keys.master:layout()\r\n"
"			end\r\n"
"\r\n"
"			keys.master:update()\r\n"
"		\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	function keys.draw()\r\n"
"	\r\n"
"		local win=oven.win\r\n"
"		local cake=oven.cake\r\n"
"		local gl=cake.gl\r\n"
"		local font=canvas.font\r\n"
"\r\n"
"		if layout.active then\r\n"
"\r\n"
"		layout.apply()\r\n"
"--		layout.viewport() -- did our window change?\r\n"
"--		layout.project23d(layout.w,layout.h,1/4,layout.h*4)\r\n"
"		canvas.gl_default() -- reset gl state\r\n"
"\r\n"
"--		gl.MatrixMode(gl.PROJECTION)\r\n"
"--		gl.LoadMatrix( layout.pmtx )\r\n"
"\r\n"
"--		gl.MatrixMode(gl.MODELVIEW)\r\n"
"--		gl.LoadIdentity()\r\n"
"--		gl.Translate(-layout.w/2,-layout.h/2,-layout.h*2) -- top left corner is origin\r\n"
"		gl.PushMatrix()\r\n"
"\r\n"
"\r\n"
"		keys.master:draw()\r\n"
"			\r\n"
"		gl.PopMatrix()\r\n"
"\r\n"
"		end\r\n"
"\r\n"
"		\r\n"
"	end\r\n"
"		\r\n"
"	function keys.msg(m)\r\n"
"	\r\n"
"		if keys.posix then -- posix translation enabled\r\n"
"			if m.class==\"posix_keyboard\" then -- re jiggle to a normal key msg\r\n"
"			\r\n"
"				if m.type==17 and m.code==1 and m.value==1 then keys.caps=false end -- reset caps\r\n"
"				if m.type~=1 then return nil end -- ignore\r\n"
"\r\n"
"				local v=map_vkeys[m.code] or 0\r\n"
"\r\n"
"--print(\"pkey\",m.type,m.code,m.value,v)\r\n"
"\r\n"
"				local act=0\r\n"
"				if m.value==0 then act=-1 end\r\n"
"				if m.value==1 then act= 1 end\r\n"
"\r\n"
"				if v==VK.CAPITAL and act==-1 then -- caps toggle\r\n"
"					keys.caps=not keys.caps\r\n"
"				end\r\n"
"				if v==VK.LSHIFT or v==VK.RSHIFT then -- shift\r\n"
"					if act==1 then\r\n"
"						keys.shift=true\r\n"
"					elseif act==-1 then\r\n"
"						keys.shift=false\r\n"
"					end\r\n"
"				end\r\n"
"				\r\n"
"				local n=nkeys[v]\r\n"
"				local asc=map_ascii[v or 0]\r\n"
"				\r\n"
"				if asc then -- handle caps and shift lookup\r\n"
"					local ai=1\r\n"
"					if keys.caps and asc[3] then ai=3 end -- caps\r\n"
"					if keys.shift then -- shift\r\n"
"						if ai==1 and asc[2] then ai=2 else ai=1 end\r\n"
"					end\r\n"
"					asc=asc[ai] -- finaly pick the ascii\r\n"
"				end\r\n"
"\r\n"
"				win:push_msg{time=os.time(),class=\"key\",action=act,keycode=v,ascii=asc or \"\",keyname=n or \"unknown\"}\r\n"
"			\r\n"
"				return nil -- delete msg\r\n"
"			end\r\n"
"		end\r\n"
"	\r\n"
"		if layout.active then\r\n"
"			if m.xraw and m.yraw then	-- we need to fix raw x,y numbers\r\n"
"				m.x,m.y=canvas.xyscale(m.xraw,m.yraw)	-- local coords, 0,0 is center of screen\r\n"
"				m.x=m.x+(layout.w/2)\r\n"
"				m.y=m.y+(layout.h/2)\r\n"
"			end\r\n"
"			keys.master:msg(m)\r\n"
"		end\r\n"
"		return m\r\n"
"		\r\n"
"	end\r\n"
"\r\n"
"-- turn a joystick msg into a key name or nil\r\n"
"-- this works on all axis inputs (bigest movement is chosen)\r\n"
"	function keys.joystick_msg_to_key(m)\r\n"
"		if m.class==\"joystick\" then\r\n"
"			local d=1/8\r\n"
"			local t,vx,vy\r\n"
"			local tt,vxx,vyy\r\n"
"			local nox,noy\r\n"
"\r\n"
"			vx=m.lx		vxx=m.lx*m.lx				\r\n"
"			t=m.rx		tt=t*t			if tt>vxx then vx=t vxx=tt end\r\n"
"			t=m.dx		tt=t*t			if tt>vxx then vx=t vxx=tt end\r\n"
"\r\n"
"			vy=m.ly		vyy=m.ly*m.ly				\r\n"
"			t=m.ry		tt=t*t			if tt>vyy then vy=t vyy=tt end\r\n"
"			t=m.dy		tt=t*t			if tt>vyy then vy=t vyy=tt end\r\n"
"		\r\n"
"			if vxx/2 > vyy then noy=true end\r\n"
"			if vyy/2 > vxx then nox=true end\r\n"
"			\r\n"
"			if not nox then\r\n"
"				if     vx>d		then	return \"right\"\r\n"
"				elseif vx<-d 	then	return \"left\"\r\n"
"				end\r\n"
"			end\r\n"
"\r\n"
"			if not noy then\r\n"
"				if    	vy>d 	then	return \"down\"\r\n"
"				elseif	vy<-d 	then	return \"up\"\r\n"
"				end\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"-- as above but this works on given axis values, expected to be +-1 range\r\n"
"	function keys.joystick_axis_to_key(vx,vy)\r\n"
"		local d=1/8\r\n"
"		local vxx,vyy\r\n"
"		local nox,noy\r\n"
"		\r\n"
"		vxx=vx*vx				\r\n"
"		vyy=vy*vy				\r\n"
"\r\n"
"		if vxx/2 > vyy then noy=true end\r\n"
"		if vyy/2 > vxx then nox=true end\r\n"
"		\r\n"
"		if not nox then\r\n"
"			if     vx>d		then	return \"right\"\r\n"
"			elseif vx<-d 	then	return \"left\"\r\n"
"			end\r\n"
"		end\r\n"
"\r\n"
"		if not noy then\r\n"
"			if    	vy>d 	then	return \"down\"\r\n"
"			elseif	vy<-d 	then	return \"up\"\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	return keys\r\n"
"end\r\n"
"",

"wetgenes.gamecake.widgets.button","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,wbutton)\r\n"
"wbutton=wbutton or {}\r\n"
"\r\n"
"\r\n"
"function wbutton.mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wbutton.key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wbutton.update(widget)\r\n"
"\r\n"
"	if widget.data then\r\n"
"		widget.text=widget.data:get_string()\r\n"
"	end\r\n"
"\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function wbutton.draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wbutton.setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.button=it\r\n"
"	widget.class=\"button\"\r\n"
"	\r\n"
"	widget.key=key\r\n"
"	widget.mouse=mouse\r\n"
"	widget.update=update\r\n"
"	widget.draw=draw\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"\r\n"
"return wbutton\r\n"
"end\r\n"
"",

"wetgenes.zips","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"-- handle zip files containing lua code and data\r\n"
"\r\n"
"local zip=require(\"zip\")\r\n"
"\r\n"
"\r\n"
"module(\"wetgenes.zips\")\r\n"
"\r\n"
"files={} -- zip files for loader to search\r\n"
"\r\n"
"-- prefix to use when io.opening \r\n"
"ioprefix=\"\"\r\n"
"\r\n"
"\r\n"
"-- convert a sensible name into something we can store in an apk\r\n"
"-- no directorys and most chars are illegal, we just convert them to _\r\n"
"-- and look in the raw directory, this is a one way destructive function.\r\n"
"-- the returned filename can then be checkedfor in the apk\r\n"
"function apk_munge_filename(s)\r\n"
"\r\n"
"	local r=string.lower(s)\r\n"
"\r\n"
"	r=string.gsub(r,\"([^a-z0-9%_]+)\",\"_\") -- replace most everything with an underscore\r\n"
"\r\n"
"	return \"res/raw/\"..r\r\n"
"end\r\n"
"\r\n"
"--\r\n"
"-- add a zipfile to the end of places to search and return it\r\n"
"-- so we can add more options ifwe need to\r\n"
"--\r\n"
"function add_zip_file(fname,t)\r\n"
"	t=t or {}\r\n"
"	\r\n"
"	t.fname=fname\r\n"
"	t.z=zip.open(fname) -- open the file for later use\r\n"
"		\r\n"
"	files[#files+1]=t\r\n"
"	return t\r\n"
"end\r\n"
"--\r\n"
"-- Like add zip but with a munger as apk files are retarded\r\n"
"--\r\n"
"function add_apk_file(fname,t)\r\n"
"	t=t or {}\r\n"
"	t.munge=apk_munge_filename\r\n"
"	return add_zip_file(fname,t)\r\n"
"end\r\n"
"--\r\n"
"-- add a zipfile (already read into memory) to the end of places to search and return it\r\n"
"-- so we can add more options if we need to\r\n"
"--\r\n"
"function add_zip_data(mem,t)\r\n"
"	t=t or {}\r\n"
"	\r\n"
"	t.fname=\"**data**\"\r\n"
"	t.mem=mem -- do not garbagecollect this value...\r\n"
"	t.z=zip.open_mem(mem) -- the file exists in memory only\r\n"
"		\r\n"
"	files[#files+1]=t\r\n"
"	return t\r\n"
"end\r\n"
"\r\n"
"--\r\n"
"-- this is inserted into the package loaders to load modules from zip\r\n"
"--\r\n"
"function loader(...)\r\n"
"\r\n"
"	if not files[1] then return \"\\n"
"\\tno zips : no files to search\" end\r\n"
"\r\n"
"	local args={...}\r\n"
"	local name=args[1]\r\n"
"\r\n"
"	if not name then return \"\\n"
"\\tno zips : no module name\" end -- sanity\r\n"
"\r\n"
"	local sname=name:gsub(\"%.\",\"/\") -- replace . with /\r\n"
"	local fnames={ \"lua/\"..sname..\".lua\" , \"lua/\"..sname..\"/init.lua\" }\r\n"
"\r\n"
"	for i,v in ipairs(files) do\r\n"
"\r\n"
"		if v.z then -- this is the pre opened zipfile\r\n"
"		\r\n"
"			for i,fname in ipairs(fnames) do\r\n"
"				fname=(v.munge and v.munge(fname)) or fname -- munge the filename (apk), or just use as is?\r\n"
"				local file=v.z:open(fname)\r\n"
"				if file then\r\n"
"					local str=file:read(\"*a\")\r\n"
"					file:close()\r\n"
"					if str:sub(1,2)==\"#!\" then\r\n"
"						str=\"--\"..str -- ignore hashbang on first line\r\n"
"					end\r\n"
"					local func,err=assert(loadstring(str))\r\n"
"					return func or err\r\n"
"				end\r\n"
"			end\r\n"
"			\r\n"
"		end\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	return \"\\n"
"\\tno zips '\"..name..\"'\" -- not found\r\n"
"\r\n"
"end\r\n"
"\r\n"
"--\r\n"
"-- open the given filename\r\n"
"--\r\n"
"function open(fname)\r\n"
"	for i,v in ipairs(files) do\r\n"
"		if v.z then -- this is the pre opened zipfile\r\n"
"			local mname=(v.munge and v.munge(fname)) or fname -- munge the filename (apk), or just use as is?\r\n"
"			local file=v.z:open(mname)\r\n"
"			if file then\r\n"
"				return file\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	return io.open(ioprefix..fname,\"rb\") -- also try the filesystem\r\n"
"end\r\n"
"\r\n"
"--\r\n"
"-- read the entire file and return the data\r\n"
"--\r\n"
"function readfile(fname)\r\n"
"	local f=open(fname)\r\n"
"	if f then\r\n"
"		local d=f:read(\"*a\")\r\n"
"		f:close()\r\n"
"		return d\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"--\r\n"
"-- returns true if a file exists\r\n"
"--\r\n"
"function exists(fname)\r\n"
"	local f=open(fname)\r\n"
"	if f then\r\n"
"		f:close()\r\n"
"		return true\r\n"
"	end\r\n"
"	return false\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.gamecake.widgets.text","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,wtext)\r\n"
"wtext=wtext or {}\r\n"
"\r\n"
"function wtext.mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wtext.key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wtext.update(widget)\r\n"
"\r\n"
"	if widget.data then\r\n"
"		widget.text=widget.data:get_string()\r\n"
"	end\r\n"
"\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function wtext.draw(widget)\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wtext.setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.button=it\r\n"
"	widget.class=\"text\"\r\n"
"	\r\n"
"	widget.key=wtext.key\r\n"
"	widget.mouse=wtext.mouse\r\n"
"	widget.update=wtext.update\r\n"
"	widget.draw=wtext.draw\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"\r\n"
"return wtext\r\n"
"end\r\n"
"",

"lanes","--\n"
"-- LANES.LUA\n"
"--\n"
"-- Multithreading and -core support for Lua\n"
"--\n"
"-- Author: Asko Kauppi <akauppi@gmail.com>\n"
"--\n"
"-- History:\n"
"--    3-Dec-10  BGe: Added support to generate a lane from a string\n"
"--    Jun-08    AKa: major revise\n"
"--    15-May-07 AKa: pthread_join():less version, some speedup & ability to\n"
"--                   handle more threads (~ 8000-9000, up from ~ 5000)\n"
"--    26-Feb-07 AKa: serialization working (C side)\n"
"--    17-Sep-06 AKa: started the module (serialization)\n"
"--\n"
"--[[\n"
"===============================================================================\n"
"\n"
"Copyright (C) 2007-10 Asko Kauppi <akauppi@gmail.com>\n"
"\n"
"Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"of this software and associated documentation files (the \"Software\"), to deal\n"
"in the Software without restriction, including without limitation the rights\n"
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"copies of the Software, and to permit persons to whom the Software is\n"
"furnished to do so, subject to the following conditions:\n"
"\n"
"The above copyright notice and this permission notice shall be included in\n"
"all copies or substantial portions of the Software.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n"
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
"THE SOFTWARE.\n"
"\n"
"===============================================================================\n"
"]]--\n"
"\n"
"-- Lua 5.1: module() creates a global variable\n"
"-- Lua 5.2: module() might go away\n"
"-- almost everything module() does is done by require()\n"
"-- -> simply create a table, populate it, return it, and be done\n"
"local lanes = {}\n"
"\n"
"lanes.configure = function( _nb_keepers, _timers)\n"
"\n"
"local mm = require \"lua51-lanes\"\n"
"assert( type(mm)==\"table\" )\n"
"\n"
"-- configure() is available only the first time lua51-lanes is required process-wide, and we *must* call it to have the other functions in the interface\n"
"if mm.configure then mm.configure( _nb_keepers) end\n"
"\n"
"local thread_new = assert(mm.thread_new)\n"
"\n"
"local _single= assert(mm._single)\n"
"local _version= assert(mm._version)\n"
"\n"
"local now_secs= assert( mm.now_secs )\n"
"lanes.now_secs=now_secs\n"
"local wakeup_conv= assert( mm.wakeup_conv )\n"
"\n"
"local max_prio= assert( mm.max_prio )\n"
"\n"
"-- This check is for sublanes requiring Lanes\n"
"--\n"
"-- TBD: We could also have the C level expose 'string.gmatch' for us. But this is simpler.\n"
"--\n"
"if not string then\n"
"    error( \"To use 'lanes', you will also need to have 'string' available.\", 2 )\n"
"end\n"
"\n"
"-- \n"
"-- Cache globals for code that might run under sandboxing \n"
"--\n"
"local assert= assert\n"
"local string_gmatch= assert( string.gmatch )\n"
"local select= assert( select )\n"
"local type= assert( type )\n"
"local pairs= assert( pairs )\n"
"local tostring= assert( tostring )\n"
"local error= assert( error )\n"
"\n"
"lanes.ABOUT= \n"
"{\n"
"    author= \"Asko Kauppi <akauppi@gmail.com>\",\n"
"    description= \"Running multiple Lua states in parallel\",\n"
"    license= \"MIT/X11\",\n"
"    copyright= \"Copyright (c) 2007-10, Asko Kauppi\",\n"
"    version= _version,\n"
"}\n"
"\n"
"\n"
"-- Making copies of necessary system libs will pass them on as upvalues;\n"
"-- only the first state doing \"require 'lanes'\" will need to have 'string'\n"
"-- and 'table' visible.\n"
"--\n"
"local function WR(str)\n"
"    io.stderr:write( str..\"\\n"
"\" )\n"
"end\n"
"\n"
"local function DUMP( tbl )\n"
"    if not tbl then return end\n"
"    local str=\"\"\n"
"    for k,v in pairs(tbl) do\n"
"        str= str..k..\"=\"..tostring(v)..\"\\n"
"\"\n"
"    end\n"
"    WR(str)\n"
"end\n"
"\n"
"\n"
"---=== Laning ===---\n"
"\n"
"-- lane_h[1..n]: lane results, same as via 'lane_h:join()'\n"
"-- lane_h[0]:    can be read to make sure a thread has finished (always gives 'true')\n"
"-- lane_h[-1]:   error message, without propagating the error\n"
"--\n"
"--      Reading a Lane result (or [0]) propagates a possible error in the lane\n"
"--      (and execution does not return). Cancelled lanes give 'nil' values.\n"
"--\n"
"-- lane_h.state: \"pending\"/\"running\"/\"waiting\"/\"done\"/\"error\"/\"cancelled\"\n"
"--\n"
"-- Note: Would be great to be able to have '__ipairs' metamethod, that gets\n"
"--      called by 'ipairs()' function to custom iterate objects. We'd use it\n"
"--      for making sure a lane has ended (results are available); not requiring\n"
"--      the user to precede a loop by explicit 'h[0]' or 'h:join()'.\n"
"--\n"
"--      Or, even better, 'ipairs()' should start valuing '__index' instead\n"
"--      of using raw reads that bypass it.\n"
"--\n"
"-----\n"
"-- lanes.gen( [libs_str|opt_tbl [, ...],] lane_func ) ( [...] ) -> h\n"
"--\n"
"-- 'libs': nil:     no libraries available (default)\n"
"--         \"\":      only base library ('assert', 'print', 'unpack' etc.)\n"
"--         \"math,os\": math + os + base libraries (named ones + base)\n"
"--         \"*\":     all standard libraries available\n"
"--\n"
"-- 'opt': .priority:  int (-2..+2) smaller is lower priority (0 = default)\n"
"--\n"
"--	      .cancelstep: bool | uint\n"
"--            false: cancellation check only at pending Linda operations\n"
"--                   (send/receive) so no runtime performance penalty (default)\n"
"--            true:  adequate cancellation check (same as 100)\n"
"--            >0:    cancellation check every x Lua lines (small number= faster\n"
"--                   reaction but more performance overhead)\n"
"--\n"
"--        .globals:  table of globals to set for a new thread (passed by value)\n"
"--\n"
"--        .required:  table of packages to require\n"
"--        ... (more options may be introduced later) ...\n"
"--\n"
"-- Calling with a function parameter ('lane_func') ends the string/table\n"
"-- modifiers, and prepares a lane generator. One can either finish here,\n"
"-- and call the generator later (maybe multiple times, with different parameters) \n"
"-- or add on actual thread arguments to also ignite the thread on the same call.\n"
"\n"
"local valid_libs= {\n"
"    [\"package\"]= true,\n"
"    [\"table\"]= true,\n"
"    [\"io\"]= true,\n"
"    [\"os\"]= true,\n"
"    [\"string\"]= true,\n"
"    [\"math\"]= true,\n"
"    [\"debug\"]= true,\n"
"    --\n"
"    [\"base\"]= true,\n"
"    [\"coroutine\"]= true,\n"
"    [\"*\"]= true\n"
"}\n"
"\n"
"-- PUBLIC LANES API\n"
"local function gen( ... )\n"
"    local opt= {}\n"
"    local libs= nil\n"
"    local lev= 2  -- level for errors\n"
"\n"
"    local n= select('#',...)\n"
"    \n"
"    if n==0 then\n"
"        error( \"No parameters!\" )\n"
"    end\n"
"\n"
"    for i=1,n-1 do\n"
"        local v= select(i,...)\n"
"        if type(v)==\"string\" then\n"
"            libs= libs and libs..\",\"..v or v\n"
"        elseif type(v)==\"table\" then\n"
"            for k,vv in pairs(v) do\n"
"                opt[k]= vv\n"
"            end\n"
"        elseif v==nil then\n"
"            -- skip\n"
"        else\n"
"            error( \"Bad parameter: \"..tostring(v) )\n"
"        end\n"
"    end\n"
"\n"
"    local func= select(n,...)\n"
"    local functype = type(func)\n"
"    if functype ~= \"function\" and functype ~= \"string\" then\n"
"        error( \"Last parameter not function or string: \"..tostring(func))\n"
"    end\n"
"\n"
"    -- Check 'libs' already here, so the error goes in the right place\n"
"    -- (otherwise will be noticed only once the generator is called)\n"
"    --\n"
"    if libs then\n"
"        for s in string_gmatch(libs, \"[%a*]+\") do\n"
"            if not valid_libs[s] then\n"
"                error( \"Bad library name: \"..s )\n"
"            end\n"
"        end\n"
"    end\n"
"    \n"
"    local prio, cs, g_tbl, package_tbl, required\n"
"\n"
"    for k,v in pairs(opt) do\n"
"            if k==\"priority\" then prio= v\n"
"        elseif k==\"cancelstep\" then\n"
"            cs = (v==true) and 100 or\n"
"                (v==false) and 0 or \n"
"                type(v)==\"number\" and v or\n"
"                error( \"Bad cancelstep: \"..tostring(v), lev )\n"
"        elseif k==\"globals\" then g_tbl= v\n"
"        elseif k==\"package\" then\n"
"            package_tbl = (type( v) == \"table\") and v or error( \"Bad package: \" .. tostring( v), lev)\n"
"        elseif k==\"required\" then\n"
"            required= (type( v) == \"table\") and v or error( \"Bad required: \" .. tostring( v), lev)\n"
"        --..\n"
"        elseif k==1 then error( \"unkeyed option: \".. tostring(v), lev )\n"
"        else error( \"Bad option: \".. tostring(k), lev )\n"
"        end\n"
"    end\n"
"\n"
"    if not package_tbl then package_tbl = package end\n"
"    -- Lane generator\n"
"    --\n"
"    return function(...)\n"
"		return thread_new( func, libs, cs, prio, g_tbl, package, required, ...)     -- args\n"
"           end\n"
"end\n"
"\n"
"---=== Lindas ===---\n"
"\n"
"-- We let the C code attach methods to userdata directly\n"
"\n"
"-----\n"
"-- lanes.linda() -> linda_ud\n"
"--\n"
"-- PUBLIC LANES API\n"
"local linda = mm.linda\n"
"\n"
"\n"
"---=== Timers ===---\n"
"\n"
"-- PUBLIC LANES API\n"
"local timer = function() error \"timers are not active\" end\n"
"\n"
"if _timers ~= \"NO_TIMERS\" then\n"
"\n"
"local timer_gateway= assert( mm.timer_gateway )\n"
"--\n"
"-- On first 'require \"lanes\"', a timer lane is spawned that will maintain\n"
"-- timer tables and sleep in between the timer events. All interaction with\n"
"-- the timer lane happens via a 'timer_gateway' Linda, which is common to\n"
"-- all that 'require \"lanes\"'.\n"
"-- \n"
"-- Linda protocol to timer lane:\n"
"--\n"
"--  TGW_KEY: linda_h, key, [wakeup_at_secs], [repeat_secs]\n"
"--\n"
"local TGW_KEY= \"(timer control)\"    -- the key does not matter, a 'weird' key may help debugging\n"
"local first_time_key= \"first time\"\n"
"\n"
"local first_time= timer_gateway:get(first_time_key) == nil\n"
"timer_gateway:set(first_time_key,true)\n"
"\n"
"--\n"
"-- Timer lane; initialize only on the first 'require \"lanes\"' instance (which naturally\n"
"-- has 'table' always declared)\n"
"--\n"
"if first_time then\n"
"    local table_remove= assert( table.remove )\n"
"    local table_insert= assert( table.insert )\n"
"\n"
"    --\n"
"    -- { [deep_linda_lightuserdata]= { [deep_linda_lightuserdata]=linda_h, \n"
"    --                                 [key]= { wakeup_secs [,period_secs] } [, ...] },\n"
"    -- }\n"
"    --\n"
"    -- Collection of all running timers, indexed with linda's & key.\n"
"    --\n"
"    -- Note that we need to use the deep lightuserdata identifiers, instead\n"
"    -- of 'linda_h' themselves as table indices. Otherwise, we'd get multiple\n"
"    -- entries for the same timer.\n"
"    --\n"
"    -- The 'hidden' reference to Linda proxy is used in 'check_timers()' but\n"
"    -- also important to keep the Linda alive, even if all outside world threw\n"
"    -- away pointers to it (which would ruin uniqueness of the deep pointer).\n"
"    -- Now we're safe.\n"
"    --\n"
"    local collection= {}\n"
"\n"
"    --\n"
"    -- set_timer( linda_h, key [,wakeup_at_secs [,period_secs]] )\n"
"    --\n"
"    local function set_timer( linda, key, wakeup_at, period )\n"
"\n"
"        assert( wakeup_at==nil or wakeup_at>0.0 )\n"
"        assert( period==nil or period>0.0 )\n"
"\n"
"        local linda_deep= linda:deep()\n"
"        assert( linda_deep )\n"
"\n"
"        -- Find or make a lookup for this timer\n"
"        --\n"
"        local t1= collection[linda_deep]\n"
"        if not t1 then\n"
"            t1= { [linda_deep]= linda }     -- proxy to use the Linda\n"
"            collection[linda_deep]= t1\n"
"        end\n"
"    \n"
"        if wakeup_at==nil then\n"
"            -- Clear the timer\n"
"            --\n"
"            t1[key]= nil\n"
"\n"
"            -- Remove empty tables from collection; speeds timer checks and\n"
"            -- lets our 'safety reference' proxy be gc:ed as well.\n"
"            --\n"
"            local empty= true\n"
"            for k,_ in pairs(t1) do\n"
"                if k~= linda_deep then\n"
"                    empty= false; break\n"
"                end\n"
"            end\n"
"            if empty then\n"
"                collection[linda_deep]= nil\n"
"            end\n"
"            \n"
"            -- Note: any unread timer value is left at 'linda[key]' intensionally;\n"
"            --       clearing a timer just stops it.\n"
"        else\n"
"            -- New timer or changing the timings\n"
"            --\n"
"            local t2= t1[key]\n"
"            if not t2 then\n"
"                t2= {}; t1[key]= t2\n"
"            end\n"
"    \n"
"            t2[1]= wakeup_at\n"
"            t2[2]= period   -- can be 'nil'\n"
"        end\n"
"    end\n"
"\n"
"    -----\n"
"    -- [next_wakeup_at]= check_timers()\n"
"    --\n"
"    -- Check timers, and wake up the ones expired (if any)\n"
"    --\n"
"    -- Returns the closest upcoming (remaining) wakeup time (or 'nil' if none).\n"
"    --\n"
"    local function check_timers()\n"
"\n"
"        local now= now_secs()\n"
"        local next_wakeup\n"
"\n"
"        for linda_deep,t1 in pairs(collection) do\n"
"            for key,t2 in pairs(t1) do\n"
"                --\n"
"                if key==linda_deep then\n"
"                    -- no 'continue' in Lua :/\n"
"                else\n"
"                    -- 't2': { wakeup_at_secs [,period_secs] }\n"
"                    --\n"
"                    local wakeup_at= t2[1]\n"
"                    local period= t2[2]     -- may be 'nil'\n"
"                    \n"
"                    if wakeup_at <= now then    \n"
"                        local linda= t1[linda_deep]\n"
"                        assert(linda)\n"
"    \n"
"                        linda:set( key, now )\n"
"        \n"
"                        -- 'pairs()' allows the values to be modified (and even\n"
"                        -- removed) as far as keys are not touched\n"
"                                                \n"
"                        if not period then\n"
"                            -- one-time timer; gone\n"
"                            --\n"
"                            t1[key]= nil\n"
"                            wakeup_at= nil   -- no 'continue' in Lua :/\n"
"                        else\n"
"                            -- repeating timer; find next wakeup (may jump multiple repeats)\n"
"                            --\n"
"                            repeat\n"
"                                wakeup_at= wakeup_at+period\n"
"                            until wakeup_at > now\n"
"    \n"
"                            t2[1]= wakeup_at\n"
"                        end\n"
"                    end\n"
"                    \n"
"                    if wakeup_at and ((not next_wakeup) or (wakeup_at < next_wakeup)) then\n"
"                        next_wakeup= wakeup_at\n"
"                    end \n"
"                end\n"
"            end -- t2 loop\n"
"        end -- t1 loop\n"
"        \n"
"        return next_wakeup  -- may be 'nil'\n"
"    end    \n"
"\n"
"    -----\n"
"    -- Snore loop (run as a lane on the background)\n"
"    --\n"
"    -- High priority, to get trustworthy timings.\n"
"    --\n"
"    -- We let the timer lane be a \"free running\" thread; no handle to it\n"
"    -- remains.\n"
"    --\n"
"    gen( \"io,package\", { priority=max_prio}, function()\n"
"        set_debug_threadname( \"LanesTimer\")\n"
"        while true do\n"
"            local next_wakeup= check_timers()\n"
"\n"
"            -- Sleep until next timer to wake up, or a set/clear command\n"
"            --\n"
"            local secs\n"
"            if next_wakeup then\n"
"                secs =  next_wakeup - now_secs()\n"
"                if secs < 0 then secs = 0 end\n"
"            end\n"
"            local linda= timer_gateway:receive( secs, TGW_KEY )\n"
"\n"
"            if linda then\n"
"                local key= timer_gateway:receive( 0.0, TGW_KEY )\n"
"                local wakeup_at= timer_gateway:receive( 0.0, TGW_KEY )\n"
"                local period= timer_gateway:receive( 0.0, TGW_KEY )\n"
"                assert( key and wakeup_at and period )\n"
"\n"
"                set_timer( linda, key, wakeup_at, period>0 and period or nil )\n"
"            elseif secs == 0 then -- got no value while block-waiting?\n"
"                WR( \"timer lane: no linda, aborted?\")\n"
"            end\n"
"        end\n"
"    end )()\n"
"end\n"
"\n"
"-----\n"
"-- = timer( linda_h, key_val, date_tbl|first_secs [,period_secs] )\n"
"--\n"
"-- PUBLIC LANES API\n"
"timer = function( linda, key, a, period )\n"
"\n"
"    if a==0.0 then\n"
"        -- Caller expects to get current time stamp in Linda, on return\n"
"        -- (like the timer had expired instantly); it would be good to set this\n"
"        -- as late as possible (to give most current time) but also we want it\n"
"        -- to precede any possible timers that might start striking.\n"
"        --\n"
"        linda:set( key, now_secs() )\n"
"\n"
"        if not period or period==0.0 then\n"
"            timer_gateway:send( TGW_KEY, linda, key, nil, nil )   -- clear the timer\n"
"            return  -- nothing more to do\n"
"        end\n"
"        a= period\n"
"    end\n"
"\n"
"    local wakeup_at= type(a)==\"table\" and wakeup_conv(a)    -- given point of time\n"
"                                       or now_secs()+a\n"
"    -- queue to timer\n"
"    --\n"
"    timer_gateway:send( TGW_KEY, linda, key, wakeup_at, period )\n"
"end\n"
"\n"
"end -- _timers\n"
"\n"
"---=== Lock & atomic generators ===---\n"
"\n"
"-- These functions are just surface sugar, but make solutions easier to read.\n"
"-- Not many applications should even need explicit locks or atomic counters.\n"
"\n"
"--\n"
"-- lock_f= lanes.genlock( linda_h, key [,N_uint=1] )\n"
"--\n"
"-- = lock_f( +M )   -- acquire M\n"
"--      ...locked...\n"
"-- = lock_f( -M )   -- release M\n"
"--\n"
"-- Returns an access function that allows 'N' simultaneous entries between\n"
"-- acquire (+M) and release (-M). For binary locks, use M==1.\n"
"--\n"
"-- PUBLIC LANES API\n"
"local function genlock( linda, key, N )\n"
"    linda:limit(key,N)\n"
"    linda:set(key,nil)  -- clears existing data\n"
"\n"
"    --\n"
"    -- [true [, ...]= trues(uint)\n"
"    --\n"
"    local function trues(n)\n"
"        if n>0 then return true,trues(n-1) end\n"
"    end\n"
"\n"
"    return\n"
"    function(M)\n"
"        if M>0 then\n"
"            -- 'nil' timeout allows 'key' to be numeric\n"
"            linda:send( nil, key, trues(M) )    -- suspends until been able to push them\n"
"        else\n"
"            for i=1,-M do\n"
"                linda:receive( key )\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"\n"
"--\n"
"-- atomic_f= lanes.genatomic( linda_h, key [,initial_num=0.0] )\n"
"--\n"
"-- int= atomic_f( [diff_num=1.0] )\n"
"--\n"
"-- Returns an access function that allows atomic increment/decrement of the\n"
"-- number in 'key'.\n"
"--\n"
"-- PUBLIC LANES API\n"
"local function genatomic( linda, key, initial_val )\n"
"    linda:limit(key,2)          -- value [,true]\n"
"    linda:set(key,initial_val or 0.0)   -- clears existing data (also queue)\n"
"\n"
"    return\n"
"    function(diff)\n"
"        -- 'nil' allows 'key' to be numeric\n"
"        linda:send( nil, key, true )    -- suspends until our 'true' is in\n"
"        local val= linda:get(key) + (diff or 1.0)\n"
"        linda:set( key, val )   -- releases the lock, by emptying queue\n"
"        return val\n"
"    end\n"
"end\n"
"\n"
"-- newuserdata = mm.newuserdata\n"
"\n"
"	-- activate full interface\n"
"	lanes.gen = gen\n"
"	lanes.linda = mm.linda\n"
"	lanes.timer = timer\n"
"	lanes.genlock = genlock\n"
"	lanes.genatomic = genatomic\n"
"	-- from now on, calling configure does nothing but checking that we don't call it with parameters that changed compared to the first invocation\n"
"	lanes.configure = function( _nk, _t)\n"
"		if _nk ~= _nb_keepers then\n"
"			error( \"mismatched configuration: \" .. tostring( _nk) .. \" keepers instead of \" .. tostring( _nb_keepers))\n"
"		end\n"
"		if _t ~= _timers  then\n"
"			error( \"mismatched configuration: \" .. tostring( _t) .. \" timer activity instead of \" .. tostring( _timers))\n"
"		end\n"
"		return lanes\n"
"	end\n"
"	return lanes\n"
"end -- lanes.configure\n"
"\n"
"--the end\n"
"return lanes\n"
"\n"
"",

"wetgenes.www.gae.users","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local core=require(\"wetgenes.www.gae.users.core\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.users\"]=_M\n"
"\n"
"function login_url(a)\n"
"\n"
"	return core.login_url(a)\n"
"\n"
"end\n"
"\n"
"\n"
"function logout_url(a)\n"
"\n"
"	return core.logout_url(a)\n"
"\n"
"end\n"
"\n"
"function get_google_user()\n"
"\n"
"	return core.get_google_user()\n"
"\n"
"end\n"
"",

"wetgenes.fenestra.test","\r\n"
"\r\n"
"local bit=require('bit')\r\n"
"local gl=require('gl')\r\n"
"\r\n"
"win=require('fenestra.wrap').win()\r\n"
"\r\n"
"\r\n"
"\r\n"
"win.setup(_G) -- create and associate with this global table, eg _G.print gets replaced\r\n"
"\r\n"
"win.width=win.get(\"width\")\r\n"
"win.height=win.get(\"height\")\r\n"
"\r\n"
"\r\n"
"local moddat,t=win.data.load(\"data/objects/xox/aball.xox\")\r\n"
"local xox=win.xox(moddat)\r\n"
"\r\n"
"\r\n"
"local xsx_dat,t=win.data.load(\"data/avatar/xsx/cycle_walk.xsx\")\r\n"
"local xsx=win.xsx(xsx_dat)\r\n"
"local soul=win.avatar.load_soul(\"local/avatar/soul/default.cthulhu.xml\")\r\n"
"\r\n"
"\r\n"
"local items={}\r\n"
"\r\n"
"world=require(\"box2d.wrap\").world({gravity={0,-10}})\r\n"
"\r\n"
"local ground = world.body{}\r\n"
"ground.shape{box={width=64,height=10},density=1,friction=0.3}\r\n"
"ground.set{x=0,y=-24-10,a=0}\r\n"
"\r\n"
"\r\n"
"function new_item(x,y,a)\r\n"
"\r\n"
"	local it={}\r\n"
"\r\n"
"	it.text=\"hello\"\r\n"
"	it.ts=1.6\r\n"
"	it.tc=0xff00ff00\r\n"
"	\r\n"
"	it.tx,it.ty=win.font_debug.size(it.text,it.ts)\r\n"
"	\r\n"
"	it.tx=-(it.tx/2)\r\n"
"	it.ty= (it.ty/2)\r\n"
"\r\n"
"	it.body=world.body{}\r\n"
"	it.body.shape{box={width=-it.tx,height=it.ty,center={0,0}},density=1,friction=0.3,restitution=0.25}\r\n"
"	it.body.set{mass=\"shapes\",x=x,y=y,a=a} -- calculate from shapes\r\n"
"	\r\n"
"	return it\r\n"
"end\r\n"
"\r\n"
"table.insert(items, new_item(0,10,0) )\r\n"
"\r\n"
"\r\n"
"function win.mouse(act,x,y,key)\r\n"
"\r\n"
"\r\n"
"	local hx=win.width/2\r\n"
"	local hy=win.height/2\r\n"
"\r\n"
"	local tx,ty\r\n"
"	\r\n"
"	if win.height/(win.width or 1) > (3/4) then -- deal with new viewport sizeing\r\n"
"	\r\n"
"		tx=(4/3)*(x-hx)/hx\r\n"
"		ty=(4/3)*(hy-y)/hx\r\n"
"		\r\n"
"	else\r\n"
"	\r\n"
"		tx=(x-hx)/hy\r\n"
"		ty=(hy-y)/hy\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"		\r\n"
"	win.widget.mouse(win.widget,act,320+tx*240,240+ty*240,key)\r\n"
"\r\n"
"	if act==\"down\" then\r\n"
"	\r\n"
"\r\n"
"		table.insert(items, new_item(tx*24,ty*24,0) )\r\n"
"	\r\n"
"	end\r\n"
"\r\n"
"end\r\n"
"	\r\n"
"--print(xsx)\r\n"
"--	xsx.set(t)\r\n"
"\r\n"
"	win.avatar.map_xsx(xsx,soul)\r\n"
"\r\n"
"\r\n"
"function modl(name)\r\n"
"\r\n"
"	moddat,t=win.data.load(\"data/avatar/xox/\"..name..\".xox\")\r\n"
"	\r\n"
"	if moddat then\r\n"
"	\r\n"
"		xox.clean()\r\n"
"		xox=win.xox(moddat)\r\n"
"		\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"local rx,ry,rz=0,0,0\r\n"
"local frame=0\r\n"
"\r\n"
"local last=win.time()\r\n"
"local frame_last=last\r\n"
"local frame_count=0\r\n"
"local fps=0\r\n"
"\r\n"
"local times={}\r\n"
"\r\n"
"local function times_setup()\r\n"
"	local t={}\r\n"
"	t.time=0\r\n"
"	t.time_live=0\r\n"
"	\r\n"
"	t.hash=0\r\n"
"	t.hash_live=0\r\n"
"	\r\n"
"	t.started=0\r\n"
"	\r\n"
"	function t.start()\r\n"
"		t.started=win.time()\r\n"
"	end\r\n"
"	\r\n"
"	function t.stop()\r\n"
"		local ended=win.time()\r\n"
"		\r\n"
"		t.time_live=t.time_live + ended-t.started\r\n"
"		t.hash_live=t.hash_live + 1\r\n"
"	end\r\n"
"	\r\n"
"	function t.done()\r\n"
"		t.time=t.time_live\r\n"
"		t.hash=t.hash_live\r\n"
"		t.time_live=0\r\n"
"		t.hash_live=0\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	return t\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"times.update=times_setup()\r\n"
"times.draw=times_setup()\r\n"
"times.swap=times_setup()\r\n"
"\r\n"
"win.update=function()\r\n"
"\r\n"
"	win.width=win.get(\"width\")\r\n"
"	win.height=win.get(\"height\")\r\n"
"	\r\n"
"	\r\n"
"	local t=win.time()\r\n"
"	local d=t-last\r\n"
"	local d_orig=d\r\n"
"\r\n"
"-- count frames	\r\n"
"	if t-frame_last >= 1 then\r\n"
"	\r\n"
"		fps=frame_count\r\n"
"		frame_count=0\r\n"
"		frame_last=t\r\n"
"	\r\n"
"		times.update.done()\r\n"
"		times.draw.done()\r\n"
"		times.swap.done()\r\n"
"	end\r\n"
"	\r\n"
"-- update\r\n"
"\r\n"
"	local do_draw=false\r\n"
"	while d >= 0.020 do\r\n"
"	\r\n"
"		times.update.start()\r\n"
"		\r\n"
"		world.step(1/50,2)\r\n"
"		\r\n"
"		rx=(rx+1)%360\r\n"
"		ry=(ry+1)%360\r\n"
"		rz=(rz+1)%360\r\n"
"		\r\n"
"		frame=(frame+0.020)\r\n"
"		if frame>xsx.length then frame=frame-xsx.length end \r\n"
"		\r\n"
"		win.widget:update()\r\n"
"		\r\n"
"		win.console.update()\r\n"
"		\r\n"
"		times.update.stop()\r\n"
"		\r\n"
"		if d>1 then -- reset when very out of sync\r\n"
"			last=t\r\n"
"			d=0\r\n"
"		else\r\n"
"			last=last+0.020\r\n"
"			d=d-0.020\r\n"
"		end\r\n"
"		\r\n"
"		do_draw=true\r\n"
"	end\r\n"
"\r\n"
"-- draw\r\n"
"\r\n"
"\r\n"
"	if do_draw then\r\n"
"\r\n"
"		times.draw.start()\r\n"
"		win.begin()\r\n"
"		\r\n"
"		gl.MatrixMode(\"MODELVIEW\")\r\n"
"		gl.LoadIdentity()\r\n"
"		\r\n"
"\r\n"
"		\r\n"
"\r\n"
"--		for x=-10,10,10 do\r\n"
"--			for y=-10,10,10 do\r\n"
"\r\n"
"		local x,y=0,0\r\n"
"			\r\n"
"				gl.PushMatrix()\r\n"
"				\r\n"
"				gl.Translate(x/2,y/2, 0)\r\n"
"				\r\n"
"		gl.Translate(0,0, -32)\r\n"
"		gl.Scale(8,8,8)\r\n"
"		gl.Rotate(rz,0,0,1);\r\n"
"		gl.Rotate(ry,0,1,0);\r\n"
"		gl.Rotate(rx,1,0,0);\r\n"
"		\r\n"
"--				win.draw_cube(0.5)\r\n"
"--				xox.draw()\r\n"
"				xsx.draw(frame);\r\n"
"				\r\n"
"				gl.PopMatrix()\r\n"
"				\r\n"
"--			end\r\n"
"--		end\r\n"
"\r\n"
"\r\n"
"		for i,v in ipairs(items) do\r\n"
"		\r\n"
"			\r\n"
"			v.body.get()\r\n"
"			gl.PushMatrix()\r\n"
"			\r\n"
"			gl.Translate(v.body.x,v.body.y, -24)\r\n"
"			gl.Rotate(v.body.a,0,0,1);\r\n"
"--[[\r\n"
"			gl.Rotate(90,0,1,0);\r\n"
"			xsx.draw(frame);\r\n"
"			gl.Rotate(-90,0,1,0);\r\n"
"]]			\r\n"
"			win.font_debug.set(v.tx,v.ty,v.tc,v.ts)\r\n"
"			win.font_debug.draw(v.text)\r\n"
"\r\n"
"		\r\n"
"			gl.PopMatrix()\r\n"
"		end\r\n"
"		\r\n"
"		\r\n"
"		gl.PushMatrix()\r\n"
"		gl.Translate(-320,-240, -240*1.0)\r\n"
"		win.widget:draw()\r\n"
"		gl.PopMatrix()\r\n"
"		\r\n"
"		win.console.draw()\r\n"
"		\r\n"
"--		win.debug_rect(0,0,640,480,0x44000000)\r\n"
"	\r\n"
"		win.swap()\r\n"
"		times.draw.stop()\r\n"
"		\r\n"
"		frame_count=frame_count+1\r\n"
"		\r\n"
"		local gci=gcinfo()\r\n"
"		win.console.display(string.format(\"fps=%02.0f t=%03.0f u=%03.0f d=%03.0f gc=%0.0fk\",fps,math.floor(0.5+(10000/fps)),math.floor(0.5+times.update.time*10000),math.floor(0.5+times.draw.time*10000/times.draw.hash),math.floor(gci) ))\r\n"
"		\r\n"
"	end\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"while win.msg(\"wait\") do\r\n"
"\r\n"
"	win.update()\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"win.clean()\r\n"
"\r\n"
"",

"socket.smtp","-----------------------------------------------------------------------------\n"
"-- SMTP client support for the Lua language.\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: smtp.lua,v 1.46 2007/03/12 04:08:40 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-----------------------------------------------------------------------------\n"
"local base = _G\n"
"local coroutine = require(\"coroutine\")\n"
"local string = require(\"string\")\n"
"local math = require(\"math\")\n"
"local os = require(\"os\")\n"
"local socket = require(\"socket\")\n"
"local tp = require(\"socket.tp\")\n"
"local ltn12 = require(\"ltn12\")\n"
"local mime = require(\"mime\")\n"
"module(\"socket.smtp\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Program constants\n"
"-----------------------------------------------------------------------------\n"
"-- timeout for connection\n"
"TIMEOUT = 60\n"
"-- default server used to send e-mails\n"
"SERVER = \"localhost\"\n"
"-- default port\n"
"PORT = 25\n"
"-- domain used in HELO command and default sendmail\n"
"-- If we are under a CGI, try to get from environment\n"
"DOMAIN = os.getenv(\"SERVER_NAME\") or \"localhost\"\n"
"-- default time zone (means we don't know)\n"
"ZONE = \"-0000\"\n"
"\n"
"---------------------------------------------------------------------------\n"
"-- Low level SMTP API\n"
"-----------------------------------------------------------------------------\n"
"local metat = { __index = {} }\n"
"\n"
"function metat.__index:greet(domain)\n"
"    self.try(self.tp:check(\"2..\"))\n"
"    self.try(self.tp:command(\"EHLO\", domain or DOMAIN))\n"
"    return socket.skip(1, self.try(self.tp:check(\"2..\")))\n"
"end\n"
"\n"
"function metat.__index:mail(from)\n"
"    self.try(self.tp:command(\"MAIL\", \"FROM:\" .. from))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:rcpt(to)\n"
"    self.try(self.tp:command(\"RCPT\", \"TO:\" .. to))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:data(src, step)\n"
"    self.try(self.tp:command(\"DATA\"))\n"
"    self.try(self.tp:check(\"3..\"))\n"
"    self.try(self.tp:source(src, step))\n"
"    self.try(self.tp:send(\"\\r\\n"
".\\r\\n"
"\"))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:quit()\n"
"    self.try(self.tp:command(\"QUIT\"))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:close()\n"
"    return self.tp:close()\n"
"end\n"
"\n"
"function metat.__index:login(user, password)\n"
"    self.try(self.tp:command(\"AUTH\", \"LOGIN\"))\n"
"    self.try(self.tp:check(\"3..\"))\n"
"    self.try(self.tp:command(mime.b64(user)))\n"
"    self.try(self.tp:check(\"3..\"))\n"
"    self.try(self.tp:command(mime.b64(password)))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:plain(user, password)\n"
"    local auth = \"PLAIN \" .. mime.b64(\"\\0\" .. user .. \"\\0\" .. password)\n"
"    self.try(self.tp:command(\"AUTH\", auth))\n"
"    return self.try(self.tp:check(\"2..\"))\n"
"end\n"
"\n"
"function metat.__index:auth(user, password, ext)\n"
"    if not user or not password then return 1 end\n"
"    if string.find(ext, \"AUTH[^\\n"
"]+LOGIN\") then\n"
"        return self:login(user, password)\n"
"    elseif string.find(ext, \"AUTH[^\\n"
"]+PLAIN\") then\n"
"        return self:plain(user, password)\n"
"    else\n"
"        self.try(nil, \"authentication not supported\")\n"
"    end\n"
"end\n"
"\n"
"-- send message or throw an exception\n"
"function metat.__index:send(mailt)\n"
"    self:mail(mailt.from)\n"
"    if base.type(mailt.rcpt) == \"table\" then\n"
"        for i,v in base.ipairs(mailt.rcpt) do\n"
"            self:rcpt(v)\n"
"        end\n"
"    else\n"
"        self:rcpt(mailt.rcpt)\n"
"    end\n"
"    self:data(ltn12.source.chain(mailt.source, mime.stuff()), mailt.step)\n"
"end\n"
"\n"
"function open(server, port, create)\n"
"    local tp = socket.try(tp.connect(server or SERVER, port or PORT,\n"
"        TIMEOUT, create))\n"
"    local s = base.setmetatable({tp = tp}, metat)\n"
"    -- make sure tp is closed if we get an exception\n"
"    s.try = socket.newtry(function()\n"
"        s:close()\n"
"    end)\n"
"    return s\n"
"end\n"
"\n"
"-- convert headers to lowercase\n"
"local function lower_headers(headers)\n"
"    local lower = {}\n"
"    for i,v in base.pairs(headers or lower) do\n"
"        lower[string.lower(i)] = v\n"
"    end\n"
"    return lower\n"
"end\n"
"\n"
"---------------------------------------------------------------------------\n"
"-- Multipart message source\n"
"-----------------------------------------------------------------------------\n"
"-- returns a hopefully unique mime boundary\n"
"local seqno = 0\n"
"local function newboundary()\n"
"    seqno = seqno + 1\n"
"    return string.format('%s%05d==%05u', os.date('%d%m%Y%H%M%S'),\n"
"        math.random(0, 99999), seqno)\n"
"end\n"
"\n"
"-- send_message forward declaration\n"
"local send_message\n"
"\n"
"-- yield the headers all at once, it's faster\n"
"local function send_headers(headers)\n"
"    local h = \"\\r\\n"
"\"\n"
"    for i,v in base.pairs(headers) do\n"
"        h = i .. ': ' .. v .. \"\\r\\n"
"\" .. h\n"
"    end\n"
"    coroutine.yield(h)\n"
"end\n"
"\n"
"-- yield multipart message body from a multipart message table\n"
"local function send_multipart(mesgt)\n"
"    -- make sure we have our boundary and send headers\n"
"    local bd = newboundary()\n"
"    local headers = lower_headers(mesgt.headers or {})\n"
"    headers['content-type'] = headers['content-type'] or 'multipart/mixed'\n"
"    headers['content-type'] = headers['content-type'] ..\n"
"        '; boundary=\"' ..  bd .. '\"'\n"
"    send_headers(headers)\n"
"    -- send preamble\n"
"    if mesgt.body.preamble then\n"
"        coroutine.yield(mesgt.body.preamble)\n"
"        coroutine.yield(\"\\r\\n"
"\")\n"
"    end\n"
"    -- send each part separated by a boundary\n"
"    for i, m in base.ipairs(mesgt.body) do\n"
"        coroutine.yield(\"\\r\\n"
"--\" .. bd .. \"\\r\\n"
"\")\n"
"        send_message(m)\n"
"    end\n"
"    -- send last boundary\n"
"    coroutine.yield(\"\\r\\n"
"--\" .. bd .. \"--\\r\\n"
"\\r\\n"
"\")\n"
"    -- send epilogue\n"
"    if mesgt.body.epilogue then\n"
"        coroutine.yield(mesgt.body.epilogue)\n"
"        coroutine.yield(\"\\r\\n"
"\")\n"
"    end\n"
"end\n"
"\n"
"-- yield message body from a source\n"
"local function send_source(mesgt)\n"
"    -- make sure we have a content-type\n"
"    local headers = lower_headers(mesgt.headers or {})\n"
"    headers['content-type'] = headers['content-type'] or\n"
"        'text/plain; charset=\"iso-8859-1\"'\n"
"    send_headers(headers)\n"
"    -- send body from source\n"
"    while true do\n"
"        local chunk, err = mesgt.body()\n"
"        if err then coroutine.yield(nil, err)\n"
"        elseif chunk then coroutine.yield(chunk)\n"
"        else break end\n"
"    end\n"
"end\n"
"\n"
"-- yield message body from a string\n"
"local function send_string(mesgt)\n"
"    -- make sure we have a content-type\n"
"    local headers = lower_headers(mesgt.headers or {})\n"
"    headers['content-type'] = headers['content-type'] or\n"
"        'text/plain; charset=\"iso-8859-1\"'\n"
"    send_headers(headers)\n"
"    -- send body from string\n"
"    coroutine.yield(mesgt.body)\n"
"end\n"
"\n"
"-- message source\n"
"function send_message(mesgt)\n"
"    if base.type(mesgt.body) == \"table\" then send_multipart(mesgt)\n"
"    elseif base.type(mesgt.body) == \"function\" then send_source(mesgt)\n"
"    else send_string(mesgt) end\n"
"end\n"
"\n"
"-- set defaul headers\n"
"local function adjust_headers(mesgt)\n"
"    local lower = lower_headers(mesgt.headers)\n"
"    lower[\"date\"] = lower[\"date\"] or\n"
"        os.date(\"!%a, %d %b %Y %H:%M:%S \") .. (mesgt.zone or ZONE)\n"
"    lower[\"x-mailer\"] = lower[\"x-mailer\"] or socket._VERSION\n"
"    -- this can't be overriden\n"
"    lower[\"mime-version\"] = \"1.0\"\n"
"    return lower\n"
"end\n"
"\n"
"function message(mesgt)\n"
"    mesgt.headers = adjust_headers(mesgt)\n"
"    -- create and return message source\n"
"    local co = coroutine.create(function() send_message(mesgt) end)\n"
"    return function()\n"
"        local ret, a, b = coroutine.resume(co)\n"
"        if ret then return a, b\n"
"        else return nil, a end\n"
"    end\n"
"end\n"
"\n"
"---------------------------------------------------------------------------\n"
"-- High level SMTP API\n"
"-----------------------------------------------------------------------------\n"
"send = socket.protect(function(mailt)\n"
"    local s = open(mailt.server, mailt.port, mailt.create)\n"
"    local ext = s:greet(mailt.domain)\n"
"    s:auth(mailt.user, mailt.password, ext)\n"
"    s:send(mailt)\n"
"    s:quit()\n"
"    return s:close()\n"
"end)\n"
"",

"wetgenes.pp","--\r\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\r\n"
"-- This file is distributed under the terms of the MIT license.\r\n"
"-- http://en.wikipedia.org/wiki/MIT_License\r\n"
"-- Please ping me if you use it for anything cool...\r\n"
"--\r\n"
"\r\n"
"local up_G=_G\r\n"
"\r\n"
"local print=print\r\n"
"local io=io\r\n"
"local table=table\r\n"
"local string=string\r\n"
"local loadfile=loadfile\r\n"
"local loadstring=loadstring\r\n"
"local assert=assert\r\n"
"local pcall=pcall\r\n"
"local xpcall=xpcall\r\n"
"\r\n"
"local setmetatable=setmetatable\r\n"
"local getfenv=getfenv\r\n"
"local setfenv=setfenv\r\n"
"\r\n"
"module(\"wetgenes.pp\")\r\n"
"\r\n"
"\r\n"
"\r\n"
"--\r\n"
"--\r\n"
"-- Create a lua program from an input file.\r\n"
"--\r\n"
"-- This can then be parsed and run to produce a preprocesed outputfile\r\n"
"--\r\n"
"--\r\n"
"\r\n"
"-- #() can be used anywhere except at the start of a line to inject the text between () as a small chunk of lua\r\n"
"-- # can be used at the start of the line to inject the rest of the line as lua\r\n"
"-- #include \"fname\" is a piece of magic that injects the given file into the output\r\n"
"-- #( at the start of the line denotes the begining of a pure lua block, rest of line is ignored\r\n"
"-- #) at the start of the line denotes the end of a pure lua block, rest of line is ignored\r\n"
"-- a pure lua block is needed for multiline table definitions otherwise the line numbering system breaks things\r\n"
"--\r\n"
"-- returns a table of strings which can be table.concat into a string result\r\n"
"\r\n"
"function ppload(filename,chunk)\r\n"
"\r\n"
"local included\r\n"
"\r\n"
"local file\r\n"
"local temp\r\n"
"local line_num\r\n"
"local new_filename\r\n"
"local lua_block_insert\r\n"
"\r\n"
"\r\n"
"	lua_block_insert=false\r\n"
"\r\n"
"	if chunk then -- we are a sub build\r\n"
"\r\n"
"		included=true\r\n"
"\r\n"
"	else\r\n"
"\r\n"
"		included=false\r\n"
"\r\n"
"		chunk = {n=0}\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"\r\n"
"	file=io.open(filename,\"r\")\r\n"
"	\r\n"
"	assert(file,\"failed to load \"..filename)\r\n"
"\r\n"
"	if not included then\r\n"
"\r\n"
"		table.insert(chunk,\"-- A lua file that builds a preprocesed file as a table\\n"
"\")\r\n"
"		table.insert(chunk,\"\\n"
"\")\r\n"
"		table.insert(chunk,\"pp_output_table = {}\\n"
"\")\r\n"
"		table.insert(chunk,\"local _out_ti=table.insert\\n"
"\")\r\n"
"		table.insert(chunk,\"local _out_tt=pp_output_table\\n"
"\")\r\n"
"		table.insert(chunk,\"local _out_do=function(s)\\n"
"\")\r\n"
"		table.insert(chunk,\"	_out_ti(_out_tt,s)\\n"
"\")\r\n"
"		table.insert(chunk,\"	for i in string.gfind(s,'\\\\n"
"') do -- count outputlines\\n"
"\")\r\n"
"		table.insert(chunk,\"		_lo=_lo+1\\n"
"\")\r\n"
"		table.insert(chunk,\"		if _lo_break then -- so we can break on line\\n"
"\")\r\n"
"		table.insert(chunk,\"			assert(_lo<_lo_break,'user line break')\\n"
"\")\r\n"
"		table.insert(chunk,\"		end\\n"
"\")\r\n"
"		table.insert(chunk,\"	end\\n"
"\")\r\n"
"		table.insert(chunk,\"end\\n"
"\")\r\n"
"		table.insert(chunk,\"_lo=0\\n"
"\")\r\n"
"		table.insert(chunk,\"local _out=function(...) for i,v in ipairs({...}) do _out_do(v) end end\\n"
"\")\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	table.insert(chunk,\"\\n"
"\")\r\n"
"	table.insert(chunk,\"_file='\"..filename..\"'\\n"
"\")\r\n"
"	table.insert(chunk,\"\\n"
"\")\r\n"
"\r\n"
"	line_num=1\r\n"
"	for line in file:lines() do\r\n"
"\r\n"
"		if lua_block_insert==false then\r\n"
"		\r\n"
"			table.insert(chunk, string.format('_l=%4d; ', line_num))\r\n"
"		end\r\n"
"		\r\n"
"		\r\n"
"		if string.find(line, \"^#%(\") then\r\n"
"		\r\n"
"			lua_block_insert=true\r\n"
"			table.insert(chunk, \"\\n"
"\")\r\n"
"			\r\n"
"		elseif string.find(line, \"^#%)\") then\r\n"
"		\r\n"
"			lua_block_insert=false\r\n"
"			table.insert(chunk, \"\\n"
"\")\r\n"
"			\r\n"
"		elseif string.find(line, \"^#dofile\") then\r\n"
"\r\n"
"			_,_,new_filename=string.find(line, \"^#dofile%s\\\"([%w%p]+)\\\"\")\r\n"
"\r\n"
"			new_filename=pp_input_cd..new_filename\r\n"
"\r\n"
"			table.insert(chunk, \"--Including \"..new_filename..\"\\n"
"\")\r\n"
"			\r\n"
"			local fp=io.open(new_filename,\"r\")\r\n"
"			local d=fp:read(\"*all\")\r\n"
"			table.insert(chunk,d)\r\n"
"\r\n"
"			table.insert(chunk,\"\\n"
"\")\r\n"
"			table.insert(chunk,\"_file='\"..filename..\"'\\n"
"\")\r\n"
"			table.insert(chunk,\"\\n"
"\")\r\n"
"\r\n"
"		elseif string.find(line, \"^#include\") then\r\n"
"\r\n"
"			_,_,new_filename=string.find(line, \"^#include%s\\\"([%w%p]+)\\\"\")\r\n"
"\r\n"
"			new_filename=pp_input_cd..new_filename\r\n"
"\r\n"
"			table.insert(chunk, \"--Including \"..new_filename..\"\\n"
"\")\r\n"
"\r\n"
"			ppload(new_filename,chunk)\r\n"
"\r\n"
"			table.insert(chunk,\"\\n"
"\")\r\n"
"			table.insert(chunk,\"_file='\"..filename..\"'\\n"
"\")\r\n"
"			table.insert(chunk,\"\\n"
"\")\r\n"
"\r\n"
"		elseif string.find(line, \"^#\") then\r\n"
"\r\n"
"			table.insert(chunk, string.sub(line, 2) .. \"\\n"
"\")\r\n"
"\r\n"
"		else\r\n"
"		\r\n"
"			if lua_block_insert then\r\n"
"			\r\n"
"				table.insert(chunk, line .. \"\\n"
"\")\r\n"
"			\r\n"
"			else\r\n"
"\r\n"
"			local last = 1\r\n"
"\r\n"
"				for text, expr, index in string.gfind(line, \"(.-)#(%b())()\") do \r\n"
"\r\n"
"					last = index\r\n"
"\r\n"
"					if text ~= \"\" then\r\n"
"\r\n"
"						table.insert(chunk, string.format('_out %q ', text))\r\n"
"\r\n"
"					end\r\n"
"\r\n"
"					table.insert(chunk, string.format('_out%s ', expr))\r\n"
"\r\n"
"				end\r\n"
"\r\n"
"-- gsub to remove ugly line ends and replace with \\n"
" to make file more readable\r\n"
"temp=string.gsub(string.sub(line, last),\"\\n"
"\",\"\\\\n"
"\")\r\n"
"temp=string.gsub(temp,\"\\r\",\"\")\r\n"
"temp=string.format('_out %q\\n"
"',temp..\"\\n"
"\")\r\n"
"\r\n"
"				table.insert(chunk, temp)\r\n"
"				\r\n"
"			end\r\n"
"\r\n"
"		end\r\n"
"\r\n"
"		line_num=line_num+1\r\n"
"	end\r\n"
"\r\n"
"	file:close()\r\n"
"\r\n"
"	if not included then\r\n"
"	\r\n"
"		table.insert(chunk,\"\\n"
"return pp_output_table\\n"
"\")\r\n"
"	end\r\n"
"\r\n"
"  return chunk\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function loadsave(fname_in,fname_out)\r\n"
"\r\n"
"pp_input_cd=\"\"\r\n"
"\r\n"
"\r\n"
"pp_input_table={}\r\n"
"pp_input_string=\"\"\r\n"
"pp_input_lua=function() end\r\n"
"\r\n"
"pp_output_table={}\r\n"
"pp_output_string=\"\"\r\n"
"\r\n"
"\r\n"
"\r\n"
"print ( \"Lua pre processing \" .. fname_in .. \" into \" .. fname_out .. \"\" )\r\n"
"\r\n"
"\r\n"
"-- create input table, and its string\r\n"
"\r\n"
"pp_input_table=ppload(fname_in)\r\n"
"\r\n"
"pp_input_string=table.concat(pp_input_table)\r\n"
"\r\n"
"\r\n"
"-- output the lua program string to a file along with the output to aid with debuging,\r\n"
"-- any lua errors will hopefully be more meaningfull this way\r\n"
"\r\n"
"\r\n"
"--[[\r\n"
"local fp\r\n"
"	fp=io.open(fname_out..\".lua\",\"w\")\r\n"
"	fp:write(pp_input_string)\r\n"
"	fp:close()\r\n"
"	fp=null\r\n"
"\r\n"
"-- load that string back in and run it to produce an output table\r\n"
"pp_input_lua,_msg=loadfile(fname_out..\".lua\")\r\n"
"]]\r\n"
"\r\n"
"\r\n"
"pp_input_lua,_msg=loadstring(pp_input_string)\r\n"
"\r\n"
"\r\n"
"assert(pp_input_lua,\".\\n"
".\\n"
"\"..( _msg or \"\" )..\"\\n"
".\\n"
".\\n"
"\")\r\n"
"\r\n"
"local newfenv = {}        -- create new environment just for this file\r\n"
"setmetatable(newfenv, {__index = up_G}) -- allow global access we are not trying to sandbox\r\n"
"setfenv(pp_input_lua, newfenv)    -- change this functions environment from the global one\r\n"
"\r\n"
"\r\n"
"local ret,_msg,_ret\r\n"
"\r\n"
"\r\n"
"	_lo_break=null\r\n"
"	\r\n"
"	ret,_ret=pcall(pp_input_lua)	-- not sure about scope here...\r\n"
"			\r\n"
"\r\n"
"	if ret~=true then\r\n"
"\r\n"
"		print('.\\n"
".\\n"
"')\r\n"
"		print(string.format('%s(%d):PP file location\\n"
"',_file or \"unknown\",_l or -1))\r\n"
"		assert(null,_ret..'\\n"
".\\n"
".\\n"
"')\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"-- write that table out as a string to the destination file\r\n"
"\r\n"
"\r\n"
"pp_output_string=table.concat(_ret)\r\n"
"\r\n"
"local fp\r\n"
"	fp=io.open(fname_out,\"w\")\r\n"
"	fp:write(pp_output_string)\r\n"
"	fp:close()\r\n"
"	fp=null\r\n"
"\r\n"
"end\r\n"
"\r\n"
"",

"wetgenes.gamecake.images","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local grd=require(\"wetgenes.grd\")\n"
"local zips=require(\"wetgenes.zips\")\n"
"local wsbox=require(\"wetgenes.sandbox\")\n"
"\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"function M.bake(oven,images)\n"
"	\n"
"	local opts=oven.opts\n"
"	local cake=oven.cake\n"
"	local gl=oven.gl\n"
"		\n"
"	images.data={}\n"
"	\n"
"	images.prefix=opts.grdprefix or \"data/\"\n"
"	images.postfix=opts.grdpostfix or { \".png\" , \".jpg\" }\n"
"\n"
"\n"
"images.get=function(id)\n"
"	return images.data[id]\n"
"end\n"
"\n"
"images.set=function(d,id)\n"
"	images.data[id]=d\n"
"end\n"
"\n"
"\n"
"--\n"
"-- unload a previously loaded image\n"
"--\n"
"images.unload=function(id)\n"
"	local t=images.get(id)\n"
"\n"
"	if t then\n"
"		if gl then --gl mode\n"
"				gl.DeleteTexture( t.id )\n"
"				t.id=nil	\n"
"		end\n"
"		images.set(nil,id)\n"
"	end\n"
"end\n"
"\n"
"-- do we have an image availble to load?\n"
"images.exists=function(filename)\n"
"\n"
"	local fname\n"
"	local fext\n"
"\n"
"	if type(images.postfix)==\"table\" then -- try a few formats\n"
"		for i,v in ipairs(images.postfix) do\n"
"			fext=v\n"
"			fname=images.prefix..filename..fext -- hardcode\n"
"			if zips.exists(fname) then  return true end -- found it\n"
"		end\n"
"	else\n"
"		fext=images.postfix\n"
"		fname=images.prefix..filename..fext -- hardcode\n"
"	end\n"
"	\n"
"	if zips.exists(fname) then  return true end -- found it\n"
"\n"
"end\n"
"\n"
"--\n"
"-- load a single image, and make it easy to lookup by the given id\n"
"--\n"
"images.load=function(filename,id)\n"
"	local t=images.get(id)\n"
"	\n"
"	if t then return t end --first check it is not already loaded\n"
"\n"
"--print(\"loading\",filename,id)\n"
"oven.preloader(filename)\n"
"\n"
"	local mname=images.prefix..filename..\".lua\"\n"
"	local fname\n"
"	local fext\n"
"	\n"
"	if type(images.postfix)==\"table\" then -- try a few formats\n"
"		for i,v in ipairs(images.postfix) do\n"
"			fext=v\n"
"			fname=images.prefix..filename..fext -- hardcode\n"
"			if zips.exists(fname) then  break end -- found it\n"
"		end\n"
"	else\n"
"		fext=images.postfix\n"
"		fname=images.prefix..filename..fext -- hardcode\n"
"	end\n"
"	\n"
"	local g=assert(grd.create())\n"
"	local d=assert(zips.readfile(fname),\"Failed to load \"..fname)\n"
"	assert(g:load_data(d,fext:sub(2))) -- skip extension period\n"
"\n"
"-- clamp to a maximum size\n"
"	local max_size=1024\n"
"	if g.width > max_size or g.height>max_size then\n"
"		local hx=g.width>max_size and max_size or g.width\n"
"		local hy=g.height>max_size and max_size or g.height\n"
"print(\"Max texture size converting \",g.width,g.height,\" to \",hx,hy)\n"
"		g:scale( hx , hy ,1)\n"
"	end\n"
"	\n"
"--	g:scale(g.width/2,g.height/2,1)\n"
"	\n"
"	if gl then --gl mode\n"
"	\n"
"		t={}\n"
"		images.upload_grd(t,g)\n"
"\n"
"		images.set(t,id)\n"
"		\n"
"		t.filename=filename\n"
"		\n"
"		local lson=zips.readfile(mname)\n"
"		if lson then -- check for lua metadata\n"
"			t.meta=wsbox.lson(lson) -- return it with the image\n"
"		end\n"
"		\n"
"		return t\n"
"\n"
"	end\n"
"	\n"
"end\n"
"\n"
"local function uptwopow(n)\n"
"\n"
"	if n<1 then return 0\n"
"	elseif n<=16   then return 16\n"
"	elseif n<=32   then return 32\n"
"	elseif n<=64   then return 64\n"
"	elseif n<=128  then return 128\n"
"	elseif n<=256  then return 256\n"
"	elseif n<=512  then return 512\n"
"	elseif n<=1024 then return 1024\n"
"	elseif n<=2048 then return 2048\n"
"	elseif n<=4096 then return 4096\n"
"	end\n"
"\n"
"	return 0\n"
"end\n"
"images.uptwopow=uptwopow\n"
"\n"
"images.upload_grd= function(t,g)\n"
"\n"
"	if not t then\n"
"		t={}\n"
"	end\n"
"	\n"
"	if not t.id then\n"
"		t.id=assert(gl.GenTexture())\n"
"	end\n"
"	\n"
"	t.x=0\n"
"	t.y=0\n"
"	t.width=g.width\n"
"	t.height=g.height\n"
"	\n"
"--	gl.extensions.ARB_texture_non_power_of_two=false\n"
"--	if gl.extensions.ARB_texture_non_power_of_two then\n"
"--		t.texture_width=g.width\n"
"--		t.texture_height=g.height\n"
"--	else -- need to place the image in a bigger texture and probably disable mipmaps.\n"
"	\n"
"-- always need powah of two so we may mipmap\n"
"-- probably best to keep textures powah of two if at all possible as well?\n"
"\n"
"		t.texture_width=uptwopow(g.width)\n"
"		t.texture_height=uptwopow(g.height)\n"
"\n"
"--	end\n"
"	\n"
"	gl.BindTexture( gl.TEXTURE_2D , t.id )\n"
"	\n"
"--	gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR)\n"
"--	gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR)\n"
"	gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE)\n"
"	gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE)\n"
"\n"
"--best mipmap?\n"
"	gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,t.TEXTURE_MIN_FILTER or images.TEXTURE_MIN_FILTER or gl.LINEAR_MIPMAP_LINEAR)\n"
"	gl.TexParameter(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,t.TEXTURE_MAG_FILTER or images.TEXTURE_MAG_FILTER or gl.LINEAR)\n"
"\n"
"\n"
"	if g.width==0 or g.height==0 then return t end -- no data to upload\n"
"	\n"
"--print(require(\"wetgenes.string\").dump(g))\n"
"--	if g.format==grd.FMT_U8_RGBA or g.format==grd.FMT_U8_RGBA_PREMULT then\n"
"		-- ok to upload as is\n"
"--	else\n"
"\n"
"		assert(g:convert(grd.FMT_U8_RGBA_PREMULT))\n"
"\n"
"--	end\n"
"\n"
"-- force powah of 2 sizes\n"
"if t.texture_width~=g.width or t.texture_height~=g.height then \n"
"		g:resize(t.texture_width,t.texture_height,1) -- resize keeping the image in the topleft corner\n"
"end\n"
"	\n"
"--local zero=string.rep(string.char(0,0,0,0), t.texture_width * t.texture_height)\n"
"\n"
"-- create a possibly bigger texture\n"
"	gl.TexImage2D(\n"
"		gl.TEXTURE_2D,\n"
"		0,\n"
"		gl.RGBA,\n"
"		t.texture_width,\n"
"		t.texture_height,\n"
"		0,\n"
"		gl.RGBA,\n"
"		gl.UNSIGNED_BYTE,\n"
"		g.data ) -- need to zero the texture?\n"
"\n"
"-- create mipmaps\n"
"	local w=g.width\n"
"	local h=g.height\n"
"	local idx=0\n"
"	while w>=2 or h>=2 do\n"
"		idx=idx+1\n"
"		w=math.ceil(w/2)\n"
"		h=math.ceil(h/2)\n"
"		g:scale(w,h,1)\n"
"--print(\"mipmap\",w,h)\n"
"		\n"
"\n"
"-- create a possibly bigger texture\n"
"		gl.TexImage2D(\n"
"			gl.TEXTURE_2D,\n"
"			idx,\n"
"			gl.RGBA,\n"
"			w,\n"
"			h,\n"
"			0,\n"
"			gl.RGBA,\n"
"			gl.UNSIGNED_BYTE,\n"
"			g.data ) -- need to zero the texture?\n"
"\n"
"gl.CheckError()\n"
"\n"
"	end\n"
"	\n"
"	return t\n"
"end\n"
"\n"
"--\n"
"-- load many images from id=filename table\n"
"--\n"
"images.loads=function(tab)\n"
"\n"
"	local function iorv(i,v) if type(i)==\"number\" then return v end return i end -- choose i or v\n"
"\n"
"	for i,v in pairs(tab) do\n"
"\n"
"		images.load(v,iorv(i,v))		\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"images.start = function()\n"
"\n"
"	if images.remember then\n"
"		for v,n in pairs(images.preload or {}) do\n"
"			images.load(v,n)\n"
"		end\n"
"	end\n"
"\n"
"	for v,n in pairs(images.remember or {}) do\n"
"		images.load(v,n)\n"
"	end\n"
"	images.remember=nil\n"
"end\n"
"\n"
"images.stop = function()\n"
"\n"
"	images.remember={}\n"
"	\n"
"	for n,t in pairs(images.data) do\n"
"		images.remember[t.filename]=n	\n"
"		images.unload(n)\n"
"	end\n"
"\n"
"end\n"
"\n"
"-- do a gl bind of this texture\n"
"images.bind = function(t)\n"
"	gl.BindTexture( gl.TEXTURE_2D , t.id )\n"
"end\n"
"	\n"
"	return images\n"
"end\n"
"\n"
"\n"
"",

"wetgenes.spew.client.comm","\n"
"\n"
"local comm=require(\"spew.comm\")\n"
"local util=require(\"spew.util\")\n"
"\n"
"local socket = require(\"socket\")\n"
"\n"
"local _G=_G\n"
"\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"local string=string\n"
"local math=math\n"
"local os=os\n"
"local print=print\n"
"\n"
"local unpack=unpack\n"
"local tostring=tostring\n"
"\n"
"\n"
"local spew_host=\"swf.wetgenes.com\"\n"
"--local spew_host=\"swf.wetgenes.local\"\n"
"local spew_port=5223\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- basic client communication with a spew server\n"
"-- uses lua sockets to connect\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module(\"spew.client.comm\")\n"
"\n"
"-- callback hooks\n"
"hooks={}\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- setup and connect to the spew server\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function setup()\n"
"\n"
"	con=comm.setup( socket.connect(spew_host,spew_port) , {format=\"spew\"} ) -- connect\n"
"	if not con then\n"
"		print( \"failed to connect to \"..spew_host )\n"
"	else\n"
"		if con.error then print(con.error) end\n"
"	end\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- clean and disconnect from the spew server\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function clean()\n"
"\n"
"	if con then\n"
"		comm.clean(con.client)\n"
"	end\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- This handles any incoming data waiting but does not block\n"
"-- so call it a few times a second, every frame should be good\n"
"-- the data will be processed and you will receive callbacks for events\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"function update()\n"
"\n"
"	local tab,_,err=socket.select(comm.recvt,nil,0.00001)\n"
"-- read from sockets\n"
"	for i,v in ipairs(tab or {}) do\n"
"	\n"
"			local p1, error ,p2 = v:receive(\"*a\")\n"
"			local line=p1 or p2\n"
"			\n"
"			if error==\"timeout\" then -- a timeout is not an error, it is actually success\n"
"				error=nil\n"
"			end\n"
"\n"
"			if error then -- error causes disconenct\n"
"			\n"
"				comm.disconnect(v)\n"
"				\n"
"			elseif line then -- got data\n"
"			\n"
"				comm.received(v , line)\n"
"				\n"
"			end\n"
"	end\n"
"	\n"
"-- handle any input\n"
"\n"
"	for client,con in pairs(comm.active) do\n"
"		for i,line in ipairs(con.linein) do\n"
"\n"
"-- as a client we only have one connection\n"
"			util.str_to_msg(line,con.msg)\n"
"			\n"
"			got_amsg(con.msg)\n"
"--			print(con.msg)\n"
"		end\n"
"		con.linein={} -- readit\n"
"	end\n"
"	comm.active={} -- clear active table\n"
"\n"
"end\n"
"\n"
"-- send a msg\n"
"function send(msg)\n"
"\n"
"	comm.send( con.client , util.msg_to_str(msg)..\"\\0\" )\n"
"\n"
"	if hooks.sent then hooks.sent(msg) end\n"
"end\n"
"\n"
"-- all msgs\n"
"function got_amsg(msg)\n"
"	if hooks.amsg then hooks.amsg(msg) end\n"
"	if msg.cmd==\"ville\" then\n"
"		got_vmsg(msg) \n"
"	else\n"
"		got_cmsg(msg)\n"
"	end\n"
"end\n"
"\n"
"-- chat msgs\n"
"function got_cmsg(msg)\n"
"--	print(msg.cmd)\n"
"	if hooks.cmsg then hooks.cmsg(msg) end\n"
"end\n"
"\n"
"-- game msgs\n"
"function got_gmsg(msg)\n"
"--	print(msg.gcmd)\n"
"	if hooks.gmsg then hooks.gmsg(msg) end\n"
"end\n"
"\n"
"-- ville msgs\n"
"function got_vmsg(msg)\n"
"--	print(msg.vcmd)\n"
"	if hooks.vmsg then hooks.vmsg(msg) end\n"
"end\n"
"\n"
"\n"
"\n"
"",

"wetgenes.gamecake.spew.scores","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"local wwin=require(\"wetgenes.win\") -- system independent helpers\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"local wsbox=require(\"wetgenes.sandbox\")\r\n"
"local lfs ; pcall( function() lfs=require(\"lfs\") end ) -- may not have a filesystem\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"M.bake=function(oven,scores)\r\n"
"\r\n"
"	scores=scores or {} \r\n"
"\r\n"
"	scores.filename=wwin.files_prefix..\"scores.lua\"\r\n"
"	scores.mode=\"none\" -- default mode\r\n"
"	\r\n"
"	local cake=oven.cake\r\n"
"	local canvas=cake.canvas\r\n"
"	\r\n"
"	local profiles=oven.rebake(\"wetgenes.gamecake.spew.profiles\")\r\n"
"\r\n"
"-- very very simple local score data\r\n"
"	local ss\r\n"
"\r\n"
"-- initialise scores data\r\n"
"	function scores.init()\r\n"
"		ss={}\r\n"
"		scores.mode=\"none\"\r\n"
"		scores.level=1\r\n"
"		\r\n"
"		ss.list={}\r\n"
"		ss.list[scores.mode]={}\r\n"
"		ss.list[scores.mode][scores.level]={}\r\n"
"	end\r\n"
"	\r\n"
"-- load all scores data\r\n"
"	function scores.load()\r\n"
"		if lfs then\r\n"
"print(\"Loading \"..scores.filename)\r\n"
"			local fp=io.open(scores.filename,\"r\")\r\n"
"			if fp then\r\n"
"				local s=fp:read(\"*all\")\r\n"
"				ss=wsbox.lson(s) -- safeish\r\n"
"				fp:close()\r\n"
"				return true\r\n"
"			end\r\n"
"		end\r\n"
"\r\n"
"		return false\r\n"
"	end\r\n"
"	\r\n"
"-- save all scores data\r\n"
"	function scores.save()\r\n"
"		if lfs then\r\n"
"print(\"Saving \"..scores.filename)\r\n"
"			local fp=io.open(scores.filename,\"w\")\r\n"
"			fp:write(wstr.serialize(ss))\r\n"
"			fp:close()\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	function scores.setup(max_up)\r\n"
"\r\n"
"		scores.show_high=true\r\n"
"\r\n"
"		max_up=max_up or 1\r\n"
"		scores.up={}\r\n"
"		for i=1,max_up do\r\n"
"			scores.up[i]={score=0,high=0} -- 1up 2up etc\r\n"
"		end\r\n"
"		scores.high=0\r\n"
"		for i,v in pairs( ss.list[scores.mode][scores.level] ) do\r\n"
"			if v.score>scores.high then scores.high=v.score end\r\n"
"		end\r\n"
"\r\n"
"		return scores -- so setup is chainable with a bake\r\n"
"	end\r\n"
"\r\n"
"	function scores.reset()\r\n"
"		for i,v in ipairs(scores.up) do\r\n"
"			v.score=0\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	function scores.add(num,up)\r\n"
"		up=up or 1\r\n"
"		local v=assert(scores.up[up])\r\n"
"		v.score=v.score+num\r\n"
"		if v.score>v.high then v.high=v.score end\r\n"
"		if v.score>scores.high then scores.high=v.score end\r\n"
"		return v.score\r\n"
"	end\r\n"
"\r\n"
"	function scores.get(up)\r\n"
"		up=up or 1\r\n"
"		local v=assert(scores.up[up])\r\n"
"		return v.score\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"	function scores.set(num,up)\r\n"
"		up=up or 1\r\n"
"		local v=assert(scores.up[up])\r\n"
"		v.score=num\r\n"
"		if v.score>v.high then v.high=v.score end\r\n"
"		if v.score>scores.high then scores.high=v.score end\r\n"
"		return v.score\r\n"
"	end\r\n"
"\r\n"
"	function scores.clean()\r\n"
"	end\r\n"
"\r\n"
"	function scores.update()	\r\n"
"	end\r\n"
"	\r\n"
"	function scores.draw(mode)\r\n"
"	\r\n"
"		local function draw_mid_text(x,y,s)\r\n"
"		\r\n"
"			local sw=canvas.font.width(s)\r\n"
"			\r\n"
"			oven.gl.Color(0,0,0,1)	\r\n"
"			canvas.font.set_xy( x-(sw/2)+1 , y+1 )\r\n"
"			canvas.font.draw(s)\r\n"
"		\r\n"
"			oven.gl.Color(1,1,1,1)	\r\n"
"			canvas.font.set_xy( x-(sw/2)-1 , y-1 )\r\n"
"			canvas.font.draw(s)\r\n"
"		\r\n"
"		end\r\n"
"		\r\n"
"-- display 1up Hi (2up) at top of screen in 8 bit font\r\n"
"-- with the scores on the line bellow\r\n"
"		if mode==\"arcade2\" then\r\n"
"\r\n"
"			local xh=canvas.layout.view_width\r\n"
"			local yh=canvas.layout.view_height		\r\n"
"			local fy=math.floor(yh/32)\r\n"
"\r\n"
"			canvas.font.set(cake.fonts.get(1))\r\n"
"			canvas.font.set(cake.fonts.get(1))\r\n"
"			canvas.font.set_size(fy,0)\r\n"
"\r\n"
"			local s=wstr.str_insert_number_commas(scores.up[1].score)\r\n"
"			draw_mid_text( (xh*3/16) , fy*0.25 , \"1up\")\r\n"
"			draw_mid_text( (xh*3/16) , fy*1.50 , s)\r\n"
"\r\n"
"			if scores.show_high then\r\n"
"				local s=wstr.str_insert_number_commas(scores.high)\r\n"
"				draw_mid_text( (xh*8/16) , fy*0.25 , \"Hi\")\r\n"
"				draw_mid_text( (xh*8/16) , fy*1.50 , s)\r\n"
"			end\r\n"
"\r\n"
"			if scores.up[2] then\r\n"
"				local s=wstr.str_insert_number_commas(scores.up[2].score)\r\n"
"				draw_mid_text( (xh*13/16) , fy*0.25 , \"2up\")\r\n"
"				draw_mid_text( (xh*13/16) , fy*1.50 , s)\r\n"
"			end\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"		\r\n"
"	function scores.msg(m)\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"	function scores.get_list(opts)\r\n"
"		local mode=opts.mode or scores.mode or \"none\"\r\n"
"		local level=opts.level or scores.level or 1\r\n"
"		if not ss.list then ss.list={} end\r\n"
"		if not ss.list[mode] then ss.list[mode]={} end\r\n"
"		if not ss.list[mode][level] then ss.list[mode][level]={} end	\r\n"
"		return ss.list[mode][level]\r\n"
"	end\r\n"
"\r\n"
"	function scores.get_high(opts)\r\n"
"		local r={}\r\n"
"		for i,v in ipairs( scores.get_list(opts) ) do\r\n"
"			local t=r[v.name] or v\r\n"
"			if (v.score>t.score) or ( (v.score==t.score) and (v.time<=t.time) ) then\r\n"
"				r[v.name]=v\r\n"
"			end\r\n"
"		end\r\n"
"		return r\r\n"
"	end\r\n"
"\r\n"
"-- get a list of scores data\r\n"
"	function scores.list(opts)\r\n"
"		\r\n"
"		\r\n"
"		local ret={}\r\n"
"\r\n"
"		local order=opts.order or \"high\"\r\n"
"		local offset=opts.offset or 1\r\n"
"		local limit=opts.limit or 10\r\n"
"\r\n"
"		local t\r\n"
"		\r\n"
"		if order==\"high\" then -- normal high score list, one score per name\r\n"
"		\r\n"
"			t=scores.high_to_list(scores.get_high(opts))			\r\n"
"\r\n"
"		else\r\n"
"\r\n"
"			t=scores.high_to_list(scores.get_list(opts))			\r\n"
"		\r\n"
"		end\r\n"
"		\r\n"
"		if t then\r\n"
"			for i=offset,offset+limit do\r\n"
"				if t[i] then\r\n"
"					t[i].idx=i -- refresh idx\r\n"
"					ret[#ret+1]=t[i]\r\n"
"				end\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"		return ret	\r\n"
"	end\r\n"
"	\r\n"
"	function scores.high_to_list(t)\r\n"
"		local k={}\r\n"
"		for i,v in pairs(t) do k[#k+1]=v end		\r\n"
"		table.sort(k,function(a,b) -- sort by score then time\r\n"
"			if a.score==b.score then\r\n"
"				return a.time<b.time\r\n"
"			end\r\n"
"			return a.score>b.score\r\n"
"		end)\r\n"
"		return k\r\n"
"	end	\r\n"
"\r\n"
"	function scores.get_best_score(opts)\r\n"
"		local name=opts.name or profiles.get(\"name\")\r\n"
"		local h=scores.get_high(opts)\r\n"
"		return h[name]\r\n"
"	end\r\n"
"	\r\n"
"	function scores.final_score(opts)\r\n"
"\r\n"
"		local score=opts.score or scores.up[1].score\r\n"
"	\r\n"
"		local scr={}\r\n"
"		\r\n"
"		scr.idx=0\r\n"
"		scr.time=opts.time or os.time()\r\n"
"		scr.name=opts.name or profiles.get(\"name\")\r\n"
"		scr.score=opts.score or scores.up[1].score\r\n"
"		scr.pid=opts.pid or profiles.pid -- which profile slot this is associated with\r\n"
"		\r\n"
"		local t=scores.get_list(opts)\r\n"
"		t[#t+1]=scr -- insert\r\n"
"		\r\n"
"		local s=scores.high_to_list(t)\r\n"
"		for i=1,#s do\r\n"
"			s[i].idx=i\r\n"
"		end\r\n"
"\r\n"
"		scores.save() -- always save new scores to disk\r\n"
"		\r\n"
"		if wwin.smell==\"gamestick\" then\r\n"
"			if wwin.hardcore.smell_score_send then wwin.hardcore.smell_score_send(score) end\r\n"
"		end\r\n"
"\r\n"
"		return scr\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"--make sure we have a dir to load/save profiles into\r\n"
"if lfs then\r\n"
"lfs.mkdir(wwin.files_prefix:sub(1,-2)) -- skip trailing slash\r\n"
"end\r\n"
"\r\n"
"-- try autoload\r\n"
"scores.init()\r\n"
"if not scores.load() then\r\n"
"-- or create and save a default file\r\n"
"	scores.init()\r\n"
"	scores.save()\r\n"
"end\r\n"
"\r\n"
"	return scores\r\n"
"end\r\n"
"",

"wetgenes.sandbox","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"--\n"
"-- Simple sandboxing of lua functions\n"
"--\n"
"\n"
"\n"
"-- make a table to be used as a reasonably \"safe\" environment\n"
"-- code can still lock up in loops or allocate too much memory\n"
"-- but it doesnt get to jump out of its sandbox\n"
"\n"
"local function local_make_env_safe()\n"
"local env={\n"
"	assert=assert,\n"
"	error=error,\n"
"	ipairs=ipairs,\n"
"	pairs=pairs,\n"
"	next=next,\n"
"	pcall=pcall,\n"
"	select=select,\n"
"	tonumber=tonumber,\n"
"	tostring=tostring,\n"
"	type=type,\n"
"	unpack=unpack,\n"
"	xpcall=xpcall,\n"
"	coroutine={\n"
"		create=coroutine and coroutine.create,\n"
"		resume=coroutine and coroutine.resume,\n"
"		running=coroutine and coroutine.running,\n"
"		status=coroutine and coroutine.status,\n"
"		wrap=coroutine and coroutine.wrap,\n"
"		yield=coroutine and coroutine.yield,\n"
"	},\n"
"	table={\n"
"		concat=table and table.concat,\n"
"		insert=table and table.insert,\n"
"		maxn=table and table.maxn,\n"
"		remove=table and table.remove,\n"
"		sort=table and table.sort,\n"
"	},\n"
"	string={\n"
"		byte=string and string.byte,\n"
"		char=string and string.char,\n"
"		find=string and string.find,\n"
"		format=string and string.format,\n"
"		gmatch=string and string.gmatch,\n"
"		gsub=string and string.gsub,\n"
"		len=string and string.len,\n"
"		lower=string and string.lower,\n"
"		match=string and string.match,\n"
"		rep=string and string.rep,\n"
"		reverse=string and string.reverse,\n"
"		sub=string and string.sub,\n"
"		upper=string and string.upper,\n"
"	},\n"
"	math={\n"
"		abs=math and math.abs,\n"
"		acos=math and math.acos,\n"
"		asin=math and math.asin,\n"
"		atan=math and math.atan,\n"
"		atan2=math and math.atan2,\n"
"		ceil=math and math.ceil,\n"
"		cos=math and math.cos,\n"
"		cosh=math and math.cosh,\n"
"		deg=math and math.deg,\n"
"		exp=math and math.exp,\n"
"		floor=math and math.floor,\n"
"		fmod=math and math.fmod,\n"
"		frexp=math and math.frexp,\n"
"		huge=math and math.huge,\n"
"		ldexp=math and math.ldexp,\n"
"		log=math and math.log,\n"
"		log10=math and math.log10,\n"
"		max=math and math.max,\n"
"		min=math and math.min,\n"
"		modf=math and math.modf,\n"
"		pi=math and math.pi,\n"
"		pow=math and math.pow,\n"
"		rad=math and math.rad,\n"
"		random=math and math.random, -- should replace with sandboxed versions\n"
"		randomseed=math and math.randomseed, -- should replace with sandboxed versions\n"
"		sin=math and math.sin,\n"
"		sinh=math and math.sinh,\n"
"		sqrt=math and math.sqrt,\n"
"		tan=math and math.tan,\n"
"		tanh=math and math.tanh,\n"
"	},\n"
"	os={\n"
"		clock=os and os.clock,\n"
"		date=os and os.date, -- this can go boom in some situations?\n"
"		difftime=os and os.difftime,\n"
"		time=os and os.time,\n"
"	},\n"
"}\n"
"\n"
"-- a modified loadstring that can set its function environment\n"
"-- setfenv is probably quite dangerous to expose, too much opportunity for\n"
"-- mischief on any function the sandbox code is given access to\n"
"-- it is however safe in this use since its your function that was just\n"
"-- loadstringed\n"
"	env.loadstring=function(s,newenv)\n"
"		local f,e=loadstring(s)\n"
"		if f then setfenv(f,newenv or env) end\n"
"		return f,e\n"
"	end\n"
"\n"
"	return env\n"
"end\n"
"\n"
"\n"
"\n"
"module(\"wetgenes.sandbox\")\n"
"\n"
"--\n"
"-- get a functional environment full of useful but \"safe\" functions\n"
"--\n"
"function make_env(opts)\n"
"\n"
"local env=local_make_env_safe()\n"
"\n"
"	return env\n"
"end\n"
"\n"
"--\n"
"-- turns a string containing lua code into a table containing the globals it sets\n"
"-- IE read an ini file, run it through this\n"
"--\n"
"function ini(s)\n"
"\n"
"	local env=make_env()\n"
"	local tab={}\n"
"	local meta={__index=env}\n"
"	env._G=tab\n"
"	setmetatable(tab, meta)\n"
"\n"
"	local f=assert(loadstring(s))\n"
"	setfenv(f,tab)\n"
"	assert(pcall(f))\n"
"\n"
"	return tab\n"
"end\n"
"\n"
"-- this performs the opposite of a string.serialize\n"
"function lson(s)\n"
"\n"
"	local env=make_env()\n"
"	local tab={}\n"
"	local meta={__index=env}\n"
"	env._G=tab\n"
"	setmetatable(tab, meta)\n"
"\n"
"	local f=assert(loadstring(\"return \"..s))\n"
"	setfenv(f,tab)\n"
"	local _,ret=assert(pcall(f))\n"
"	return ret\n"
"end\n"
"",

"wetgenes.gamecake.spew.gui","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local function print(...) _G.print(...) end\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"local wwin=require(\"wetgenes.win\")\n"
"local pack=require(\"wetgenes.pack\")\n"
"\n"
"local snames=require(\"wetgenes.gamecake.spew.names\")\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"\n"
"M.bake=function(oven,gui)\n"
"\n"
"	gui=gui or {} \n"
"	gui.modname=M.modname\n"
"\n"
"	gui.strings={} -- put user type strings here\n"
"\n"
"	gui.clicks={} -- put onclick function in here\n"
"	gui.pages={} -- put functions to fill in pages in here\n"
"\n"
"	local cake=oven.cake\n"
"	local sounds=cake.sounds\n"
"	local canvas=cake.canvas\n"
"	local layout=cake.layouts.create{}\n"
"	local flat=canvas.flat\n"
"	\n"
"	local gl=oven.gl\n"
"\n"
"	local wetiso=oven.rebake(\"wetgenes.gamecake.spew.geom_wetiso\")\n"
"	local geom=oven.rebake(\"wetgenes.gamecake.spew.geom\")\n"
"\n"
"--	function gui.returnpage()\n"
"--		gui.active=false -- stop displaying our stuff\n"
"--	end\n"
"	function gui.mpage(pname) --request that we go to this page please?\n"
"		gui.active=false -- stop displaying our stuff\n"
"		if gui.page_hook then\n"
"			gui.page_hook(pname)\n"
"		end\n"
"	end\n"
"\n"
"	function gui.setup(parent)\n"
"		if parent then\n"
"			gui.parent=parent\n"
"			gui.master=parent.master\n"
"		end\n"
"		wetiso.setup()\n"
"		gui.time=0\n"
"\n"
"	end\n"
"	\n"
"	local wdata=oven.rebake(\"wetgenes.gamecake.widgets.data\")\n"
"	local mkeys=oven.rebake(\"wetgenes.gamecake.mods.keys\")\n"
"	local sprofiles=oven.rebake(\"wetgenes.gamecake.spew.profiles\")\n"
"	local sscores=oven.rebake(\"wetgenes.gamecake.spew.scores\")\n"
"\n"
"	local ssettings=oven.rebake(\"wetgenes.gamecake.spew.settings\")\n"
"	\n"
"\n"
"\n"
"--	local bpages=oven.rebake(\"bulb.pages\")\n"
"	\n"
"	gui.ids={}\n"
"	gui.data={}\n"
"	function gui.initdata() -- call this later\n"
"\n"
"		gui.offset=1\n"
"		\n"
"		gui.data.mode=1\n"
"--		gui.data.score=0\n"
"		gui.data.name=wdata.new_data({class=\"string\",hooks=gui.hooks})\n"
"		gui.data.vol_music=wdata.new_data({id=\"vol_music\",class=\"number\",hooks=gui.hooks,num=ssettings.get(\"vol_music\")*11,min=0,max=11,step=1})\n"
"		gui.data.vol_sfx=wdata.new_data({id=\"vol_sfx\",class=\"number\",hooks=gui.hooks,num=ssettings.get(\"vol_sfx\")*11,min=0,max=11,step=1})\n"
"\n"
"	end\n"
"	\n"
"	function gui.set_all_values()\n"
"		local ids=gui.master.ids\n"
"		local d=gui.data\n"
"--		if ids.menu_gamemode then ids.menu_gamemode.text=d.modes[d.mode].title end\n"
"	end\n"
"	\n"
"	\n"
"local beep_play=function() end\n"
"	\n"
"	\n"
"	function gui.hooks(act,widget)\n"
"\n"
"		if gui.beep_hook then\n"
"			beep_play=gui.beep_hook.play\n"
"		else\n"
"			beep_play=function() end\n"
"		end\n"
"\n"
"		local d=gui.data\n"
"		local id=widget and widget.id\n"
"\n"
"		if act==\"value\" then\n"
"			if     id==\"vol_music\" then\n"
"				ssettings.set(\"vol_music\",widget.num/11)\n"
"			elseif id==\"vol_sfx\" then\n"
"				ssettings.set(\"vol_sfx\",widget.num/11)\n"
"			end\n"
"		end\n"
"		\n"
"\n"
"		if act==\"over\" then gui.anim.bounce(widget,0.25) end\n"
"\n"
"		if act==\"click\" then\n"
"		\n"
"print(\"click\",id)\n"
"\n"
"			if gui.clicks[id] then\n"
"				return gui.clicks[id](act,widget)\n"
"			end\n"
"\n"
"\n"
"			if id==\"profiles_select\" then\n"
"			\n"
"				beep_play(\"button\")\n"
"			\n"
"				sprofiles.select(widget.user)\n"
"				gui.page(\"profile\")\n"
"				\n"
"			elseif id==\"profile_name_clear\" then\n"
"\n"
"				beep_play(\"button\")\n"
"\n"
"				gui.data.name:value( \"\" )\n"
"				\n"
"			elseif id==\"profile_name_rand\" then\n"
"\n"
"				beep_play(\"button\")\n"
"\n"
"				gui.data.name:value( snames.random() )\n"
"\n"
"			elseif id==\"profile_name_edit\" then\n"
"			\n"
"				beep_play(\"button\")\n"
"\n"
"				gui.page(\"profile_name_edit\")\n"
"				\n"
"			elseif id==\"profile_name_set\" then\n"
"			\n"
"				beep_play(\"button\")\n"
"\n"
"				sprofiles.set(\"name\",gui.data.name:value())\n"
"				gui.page(\"profile\")\n"
"\n"
"			elseif id==\"profile_return\" then\n"
"			\n"
"				beep_play(\"button\")\n"
"\n"
"				gui.mpage(\"menu\")\n"
"				\n"
"			elseif id==\"profile_goto\" then\n"
"\n"
"				beep_play(\"button\")\n"
"\n"
"				gui.page(widget.user)\n"
"			\n"
"			elseif id==\"profile_cancel\" then\n"
"			\n"
"				beep_play(\"button\")\n"
"\n"
"					if widget.user then\n"
"						gui.page(widget.user)\n"
"					else\n"
"						gui.mpage(\"menu\")	\n"
"					end\n"
"\n"
"			elseif id==\"score_list\" then\n"
"\n"
"				beep_play(\"button\")\n"
"\n"
"--				gui.offset=1\n"
"				gui.page(\"score_list\")\n"
"\n"
"			elseif id==\"score_brag\" then\n"
"\n"
"				beep_play(\"button\")\n"
"\n"
"				local score=sscores.up[1].score\n"
"				if wwin.hardcore.send_intent then -- we have a way to brag\n"
"					if gui.strings.brag then\n"
"						wwin.hardcore.send_intent(wstr.replace(\n"
"							gui.strings.brag,\n"
"							{\n"
"								score=wstr.str_insert_number_commas(score)\n"
"							}))\n"
"					end\n"
"				end\n"
"				gui.mpage(\"menu\") -- callback to return to original menu			\n"
"			end\n"
"		end\n"
"	\n"
"	end\n"
"\n"
"	\n"
"	function gui.add_part(top,name)\n"
"--[[\n"
"		if name==\"profile_bar\" then\n"
"			local bback\n"
"			if gui.page_name==\"profile\" then bback=\"profiles\" end\n"
"			top:add({sx=110,sy=40,color=0xffcccccc,text=\"OK\",id=\"profile_ok\",hooks=gui.hooks,user=bback})\n"
"			top:add({sx=100,sy=40})\n"
"			top:add({sx=110,sy=40,color=0xffcccccc,text=\"Cancel\",id=\"profile_cancel\",hooks=gui.hooks,user=bback})\n"
"		end\n"
"]]\n"
"	end\n"
"\n"
"\n"
"	function gui.pages.profiles(master)\n"
"\n"
"		local top=master:add({hx=320,hy=480,class=\"fill\",font=\"Vera\",text_size=24})\n"
"\n"
"		top:add({hx=320,hy=110,text=\"Choose profile.\",text_color=0xffffffff})\n"
"\n"
"		for i,v in sprofiles.ipairs() do\n"
"			top:add({hx=320,hy=20})\n"
"			top:add({hx=20,hy=50})\n"
"			top:add({hx=280,hy=50,color=0xffcccccc,text=v.name,id=\"profiles_select\",hooks=gui.hooks,user=i})\n"
"			top:add({hx=20,hy=50})\n"
"		end\n"
"		top:add({hx=320,hy=20})\n"
"\n"
"		master.go_back_id=\"profiles_select\"\n"
"		master.go_forward_id=\"profiles_select\"\n"
"		\n"
"	end\n"
"		\n"
"	function gui.pages.profile(master)\n"
"		local top=master:add({hx=320,hy=480,class=\"fill\",font=\"Vera\",text_size=24})\n"
"		\n"
"		gui.data.name:value( sprofiles.get(\"name\") )\n"
"\n"
"		top:add({hx=320,hy=20})\n"
"		top:add({hx=320,hy=40,text_color=0xffffffff,text=\"My name is\"})\n"
"		top:add({hx=320,hy=20})\n"
"\n"
"		top:add({hx=20,hy=40})\n"
"		top:add({hx=280,hy=40,color=0xffcccccc,text=gui.data.name:value(),id=\"profile_name_edit\",hooks=gui.hooks})\n"
"		top:add({hx=20,hy=40})\n"
"\n"
"		top:add({hx=200,hy=40})\n"
"		top:add({hx=100,hy=40,color=0xffcccccc,text=\"Edit\",id=\"profile_name_edit\",hooks=gui.hooks})\n"
"		top:add({hx=20,hy=40})\n"
"\n"
"		top:add({hx=320,hy=40*7})\n"
"\n"
"		top:add({hx=110,hy=40,color=0xffcccccc,text=\"OK\",id=\"profile_return\",hooks=gui.hooks})\n"
"		top:add({hx=100,hy=40})\n"
"		top:add({hx=110,hy=40,color=0xffcccccc,text=\"Cancel\",id=\"profile_goto\",hooks=gui.hooks,user=\"profiles\"})\n"
"\n"
"		master.go_back_id=\"profile_return\"\n"
"		master.go_forward_id=\"profile_return\"\n"
"\n"
"	end\n"
"\n"
"	function gui.pages.profile_name_edit(master)\n"
"		local top=master:add({hx=320,hy=480,class=\"fill\",font=\"Vera\",text_size=24})\n"
"		\n"
"		gui.data.name:value( sprofiles.get(\"name\") )\n"
"\n"
"		top:add({hx=320,hy=80,text_color=0xffffffff,text=\"Type your name\"})\n"
"\n"
"		top:add({hx=20,hy=40})\n"
"		top:add({hx=280,hy=40,color=0xffcccccc,data=gui.data.name,id=\"profile_name\",hooks=gui.hooks,class=\"textedit\"})\n"
"		top:add({hx=20,hy=40})\n"
"\n"
"		top:add({hx=20,hy=40})\n"
"		top:add({hx=120,hy=40,color=0xffcccccc,text=\"Clear\",id=\"profile_name_clear\",hooks=gui.hooks})\n"
"		top:add({hx=40,hy=40})\n"
"		top:add({hx=120,hy=40,color=0xffcccccc,text=\"Random\",id=\"profile_name_rand\",hooks=gui.hooks})\n"
"		top:add({hx=20,hy=40})\n"
"		\n"
"		top:add({hx=320,hy=40})\n"
"		top:add({hx=320,hy=40})\n"
"\n"
"		top:add({hx=110,hy=40,color=0xffcccccc,text=\"OK\",id=\"profile_name_set\",hooks=gui.hooks})\n"
"		top:add({hx=100,hy=40})\n"
"		top:add({hx=110,hy=40,color=0xffcccccc,text=\"Cancel\",id=\"profile_goto\",hooks=gui.hooks,user=\"profile\"})\n"
"\n"
"		top:add({hx=320,hy=40})\n"
"\n"
"		local m=top:add({hx=320,hy=160})		\n"
"		mkeys.setup_keyboard_widgets(m)\n"
"		\n"
"		master.go_back_id=\"profile_name_set\"\n"
"		master.go_forward_id=\"profile_name_set\"\n"
"\n"
"	end\n"
"\n"
"	function gui.pages.score(master)\n"
"\n"
"		local score=sscores.up[1].score\n"
"		local best=sscores.list({})[1]			best=(best and best.score) or 0\n"
"		local mine=sscores.get_best_score({})	mine=(mine and mine.score) or 0\n"
"		if best<score then best=score end\n"
"		if mine<score then mine=score end\n"
"\n"
"		local best_pct=0\n"
"		local mine_pct=0\n"
"		if best<1 then best_pct=0 else best_pct=math.floor(100*score/best) end\n"
"		if mine<1 then mine_pct=0 else mine_pct=math.floor(100*score/mine) end\n"
"\n"
"\n"
"		gui.clicks.score_back=function()\n"
"			beep_play(\"button\")\n"
"			gui.mpage(\"menu\") -- callback to return to original menu			\n"
"		end\n"
"		\n"
"\n"
"\n"
"		local top=master:add({hx=320,hy=480,class=\"fill\",font=\"Vera\",text_size=24})\n"
"		top:add({hx=320,hy=40})\n"
"\n"
"		top:add({hx=320,hy=80,text_color=0xffffffff,text=\"You scored \"..wstr.str_append_english_number_postfix(gui.offset)..\"!\"})\n"
"		\n"
"		top:add({hx=20,hy=40})\n"
"		top:add({hx=280,hy=40,color=0xffcccccc,text=wstr.str_insert_number_commas(score)})\n"
"		top:add({hx=20,hy=40})\n"
"		\n"
"		top:add({hx=320,hy=40})\n"
"\n"
"		top:add({hx=20,hy=40})\n"
"		if oven.opts.smell==\"gamestick\" then -- hide brag button\n"
"			top:add({hx=130,hy=40})\n"
"		else\n"
"			top:add({hx=130,hy=40,color=0xffcccccc,text=\"Brag\",id=\"score_brag\",hooks=gui.hooks})\n"
"		end\n"
"		top:add({hx=20,hy=40})\n"
"		top:add({hx=130,hy=40,color=0xffcccccc,text=\"List\",id=\"score_list\",hooks=gui.hooks})\n"
"--		top:add({hx= 5,hy=40})\n"
"--		top:add({hx=90,hy=40,color=0xffcccccc,text=\"Send\",id=\"profile_score_send\",hooks=gui.hooks})\n"
"		top:add({hx=20,hy=40})\n"
"\n"
"		top:add({hx=320,hy=40})\n"
"		top:add({hx=320,hy=60,text_color=0xffffffff,text=\"\"..best_pct..\"% success\"})\n"
"		top:add({hx=320,hy=60,text_color=0xffffffff,text=\"\"..mine_pct..\"% effort\"})\n"
"		top:add({hx=320,hy=40})\n"
"\n"
"		top:add({hx=120,hy=40,color=0xffcccccc,text=\"Back\",id=\"score_back\",hooks=gui.hooks})\n"
"		top:add({hx=200,hy=40})\n"
"		\n"
"		master.go_back_id=\"score_back\"\n"
"		master.go_forward_id=\"score_list\"\n"
"		\n"
"	end\n"
"\n"
"	function gui.pages.score_list(master)\n"
"\n"
"		gui.clicks.score_list_less=function()\n"
"			beep_play(\"button\")\n"
"			gui.offset=gui.offset-5\n"
"			gui.page(\"score_list\")\n"
"		end\n"
"		gui.clicks.score_list_more=function()\n"
"			beep_play(\"button\")\n"
"			gui.offset=gui.offset+5\n"
"			gui.page(\"score_list\")\n"
"		end\n"
"		gui.clicks.score_list_exit=function()\n"
"			beep_play(\"button\")\n"
"			gui.offset=1\n"
"			gui.mpage(\"menu\") -- callback to return to original menu			\n"
"		end\n"
"	\n"
"		if gui.offset<1 then\n"
"			gui.offset=1\n"
"		end\n"
"\n"
"		local top=master:add({hx=320,hy=480,class=\"fill\",font=\"Vera\",text_size=24})\n"
"		\n"
"		local tab={}\n"
"\n"
"		\n"
"		local fill=function()\n"
"		\n"
"			top:clean_all()\n"
"		\n"
"			local b=top:add({hx=320,hy=90,class=\"fill\",font=\"Vera\",text_size=24,id=\"score_title\"})			\n"
"\n"
"			b:add({hx=320,hy=5})\n"
"\n"
"			b:add({hx=20,hy=30})\n"
"			b:add({hx=280,hy=30,text_color=0xffffffff,text=\"High Scores\",id=\"score_title_text\"})\n"
"			b:add({hx=20,hy=30})\n"
"\n"
"			b:add({hx=320,hy=5})\n"
"\n"
"			b:add({hx=320,hy=50})\n"
"\n"
"			for i=1,5 do\n"
"				local v=tab[i]\n"
"\n"
"				if v then\n"
"\n"
"					local b=top:add({hx=320,hy=70,class=\"fill\",font=\"Vera\",text_size=24,id=\"score_block\"})			\n"
"\n"
"					b:add({hx=320,hy=5})\n"
"\n"
"					b:add({hx=5,hy=60})\n"
"\n"
"					local s=b:add({hx=310,hy=60,class=\"fill\"})			\n"
"					s:add(\n"
"						{hx=100,hy=30,color=0xffcccccc,text=wstr.str_append_english_number_postfix(v.idx),hooks=gui.hooks,id=\"score_part\"},\n"
"						{hx=210,hy=30,color=0xffcccccc,text=wstr.str_insert_number_commas(v.score),hooks=gui.hooks,id=\"score_part\"},\n"
"						{hx=310,hy=30,color=0xffcccccc,text=v.name,hooks=gui.hooks,id=\"score_part\"})\n"
"\n"
"					b:add({hx=5,hy=60})\n"
"\n"
"					b:add({hx=320,hy=5})\n"
"				else\n"
"\n"
"					top:add({hx=320,hy=70})\n"
"				\n"
"				end\n"
"			end\n"
"			\n"
"			\n"
"			if gui.offset>1 then\n"
"				top:add({hx=100,hy=40,color=0xffcccccc,text=\"Back\",id=\"score_list_less\",hooks=gui.hooks})\n"
"				top:add({hx=10,hy=40})\n"
"			else\n"
"				top:add({hx=110,hy=40})\n"
"			end\n"
"\n"
"			top:add({hx=100,hy=40,color=0xffcccccc,text=\"Exit\",id=\"score_list_exit\",hooks=gui.hooks})\n"
"\n"
"			if nomore then\n"
"				top:add({hx=110,hy=40})\n"
"			else\n"
"				top:add({hx=10,hy=40})\n"
"				top:add({hx=100,hy=40,color=0xffcccccc,text=\"More\",id=\"score_list_more\",hooks=gui.hooks})\n"
"			end\n"
"		end\n"
"		\n"
"\n"
"		if wwin.smell==\"gamestick\" then\n"
"		\n"
"			gui.msg_smell_hook=function(m)\n"
"\n"
"--print(gui.msg_smell_hook,wstr.dump(m))\n"
"\n"
"--				if m.class==\"LeaderBoard\" then\n"
"					if m.data then\n"
"						for i=1,5 do\n"
"							for _,v in ipairs(m.data) do\n"
"								if v.position==gui.offset+i-1 then\n"
"									tab[i]={\n"
"										idx=tonumber(v.position or 0) or 0,\n"
"										name=v.name,\n"
"										score=tonumber(v.score or 0) or 0,\n"
"									}\n"
"								end\n"
"							end\n"
"						end\n"
"\n"
"						fill()\n"
"\n"
"						gui.master:layout()\n"
"						\n"
"					end\n"
"--				end\n"
"			end\n"
"		\n"
"			if wwin.hardcore.smell_score_range then wwin.hardcore.smell_score_range(gui.offset,gui.offset+4) end\n"
"			\n"
"		else\n"
"		\n"
"			local sc=sscores.list({offset=gui.offset,order=\"full\"})\n"
"			local nomore=not sc[6]\n"
"			for i=1,5 do\n"
"				local v=sc[i]\n"
"				if v then\n"
"					tab[i]={\n"
"						idx=v.idx,\n"
"						name=v.name,\n"
"						score=v.score,\n"
"					}\n"
"				end\n"
"			end\n"
"\n"
"		end\n"
"		\n"
"				\n"
"		fill()\n"
"\n"
"		master.go_back_id=\"score_list_less\"\n"
"		master.go_forward_id=\"score_list_exit\"\n"
"\n"
"	end\n"
"\n"
"	function gui.pages.settings(master)\n"
"	\n"
"		gui.clicks.settings_return=function()\n"
"			beep_play(\"button\")\n"
"			gui.mpage(\"menu\")\n"
"		end\n"
"		gui.clicks.settings_quit=function()\n"
"			beep_play(\"button\")\n"
"			gui.page(\"quit\")\n"
"		end\n"
"		gui.clicks.settings_game=function()\n"
"			beep_play(\"button\")\n"
"			if not gui.mpage(\"settings_game\") then gui.mpage(\"menu\") end\n"
"		end\n"
"		gui.clicks.settings_scores=function()\n"
"			beep_play(\"button\")\n"
"			gui.page(\"score_list\")\n"
"		end\n"
"		gui.clicks.settings_about=function()\n"
"			beep_play(\"button\")\n"
"			oven.next=oven.rebake(gui.about or \"wetgenes.gamecake.spew.about.sinescroll\")\n"
"		end\n"
"\n"
"		local top=master:add({hx=320,hy=480,class=\"fill\",font=\"Vera\",text_size=24})\n"
"\n"
"		top:add({hx=100,hy=40,color=0xffcccccc,text=\"Main\",id=\"settings_main\",hooks=gui.hooks})\n"
"		top:add({hx=10,hy=40})\n"
"		top:add({hx=100,hy=40,color=0xffcccccc,text=\"Game\",id=\"settings_game\",hooks=gui.hooks})\n"
"		top:add({hx=10,hy=40})\n"
"		top:add({hx=100,hy=40,color=0xffcccccc,text=\"Scores\",id=\"settings_scores\",hooks=gui.hooks})\n"
"\n"
"		top:add({hx=320,hy=40,text_color=0xffffffff,text=\"Music volume\"})\n"
"		top:add({class=\"slide\",color=0xffcccccc,hx=320,hy=40,datx=gui.data.vol_music,data=gui.data.vol_music,hooks=gui.hooks})\n"
"		top:add({hx=320,hy=40,text_color=0xffffffff,text=\"Sound effects volume\"})\n"
"		top:add({class=\"slide\",color=0xffcccccc,hx=320,hy=40,datx=gui.data.vol_sfx,data=gui.data.vol_sfx,hooks=gui.hooks})\n"
"\n"
"\n"
"		local t=top:add({hx=320,hy=40,class=\"fill\",font=\"Vera\",text_size=12,text_color=0xffffffff})\n"
"		t:add{hx=320,hy=20,text=oven.opts.title}\n"
"		t:add{hx=320,hy=20,text=\"\"}\n"
"\n"
"		top:add({hx=320,hy=40,color=0xffcccccc,text=\"About\",id=\"settings_about\",hooks=gui.hooks}):\n"
"			add{hx=80,hy=80,px=20,py=-20}.draw=function(w)\n"
"			w:draw_base(function(w)\n"
"				gl.Color(0,0.25,0.75,1)\n"
"				gl.PushMatrix()\n"
"				gl.Translate(w.hy*0.5,w.hy*0.5,0)\n"
"				gl.Scale(w.hy,w.hy,w.hy)\n"
"				gl.Rotate(gui.time,0,-1,0)\n"
"				gl.Rotate(gui.time/8,1,0,0)\n"
"				gl.Enable(gl.CULL_FACE)\n"
"				wetiso.draw()\n"
"				gl.Disable(gl.CULL_FACE)\n"
"				gl.PopMatrix()\n"
"			end)\n"
"		end\n"
"		\n"
"		local v= ( oven.opts.bake and oven.opts.bake.version ) or 0\n"
"\n"
"		local t=top:add({hx=320,hy=40,class=\"fill\",font=\"Vera\",text_size=12,text_color=0xffffffff})\n"
"		t:add{hx=320,hy=20,text=\"\"}\n"
"		t:add{hx=320,hy=20,text=(wwin.smell or \"vanilla\") .. \" build v\".. v}\n"
"\n"
"						\n"
"						\n"
"		top:add({hx=320,hy=40*3})\n"
"\n"
"		top:add({hx=120,hy=40,color=0xffcccccc,text=\"Back\",id=\"settings_return\",hooks=gui.hooks})\n"
"		top:add({hx=80,hy=40})\n"
"		top:add({hx=120,hy=40,color=0xffcc4444,text=\"Quit\",id=\"settings_quit\",hooks=gui.hooks})\n"
"\n"
"		master.go_back_id=\"settings_return\"\n"
"		master.go_forward_id=\"settings_return\"\n"
"\n"
"	end\n"
"	\n"
"	function gui.pages.quit(master)\n"
"\n"
"		gui.clicks.quit_back=function()\n"
"			beep_play(\"button\")\n"
"			gui.mpage(\"menu\")\n"
"--			gui.page(\"settings\")\n"
"		end\n"
"		gui.clicks.quit_exit=function()\n"
"			beep_play(\"button\")\n"
"			oven.next=true -- really quit\n"
"		end\n"
"				\n"
"		local top=master:add({hx=320,hy=480,class=\"fill\",font=\"Vera\",text_size=24})\n"
"\n"
"		top:add({hx=320,hy=40*3})\n"
"\n"
"		top:add({hx=320,hy=40*2,text_color=0xffffffff,text=\"Are you sure?\"})\n"
"\n"
"		top:add({hx=20,hy=40*2})\n"
"		top:add({hx=120,hy=40*2,color=0xffcccccc,text=\"Back\",id=\"quit_back\",hooks=gui.hooks})\n"
"		top:add({hx=40,hy=40*2})\n"
"		top:add({hx=120,hy=40*2,color=0xffcc4444,text=\"Quit\",id=\"quit_exit\",hooks=gui.hooks})\n"
"		top:add({hx=20,hy=40*2})\n"
"\n"
"		top:add({hx=320,hy=40*5})\n"
"		\n"
"		master.go_back_id=\"quit_back\"\n"
"		master.go_forward_id=\"quit_back\"\n"
"		\n"
"	end\n"
"	\n"
"	function gui.page(pname)\n"
"		\n"
"		gui.active=true -- display out stuff\n"
"\n"
"		if not gui.master then\n"
"			gui.master=oven.rebake(\"wetgenes.gamecake.widgets\").setup({hx=320,hy=480,px=0,py=0})\n"
"		end\n"
"	\n"
"		gui.master:clean_all()\n"
"		\n"
"		if pname then\n"
"			local f=gui.pages[pname]\n"
"			if f then\n"
"				f(gui.master) -- pass in the master so we could fill up other widgets\n"
"			end\n"
"		end\n"
"\n"
"		gui.page_name=pname\n"
"\n"
"		gui.set_all_values()\n"
"\n"
"		gui.master:layout()\n"
"		\n"
"		gui.master:call_descendents(function(w) if not w.hooks then return end gui.anim.bounce(w,1) end)\n"
"\n"
"		if gui.widget_hook then\n"
"			gui.master:call_descendents(function(w) gui.widget_hook(w) end)\n"
"		end\n"
"		\n"
"		if gui.master.go_forward_id then\n"
"			gui.master.activate_by_id(gui.master.go_forward_id)\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"	function gui.clean()\n"
"\n"
"		gui.master=nil\n"
"	\n"
"	end\n"
"	\n"
"	function gui.update()\n"
"		gui.time=gui.time+1\n"
"	\n"
"		gui.master:update()\n"
"\n"
"	end\n"
"	\n"
"	function gui.msg(m)\n"
"\n"
"		if m.xraw and m.yraw then	-- we need to fix raw x,y numbers\n"
"			m.x,m.y=layout.xyscale(m.xraw,m.yraw)	-- local coords, 0,0 is now center of screen\n"
"			m.x=m.x+(320/2)\n"
"			m.y=m.y+(480/2)\n"
"		end\n"
"		\n"
"\n"
"		if gui.msg_smell_hook then\n"
"			if m.cmd and m.cmd:sub(1,11)==\"LeaderBoard\" then\n"
"				return gui.msg_smell_hook(m)\n"
"			end\n"
"		end\n"
"\n"
"		gui.master:msg(m)\n"
"\n"
"	end\n"
"\n"
"	function gui.draw()\n"
"\n"
"		layout.viewport() -- set clip area\n"
"		layout.project23d(320,480,1/4,480*4) -- build projection\n"
"\n"
"		gl.MatrixMode(gl.PROJECTION)\n"
"		gl.LoadMatrix( layout.pmtx )\n"
"\n"
"		gl.MatrixMode(gl.MODELVIEW)\n"
"		gl.LoadIdentity()\n"
"		gl.Translate(-320/2,-480/2,-480*2) -- top left corner is origin\n"
"\n"
"		gl.PushMatrix()\n"
"		\n"
"			gui.master:draw()\n"
"\n"
"		gl.PopMatrix()\n"
"\n"
"	end\n"
"	\n"
"	gui.anim={}\n"
"	function gui.anim.bounce(w,size)\n"
"		w.anim={\n"
"			widget=w,\n"
"			num=size or 1,\n"
"			vel=0,\n"
"			update=function(anim)\n"
"				anim.vel=anim.vel-(anim.num*1/16)\n"
"				anim.vel=anim.vel*14/16\n"
"				anim.num=anim.num+anim.vel\n"
"				if (math.abs(anim.vel) + math.abs(anim.num)) <(1/1024) then\n"
"					anim.widget.anim=nil\n"
"				end\n"
"				anim.widget:set_dirty()\n"
"\n"
"				local s=1+anim.num\n"
"				w.sx=s\n"
"				w.sy=s\n"
"			end,\n"
"			draw=function(anim)\n"
"			end\n"
"		}\n"
"		return w\n"
"	end\n"
"\n"
"\n"
"	gui.initdata()\n"
"	return gui\n"
"end\n"
"",

"socket.http","-----------------------------------------------------------------------------\n"
"-- HTTP/1.1 client support for the Lua language.\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: http.lua,v 1.70 2007/03/12 04:08:40 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module and import dependencies\n"
"-------------------------------------------------------------------------------\n"
"local socket = require(\"socket\")\n"
"local url = require(\"socket.url\")\n"
"local ltn12 = require(\"ltn12\")\n"
"local mime = require(\"mime\")\n"
"local string = require(\"string\")\n"
"local base = _G\n"
"local table = require(\"table\")\n"
"module(\"socket.http\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Program constants\n"
"-----------------------------------------------------------------------------\n"
"-- connection timeout in seconds\n"
"TIMEOUT = 60\n"
"-- default port for document retrieval\n"
"PORT = 80\n"
"-- user agent field sent in request\n"
"USERAGENT = socket._VERSION\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Reads MIME headers from a connection, unfolding where needed\n"
"-----------------------------------------------------------------------------\n"
"local function receiveheaders(sock, headers)\n"
"    local line, name, value, err\n"
"    headers = headers or {}\n"
"    -- get first line\n"
"    line, err = sock:receive()\n"
"    if err then return nil, err end\n"
"    -- headers go until a blank line is found\n"
"    while line ~= \"\" do\n"
"        -- get field-name and value\n"
"        name, value = socket.skip(2, string.find(line, \"^(.-):%s*(.*)\"))\n"
"        if not (name and value) then return nil, \"malformed reponse headers\" end\n"
"        name = string.lower(name)\n"
"        -- get next line (value might be folded)\n"
"        line, err  = sock:receive()\n"
"        if err then return nil, err end\n"
"        -- unfold any folded values\n"
"        while string.find(line, \"^%s\") do\n"
"            value = value .. line\n"
"            line = sock:receive()\n"
"            if err then return nil, err end\n"
"        end\n"
"        -- save pair in table\n"
"        if headers[name] then headers[name] = headers[name] .. \", \" .. value\n"
"        else headers[name] = value end\n"
"    end\n"
"    return headers\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Extra sources and sinks\n"
"-----------------------------------------------------------------------------\n"
"socket.sourcet[\"http-chunked\"] = function(sock, headers)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function()\n"
"            -- get chunk size, skip extention\n"
"            local line, err = sock:receive()\n"
"            if err then return nil, err end\n"
"            local size = base.tonumber(string.gsub(line, \";.*\", \"\"), 16)\n"
"            if not size then return nil, \"invalid chunk size\" end\n"
"            -- was it the last chunk?\n"
"            if size > 0 then\n"
"                -- if not, get chunk and skip terminating CRLF\n"
"                local chunk, err, part = sock:receive(size)\n"
"                if chunk then sock:receive() end\n"
"                return chunk, err\n"
"            else\n"
"                -- if it was, read trailers into headers table\n"
"                headers, err = receiveheaders(sock, headers)\n"
"                if not headers then return nil, err end\n"
"            end\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"socket.sinkt[\"http-chunked\"] = function(sock)\n"
"    return base.setmetatable({\n"
"        getfd = function() return sock:getfd() end,\n"
"        dirty = function() return sock:dirty() end\n"
"    }, {\n"
"        __call = function(self, chunk, err)\n"
"            if not chunk then return sock:send(\"0\\r\\n"
"\\r\\n"
"\") end\n"
"            local size = string.format(\"%X\\r\\n"
"\", string.len(chunk))\n"
"            return sock:send(size ..  chunk .. \"\\r\\n"
"\")\n"
"        end\n"
"    })\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Low level HTTP API\n"
"-----------------------------------------------------------------------------\n"
"local metat = { __index = {} }\n"
"\n"
"function open(host, port, create)\n"
"    -- create socket with user connect function, or with default\n"
"    local c = socket.try((create or socket.tcp)())\n"
"    local h = base.setmetatable({ c = c }, metat)\n"
"    -- create finalized try\n"
"    h.try = socket.newtry(function() h:close() end)\n"
"    -- set timeout before connecting\n"
"    h.try(c:settimeout(TIMEOUT))\n"
"    h.try(c:connect(host, port or PORT))\n"
"    -- here everything worked\n"
"    return h\n"
"end\n"
"\n"
"function metat.__index:sendrequestline(method, uri)\n"
"    local reqline = string.format(\"%s %s HTTP/1.1\\r\\n"
"\", method or \"GET\", uri)\n"
"    return self.try(self.c:send(reqline))\n"
"end\n"
"\n"
"function metat.__index:sendheaders(headers)\n"
"    local h = \"\\r\\n"
"\"\n"
"    for i, v in base.pairs(headers) do\n"
"        h = i .. \": \" .. v .. \"\\r\\n"
"\" .. h\n"
"    end\n"
"    self.try(self.c:send(h))\n"
"    return 1\n"
"end\n"
"\n"
"function metat.__index:sendbody(headers, source, step)\n"
"    source = source or ltn12.source.empty()\n"
"    step = step or ltn12.pump.step\n"
"    -- if we don't know the size in advance, send chunked and hope for the best\n"
"    local mode = \"http-chunked\"\n"
"    if headers[\"content-length\"] then mode = \"keep-open\" end\n"
"    return self.try(ltn12.pump.all(source, socket.sink(mode, self.c), step))\n"
"end\n"
"\n"
"function metat.__index:receivestatusline()\n"
"    local status = self.try(self.c:receive())\n"
"    local code = socket.skip(2, string.find(status, \"HTTP/%d*%.%d* (%d%d%d)\"))\n"
"    return self.try(base.tonumber(code), status)\n"
"end\n"
"\n"
"function metat.__index:receiveheaders()\n"
"    return self.try(receiveheaders(self.c))\n"
"end\n"
"\n"
"function metat.__index:receivebody(headers, sink, step)\n"
"    sink = sink or ltn12.sink.null()\n"
"    step = step or ltn12.pump.step\n"
"    local length = base.tonumber(headers[\"content-length\"])\n"
"    local t = headers[\"transfer-encoding\"] -- shortcut\n"
"    local mode = \"default\" -- connection close\n"
"    if t and t ~= \"identity\" then mode = \"http-chunked\"\n"
"    elseif base.tonumber(headers[\"content-length\"]) then mode = \"by-length\" end\n"
"    return self.try(ltn12.pump.all(socket.source(mode, self.c, length),\n"
"        sink, step))\n"
"end\n"
"\n"
"function metat.__index:close()\n"
"    return self.c:close()\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- High level HTTP API\n"
"-----------------------------------------------------------------------------\n"
"local function adjusturi(reqt)\n"
"    local u = reqt\n"
"    -- if there is a proxy, we need the full url. otherwise, just a part.\n"
"    if not reqt.proxy and not PROXY then\n"
"        u = {\n"
"           path = socket.try(reqt.path, \"invalid path 'nil'\"),\n"
"           params = reqt.params,\n"
"           query = reqt.query,\n"
"           fragment = reqt.fragment\n"
"        }\n"
"    end\n"
"    return url.build(u)\n"
"end\n"
"\n"
"local function adjustproxy(reqt)\n"
"    local proxy = reqt.proxy or PROXY\n"
"    if proxy then\n"
"        proxy = url.parse(proxy)\n"
"        return proxy.host, proxy.port or 3128\n"
"    else\n"
"        return reqt.host, reqt.port\n"
"    end\n"
"end\n"
"\n"
"local function adjustheaders(reqt)\n"
"    -- default headers\n"
"    local lower = {\n"
"        [\"user-agent\"] = USERAGENT,\n"
"        [\"host\"] = reqt.host,\n"
"        [\"connection\"] = \"close, TE\",\n"
"        [\"te\"] = \"trailers\"\n"
"    }\n"
"    -- if we have authentication information, pass it along\n"
"    if reqt.user and reqt.password then\n"
"        lower[\"authorization\"] = \n"
"            \"Basic \" ..  (mime.b64(reqt.user .. \":\" .. reqt.password))\n"
"    end\n"
"    -- override with user headers\n"
"    for i,v in base.pairs(reqt.headers or lower) do\n"
"        lower[string.lower(i)] = v\n"
"    end\n"
"    return lower\n"
"end\n"
"\n"
"-- default url parts\n"
"local default = {\n"
"    host = \"\",\n"
"    port = PORT,\n"
"    path =\"/\",\n"
"    scheme = \"http\"\n"
"}\n"
"\n"
"local function adjustrequest(reqt)\n"
"    -- parse url if provided\n"
"    local nreqt = reqt.url and url.parse(reqt.url, default) or {}\n"
"    -- explicit components override url\n"
"    for i,v in base.pairs(reqt) do nreqt[i] = v end\n"
"    if nreqt.port == \"\" then nreqt.port = 80 end\n"
"    socket.try(nreqt.host and nreqt.host ~= \"\", \n"
"        \"invalid host '\" .. base.tostring(nreqt.host) .. \"'\")\n"
"    -- compute uri if user hasn't overriden\n"
"    nreqt.uri = reqt.uri or adjusturi(nreqt)\n"
"    -- ajust host and port if there is a proxy\n"
"    nreqt.host, nreqt.port = adjustproxy(nreqt)\n"
"    -- adjust headers in request\n"
"    nreqt.headers = adjustheaders(nreqt)\n"
"    return nreqt\n"
"end\n"
"\n"
"local function shouldredirect(reqt, code, headers)\n"
"    return headers.location and\n"
"           string.gsub(headers.location, \"%s\", \"\") ~= \"\" and\n"
"           (reqt.redirect ~= false) and\n"
"           (code == 301 or code == 302) and\n"
"           (not reqt.method or reqt.method == \"GET\" or reqt.method == \"HEAD\")\n"
"           and (not reqt.nredirects or reqt.nredirects < 5)\n"
"end\n"
"\n"
"local function shouldreceivebody(reqt, code)\n"
"    if reqt.method == \"HEAD\" then return nil end\n"
"    if code == 204 or code == 304 then return nil end\n"
"    if code >= 100 and code < 200 then return nil end\n"
"    return 1\n"
"end\n"
"\n"
"-- forward declarations\n"
"local trequest, tredirect\n"
"\n"
"function tredirect(reqt, location)\n"
"    local result, code, headers, status = trequest {\n"
"        -- the RFC says the redirect URL has to be absolute, but some\n"
"        -- servers do not respect that\n"
"        url = url.absolute(reqt.url, location),\n"
"        source = reqt.source,\n"
"        sink = reqt.sink,\n"
"        headers = reqt.headers,\n"
"        proxy = reqt.proxy, \n"
"        nredirects = (reqt.nredirects or 0) + 1,\n"
"        create = reqt.create\n"
"    }   \n"
"    -- pass location header back as a hint we redirected\n"
"    headers.location = headers.location or location\n"
"    return result, code, headers, status\n"
"end\n"
"\n"
"function trequest(reqt)\n"
"    -- we loop until we get what we want, or\n"
"    -- until we are sure there is no way to get it\n"
"    local nreqt = adjustrequest(reqt)\n"
"    local h = open(nreqt.host, nreqt.port, nreqt.create)\n"
"    -- send request line and headers\n"
"    h:sendrequestline(nreqt.method, nreqt.uri)\n"
"    h:sendheaders(nreqt.headers)\n"
"    local code = 100 \n"
"    local headers, status\n"
"    -- if there is a body, check for server status\n"
"    if nreqt.source then\n"
"        h:sendbody(nreqt.headers, nreqt.source, nreqt.step) \n"
"    end\n"
"    -- ignore any 100-continue messages\n"
"    while code == 100 do \n"
"        code, status = h:receivestatusline()\n"
"        headers = h:receiveheaders()\n"
"    end\n"
"    -- at this point we should have a honest reply from the server\n"
"    -- we can't redirect if we already used the source, so we report the error \n"
"    if shouldredirect(nreqt, code, headers) and not nreqt.source then\n"
"        h:close()\n"
"        return tredirect(reqt, headers.location)\n"
"    end\n"
"    -- here we are finally done\n"
"    if shouldreceivebody(nreqt, code) then\n"
"        h:receivebody(headers, nreqt.sink, nreqt.step)\n"
"    end\n"
"    h:close()\n"
"    return 1, code, headers, status\n"
"end\n"
"\n"
"local function srequest(u, b)\n"
"    local t = {}\n"
"    local reqt = {\n"
"        url = u,\n"
"        sink = ltn12.sink.table(t)\n"
"    }\n"
"    if b then\n"
"        reqt.source = ltn12.source.string(b)\n"
"        reqt.headers = {\n"
"            [\"content-length\"] = string.len(b),\n"
"            [\"content-type\"] = \"application/x-www-form-urlencoded\"\n"
"        }\n"
"        reqt.method = \"POST\"\n"
"    end\n"
"    local code, headers, status = socket.skip(1, trequest(reqt))\n"
"    return table.concat(t), code, headers, status\n"
"end\n"
"\n"
"request = socket.protect(function(reqt, body)\n"
"    if base.type(reqt) == \"string\" then return srequest(reqt, body)\n"
"    else return trequest(reqt) end\n"
"end)\n"
"",

"wetgenes.gamecake.spew.names","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- this uses math.random so remember to seed it if you want it to really be \"random\"\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"M.bake=function(oven,names)\n"
"\n"
"	names=names or {}\n"
"	\n"
"	names.random=M.random\n"
"\n"
"	return names\n"
"end\n"
"\n"
"function M.random_adjective()\n"
"	return M.txt_adjectives[ math.random(1,#M.txt_adjectives) ]\n"
"end\n"
"\n"
"function M.random_noun()\n"
"	return M.txt_nouns[ math.random(1,#M.txt_nouns) ]\n"
"end\n"
"\n"
"function M.random()\n"
"	return M.random_adjective()..\"_\"..M.random_noun()\n"
"end\n"
"\n"
"M.txt_adjectives={\n"
"\"ravishing\",\n"
"\"mimic\",\n"
"\"famous\",\n"
"\"cheerful\",\n"
"\"livid\",\n"
"\"obstinate\",\n"
"\"exhausted\",\n"
"\"graceful\",\n"
"\"outrageous\",\n"
"\"radical\",\n"
"\"childish\",\n"
"\"snobbish\",\n"
"\"miserly\",\n"
"\"amiable\",\n"
"\"disgusting\",\n"
"\"awful\",\n"
"\"humorous\",\n"
"\"fanciful\",\n"
"\"pathetic\",\n"
"\"windy\",\n"
"\"dusty\",\n"
"\"bashful\",\n"
"\"freaky\",\n"
"\"chilly\",\n"
"\"stormy\",\n"
"\"humid\",\n"
"\"bountiful\",\n"
"\"jubilant\",\n"
"\"irritated\",\n"
"\"patient\",\n"
"\"dizzy\",\n"
"\"skeptical\",\n"
"\"puzzled\",\n"
"\"perplexed\",\n"
"\"jovial\",\n"
"\"hyper\",\n"
"\"squirrely\",\n"
"\"jittery\",\n"
"\"elegant\",\n"
"\"gleeful\",\n"
"\"dreary\",\n"
"\"impish\",\n"
"\"sneaky\",\n"
"\"horrid\",\n"
"\"monsterous\",\n"
"\"able\",\n"
"\"abnormal\",\n"
"\"absent\",\n"
"\"absolute\",\n"
"\"accurate\",\n"
"\"acidic\",\n"
"\"acoustic\",\n"
"\"active\",\n"
"\"adequate\",\n"
"\"airborne\",\n"
"\"airy\",\n"
"\"all\",\n"
"\"alone\",\n"
"\"american\",\n"
"\"amphibious\",\n"
"\"angry\",\n"
"\"annual\",\n"
"\"another\",\n"
"\"any\",\n"
"\"apparent\",\n"
"\"artificial\",\n"
"\"atomic\",\n"
"\"audible\",\n"
"\"automatic\",\n"
"\"auxiliary\",\n"
"\"available\",\n"
"\"bad\",\n"
"\"ballistic\",\n"
"\"bare\",\n"
"\"basic\",\n"
"\"beautiful\",\n"
"\"beneficial\",\n"
"\"best\",\n"
"\"better\",\n"
"\"big\",\n"
"\"biggest\",\n"
"\"binary\",\n"
"\"bipolar\",\n"
"\"bitter\",\n"
"\"black\",\n"
"\"blind\",\n"
"\"blue\",\n"
"\"both\",\n"
"\"brief\",\n"
"\"bright\",\n"
"\"broad\",\n"
"\"brown\",\n"
"\"busy\",\n"
"\"capable\",\n"
"\"careful\",\n"
"\"careless\",\n"
"\"carnal\",\n"
"\"cautious\",\n"
"\"celestial\",\n"
"\"celsius\",\n"
"\"central\",\n"
"\"ceramic\",\n"
"\"certain\",\n"
"\"cheap\",\n"
"\"cheaper\",\n"
"\"civil\",\n"
"\"clean\",\n"
"\"clear\",\n"
"\"closer\",\n"
"\"coarse\",\n"
"\"cold\",\n"
"\"common\",\n"
"\"compact\",\n"
"\"complete\",\n"
"\"complex\",\n"
"\"compound\",\n"
"\"compulsory\",\n"
"\"concrete\",\n"
"\"conscious\",\n"
"\"constant\",\n"
"\"continuous\",\n"
"\"convenient\",\n"
"\"cool\",\n"
"\"correct\",\n"
"\"corrosive\",\n"
"\"critical\",\n"
"\"cruel\",\n"
"\"cubic\",\n"
"\"culpable\",\n"
"\"current\",\n"
"\"daily\",\n"
"\"dangerous\",\n"
"\"dark\",\n"
"\"darker\",\n"
"\"darkest\",\n"
"\"dead\",\n"
"\"deaf\",\n"
"\"dear\",\n"
"\"dearer\",\n"
"\"dearest\",\n"
"\"decimal\",\n"
"\"deep\",\n"
"\"deeper\",\n"
"\"deepest\",\n"
"\"defective\",\n"
"\"definite\",\n"
"\"delicate\",\n"
"\"dental\",\n"
"\"dependent\",\n"
"\"destructive\",\n"
"\"diagonal\",\n"
"\"different\",\n"
"\"difficult\",\n"
"\"digital\",\n"
"\"dim\",\n"
"\"diseased\",\n"
"\"distinct\",\n"
"\"ditty\",\n"
"\"dormant\",\n"
"\"double\",\n"
"\"drafty\",\n"
"\"drier\",\n"
"\"driest\",\n"
"\"drowsy\",\n"
"\"dry\",\n"
"\"dual\",\n"
"\"due\",\n"
"\"dull\",\n"
"\"dumb\",\n"
"\"dynamic\",\n"
"\"each\",\n"
"\"easy\",\n"
"\"eighth\",\n"
"\"either\",\n"
"\"elastic\",\n"
"\"electric\",\n"
"\"eligible\",\n"
"\"else\",\n"
"\"empty\",\n"
"\"enough\",\n"
"\"entire\",\n"
"\"equal\",\n"
"\"erect\",\n"
"\"erratic\",\n"
"\"essential\",\n"
"\"eventual\",\n"
"\"every\",\n"
"\"everyday\",\n"
"\"evident\",\n"
"\"exact\",\n"
"\"excellent\",\n"
"\"excessive\",\n"
"\"exclusive\",\n"
"\"explosive\",\n"
"\"extensive\",\n"
"\"external\",\n"
"\"extra\",\n"
"\"extreme\",\n"
"\"extrinsic\",\n"
"\"faint\",\n"
"\"fair\",\n"
"\"false\",\n"
"\"familiar\",\n"
"\"fast\",\n"
"\"fat\",\n"
"\"fatal\",\n"
"\"fattest\",\n"
"\"faulty\",\n"
"\"feasible\",\n"
"\"federal\",\n"
"\"feeble\",\n"
"\"fertile\",\n"
"\"few\",\n"
"\"fifth\",\n"
"\"final\",\n"
"\"fine\",\n"
"\"firm\",\n"
"\"first\",\n"
"\"fiscal\",\n"
"\"fit\",\n"
"\"flammable\",\n"
"\"flat\",\n"
"\"flexible\",\n"
"\"foggy\",\n"
"\"foolish\",\n"
"\"foreign\",\n"
"\"formal\",\n"
"\"former\",\n"
"\"fourth\",\n"
"\"free\",\n"
"\"frequent\",\n"
"\"fresh\",\n"
"\"full\",\n"
"\"gamma\",\n"
"\"general\",\n"
"\"gentle\",\n"
"\"good\",\n"
"\"gradual\",\n"
"\"grand\",\n"
"\"graphic\",\n"
"\"grave\",\n"
"\"gray\",\n"
"\"great\",\n"
"\"green\",\n"
"\"grievous\",\n"
"\"grocery\",\n"
"\"happy\",\n"
"\"hard\",\n"
"\"harmful\",\n"
"\"hazardous\",\n"
"\"healthy\",\n"
"\"heavy\",\n"
"\"helpful\",\n"
"\"high\",\n"
"\"hilly\",\n"
"\"hind\",\n"
"\"hollow\",\n"
"\"hot\",\n"
"\"huge\",\n"
"\"icy\",\n"
"\"identical\",\n"
"\"idle\",\n"
"\"ill\",\n"
"\"imminent\",\n"
"\"important\",\n"
"\"improper\",\n"
"\"inboard\",\n"
"\"inner\",\n"
"\"instant\",\n"
"\"intense\",\n"
"\"internal\",\n"
"\"intrinsic\",\n"
"\"iterative\",\n"
"\"jet\",\n"
"\"julian\",\n"
"\"junior\",\n"
"\"keen\",\n"
"\"kelvin\",\n"
"\"kind\",\n"
"\"knobbed\",\n"
"\"large\",\n"
"\"last\",\n"
"\"late\",\n"
"\"lawful\",\n"
"\"lazy\",\n"
"\"leaky\",\n"
"\"lean\",\n"
"\"least\",\n"
"\"legal\",\n"
"\"less\",\n"
"\"lethal\",\n"
"\"level\",\n"
"\"likely\",\n"
"\"linear\",\n"
"\"liquid\",\n"
"\"literal\",\n"
"\"little\",\n"
"\"lively\",\n"
"\"local\",\n"
"\"lone\",\n"
"\"long\",\n"
"\"loose\",\n"
"\"loud\",\n"
"\"low\",\n"
"\"magnetic\",\n"
"\"main\",\n"
"\"many\",\n"
"\"maple\",\n"
"\"marine\",\n"
"\"martial\",\n"
"\"mean\",\n"
"\"medical\",\n"
"\"mental\",\n"
"\"mere\",\n"
"\"metallic\",\n"
"\"middle\",\n"
"\"minor\",\n"
"\"minus\",\n"
"\"misty\",\n"
"\"mnemonic\",\n"
"\"mobile\",\n"
"\"modern\",\n"
"\"modular\",\n"
"\"molten\",\n"
"\"moral\",\n"
"\"more\",\n"
"\"most\",\n"
"\"movable\",\n"
"\"muddy\",\n"
"\"multiple\",\n"
"\"mutual\",\n"
"\"naked\",\n"
"\"narcotic\",\n"
"\"narrow\",\n"
"\"national\",\n"
"\"natural\",\n"
"\"nautical\",\n"
"\"naval\",\n"
"\"neat\",\n"
"\"necessary\",\n"
"\"negative\",\n"
"\"nervous\",\n"
"\"neutral\",\n"
"\"new\",\n"
"\"next\",\n"
"\"nice\",\n"
"\"noisy\",\n"
"\"nominal\",\n"
"\"normal\",\n"
"\"nuclear\",\n"
"\"numeric\",\n"
"\"numerical\",\n"
"\"numerous\",\n"
"\"obsolete\",\n"
"\"obvious\",\n"
"\"odd\",\n"
"\"offline\",\n"
"\"okay\",\n"
"\"old\",\n"
"\"online\",\n"
"\"open\",\n"
"\"optimum\",\n"
"\"optional\",\n"
"\"oral\",\n"
"\"ordinary\",\n"
"\"original\",\n"
"\"other\",\n"
"\"outboard\",\n"
"\"outer\",\n"
"\"outside\",\n"
"\"outward\",\n"
"\"overhead\",\n"
"\"oversize\",\n"
"\"own\",\n"
"\"pale\",\n"
"\"paler\",\n"
"\"palest\",\n"
"\"parallel\",\n"
"\"partial\",\n"
"\"passive\",\n"
"\"past\",\n"
"\"peculiar\",\n"
"\"periodic\",\n"
"\"permanent\",\n"
"\"personal\",\n"
"\"petty\",\n"
"\"phonetic\",\n"
"\"physical\",\n"
"\"plain\",\n"
"\"planar\",\n"
"\"plenty\",\n"
"\"poisonous\",\n"
"\"polite\",\n"
"\"political\",\n"
"\"poor\",\n"
"\"portable\",\n"
"\"positive\",\n"
"\"possible\",\n"
"\"potential\",\n"
"\"powerful\",\n"
"\"practical\",\n"
"\"precise\",\n"
"\"pretty\",\n"
"\"previous\",\n"
"\"primary\",\n"
"\"prior\",\n"
"\"private\",\n"
"\"probable\",\n"
"\"prompt\",\n"
"\"proper\",\n"
"\"protective\",\n"
"\"proximate\",\n"
"\"punitive\",\n"
"\"pure\",\n"
"\"purple\",\n"
"\"quick\",\n"
"\"quiet\",\n"
"\"random\",\n"
"\"rapid\",\n"
"\"raw\",\n"
"\"ready\",\n"
"\"real\",\n"
"\"red\",\n"
"\"regional\",\n"
"\"regular\",\n"
"\"relative\",\n"
"\"reliable\",\n"
"\"remote\",\n"
"\"removable\",\n"
"\"responsible\",\n"
"\"retail\",\n"
"\"reusable\",\n"
"\"rich\",\n"
"\"richer\",\n"
"\"richest\",\n"
"\"right\",\n"
"\"rigid\",\n"
"\"ripe\",\n"
"\"rough\",\n"
"\"sad\",\n"
"\"sadder\",\n"
"\"saddest\",\n"
"\"safe\",\n"
"\"safer\",\n"
"\"safest\",\n"
"\"same\",\n"
"\"secondary\",\n"
"\"secure\",\n"
"\"senior\",\n"
"\"sensitive\",\n"
"\"separate\",\n"
"\"serious\",\n"
"\"seventh\",\n"
"\"several\",\n"
"\"severe\",\n"
"\"shady\",\n"
"\"shallow\",\n"
"\"sharp\",\n"
"\"shy\",\n"
"\"shiny\",\n"
"\"short\",\n"
"\"sick\",\n"
"\"silent\",\n"
"\"similar\",\n"
"\"simple\",\n"
"\"single\",\n"
"\"sixth\",\n"
"\"slack\",\n"
"\"slight\",\n"
"\"slippery\",\n"
"\"slower\",\n"
"\"slowest\",\n"
"\"small\",\n"
"\"smart\",\n"
"\"smooth\",\n"
"\"snug\",\n"
"\"social\",\n"
"\"soft\",\n"
"\"solar\",\n"
"\"solid\",\n"
"\"some\",\n"
"\"sour\",\n"
"\"special\",\n"
"\"specific\",\n"
"\"stable\",\n"
"\"static\",\n"
"\"steady\",\n"
"\"steep\",\n"
"\"sterile\",\n"
"\"sticky\",\n"
"\"stiff\",\n"
"\"still\",\n"
"\"straight\",\n"
"\"strange\",\n"
"\"strict\",\n"
"\"strong\",\n"
"\"such\",\n"
"\"sudden\",\n"
"\"suitable\",\n"
"\"sunny\",\n"
"\"superior\",\n"
"\"sure\",\n"
"\"sweet\",\n"
"\"swift\",\n"
"\"swollen\",\n"
"\"symbolic\",\n"
"\"synthetic\",\n"
"\"tactical\",\n"
"\"tall\",\n"
"\"taut\",\n"
"\"technical\",\n"
"\"temporary\",\n"
"\"tentative\",\n"
"\"terminal\",\n"
"\"thermal\",\n"
"\"thick\",\n"
"\"thin\",\n"
"\"third\",\n"
"\"thirsty\",\n"
"\"tight\",\n"
"\"tiny\",\n"
"\"toxic\",\n"
"\"tropical\",\n"
"\"true\",\n"
"\"turbulent\",\n"
"\"typical\",\n"
"\"unique\",\n"
"\"upper\",\n"
"\"urgent\",\n"
"\"useable\",\n"
"\"useful\",\n"
"\"usual\",\n"
"\"valid\",\n"
"\"valuable\",\n"
"\"various\",\n"
"\"vertical\",\n"
"\"viable\",\n"
"\"violent\",\n"
"\"virtual\",\n"
"\"visible\",\n"
"\"visual\",\n"
"\"vital\",\n"
"\"void\",\n"
"\"volatile\",\n"
"\"wanton\",\n"
"\"warm\",\n"
"\"weak\",\n"
"\"weary\",\n"
"\"wet\",\n"
"\"white\",\n"
"\"whole\",\n"
"\"wide\",\n"
"\"wise\",\n"
"\"wooden\",\n"
"\"woolen\",\n"
"\"worse\",\n"
"\"worst\",\n"
"\"wrong\",\n"
"\"yellow\",\n"
"\"young\",\n"
"\"harmless\",\n"
"\"inactive\",\n"
"\"incorrect\",\n"
"\"indirect\",\n"
"\"invalid\",\n"
"\"unable\",\n"
"\"unknown\",\n"
"\"unmated\",\n"
"\"unsafe\",\n"
"\"unsigned\",\n"
"\"unused\",\n"
"\"unusual\",\n"
"\"unwanted\",\n"
"\"useless\",\n"
"\"aged\",\n"
"\"etched\",\n"
"\"finished\",\n"
"\"given\",\n"
"\"left\",\n"
"\"lost\",\n"
"\"mistaken\",\n"
"\"proven\",\n"
"}\n"
"\n"
"\n"
"M.txt_nouns={\n"
"\"abrasive\",\n"
"\"abuser\",\n"
"\"accident\",\n"
"\"acid\",\n"
"\"acre\",\n"
"\"acronym\",\n"
"\"act\",\n"
"\"address\",\n"
"\"admiral\",\n"
"\"adverb\",\n"
"\"adviser\",\n"
"\"affair\",\n"
"\"agent\",\n"
"\"aid\",\n"
"\"aim\",\n"
"\"air\",\n"
"\"airplane\",\n"
"\"airport\",\n"
"\"airship\",\n"
"\"alarm\",\n"
"\"alcoholic\",\n"
"\"algebra\",\n"
"\"alias\",\n"
"\"alibi\",\n"
"\"alley\",\n"
"\"alloy\",\n"
"\"analog\",\n"
"\"analyst\",\n"
"\"anchor\",\n"
"\"angle\",\n"
"\"animal\",\n"
"\"anthem\",\n"
"\"apple\",\n"
"\"april\",\n"
"\"apron\",\n"
"\"arc\",\n"
"\"arch\",\n"
"\"area\",\n"
"\"arm\",\n"
"\"army\",\n"
"\"array\",\n"
"\"arrest\",\n"
"\"arrow\",\n"
"\"atom\",\n"
"\"attack\",\n"
"\"ax\",\n"
"\"axis\",\n"
"\"baby\",\n"
"\"back\",\n"
"\"bag\",\n"
"\"ball\",\n"
"\"balloon\",\n"
"\"band\",\n"
"\"bang\",\n"
"\"bar\",\n"
"\"barge\",\n"
"\"barrel\",\n"
"\"base\",\n"
"\"basin\",\n"
"\"basket\",\n"
"\"bat\",\n"
"\"batch\",\n"
"\"bath\",\n"
"\"bather\",\n"
"\"battery\",\n"
"\"bay\",\n"
"\"beach\",\n"
"\"beacon\",\n"
"\"bead\",\n"
"\"beam\",\n"
"\"bean\",\n"
"\"bear\",\n"
"\"beat\",\n"
"\"bed\",\n"
"\"being\",\n"
"\"bend\",\n"
"\"berry\",\n"
"\"bigamy\",\n"
"\"blade\",\n"
"\"blank\",\n"
"\"blanket\",\n"
"\"blast\",\n"
"\"blasts\",\n"
"\"block\",\n"
"\"blood\",\n"
"\"blot\",\n"
"\"blow\",\n"
"\"blower\",\n"
"\"boat\",\n"
"\"body\",\n"
"\"boil\",\n"
"\"bolt\",\n"
"\"bone\",\n"
"\"book\",\n"
"\"boot\",\n"
"\"bore\",\n"
"\"bottle\",\n"
"\"bottom\",\n"
"\"box\",\n"
"\"boy\",\n"
"\"brain\",\n"
"\"bread\",\n"
"\"breast\",\n"
"\"brick\",\n"
"\"broom\",\n"
"\"bubble\",\n"
"\"bucket\",\n"
"\"builder\",\n"
"\"bullet\",\n"
"\"bump\",\n"
"\"bus\",\n"
"\"bush\",\n"
"\"butt\",\n"
"\"butter\",\n"
"\"button\",\n"
"\"byte\",\n"
"\"cab\",\n"
"\"cake\",\n"
"\"camp\",\n"
"\"cannon\",\n"
"\"cap\",\n"
"\"captain\",\n"
"\"carpet\",\n"
"\"cause\",\n"
"\"cave\",\n"
"\"cell\",\n"
"\"cellar\",\n"
"\"chair\",\n"
"\"chalk\",\n"
"\"cheat\",\n"
"\"cheek\",\n"
"\"cheese\",\n"
"\"chief\",\n"
"\"child\",\n"
"\"chimney\",\n"
"\"church\",\n"
"\"circle\",\n"
"\"citizen\",\n"
"\"civilian\",\n"
"\"clamp\",\n"
"\"claw\",\n"
"\"clerk\",\n"
"\"clock\",\n"
"\"cloud\",\n"
"\"club\",\n"
"\"clump\",\n"
"\"coal\",\n"
"\"coat\",\n"
"\"coder\",\n"
"\"colon\",\n"
"\"comb\",\n"
"\"comma\",\n"
"\"computer\",\n"
"\"cone\",\n"
"\"console\",\n"
"\"control\",\n"
"\"copy\",\n"
"\"cord\",\n"
"\"core\",\n"
"\"cork\",\n"
"\"corner\",\n"
"\"cough\",\n"
"\"count\",\n"
"\"crack\",\n"
"\"cradle\",\n"
"\"craft\",\n"
"\"cramp\",\n"
"\"crash\",\n"
"\"crawl\",\n"
"\"crust\",\n"
"\"cube\",\n"
"\"cup\",\n"
"\"cure\",\n"
"\"curl\",\n"
"\"dam\",\n"
"\"data\",\n"
"\"date\",\n"
"\"dealer\",\n"
"\"death\",\n"
"\"debris\",\n"
"\"debt\",\n"
"\"decay\",\n"
"\"december\",\n"
"\"deck\",\n"
"\"decoder\",\n"
"\"default\",\n"
"\"defect\",\n"
"\"delight\",\n"
"\"dent\",\n"
"\"desert\",\n"
"\"desire\",\n"
"\"desk\",\n"
"\"device\",\n"
"\"diode\",\n"
"\"dirt\",\n"
"\"disease\",\n"
"\"disgust\",\n"
"\"dish\",\n"
"\"disk\",\n"
"\"ditch\",\n"
"\"ditches\",\n"
"\"diver\",\n"
"\"divider\",\n"
"\"dolly\",\n"
"\"dope\",\n"
"\"dose\",\n"
"\"drag\",\n"
"\"dress\",\n"
"\"drug\",\n"
"\"dump\",\n"
"\"ear\",\n"
"\"edge\",\n"
"\"egg\",\n"
"\"elbow\",\n"
"\"electron\",\n"
"\"eleven\",\n"
"\"end\",\n"
"\"enemy\",\n"
"\"error\",\n"
"\"exit\",\n"
"\"expert\",\n"
"\"face\",\n"
"\"factory\",\n"
"\"fake\",\n"
"\"fall\",\n"
"\"family\",\n"
"\"fan\",\n"
"\"farm\",\n"
"\"father\",\n"
"\"fear\",\n"
"\"feather\",\n"
"\"feeder\",\n"
"\"feet\",\n"
"\"field\",\n"
"\"fighter\",\n"
"\"file\",\n"
"\"filter\",\n"
"\"finger\",\n"
"\"fish\",\n"
"\"fist\",\n"
"\"flake\",\n"
"\"flap\",\n"
"\"flash\",\n"
"\"flood\",\n"
"\"floor\",\n"
"\"flush\",\n"
"\"foam\",\n"
"\"fog\",\n"
"\"fold\",\n"
"\"food\",\n"
"\"foot\",\n"
"\"force\",\n"
"\"forest\",\n"
"\"fork\",\n"
"\"form\",\n"
"\"fort\",\n"
"\"friction\",\n"
"\"friday\",\n"
"\"friend\",\n"
"\"front\",\n"
"\"frost\",\n"
"\"fruit\",\n"
"\"fur\",\n"
"\"game\",\n"
"\"gang\",\n"
"\"gap\",\n"
"\"garage\",\n"
"\"garden\",\n"
"\"gas\",\n"
"\"gate\",\n"
"\"gear\",\n"
"\"gene\",\n"
"\"giant\",\n"
"\"girl\",\n"
"\"gland\",\n"
"\"glass\",\n"
"\"glaze\",\n"
"\"gleam\",\n"
"\"glide\",\n"
"\"glove\",\n"
"\"glow\",\n"
"\"glue\",\n"
"\"goal\",\n"
"\"grade\",\n"
"\"graph\",\n"
"\"grass\",\n"
"\"grease\",\n"
"\"grid\",\n"
"\"grip\",\n"
"\"groan\",\n"
"\"gross\",\n"
"\"growth\",\n"
"\"guard\",\n"
"\"guest\",\n"
"\"guide\",\n"
"\"gum\",\n"
"\"gun\",\n"
"\"guy\",\n"
"\"habit\",\n"
"\"hail\",\n"
"\"hair\",\n"
"\"half\",\n"
"\"hall\",\n"
"\"hammer\",\n"
"\"hand\",\n"
"\"handle\",\n"
"\"hangar\",\n"
"\"harbor\",\n"
"\"hardware\",\n"
"\"harm\",\n"
"\"harpoon\",\n"
"\"haste\",\n"
"\"hat\",\n"
"\"hatch\",\n"
"\"hate\",\n"
"\"hazard\",\n"
"\"head\",\n"
"\"heap\",\n"
"\"heart\",\n"
"\"heat\",\n"
"\"heater\",\n"
"\"heel\",\n"
"\"heels\",\n"
"\"height\",\n"
"\"hello\",\n"
"\"helm\",\n"
"\"helmet\",\n"
"\"help\",\n"
"\"hem\",\n"
"\"here\",\n"
"\"hertz\",\n"
"\"hill\",\n"
"\"hint\",\n"
"\"hip\",\n"
"\"hiss\",\n"
"\"hold\",\n"
"\"hole\",\n"
"\"home\",\n"
"\"honk\",\n"
"\"hood\",\n"
"\"hoof\",\n"
"\"hook\",\n"
"\"hoop\",\n"
"\"horn\",\n"
"\"hose\",\n"
"\"hotel\",\n"
"\"hour\",\n"
"\"house\",\n"
"\"howl\",\n"
"\"hub\",\n"
"\"hug\",\n"
"\"hull\",\n"
"\"hum\",\n"
"\"human\",\n"
"\"humor\",\n"
"\"hump\",\n"
"\"hundred\",\n"
"\"hunk\",\n"
"\"hunt\",\n"
"\"hush\",\n"
"\"hut\",\n"
"\"ice\",\n"
"\"icing\",\n"
"\"idea\",\n"
"\"ideal\",\n"
"\"image\",\n"
"\"impact\",\n"
"\"impulse\",\n"
"\"inch\",\n"
"\"injury\",\n"
"\"ink\",\n"
"\"inlet\",\n"
"\"inlets\",\n"
"\"input\",\n"
"\"inquiry\",\n"
"\"insanity\",\n"
"\"insignia\",\n"
"\"intake\",\n"
"\"intakes\",\n"
"\"integer\",\n"
"\"integrity\",\n"
"\"intent\",\n"
"\"intents\",\n"
"\"intercom\",\n"
"\"interest\",\n"
"\"interface\",\n"
"\"interior\",\n"
"\"interval\",\n"
"\"interview\",\n"
"\"invention\",\n"
"\"invoice\",\n"
"\"iron\",\n"
"\"island\",\n"
"\"issue\",\n"
"\"item\",\n"
"\"ivory\",\n"
"\"jack\",\n"
"\"jail\",\n"
"\"jam\",\n"
"\"jar\",\n"
"\"jaw\",\n"
"\"jelly\",\n"
"\"jewel\",\n"
"\"jig\",\n"
"\"job\",\n"
"\"joint\",\n"
"\"judge\",\n"
"\"jug\",\n"
"\"july\",\n"
"\"jump\",\n"
"\"june\",\n"
"\"junk\",\n"
"\"jury\",\n"
"\"justice\",\n"
"\"keel\",\n"
"\"kettle\",\n"
"\"key\",\n"
"\"keyboard\",\n"
"\"keyword\",\n"
"\"kick\",\n"
"\"kill\",\n"
"\"kiss\",\n"
"\"kit\",\n"
"\"kite\",\n"
"\"knee\",\n"
"\"knife\",\n"
"\"knob\",\n"
"\"knock\",\n"
"\"knot\",\n"
"\"label\",\n"
"\"labor\",\n"
"\"lace\",\n"
"\"lack\",\n"
"\"ladder\",\n"
"\"lake\",\n"
"\"lamp\",\n"
"\"land\",\n"
"\"lane\",\n"
"\"lantern\",\n"
"\"lap\",\n"
"\"lapse\",\n"
"\"lard\",\n"
"\"laser\",\n"
"\"lash\",\n"
"\"latch\",\n"
"\"laugh\",\n"
"\"launch\",\n"
"\"laundry\",\n"
"\"law\",\n"
"\"layer\",\n"
"\"lead\",\n"
"\"leader\",\n"
"\"leaf\",\n"
"\"leak\",\n"
"\"leakage\",\n"
"\"leap\",\n"
"\"leaper\",\n"
"\"leather\",\n"
"\"leave\",\n"
"\"leg\",\n"
"\"legend\",\n"
"\"length\",\n"
"\"lesson\",\n"
"\"letter\",\n"
"\"liberty\",\n"
"\"library\",\n"
"\"lick\",\n"
"\"lid\",\n"
"\"life\",\n"
"\"lift\",\n"
"\"light\",\n"
"\"limb\",\n"
"\"lime\",\n"
"\"limit\",\n"
"\"limp\",\n"
"\"line\",\n"
"\"linen\",\n"
"\"link\",\n"
"\"lint\",\n"
"\"lip\",\n"
"\"liquor\",\n"
"\"list\",\n"
"\"liter\",\n"
"\"litre\",\n"
"\"liver\",\n"
"\"load\",\n"
"\"loaf\",\n"
"\"loan\",\n"
"\"lock\",\n"
"\"locker\",\n"
"\"log\",\n"
"\"logic\",\n"
"\"look\",\n"
"\"loop\",\n"
"\"loss\",\n"
"\"lot\",\n"
"\"love\",\n"
"\"lumber\",\n"
"\"lump\",\n"
"\"lung\",\n"
"\"machine\",\n"
"\"magnet\",\n"
"\"mail\",\n"
"\"major\",\n"
"\"make\",\n"
"\"male\",\n"
"\"man\",\n"
"\"map\",\n"
"\"marble\",\n"
"\"march\",\n"
"\"margin\",\n"
"\"mark\",\n"
"\"market\",\n"
"\"mask\",\n"
"\"mass\",\n"
"\"mast\",\n"
"\"master\",\n"
"\"mat\",\n"
"\"match\",\n"
"\"mate\",\n"
"\"material\",\n"
"\"math\",\n"
"\"meal\",\n"
"\"meat\",\n"
"\"medal\",\n"
"\"medium\",\n"
"\"meet\",\n"
"\"member\",\n"
"\"memory\",\n"
"\"men\",\n"
"\"mention\",\n"
"\"mentions\",\n"
"\"menu\",\n"
"\"menus\",\n"
"\"mess\",\n"
"\"metal\",\n"
"\"meter\",\n"
"\"method\",\n"
"\"mile\",\n"
"\"milk\",\n"
"\"mill\",\n"
"\"mind\",\n"
"\"mine\",\n"
"\"mint\",\n"
"\"mirror\",\n"
"\"misfit\",\n"
"\"miss\",\n"
"\"mission\",\n"
"\"mist\",\n"
"\"mitt\",\n"
"\"mitten\",\n"
"\"mix\",\n"
"\"mode\",\n"
"\"model\",\n"
"\"modem\",\n"
"\"module\",\n"
"\"moment\",\n"
"\"monday\",\n"
"\"money\",\n"
"\"monitor\",\n"
"\"moon\",\n"
"\"moonlight\",\n"
"\"mop\",\n"
"\"moss\",\n"
"\"motel\",\n"
"\"mother\",\n"
"\"motion\",\n"
"\"motor\",\n"
"\"mount\",\n"
"\"mouth\",\n"
"\"move\",\n"
"\"mover\",\n"
"\"much\",\n"
"\"mud\",\n"
"\"mug\",\n"
"\"mule\",\n"
"\"muscle\",\n"
"\"music\",\n"
"\"mustard\",\n"
"\"nail\",\n"
"\"name\",\n"
"\"nation\",\n"
"\"nature\",\n"
"\"nausea\",\n"
"\"navy\",\n"
"\"neck\",\n"
"\"need\",\n"
"\"needle\",\n"
"\"neglect\",\n"
"\"nerve\",\n"
"\"nest\",\n"
"\"net\",\n"
"\"neutron\",\n"
"\"nickel\",\n"
"\"night\",\n"
"\"nod\",\n"
"\"noise\",\n"
"\"noon\",\n"
"\"north\",\n"
"\"nose\",\n"
"\"notation\",\n"
"\"note\",\n"
"\"notice\",\n"
"\"noun\",\n"
"\"nozzle\",\n"
"\"null\",\n"
"\"number\",\n"
"\"numeral\",\n"
"\"nurse\",\n"
"\"nut\",\n"
"\"nylon\",\n"
"\"oak\",\n"
"\"oar\",\n"
"\"object\",\n"
"\"ocean\",\n"
"\"odor\",\n"
"\"odors\",\n"
"\"offer\",\n"
"\"officer\",\n"
"\"ohm\",\n"
"\"oil\",\n"
"\"operand\",\n"
"\"opinion\",\n"
"\"option\",\n"
"\"orange\",\n"
"\"order\",\n"
"\"ore\",\n"
"\"organ\",\n"
"\"orifice\",\n"
"\"origin\",\n"
"\"ornament\",\n"
"\"ounce\",\n"
"\"ounces\",\n"
"\"outfit\",\n"
"\"outing\",\n"
"\"outlet\",\n"
"\"outline\",\n"
"\"output\",\n"
"\"oven\",\n"
"\"owner\",\n"
"\"oxide\",\n"
"\"oxygen\",\n"
"\"pace\",\n"
"\"pack\",\n"
"\"pad\",\n"
"\"page\",\n"
"\"pail\",\n"
"\"pain\",\n"
"\"paint\",\n"
"\"pair\",\n"
"\"pan\",\n"
"\"pane\",\n"
"\"panel\",\n"
"\"paper\",\n"
"\"parcel\",\n"
"\"parity\",\n"
"\"park\",\n"
"\"part\",\n"
"\"partner\",\n"
"\"party\",\n"
"\"pascal\",\n"
"\"pass\",\n"
"\"passage\",\n"
"\"paste\",\n"
"\"pat\",\n"
"\"patch\",\n"
"\"path\",\n"
"\"patient\",\n"
"\"patrol\",\n"
"\"paw\",\n"
"\"paws\",\n"
"\"pay\",\n"
"\"pea\",\n"
"\"peace\",\n"
"\"peak\",\n"
"\"pear\",\n"
"\"peck\",\n"
"\"pedal\",\n"
"\"peg\",\n"
"\"pen\",\n"
"\"pencil\",\n"
"\"people\",\n"
"\"percent\",\n"
"\"perfect\",\n"
"\"period\",\n"
"\"permit\",\n"
"\"person\",\n"
"\"phase\",\n"
"\"photo\",\n"
"\"pick\",\n"
"\"picture\",\n"
"\"piece\",\n"
"\"pier\",\n"
"\"pile\",\n"
"\"pilot\",\n"
"\"pin\",\n"
"\"pink\",\n"
"\"pipe\",\n"
"\"pistol\",\n"
"\"piston\",\n"
"\"pit\",\n"
"\"place\",\n"
"\"plan\",\n"
"\"plane\",\n"
"\"plant\",\n"
"\"plastic\",\n"
"\"plate\",\n"
"\"play\",\n"
"\"plead\",\n"
"\"pleasure\",\n"
"\"plot\",\n"
"\"plow\",\n"
"\"plug\",\n"
"\"pocket\",\n"
"\"point\",\n"
"\"poison\",\n"
"\"poke\",\n"
"\"pole\",\n"
"\"police\",\n"
"\"polish\",\n"
"\"poll\",\n"
"\"pond\",\n"
"\"pool\",\n"
"\"pop\",\n"
"\"port\",\n"
"\"portion\",\n"
"\"post\",\n"
"\"pot\",\n"
"\"potato\",\n"
"\"pound\",\n"
"\"powder\",\n"
"\"power\",\n"
"\"prefix\",\n"
"\"presence\",\n"
"\"present\",\n"
"\"president\",\n"
"\"press\",\n"
"\"price\",\n"
"\"prime\",\n"
"\"print\",\n"
"\"prism\",\n"
"\"prison\",\n"
"\"probe\",\n"
"\"problem\",\n"
"\"produce\",\n"
"\"product\",\n"
"\"profile\",\n"
"\"profit\",\n"
"\"program\",\n"
"\"progress\",\n"
"\"project\",\n"
"\"pronoun\",\n"
"\"proof\",\n"
"\"prop\",\n"
"\"protest\",\n"
"\"public\",\n"
"\"puddle\",\n"
"\"puff\",\n"
"\"pull\",\n"
"\"pulse\",\n"
"\"pump\",\n"
"\"punch\",\n"
"\"pupil\",\n"
"\"purchase\",\n"
"\"purge\",\n"
"\"purpose\",\n"
"\"push\",\n"
"\"pyramid\",\n"
"\"quart\",\n"
"\"quarter\",\n"
"\"question\",\n"
"\"quiet\",\n"
"\"quota\",\n"
"\"race\",\n"
"\"rack\",\n"
"\"radar\",\n"
"\"radian\",\n"
"\"radio\",\n"
"\"rag\",\n"
"\"rail\",\n"
"\"rain\",\n"
"\"rainbow\",\n"
"\"raincoat\",\n"
"\"raise\",\n"
"\"rake\",\n"
"\"ram\",\n"
"\"ramp\",\n"
"\"range\",\n"
"\"rank\",\n"
"\"rap\",\n"
"\"rate\",\n"
"\"ratio\",\n"
"\"ratios\",\n"
"\"rattle\",\n"
"\"ray\",\n"
"\"reach\",\n"
"\"reader\",\n"
"\"ream\",\n"
"\"rear\",\n"
"\"reason\",\n"
"\"rebound\",\n"
"\"receipt\",\n"
"\"recess\",\n"
"\"record\",\n"
"\"recovery\",\n"
"\"recruit\",\n"
"\"reel\",\n"
"\"refund\",\n"
"\"refuse\",\n"
"\"region\",\n"
"\"regret\",\n"
"\"relay\",\n"
"\"release\",\n"
"\"relief\",\n"
"\"remedy\",\n"
"\"removal\",\n"
"\"repair\",\n"
"\"report\",\n"
"\"request\",\n"
"\"rescue\",\n"
"\"reserve\",\n"
"\"resident\",\n"
"\"residue\",\n"
"\"resource\",\n"
"\"respect\",\n"
"\"rest\",\n"
"\"result\",\n"
"\"return\",\n"
"\"reverse\",\n"
"\"review\",\n"
"\"reward\",\n"
"\"rheostat\",\n"
"\"rhythm\",\n"
"\"rib\",\n"
"\"ribbon\",\n"
"\"rice\",\n"
"\"riddle\",\n"
"\"ride\",\n"
"\"rifle\",\n"
"\"rig\",\n"
"\"rim\",\n"
"\"rinse\",\n"
"\"river\",\n"
"\"road\",\n"
"\"roar\",\n"
"\"rock\",\n"
"\"rocket\",\n"
"\"rod\",\n"
"\"roll\",\n"
"\"roof\",\n"
"\"room\",\n"
"\"root\",\n"
"\"rope\",\n"
"\"rose\",\n"
"\"round\",\n"
"\"route\",\n"
"\"rower\",\n"
"\"rubber\",\n"
"\"rudder\",\n"
"\"rug\",\n"
"\"rule\",\n"
"\"rumble\",\n"
"\"run\",\n"
"\"runner\",\n"
"\"rush\",\n"
"\"rust\",\n"
"\"sack\",\n"
"\"saddle\",\n"
"\"safety\",\n"
"\"sail\",\n"
"\"sailor\",\n"
"\"sale\",\n"
"\"salt\",\n"
"\"salute\",\n"
"\"sample\",\n"
"\"sand\",\n"
"\"sap\",\n"
"\"sash\",\n"
"\"scab\",\n"
"\"scale\",\n"
"\"scene\",\n"
"\"school\",\n"
"\"science\",\n"
"\"scope\",\n"
"\"score\",\n"
"\"scrap\",\n"
"\"scratch\",\n"
"\"scream\",\n"
"\"screen\",\n"
"\"screw\",\n"
"\"sea\",\n"
"\"seal\",\n"
"\"seam\",\n"
"\"search\",\n"
"\"season\",\n"
"\"seat\",\n"
"\"second\",\n"
"\"secret\",\n"
"\"sector\",\n"
"\"seed\",\n"
"\"self\",\n"
"\"sense\",\n"
"\"sentry\",\n"
"\"serial\",\n"
"\"series\",\n"
"\"servant\",\n"
"\"session\",\n"
"\"setup\",\n"
"\"sewage\",\n"
"\"sewer\",\n"
"\"sex\",\n"
"\"shade\",\n"
"\"shadow\",\n"
"\"shaft\",\n"
"\"shame\",\n"
"\"shape\",\n"
"\"share\",\n"
"\"shave\",\n"
"\"sheet\",\n"
"\"shelf\",\n"
"\"shell\",\n"
"\"shelter\",\n"
"\"shield\",\n"
"\"shift\",\n"
"\"ship\",\n"
"\"shirt\",\n"
"\"shock\",\n"
"\"shoe\",\n"
"\"shop\",\n"
"\"shore\",\n"
"\"shoulder\",\n"
"\"shout\",\n"
"\"shovel\",\n"
"\"show\",\n"
"\"shower\",\n"
"\"side\",\n"
"\"sight\",\n"
"\"sign\",\n"
"\"silence\",\n"
"\"silk\",\n"
"\"sill\",\n"
"\"silver\",\n"
"\"sink\",\n"
"\"sip\",\n"
"\"sir\",\n"
"\"siren\",\n"
"\"sister\",\n"
"\"site\",\n"
"\"size\",\n"
"\"skew\",\n"
"\"skill\",\n"
"\"skin\",\n"
"\"skip\",\n"
"\"skirt\",\n"
"\"sky\",\n"
"\"slap\",\n"
"\"slash\",\n"
"\"slate\",\n"
"\"slave\",\n"
"\"sled\",\n"
"\"sleep\",\n"
"\"sleeve\",\n"
"\"slice\",\n"
"\"slide\",\n"
"\"slope\",\n"
"\"slot\",\n"
"\"smash\",\n"
"\"smell\",\n"
"\"smile\",\n"
"\"smoke\",\n"
"\"snap\",\n"
"\"sneeze\",\n"
"\"snow\",\n"
"\"soap\",\n"
"\"society\",\n"
"\"sock\",\n"
"\"socket\",\n"
"\"sod\",\n"
"\"software\",\n"
"\"soil\",\n"
"\"soldier\",\n"
"\"sole\",\n"
"\"son\",\n"
"\"sonar\",\n"
"\"song\",\n"
"\"sort\",\n"
"\"sound\",\n"
"\"soup\",\n"
"\"source\",\n"
"\"south\",\n"
"\"space\",\n"
"\"spacer\",\n"
"\"spade\",\n"
"\"span\",\n"
"\"spar\",\n"
"\"spare\",\n"
"\"spark\",\n"
"\"speaker\",\n"
"\"spear\",\n"
"\"speech\",\n"
"\"speed\",\n"
"\"speeder\",\n"
"\"spike\",\n"
"\"spill\",\n"
"\"spiral\",\n"
"\"splash\",\n"
"\"splice\",\n"
"\"splint\",\n"
"\"spoke\",\n"
"\"sponge\",\n"
"\"sponsor\",\n"
"\"sponsors\",\n"
"\"spool\",\n"
"\"spoon\",\n"
"\"sport\",\n"
"\"spot\",\n"
"\"spray\",\n"
"\"spring\",\n"
"\"square\",\n"
"\"squeak\",\n"
"\"stack\",\n"
"\"staff\",\n"
"\"stage\",\n"
"\"stair\",\n"
"\"stake\",\n"
"\"stall\",\n"
"\"stamp\",\n"
"\"stand\",\n"
"\"staple\",\n"
"\"star\",\n"
"\"stare\",\n"
"\"start\",\n"
"\"state\",\n"
"\"status\",\n"
"\"steam\",\n"
"\"steamer\",\n"
"\"steel\",\n"
"\"stem\",\n"
"\"step\",\n"
"\"stern\",\n"
"\"stick\",\n"
"\"sting\",\n"
"\"stitch\",\n"
"\"stock\",\n"
"\"stomach\",\n"
"\"stone\",\n"
"\"stool\",\n"
"\"stop\",\n"
"\"store\",\n"
"\"storm\",\n"
"\"story\",\n"
"\"stove\",\n"
"\"strain\",\n"
"\"strand\",\n"
"\"strap\",\n"
"\"straw\",\n"
"\"streak\",\n"
"\"stream\",\n"
"\"street\",\n"
"\"stress\",\n"
"\"strike\",\n"
"\"string\",\n"
"\"strip\",\n"
"\"stripe\",\n"
"\"strobe\",\n"
"\"stroke\",\n"
"\"strut\",\n"
"\"stub\",\n"
"\"student\",\n"
"\"study\",\n"
"\"stuff\",\n"
"\"stump\",\n"
"\"submarine\",\n"
"\"success\",\n"
"\"sugar\",\n"
"\"suit\",\n"
"\"sum\",\n"
"\"sun\",\n"
"\"sunday\",\n"
"\"sunlight\",\n"
"\"sunrise\",\n"
"\"sunset\",\n"
"\"sunshine\",\n"
"\"surface\",\n"
"\"surge\",\n"
"\"surprise\",\n"
"\"swab\",\n"
"\"swallow\",\n"
"\"swamp\",\n"
"\"swap\",\n"
"\"sweep\",\n"
"\"swell\",\n"
"\"swim\",\n"
"\"swimmer\",\n"
"\"swing\",\n"
"\"switch\",\n"
"\"swivel\",\n"
"\"sword\",\n"
"\"symbol\",\n"
"\"system\",\n"
"\"tab\",\n"
"\"table\",\n"
"\"tablet\",\n"
"\"tack\",\n"
"\"tactic\",\n"
"\"tag\",\n"
"\"tail\",\n"
"\"tailor\",\n"
"\"talk\",\n"
"\"tan\",\n"
"\"tank\",\n"
"\"tap\",\n"
"\"tape\",\n"
"\"tar\",\n"
"\"target\",\n"
"\"task\",\n"
"\"taste\",\n"
"\"tax\",\n"
"\"taxi\",\n"
"\"team\",\n"
"\"tear\",\n"
"\"teeth\",\n"
"\"teller\",\n"
"\"temper\",\n"
"\"tender\",\n"
"\"tens\",\n"
"\"tension\",\n"
"\"tent\",\n"
"\"tenth\",\n"
"\"term\",\n"
"\"terrain\",\n"
"\"test\",\n"
"\"tests\",\n"
"\"text\",\n"
"\"theory\",\n"
"\"thin\",\n"
"\"thing\",\n"
"\"thirty\",\n"
"\"thread\",\n"
"\"threat\",\n"
"\"throat\",\n"
"\"thumb\",\n"
"\"thunder\",\n"
"\"tick\",\n"
"\"tide\",\n"
"\"tie\",\n"
"\"till\",\n"
"\"time\",\n"
"\"timer\",\n"
"\"timers\",\n"
"\"times\",\n"
"\"tin\",\n"
"\"tip\",\n"
"\"tips\",\n"
"\"tire\",\n"
"\"tissue\",\n"
"\"title\",\n"
"\"today\",\n"
"\"toe\",\n"
"\"ton\",\n"
"\"tongue\",\n"
"\"tool\",\n"
"\"tools\",\n"
"\"tooth\",\n"
"\"top\",\n"
"\"topic\",\n"
"\"toss\",\n"
"\"total\",\n"
"\"touch\",\n"
"\"tour\",\n"
"\"towel\",\n"
"\"tower\",\n"
"\"town\",\n"
"\"trace\",\n"
"\"track\",\n"
"\"tracker\",\n"
"\"tractor\",\n"
"\"trade\",\n"
"\"traffic\",\n"
"\"trail\",\n"
"\"trailer\",\n"
"\"train\",\n"
"\"transfer\",\n"
"\"transit\",\n"
"\"trap\",\n"
"\"trash\",\n"
"\"tray\",\n"
"\"tree\",\n"
"\"trial\",\n"
"\"trick\",\n"
"\"trigger\",\n"
"\"trim\",\n"
"\"trip\",\n"
"\"troop\",\n"
"\"trouble\",\n"
"\"truck\",\n"
"\"trunk\",\n"
"\"truth\",\n"
"\"try\",\n"
"\"tub\",\n"
"\"tug\",\n"
"\"tune\",\n"
"\"tunnel\",\n"
"\"turn\",\n"
"\"twig\",\n"
"\"twin\",\n"
"\"twine\",\n"
"\"twirl\",\n"
"\"twist\",\n"
"\"type\",\n"
"\"typist\",\n"
"\"umbrella\",\n"
"\"uniform\",\n"
"\"unit\",\n"
"\"update\",\n"
"\"upside\",\n"
"\"usage\",\n"
"\"use\",\n"
"\"user\",\n"
"\"vacuum\",\n"
"\"value\",\n"
"\"valve\",\n"
"\"vapor\",\n"
"\"vector\",\n"
"\"vehicle\",\n"
"\"vendor\",\n"
"\"vent\",\n"
"\"verb\",\n"
"\"version\",\n"
"\"vessel\",\n"
"\"veteran\",\n"
"\"vice\",\n"
"\"victim\",\n"
"\"video\",\n"
"\"view\",\n"
"\"village\",\n"
"\"vine\",\n"
"\"violet\",\n"
"\"visit\",\n"
"\"voice\",\n"
"\"volt\",\n"
"\"vomit\",\n"
"\"wafer\",\n"
"\"wage\",\n"
"\"wagon\",\n"
"\"waist\",\n"
"\"wait\",\n"
"\"wake\",\n"
"\"walk\",\n"
"\"wall\",\n"
"\"want\",\n"
"\"war\",\n"
"\"wash\",\n"
"\"waste\",\n"
"\"watch\",\n"
"\"water\",\n"
"\"watt\",\n"
"\"wave\",\n"
"\"wax\",\n"
"\"way\",\n"
"\"web\",\n"
"\"weed\",\n"
"\"week\",\n"
"\"weight\",\n"
"\"weld\",\n"
"\"west\",\n"
"\"wheel\",\n"
"\"whip\",\n"
"\"whirl\",\n"
"\"width\",\n"
"\"wiggle\",\n"
"\"win\",\n"
"\"winch\",\n"
"\"wind\",\n"
"\"wine\",\n"
"\"wing\",\n"
"\"winter\",\n"
"\"wire\",\n"
"\"wish\",\n"
"\"woman\",\n"
"\"wonder\",\n"
"\"wood\",\n"
"\"wool\",\n"
"\"word\",\n"
"\"work\",\n"
"\"world\",\n"
"\"worm\",\n"
"\"worry\",\n"
"\"worth\",\n"
"\"wrap\",\n"
"\"wreck\",\n"
"\"wrench\",\n"
"\"wrist\",\n"
"\"writer\",\n"
"\"yard\",\n"
"\"yarn\",\n"
"\"year\",\n"
"\"yell\",\n"
"\"yield\",\n"
"\"yolk\",\n"
"\"zero\",\n"
"\"zip\",\n"
"\"zone\",\n"
"\"can\",\n"
"\"may\",\n"
"\"coupling\",\n"
"\"damping\",\n"
"\"ending\",\n"
"\"rigging\",\n"
"\"ring\",\n"
"\"sizing\",\n"
"\"sling\",\n"
"\"nothing\",\n"
"\"cast\",\n"
"\"cost\",\n"
"\"cut\",\n"
"\"drunk\",\n"
"\"felt\",\n"
"\"ground\",\n"
"\"hit\",\n"
"\"lent\",\n"
"\"offset\",\n"
"\"set\",\n"
"\"shed\",\n"
"\"shot\",\n"
"\"slit\",\n"
"\"thought\",\n"
"\"wound\",\n"
"}\n"
"\n"
"\n"
"",

"global","--\r\n"
"-- Simple lock on the global table to stop accidental creation of new gobals\r\n"
"--\r\n"
"-- if you really want to create a new global use global.name=value which bypasses this lock\r\n"
"--\r\n"
"-- locks globals by default but this lock can be turned on/off later on\r\n"
"--\r\n"
"-- this assumes you are not using the newindex metamethod on your global table already or\r\n"
"-- doing anything with function environment so I'm free to set or clear it at will\r\n"
"-- \r\n"
"--\r\n"
"\r\n"
"local _G=_G\r\n"
"local rawget=rawget\r\n"
"local rawset=rawset\r\n"
"\r\n"
"local g =\r\n"
"{\r\n"
"\r\n"
"	__newindex_lock = function ()	-- set error function\r\n"
"		local mt=getmetatable(_G)\r\n"
"			if not mt then\r\n"
"				mt={}\r\n"
"				setmetatable(_G,mt)\r\n"
"			end\r\n"
"			mt.__newindex = function(t,i,v)\r\n"
"				error(\"cannot create global variable `\"..i..\"'\",2)\r\n"
"			end\r\n"
"		end\r\n"
"	,\r\n"
"	__newindex_unlock = function ()	-- clear error function\r\n"
"		local mt=getmetatable(_G)\r\n"
"			if mt then\r\n"
"				mt.__newindex = null\r\n"
"			end\r\n"
"		end\r\n"
"}\r\n"
"setmetatable(g, {\r\n"
"		__index=function(t,i) return rawget(_G,i) end,\r\n"
"		__newindex=function(t,i,v) rawset(_G,i,v) end,\r\n"
"	})\r\n"
"\r\n"
"\r\n"
"-- the default module function is bad... replace it with one that is less bad\r\n"
"-- this may technically break some modules but probably wont\r\n"
"\r\n"
"local _LOADED = package.loaded\r\n"
"function _G.module (modname, ...)\r\n"
"	local ns = {}\r\n"
"\r\n"
"	if type(_LOADED[modname])==\"table\" then error(\"module name clash \"..modname) end -- check\r\n"
"	_LOADED[modname]=ns -- set\r\n"
"	\r\n"
"	if not ns._NAME then\r\n"
"		ns._NAME = modname\r\n"
"		ns._M = ns\r\n"
"		ns._PACKAGE = string.gsub (modname, \"[^.]*$\", \"\")\r\n"
"	end\r\n"
"	setfenv (2, ns)\r\n"
"	for i, f in ipairs({...}) do\r\n"
"		f(ns)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"--[[\r\n"
"local req=require\r\n"
"function _G.require(...)\r\n"
"	print(\"require\",...)\r\n"
"	return req(...)\r\n"
"end\r\n"
"]]\r\n"
"\r\n"
"-- switch global lock on\r\n"
"g.__newindex_lock()\r\n"
"\r\n"
"return g\r\n"
"",

"wetgenes.gamecake.mods.mouse","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"local gcinfo=gcinfo\r\n"
"\r\n"
"local hex=function(str) return tonumber(str,16) end\r\n"
"\r\n"
"local pack=require(\"wetgenes.pack\")\r\n"
"\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"local tardis=require(\"wetgenes.tardis\")	-- matrix/vector math\r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"local buffedit=require(\"wetgenes.gamecake.mods.console.buffedit\")\r\n"
"\r\n"
"\r\n"
"function M.bake(oven,mouse)\r\n"
"\r\n"
"	mouse=mouse or {}\r\n"
"	mouse.modname=M.modname\r\n"
"	\r\n"
"	mouse.active=false\r\n"
"\r\n"
"	local win=oven.win\r\n"
"	local cake=oven.cake\r\n"
"	local gl=oven.gl\r\n"
"\r\n"
"	local canvas=cake.canvas\r\n"
"	local font=canvas.font\r\n"
"	local flat=canvas.flat\r\n"
"	local layout=cake.layouts.create{} -- fullscreen\r\n"
"\r\n"
"	function mouse.setup()\r\n"
"	\r\n"
"		mouse.input={\r\n"
"			x=0,\r\n"
"			y=0,\r\n"
"		} -- current state of the raw posix mouse inputs\r\n"
"\r\n"
"		mouse.x=0\r\n"
"		mouse.y=0\r\n"
"		mouse.xraw=0\r\n"
"		mouse.yraw=0\r\n"
"		\r\n"
"		if win.flavour==\"raspi\" then -- we need to manage a mouse curser and input\r\n"
"			mouse.active=true\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"\r\n"
"	function mouse.clean()\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	function mouse.update()\r\n"
"	\r\n"
"		if not mouse.active then return end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"	function mouse.draw()\r\n"
"	\r\n"
"		if not mouse.active then return end\r\n"
"		\r\n"
"		layout.apply()\r\n"
"\r\n"
"--		layout.viewport() -- did our window change?\r\n"
"--		layout.project23d(layout.w,layout.h,1/4,layout.h*4)\r\n"
"		\r\n"
"		canvas.gl_default() -- reset gl state\r\n"
"\r\n"
"--		gl.MatrixMode(gl.PROJECTION)\r\n"
"--		gl.LoadMatrix( layout.pmtx )\r\n"
"\r\n"
"--		gl.MatrixMode(gl.MODELVIEW)\r\n"
"--		gl.LoadIdentity()\r\n"
"--		gl.Translate(-w/2,-h/2,-h) -- top/left 1unit==1pixel\r\n"
"		gl.PushMatrix()\r\n"
"\r\n"
"		local wh=layout.w*layout.h\r\n"
"		local ss=math.ceil(math.sqrt(wh)/1000)\r\n"
"		\r\n"
"\r\n"
"--		flat.quad(mouse.xraw,mouse.yraw,mouse.xraw+16*ss,mouse.yraw+16*ss)\r\n"
"		\r\n"
"		local x,y=mouse.xraw,mouse.yraw\r\n"
"\r\n"
"		local dat1={\r\n"
"			x+12*ss,	y+12*ss,	0,		0.75,0.75,0.75,0.75,\r\n"
"			x+5*ss,		y+12*ss,	0,		0.75,0.75,0.75,0.75,\r\n"
"			x,			y,			0,		1,1,1,1,\r\n"
"			x,			y+17*ss,	0,		0.75,0.75,0.75,0.75,\r\n"
"			\r\n"
"			}\r\n"
"			\r\n"
"		local dat2={\r\n"
"			x+14*ss,		y+13*ss,	0,\r\n"
"			x+5*ss,			y+13*ss,	0,\r\n"
"			x-1*ss,			y-2*ss,		0,\r\n"
"			x-1*ss,			y+19*ss,	0,\r\n"
"			\r\n"
"			}\r\n"
"		\r\n"
"		gl.Color(pack.argb4_pmf4(0xf000))\r\n"
"		flat.tristrip(\"xyz\",dat2)\r\n"
"\r\n"
"		gl.Color(pack.argb4_pmf4(0xffff))			\r\n"
"		flat.tristrip(\"xyzrgba\",dat1)\r\n"
"\r\n"
"		gl.PopMatrix()\r\n"
"\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	\r\n"
"	function mouse.msg(m)\r\n"
"	\r\n"
"		if not mouse.active then return m end\r\n"
"	\r\n"
"if m.class==\"posix_mouse\" then\r\n"
"\r\n"
"	local function adjust(dx,dy)\r\n"
"\r\n"
"		local inp=mouse.input\r\n"
"		\r\n"
"		inp.x=inp.x+dx\r\n"
"		inp.y=inp.y+dy\r\n"
"		\r\n"
"		if inp.x<0   then inp.x=0    end\r\n"
"		if inp.y<0   then inp.y=0    end\r\n"
"		if inp.x>=win.width  then inp.x=win.width-1 end\r\n"
"		if inp.y>=win.height then inp.y=win.height-1 end\r\n"
"		\r\n"
"		win:push_msg{time=os.time(),class=\"mouse\",x=inp.x,y=inp.y,action=0,keycode=0}\r\n"
"		\r\n"
"	end\r\n"
"	local function click(code,act)\r\n"
"\r\n"
"		local inp=mouse.input\r\n"
"\r\n"
"		win:push_msg{time=os.time(),class=\"mouse\",x=inp.x,y=inp.y,action=act,keycode=code}\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"--	print(m.class,m.type,m.code,m.value)\r\n"
"\r\n"
"	if m.type==2 then -- movement\r\n"
"	\r\n"
"		local v=m.value\r\n"
"		if v >= 0x80000000 then v=v-0x100000000 end\r\n"
"\r\n"
"		if m.code==0 then -- x\r\n"
"			adjust(v,0)\r\n"
"		elseif m.code==1 then -- y\r\n"
"			adjust(0,v)			\r\n"
"--		elseif m.code==8 then -- mouse wheel\r\n"
"--			print(\"z\",v)\r\n"
"		end\r\n"
"		\r\n"
"	elseif m.type==1 then -- buttons\r\n"
"	\r\n"
"		local k=1+m.code-272 -- 1 is the left mouse button\r\n"
"		\r\n"
"		if m.value==0 then --up\r\n"
"			click(k,-1)\r\n"
"		elseif m.value==1 then --down\r\n"
"			click(k, 1)		\r\n"
"		end\r\n"
"	\r\n"
"	end\r\n"
"	\r\n"
"	return nil -- we ate it\r\n"
"end\r\n"
"\r\n"
"--print(m.class)\r\n"
"\r\n"
"		if m.class==\"key\" then\r\n"
"		\r\n"
"			\r\n"
"		elseif m.class==\"mouse\" then\r\n"
"		\r\n"
"			mouse.xraw=m.xraw or m.x\r\n"
"			mouse.yraw=m.yraw or m.y\r\n"
"			mouse.x=m.x\r\n"
"			mouse.y=m.y\r\n"
"			\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"		return m\r\n"
"	end\r\n"
"\r\n"
"	return mouse\r\n"
"end\r\n"
"",

"ltn12","-----------------------------------------------------------------------------\n"
"-- LTN12 - Filters, sources, sinks and pumps.\n"
"-- LuaSocket toolkit.\n"
"-- Author: Diego Nehab\n"
"-- RCS ID: $Id: ltn12.lua,v 1.31 2006/04/03 04:45:42 diego Exp $\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Declare module\n"
"-----------------------------------------------------------------------------\n"
"local string = require(\"string\")\n"
"local table = require(\"table\")\n"
"local base = _G\n"
"module(\"ltn12\")\n"
"\n"
"filter = {}\n"
"source = {}\n"
"sink = {}\n"
"pump = {}\n"
"\n"
"-- 2048 seems to be better in windows...\n"
"BLOCKSIZE = 2048\n"
"_VERSION = \"LTN12 1.0.1\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Filter stuff\n"
"-----------------------------------------------------------------------------\n"
"-- returns a high level filter that cycles a low-level filter\n"
"function filter.cycle(low, ctx, extra)\n"
"    base.assert(low)\n"
"    return function(chunk)\n"
"        local ret\n"
"        ret, ctx = low(ctx, chunk, extra)\n"
"        return ret\n"
"    end\n"
"end\n"
"\n"
"-- chains a bunch of filters together\n"
"-- (thanks to Wim Couwenberg)\n"
"function filter.chain(...)\n"
"    local n = table.getn(arg)\n"
"    local top, index = 1, 1\n"
"    local retry = \"\"\n"
"    return function(chunk)\n"
"        retry = chunk and retry\n"
"        while true do\n"
"            if index == top then\n"
"                chunk = arg[index](chunk)\n"
"                if chunk == \"\" or top == n then return chunk\n"
"                elseif chunk then index = index + 1\n"
"                else\n"
"                    top = top+1\n"
"                    index = top\n"
"                end\n"
"            else\n"
"                chunk = arg[index](chunk or \"\")\n"
"                if chunk == \"\" then\n"
"                    index = index - 1\n"
"                    chunk = retry\n"
"                elseif chunk then\n"
"                    if index == n then return chunk\n"
"                    else index = index + 1 end\n"
"                else base.error(\"filter returned inappropriate nil\") end\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Source stuff\n"
"-----------------------------------------------------------------------------\n"
"-- create an empty source\n"
"local function empty()\n"
"    return nil\n"
"end\n"
"\n"
"function source.empty()\n"
"    return empty\n"
"end\n"
"\n"
"-- returns a source that just outputs an error\n"
"function source.error(err)\n"
"    return function()\n"
"        return nil, err\n"
"    end\n"
"end\n"
"\n"
"-- creates a file source\n"
"function source.file(handle, io_err)\n"
"    if handle then\n"
"        return function()\n"
"            local chunk = handle:read(BLOCKSIZE)\n"
"            if not chunk then handle:close() end\n"
"            return chunk\n"
"        end\n"
"    else return source.error(io_err or \"unable to open file\") end\n"
"end\n"
"\n"
"-- turns a fancy source into a simple source\n"
"function source.simplify(src)\n"
"    base.assert(src)\n"
"    return function()\n"
"        local chunk, err_or_new = src()\n"
"        src = err_or_new or src\n"
"        if not chunk then return nil, err_or_new\n"
"        else return chunk end\n"
"    end\n"
"end\n"
"\n"
"-- creates string source\n"
"function source.string(s)\n"
"    if s then\n"
"        local i = 1\n"
"        return function()\n"
"            local chunk = string.sub(s, i, i+BLOCKSIZE-1)\n"
"            i = i + BLOCKSIZE\n"
"            if chunk ~= \"\" then return chunk\n"
"            else return nil end\n"
"        end\n"
"    else return source.empty() end\n"
"end\n"
"\n"
"-- creates rewindable source\n"
"function source.rewind(src)\n"
"    base.assert(src)\n"
"    local t = {}\n"
"    return function(chunk)\n"
"        if not chunk then\n"
"            chunk = table.remove(t)\n"
"            if not chunk then return src()\n"
"            else return chunk end\n"
"        else\n"
"            table.insert(t, chunk)\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function source.chain(src, f)\n"
"    base.assert(src and f)\n"
"    local last_in, last_out = \"\", \"\"\n"
"    local state = \"feeding\"\n"
"    local err\n"
"    return function()\n"
"        if not last_out then\n"
"            base.error('source is empty!', 2)\n"
"        end\n"
"        while true do\n"
"            if state == \"feeding\" then\n"
"                last_in, err = src()\n"
"                if err then return nil, err end\n"
"                last_out = f(last_in)\n"
"                if not last_out then\n"
"                    if last_in then\n"
"                        base.error('filter returned inappropriate nil')\n"
"                    else\n"
"                        return nil\n"
"                    end\n"
"                elseif last_out ~= \"\" then\n"
"                    state = \"eating\"\n"
"                    if last_in then last_in = \"\" end\n"
"                    return last_out\n"
"                end\n"
"            else\n"
"                last_out = f(last_in)\n"
"                if last_out == \"\" then\n"
"                    if last_in == \"\" then\n"
"                        state = \"feeding\"\n"
"                    else\n"
"                        base.error('filter returned \"\"')\n"
"                    end\n"
"                elseif not last_out then\n"
"                    if last_in then\n"
"                        base.error('filter returned inappropriate nil')\n"
"                    else\n"
"                        return nil\n"
"                    end\n"
"                else\n"
"                    return last_out\n"
"                end\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-- creates a source that produces contents of several sources, one after the\n"
"-- other, as if they were concatenated\n"
"-- (thanks to Wim Couwenberg)\n"
"function source.cat(...)\n"
"    local src = table.remove(arg, 1)\n"
"    return function()\n"
"        while src do\n"
"            local chunk, err = src()\n"
"            if chunk then return chunk end\n"
"            if err then return nil, err end\n"
"            src = table.remove(arg, 1)\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Sink stuff\n"
"-----------------------------------------------------------------------------\n"
"-- creates a sink that stores into a table\n"
"function sink.table(t)\n"
"    t = t or {}\n"
"    local f = function(chunk, err)\n"
"        if chunk then table.insert(t, chunk) end\n"
"        return 1\n"
"    end\n"
"    return f, t\n"
"end\n"
"\n"
"-- turns a fancy sink into a simple sink\n"
"function sink.simplify(snk)\n"
"    base.assert(snk)\n"
"    return function(chunk, err)\n"
"        local ret, err_or_new = snk(chunk, err)\n"
"        if not ret then return nil, err_or_new end\n"
"        snk = err_or_new or snk\n"
"        return 1\n"
"    end\n"
"end\n"
"\n"
"-- creates a file sink\n"
"function sink.file(handle, io_err)\n"
"    if handle then\n"
"        return function(chunk, err)\n"
"            if not chunk then\n"
"                handle:close()\n"
"                return 1\n"
"            else return handle:write(chunk) end\n"
"        end\n"
"    else return sink.error(io_err or \"unable to open file\") end\n"
"end\n"
"\n"
"-- creates a sink that discards data\n"
"local function null()\n"
"    return 1\n"
"end\n"
"\n"
"function sink.null()\n"
"    return null\n"
"end\n"
"\n"
"-- creates a sink that just returns an error\n"
"function sink.error(err)\n"
"    return function()\n"
"        return nil, err\n"
"    end\n"
"end\n"
"\n"
"-- chains a sink with a filter\n"
"function sink.chain(f, snk)\n"
"    base.assert(f and snk)\n"
"    return function(chunk, err)\n"
"        if chunk ~= \"\" then\n"
"            local filtered = f(chunk)\n"
"            local done = chunk and \"\"\n"
"            while true do\n"
"                local ret, snkerr = snk(filtered, err)\n"
"                if not ret then return nil, snkerr end\n"
"                if filtered == done then return 1 end\n"
"                filtered = f(done)\n"
"            end\n"
"        else return 1 end\n"
"    end\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Pump stuff\n"
"-----------------------------------------------------------------------------\n"
"-- pumps one chunk from the source to the sink\n"
"function pump.step(src, snk)\n"
"    local chunk, src_err = src()\n"
"    local ret, snk_err = snk(chunk, src_err)\n"
"    if chunk and ret then return 1\n"
"    else return nil, src_err or snk_err end\n"
"end\n"
"\n"
"-- pumps all data from a source to a sink, using a step function\n"
"function pump.all(src, snk, step)\n"
"    base.assert(src and snk)\n"
"    step = step or pump.step\n"
"    while true do\n"
"        local ret, err = step(src, snk)\n"
"        if not ret then\n"
"            if err then return nil, err\n"
"            else return 1 end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"",

"wetgenes.gamecake.canvas","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"local wgrd=require(\"wetgenes.grd\")\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"local pack=require(\"wetgenes.pack\")\r\n"
"local core=require(\"wetgenes.gamecake.core\")\r\n"
"\r\n"
"local tcore=require(\"wetgenes.tardis.core\")\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,canvas)\r\n"
"		\r\n"
"-- link together sub parts\r\n"
"	local font={}\r\n"
"	local flat={}\r\n"
"	canvas.font,font.canvas=font,canvas\r\n"
"	canvas.flat,flat.canvas=flat,canvas\r\n"
"\r\n"
"	local gl=oven.gl\r\n"
"	local cake=oven.cake\r\n"
"	local win=oven.win\r\n"
"	local images=cake.images\r\n"
"	local buffers=cake.buffers\r\n"
"\r\n"
"-- prefer shader that discard pixels with low alpha < 0.25\r\n"
"	canvas.discard_low_alpha=false\r\n"
"\r\n"
"canvas.gl_default=function()\r\n"
"\r\n"
"-- the default gl state, when we deviate from this we should restore it...\r\n"
"\r\n"
"	gl.PixelStore(gl.PACK_ALIGNMENT,1)\r\n"
"	gl.PixelStore(gl.UNPACK_ALIGNMENT,1) -- the grd code expects fully packed bitmaps\r\n"
"\r\n"
"	gl.Disable(gl.DEPTH_TEST)\r\n"
"	gl.Disable(gl.CULL_FACE)\r\n"
"	\r\n"
"	gl.Color(1,1,1,1)	\r\n"
"\r\n"
"	gl.BlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)\r\n"
"	gl.Enable(gl.BLEND)\r\n"
"	\r\n"
"	gl.MatrixMode(gl.MODELVIEW)\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"font.set = function(dat)\r\n"
"	if dat and dat~=font.dat then -- newfont, autokill the cache?\r\n"
"		font.dat=dat\r\n"
"	end\r\n"
"	font.dat=dat or font.dat\r\n"
"	font.size=16\r\n"
"	font.add=0\r\n"
"	font.x=0\r\n"
"	font.y=0\r\n"
"	if gl.patch_functions_method~=\"disable\" then\r\n"
"		core.canvas_font_sync(font)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"font.set_size = function(size,add)\r\n"
"	font.size=size\r\n"
"	font.add=add or 0 -- clear the x space tweak\r\n"
"	if gl.patch_functions_method~=\"disable\" then\r\n"
"		core.canvas_font_sync(font)\r\n"
"	end\r\n"
"end\r\n"
"font.set_xy = function(x,y)\r\n"
"	font.x=x or font.x\r\n"
"	font.y=y or font.y\r\n"
"	if gl.patch_functions_method~=\"disable\" then\r\n"
"		core.canvas_font_sync(font)\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"font.xindex=function(text,px)\r\n"
"	if px<0 then return 1 end\r\n"
"	\r\n"
"	local font_dat=font.dat\r\n"
"	local s=font.size/font_dat.size\r\n"
"	local x=0\r\n"
"	for i=1,#text do\r\n"
"	\r\n"
"		local cid=text:byte(i)\r\n"
"		local c=font_dat.chars[cid] or font_dat.chars[32]\r\n"
"		\r\n"
"		x=x+(c.add*s)+font.add\r\n"
"		\r\n"
"		if x>=px then return i end\r\n"
"	end\r\n"
"\r\n"
"	return #text\r\n"
"end\r\n"
"\r\n"
"font.width=function(text)\r\n"
"\r\n"
"	local font_dat=font.dat\r\n"
"	local s=font.size/font_dat.size\r\n"
"	local x=0\r\n"
"	for i=1,#text do\r\n"
"	\r\n"
"		local cid=text:byte(i)\r\n"
"		local c=font_dat.chars[cid] or font_dat.chars[32]\r\n"
"		\r\n"
"		x=x+(c.add*s)+font.add\r\n"
"	end\r\n"
"\r\n"
"	return x\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function font.wrap(text,opts)\r\n"
"	local w=opts.w\r\n"
"	\r\n"
"	local ls=wstr.split_whitespace(text)\r\n"
"	local t={}\r\n"
"	\r\n"
"	local wide=0\r\n"
"	local line={}\r\n"
"	\r\n"
"	local function newline()\r\n"
"		t[#t+1]=table.concat(line,\" \") or \"\"\r\n"
"		wide=0\r\n"
"		line={}\r\n"
"	end\r\n"
"	\r\n"
"	for i,v in ipairs(ls) do\r\n"
"	\r\n"
"		if v:find(\"%s\") then -- just white space\r\n"
"		\r\n"
"			for i,v in string.gfind(v,\"\\n"
"\") do -- keep newlines\r\n"
"				newline()\r\n"
"			end\r\n"
"		\r\n"
"		else -- a normal word\r\n"
"		\r\n"
"			local fw=font.width(v)\r\n"
"			if #line>0 then wide=wide+font.width(\" \") end\r\n"
"\r\n"
"			if wide + fw > w then -- split\r\n"
"				newline()\r\n"
"			end\r\n"
"			\r\n"
"			line[#line+1]=v\r\n"
"			wide=wide+fw\r\n"
"			\r\n"
"		end\r\n"
"	end\r\n"
"	if wide~=0 then newline() end -- final newline\r\n"
"	\r\n"
"	return t\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"font.draw = function(text)\r\n"
"	\r\n"
"	local p=gl.program(\"pos_tex\")\r\n"
"	\r\n"
"	gl.UseProgram( p[0] )\r\n"
"	gl.UniformMatrix4f( p:uniform(\"modelview\"), gl.matrix(gl.MODELVIEW) )\r\n"
"	gl.UniformMatrix4f( p:uniform(\"projection\"), gl.matrix(gl.PROJECTION) )	\r\n"
"	gl.Uniform4f( p:uniform(\"color\"), gl.cache.color )\r\n"
"\r\n"
"	images.bind(font.dat.images[1])\r\n"
"	\r\n"
"	gl.BindBuffer(gl.ARRAY_BUFFER,canvas.get_vb())\r\n"
"\r\n"
"	if gl.patch_functions_method~=\"disable\" then\r\n"
"		core.canvas_font_draw(font,text,p:attrib(\"a_vertex\"),p:attrib(\"a_texcoord\"))\r\n"
"	end\r\n"
"end\r\n"
"\r\n"
"\r\n"
"-- should replace this with tristrip\r\n"
"flat.quad = function(x1,y1,x2,y2,x3,y3,x4,y4)\r\n"
"\r\n"
"	if y4 then\r\n"
"		pack.save_array({\r\n"
"			x1,		y1,		0,		0,		0,\r\n"
"			x2,		y2,		0,		1,		0,\r\n"
"			x4,		y4,		0,		0,		1,\r\n"
"			x3,		y3,		0,		1,		1,\r\n"
"		},\"f32\",0,5*4,canvas.vdat)	\r\n"
"	else\r\n"
"		pack.save_array({\r\n"
"			x1,		y1,		0,		0,		0,\r\n"
"			x2,		y1,		0,		1,		0,\r\n"
"			x1,		y2,		0,		0,		1,\r\n"
"			x2,		y2,		0,		1,		1,\r\n"
"		},\"f32\",0,5*4,canvas.vdat)	\r\n"
"	end\r\n"
"\r\n"
"	local p=gl.program(\"pos\")\r\n"
"	gl.UseProgram( p[0] )\r\n"
"	gl.BindTexture( gl.TEXTURE_2D , 0 )\r\n"
"\r\n"
"	gl.BindBuffer(gl.ARRAY_BUFFER,canvas.get_vb())\r\n"
"	gl.BufferData(gl.ARRAY_BUFFER,5*4*4,canvas.vdat,gl.DYNAMIC_DRAW)\r\n"
"\r\n"
"	gl.UniformMatrix4f(p:uniform(\"modelview\"), gl.matrix(gl.MODELVIEW) )\r\n"
"	gl.UniformMatrix4f(p:uniform(\"projection\"), gl.matrix(gl.PROJECTION) )\r\n"
"	gl.Uniform4f( p:uniform(\"color\"), gl.cache.color )\r\n"
"\r\n"
"	gl.VertexAttribPointer(p:attrib(\"a_vertex\"),3,gl.FLOAT,gl.FALSE,5*4,0)\r\n"
"	gl.EnableVertexAttribArray(p:attrib(\"a_vertex\"))\r\n"
"\r\n"
"	gl.DrawArrays(gl.TRIANGLE_STRIP,0,4)\r\n"
"\r\n"
"end\r\n"
"\r\n"
"-- this allows us to prepare vertex buffers, then draw at anytime\r\n"
"-- just call it.draw on the returned table.\r\n"
"flat.tristrip_predraw = function(it) -- pass in fmt,data,progname,vb=-1 in here\r\n"
"\r\n"
"-- some basic vertexformats\r\n"
"	local pstride\r\n"
"	local pnrm\r\n"
"	local ptex\r\n"
"	local pcolor\r\n"
"	local p\r\n"
"	local progname=it.progname\r\n"
"	local fmt=it.fmt\r\n"
"	if fmt==\"xyz\" then -- xyz only\r\n"
"	\r\n"
"		progname = progname or \"pos\"\r\n"
"		pstride=12\r\n"
"	\r\n"
"	elseif fmt==\"xyznrm\" then -- xyz and normal (so we may light the thing)\r\n"
"\r\n"
"		progname = progname or \"pos_normal\"\r\n"
"\r\n"
"		pstride=24\r\n"
"		pnrm=12\r\n"
"	\r\n"
"	elseif fmt==\"xyznrmuv\" then -- xyz and normal and texture\r\n"
"\r\n"
"		progname = progname or \"pos_normal_tex\"\r\n"
"\r\n"
"		pstride=32\r\n"
"		pnrm=12\r\n"
"		ptex=24\r\n"
"	\r\n"
"	elseif fmt==\"xyzuv\" then -- xyz and texture\r\n"
"\r\n"
"		progname = progname or \"pos_tex\"\r\n"
"\r\n"
"		pstride=20\r\n"
"		ptex=12\r\n"
"	\r\n"
"	elseif fmt==\"xyzrgba\" then -- xyz and color\r\n"
"\r\n"
"		progname = progname or \"pos_color\"\r\n"
"\r\n"
"		pstride=28\r\n"
"		pcolor=12\r\n"
"	\r\n"
"	elseif fmt==\"xyzuvrgba\" then -- xyz and texture and color\r\n"
"	\r\n"
"		progname = progname or \"pos_tex_color\"\r\n"
"\r\n"
"		pstride=36\r\n"
"		ptex=12\r\n"
"		pcolor=20\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"	if canvas.discard_low_alpha then -- try not to break the zbuffer\r\n"
"		progname=progname..\"_discard\"\r\n"
"	end\r\n"
"\r\n"
"	\r\n"
"	local data=it.data\r\n"
"	local datalen=#data\r\n"
"	local datasize=datalen*4 -- we need this much vdat memory\r\n"
"	canvas.vdat_check(datasize) -- make sure we have space in the buffer\r\n"
"	\r\n"
"	if it.vb then\r\n"
"		if type(it.vb)~=\"table\" then -- need to create\r\n"
"			it.vb=buffers.create({\r\n"
"				start=function(vb)\r\n"
"					vb:bind()\r\n"
"					pack.save_array(data,\"f32\",0,datalen,canvas.vdat)\r\n"
"					gl.BufferData(gl.ARRAY_BUFFER,datasize,canvas.vdat,gl.STATIC_DRAW)\r\n"
"				end,\r\n"
"			})\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"	it.draw=function()\r\n"
"	\r\n"
"		local p=gl.program(progname)\r\n"
"		gl.UseProgram( p[0] )\r\n"
"\r\n"
"		if it.vb then -- use a precached buffer\r\n"
"			it.vb:bind()\r\n"
"		else\r\n"
"			pack.save_array(data,\"f32\",0,datalen,canvas.vdat)\r\n"
"			gl.BindBuffer(gl.ARRAY_BUFFER,canvas.get_vb())\r\n"
"			gl.BufferData(gl.ARRAY_BUFFER,datasize,canvas.vdat,gl.DYNAMIC_DRAW)\r\n"
"		end\r\n"
"\r\n"
"		gl.UniformMatrix4f(p:uniform(\"modelview\"), gl.matrix(gl.MODELVIEW) )\r\n"
"		gl.UniformMatrix4f(p:uniform(\"projection\"), gl.matrix(gl.PROJECTION) )\r\n"
"		gl.Uniform4f( p:uniform(\"color\"), gl.cache.color )\r\n"
"\r\n"
"		gl.VertexAttribPointer(p:attrib(\"a_vertex\"),3,gl.FLOAT,gl.FALSE,pstride,0)\r\n"
"		gl.EnableVertexAttribArray(p:attrib(\"a_vertex\"))\r\n"
"		\r\n"
"		if pnrm then\r\n"
"			gl.VertexAttribPointer(p:attrib(\"a_normal\"),3,gl.FLOAT,gl.TRUE,pstride,pnrm)\r\n"
"			gl.EnableVertexAttribArray(p:attrib(\"a_normal\"))\r\n"
"		end\r\n"
"\r\n"
"		if ptex then\r\n"
"			gl.VertexAttribPointer(p:attrib(\"a_texcoord\"),2,gl.FLOAT,gl.FALSE,pstride,ptex)\r\n"
"			gl.EnableVertexAttribArray(p:attrib(\"a_texcoord\"))\r\n"
"		end\r\n"
"\r\n"
"		if pcolor then\r\n"
"			gl.VertexAttribPointer(p:attrib(\"a_color\"),4,gl.FLOAT,gl.FALSE,pstride,pcolor)\r\n"
"			gl.EnableVertexAttribArray(p:attrib(\"a_color\"))\r\n"
"		end\r\n"
"\r\n"
"		gl.DrawArrays(gl.TRIANGLE_STRIP,0,datasize/pstride)\r\n"
"	end\r\n"
"\r\n"
"	return it\r\n"
"end\r\n"
"\r\n"
"-- tristrip is the most useful, 3 points gives us a tri\r\n"
"-- 4 gives us a quad, and of course you can keep going to create a strip\r\n"
"flat.tristrip = function(fmt,data,progname)\r\n"
"\r\n"
"	local it=flat.tristrip_predraw({fmt=fmt,data=data,progname=progname})\r\n"
"	it.draw()\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"\r\n"
"function canvas.delete_vbs()\r\n"
"	for i,v in ipairs(canvas.vbs) do\r\n"
"		gl.DeleteBuffer(v)\r\n"
"	end\r\n"
"	canvas.vbs={}\r\n"
"	canvas.vbi=1\r\n"
"end\r\n"
"\r\n"
"function canvas.reuse_vbs()\r\n"
"	canvas.vbi=1\r\n"
"end\r\n"
"\r\n"
"function canvas.get_vb()\r\n"
"	local vb=canvas.vbs[canvas.vbi]\r\n"
"	if not vb then\r\n"
"		vb=gl.GenBuffer()\r\n"
"		canvas.vbs[canvas.vbi]=vb\r\n"
"	end\r\n"
"	canvas.vbi=canvas.vbi+1\r\n"
"	return vb\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function canvas.start()\r\n"
"end\r\n"
"function canvas.stop()\r\n"
"	canvas.delete_vbs()\r\n"
"end\r\n"
"function canvas.draw()\r\n"
"	if canvas.vbi_flop then\r\n"
"		canvas.reuse_vbs()\r\n"
"	end\r\n"
"	canvas.vbi_flop=not canvas.vbi_flop\r\n"
"	cake.sheets.UseSheet=nil\r\n"
"end\r\n"
"\r\n"
"-- basic setup of canvas\r\n"
"	canvas.vbs={}\r\n"
"	canvas.vbi=1\r\n"
"	\r\n"
"	canvas.vdat_size=0\r\n"
"	canvas.vdat_check=function(size) -- check we have enough buffer\r\n"
"		if canvas.vdat_size<size then\r\n"
"			canvas.vdat_size=size\r\n"
"			canvas.vdat=pack.alloc(canvas.vdat_size) -- temp draw buffer		\r\n"
"		end\r\n"
"	end\r\n"
"	canvas.vdat_check(1024) -- initial buffer size it may grow but this is probably more than enough\r\n"
"	\r\n"
"	cake.fonts.load(1,1) -- make sure we have loaded the 8x8 font\r\n"
"	font.set( cake.fonts.get(1) ) -- now use it\r\n"
"	\r\n"
"	return canvas\r\n"
"end\r\n"
"",

"wetgenes.gamecake.spew.keys","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"M.bake=function(oven,keys)\r\n"
"\r\n"
"	keys=keys or {}\r\n"
"	\r\n"
"	local cake=oven.cake\r\n"
"	local canvas=cake.canvas\r\n"
"	\r\n"
"	local mkeys=oven.rebake(\"wetgenes.gamecake.mods.keys\")\r\n"
"	local recaps=oven.rebake(\"wetgenes.gamecake.spew.recaps\")\r\n"
"	\r\n"
"	keys.defaults={}\r\n"
"	keys.defaults[0]={\r\n"
"		[\"up\"]			=	\"up\",\r\n"
"		[\"w\"]			=	\"up\",\r\n"
"		[\"down\"]		=	\"down\",\r\n"
"		[\"s\"]			=	\"down\",\r\n"
"		[\"left\"]		=	\"left\",\r\n"
"		[\"a\"]			=	\"left\",\r\n"
"		[\"right\"]		=	\"right\",\r\n"
"		[\"d\"]			=	\"right\",\r\n"
"		[\"rcontrol\"]	=	\"fire\",\r\n"
"		[\"rmenu\"]		=	\"fire\",\r\n"
"		[\"space\"]		=	\"fire\",\r\n"
"		[\"lcontrol\"]	=	\"fire\",\r\n"
"		[\"lmenu\"]		=	\"fire\",\r\n"
"	}\r\n"
"\r\n"
"	keys.defaults[1]={\r\n"
"		[\"w\"]			=	\"up\",\r\n"
"		[\"s\"]			=	\"down\",\r\n"
"		[\"a\"]			=	\"left\",\r\n"
"		[\"d\"]			=	\"right\",\r\n"
"		[\"lcontrol\"]	=	\"fire\",\r\n"
"		[\"lmenu\"]		=	\"fire\",\r\n"
"	}\r\n"
"	keys.defaults[2]={\r\n"
"		[\"up\"]			=	\"up\",\r\n"
"		[\"down\"]		=	\"down\",\r\n"
"		[\"left\"]		=	\"left\",\r\n"
"		[\"right\"]		=	\"right\",\r\n"
"		[\"rcontrol\"]	=	\"fire\",\r\n"
"		[\"rmenu\"]		=	\"fire\",\r\n"
"	}\r\n"
"\r\n"
"	function keys.setup(max_up)\r\n"
"		max_up=max_up or 1\r\n"
"		keys.up={}\r\n"
"		for i=1,max_up do\r\n"
"			keys.up[i]=keys.create(i) -- 1up 2up etc\r\n"
"		end\r\n"
"		\r\n"
"		if max_up==1 then -- single player, grab lots of keys\r\n"
"			for n,v in pairs(keys.defaults[0]) do\r\n"
"				keys.up[1].set(n,v)\r\n"
"			end\r\n"
"		else\r\n"
"			for i=1,max_up do -- multiplayer use keyislands so we can all fit on a keyboard\r\n"
"				for n,v in pairs(keys.defaults[i] or {}) do\r\n"
"					keys.up[i].set(n,v)\r\n"
"				end\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"		return keys -- so setup is chainable with a bake\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"-- convert keys or whatever into recaps changes\r\n"
"	function keys.msg(m)\r\n"
"		if not keys.up then return end\r\n"
"		\r\n"
"		for i,v in ipairs(keys.up) do\r\n"
"			v.msg(m)\r\n"
"		end\r\n"
"		\r\n"
"	end\r\n"
"	\r\n"
"\r\n"
"-- a players key mappings, maybe we need multiple people on the same keyboard or device\r\n"
"	function keys.create(idx)\r\n"
"		local key={}\r\n"
"		key.idx=idx\r\n"
"		key.maps={}\r\n"
"		\r\n"
"		function key.clear()\r\n"
"			key.maps={}\r\n"
"		end\r\n"
"		function key.set(n,v)\r\n"
"			key.maps[n]=v\r\n"
"		end\r\n"
"\r\n"
"		function key.msg(m)\r\n"
"			local recap=key.idx and recaps.up and recaps.up[key.idx]\r\n"
"			if not recap then return end\r\n"
"			\r\n"
"			if m.class==\"key\" then\r\n"
"\r\n"
"				for n,v in pairs(key.maps) do\r\n"
"					if m.keyname==n then\r\n"
"						if m.action==1 then -- key set\r\n"
"							recap.but(v,true)\r\n"
"						elseif m.action==-1 then -- key clear\r\n"
"							recap.but(v,false)\r\n"
"						end\r\n"
"					end\r\n"
"				end				\r\n"
"\r\n"
"			elseif m.class==\"joystick\" then\r\n"
"\r\n"
"				local joydir=mkeys.joystick_msg_to_key(m)\r\n"
"				\r\n"
"				-- this does not handle diagonal movement, forces one of 4 directions.\r\n"
"\r\n"
"				if keys.last_joydir~=joydir then -- only when we change\r\n"
"--print(wstr.dump(m))\r\n"
"					if keys.last_joydir then -- first clear any previous key\r\n"
"						recap.but(keys.last_joydir,false)\r\n"
"					end\r\n"
"					keys.last_joydir=joydir\r\n"
"					if joydir then\r\n"
"						recap.but(joydir,true) -- then send any new key\r\n"
"					end\r\n"
"				end\r\n"
"\r\n"
"			elseif m.class==\"joykey\" then\r\n"
"			\r\n"
"				if m.action==1 then -- key set\r\n"
"					recap.but(\"fire\",true)\r\n"
"				elseif m.action==-1 then -- key clear\r\n"
"					recap.but(\"fire\",false)\r\n"
"				end\r\n"
"\r\n"
"			end\r\n"
"			\r\n"
"		end\r\n"
"		\r\n"
"		return key\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"	return keys\r\n"
"end\r\n"
"",

"wetgenes.www.any.sys","if ngx then\r	return require(\"wetgenes.www.ngx.sys\")\relse\r	return require(\"wetgenes.www.gae.sys\")\rend\r",

"wetgenes.grdmap","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local grdmap={}\n"
"\n"
"local core=require(\"wetgenes.grdmap.core\")\n"
"\n"
"local base={}\n"
"local meta={}\n"
"meta.__index=base\n"
"\n"
"function grdmap.create()\n"
"\n"
"	local gm={}\n"
"	\n"
"	gm[0]=core.create()	\n"
"	setmetatable(gm,meta)\n"
"	\n"
"	core.info(gm[0],gm)\n"
"	\n"
"	return gm\n"
"end\n"
"\n"
"base.setup=function(gm,g)\n"
"	local r=core.setup(gm[0],g[0])\n"
"	core.info(gm[0],gm)\n"
"	return r\n"
"end\n"
"\n"
"base.cutup=function(gm,...)\n"
"	local r=core.cutup(gm[0],...)\n"
"	core.info(gm[0],gm)\n"
"	return r\n"
"end\n"
"\n"
"base.tile=function(gm,...)\n"
"	local r=core.tile(gm[0],...)\n"
"	return r\n"
"end\n"
"\n"
"base.merge=function(gm,...)\n"
"	local r=core.merge(gm[0],...)\n"
"	core.info(gm[0],gm)\n"
"	return r\n"
"end\n"
"\n"
"base.shrink=function(gm,...)\n"
"	local r=core.shrink(gm[0],...)\n"
"	core.info(gm[0],gm)\n"
"	return r\n"
"end\n"
"\n"
"base.keymap=function(gma,gmb)\n"
"	local r=core.keymap(gma[0],gmb[0])\n"
"	core.info(gma[0],gma)\n"
"	return r\n"
"end\n"
"\n"
"return grdmap\n"
"",

"wetgenes.gamecake.widgets.meta_layout","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"-- generic default widget layout functions\n"
"\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"function M.bake(oven,wmeta)\n"
"wmeta=wmeta or {}\n"
"\n"
"--\n"
"-- add meta functions\n"
"--\n"
"function wmeta.setup(def)\n"
"\n"
"--	local master=def.master\n"
"	local meta=def.meta\n"
"	local win=def.win\n"
"\n"
"--\n"
"-- initial layout of widgets, to put them into reasonable positions\n"
"--\n"
"	function meta.layout(widget)\n"
"--print(widget.class)\n"
"		if widget.class==\"fill\" or widget.class==\"pan\" or widget.class==\"drag\" then\n"
"			meta.layout_fill(widget)\n"
"--		elseif widget.class==\"slide\" or widget.class==\"pad\" then\n"
"--			meta.layout_padding(widget)\n"
"--		elseif widget.class==\"master\" or widget.class==\"abs\" then\n"
"--			meta.layout_base(widget)\n"
"		else\n"
"			meta.layout_base(widget)\n"
"		end\n"
"	end\n"
"	\n"
"	function meta.layout_none(widget)\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"	function meta.layout_padding(widget)\n"
"		for i,v in ipairs(widget) do\n"
"\n"
"			if v.hxf then v.hx=widget.hx*v.hxf end -- generate size as a fraction of parent\n"
"			if v.hyf then v.hy=widget.hy*v.hyf end\n"
"			\n"
"--			v.px=(widget.hx-v.hx)*v.pxf -- local position relative to parents size\n"
"--			v.py=(widget.hy-v.hy)*v.pyf\n"
"\n"
"			v.pxd=widget.pxd+v.px -- local absolute position\n"
"			v.pyd=widget.pyd+v.py\n"
"\n"
"		end\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"	\n"
"\n"
"	function meta.layout_base(widget)\n"
"		for i,v in ipairs(widget) do\n"
"		\n"
"			if v.hxf then v.hx=widget.hx*v.hxf end -- generate size as a fraction of parent\n"
"			if v.hyf then v.hy=widget.hy*v.hyf end\n"
"			\n"
"--			if v.pxf then v.px=(widget.hx)*v.pxf end -- local position relative to parents size\n"
"--			if v.pyf then v.py=(widget.hy)*v.pyf end\n"
"\n"
"			v.pxd=widget.pxd+v.px -- absolute position\n"
"			v.pyd=widget.pyd+v.py\n"
"			\n"
"		end\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"\n"
"-- this is a fixed layout that works kind of like text\n"
"-- we do not adjust the hx,hy size of sub widgets\n"
"-- we just place them left to right top to bottom\n"
"-- finally we resize this widget to fit its content\n"
"-- the widgets sx,sy is used as default hx,hy for layout\n"
"	function meta.layout_fill(widget)\n"
"		\n"
"		local hx,hy=0,0\n"
"		local my=0\n"
"		widget.hx_max=0\n"
"		widget.hy_max=0\n"
"		local function addone(w)\n"
"			w.px=hx\n"
"			w.py=hy\n"
"			hx=hx+w.hx\n"
"			if hx > widget.hx_max then widget.hx_max=hx end -- max x total size\n"
"			if w.hy > my then my=w.hy end -- max y size for this line\n"
"--print(w.id or \"?\",w.px,w.py,w.hx,w.hy)\n"
"		end\n"
"		\n"
"		local function endoflines()\n"
"		end\n"
"		\n"
"		local function endofline()\n"
"			hx=0\n"
"			hy=hy+my\n"
"			my=0\n"
"			widget.hy_max=hy\n"
"		end\n"
"		\n"
"		if #widget>0 then\n"
"		\n"
"			for i,w in ipairs(widget) do\n"
"			\n"
"				if hx+w.hx>widget.hx then\n"
"					if hx==0 then -- need one item per line so add it anyway\n"
"						addone(w)\n"
"						endofline()\n"
"					else -- skip this one, push it onto nextline\n"
"						endofline()\n"
"						addone(w)\n"
"					end\n"
"				else -- it fits so just add\n"
"					addone(w)\n"
"				end\n"
"			end\n"
"\n"
"			if hx>0 then endofline() end -- final end of line\n"
"			\n"
"			endoflines()\n"
"			\n"
"		end\n"
"		\n"
"		for i,v in ipairs(widget) do\n"
"			v.pxd=widget.pxd+v.px\n"
"			v.pyd=widget.pyd+v.py\n"
"		end\n"
"\n"
"-- layout sub sub widgets	\n"
"		for i,v in ipairs(widget) do\n"
"			v:layout()\n"
"		end\n"
"	end\n"
"\n"
"\n"
"end\n"
"\n"
"\n"
"return wmeta\n"
"end\n"
"",

"wetgenes.www.ngx.users","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.users\"]=_M\n"
"\n"
"function login_url(a)\n"
"\n"
"--	log(\"users.login_url:\")\n"
"--	return core.login_url(a)\n"
"\n"
"end\n"
"\n"
"\n"
"function logout_url(a)\n"
"\n"
"--	log(\"users.logout_url:\")\n"
"--	return core.logout_url(a)\n"
"\n"
"end\n"
"\n"
"function get_google_user()\n"
"\n"
"--	log(\"users.get_google_user:\")\n"
"--	return core.get_google_user()\n"
"\n"
"end\n"
"",

"wetgenes.www.any.oauth","\n"
"\n"
"local wet_html=require(\"wetgenes.html\")\n"
"\n"
"local sys=require(\"wetgenes.www.any.sys\")\n"
"\n"
"local json=require(\"wetgenes.json\")\n"
"local dat=require(\"wetgenes.www.any.data\")\n"
"\n"
"local users=require(\"wetgenes.www.any.users\")\n"
"\n"
"local fetch=require(\"wetgenes.www.any.fetch\")\n"
"\n"
"local img=require(\"wetgenes.www.any.img\")\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log -- grab the func from the package\n"
"\n"
"local wet_string=require(\"wetgenes.string\")\n"
"local str_split=wet_string.str_split\n"
"local serialize=wet_string.serialize\n"
"\n"
"\n"
"local math=math\n"
"local string=string\n"
"local table=table\n"
"local os=os\n"
"\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"local tostring=tostring\n"
"local tonumber=tonumber\n"
"local type=type\n"
"local pcall=pcall\n"
"local loadstring=loadstring\n"
"\n"
"\n"
"module(...)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- The escape function for oauth must be exactly this, RFC3986\n"
"-- it would be nice if / was not escaped since base64 is also used all over the place\n"
"-- but that is not the case.\n"
"--\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function esc(s)\n"
"	return string.gsub(s,'[^0-9A-Za-z%-._~]', -- RFC3986 happy chars\n"
"		function(c) return ( string.format(\"%%%02X\", string.byte(c)) ) end )\n"
"end\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- unesc performs the oposite of esc\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function unesc(str)\n"
"    return string.gsub(str, \"%%(%x%x)\", function(hex)\n"
"        return string.char(tonumber(hex, 16))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- perform a hmac_sha1 that is oauth friendly, key is an RFC3986 string, result is a base64 hash\n"
"--\n"
"-- this uses some java crypto functions exposed in sys for dealing with hmac and sha1\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function hmac_sha1(key,str)\n"
"	local bin=sys.hmac_sha1(key,str,\"bin\") -- key gets used as is, (string is 7bit safe).\n"
"	local b64=sys.bin_encode(\"base64\",bin) -- we need to convert the resuilt to base64\n"
"	return b64\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get the current time and build a nonce for it using a passed in key value\n"
"-- which i do not think has to be terribly secret, we reuse hmac_sha1\n"
"-- just to keep the number of strange functions used low, really this could generate anything\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function time_nonce(key) -- pass in a secret key\n"
"	local t=math.floor(os.time())\n"
"	local n=sys.bin_encode(\"hex\",sys.hmac_sha1(key,tostring(t)..\"&aelua.dumid.oauth\",\"bin\"))\n"
"	return t,n -- returns time,nonce\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- vars contains the variables we intend to send to the oauth server\n"
"-- opts contains extra options:\n"
"--  post should be set to GET if we do not intend to use POST\n"
"--  url should be the oauth server url for this request\n"
"--  secret should be the token secret provided by the oauth server or nil for initial signin\n"
"--  api_secret should be your special api/consumer secret\n"
"-- these opts are used to build a request string from the vars and sign it so that\n"
"-- the oauth server will be happy with it\n"
"-- it returns a base64 signature , request string\n"
"-- the request string could be used in the body of a POST (default)\n"
"-- or if you set opts.post=\"GET\" then you could the use it in a GET request\n"
"--\n"
"-- aparently it is better to put this stuff in the header, Authorization:\n"
"-- but I have my doubts\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function build(vars,opts)\n"
"\n"
"	local post      =opts.post       or \"POST\" \n"
"	local url       =opts.url        or \"\"\n"
"	local tok_secret=opts.tok_secret or \"\"\n"
"	local api_secret=opts.api_secret or \"\"\n"
"\n"
"	local vals={}\n"
"\n"
"-- esc and shove all oauth vars into vals\n"
"	for i,v in pairs(vars) do\n"
"		vals[#vals+1]={esc(i),esc(v)} -- record a simple table , i==[1] v==[2]\n"
"	end\n"
"\n"
"	table.sort(vals, function(a,b)\n"
"			if a[1]==b[1] then return a[2]<b[2] end -- sort by [2] if [1] is the same\n"
"			return a[1]<b[1] -- other wise sort by [1]\n"
"		end)\n"
"		\n"
"-- now they are in the right order, build the query string\n"
"\n"
"	for i=1,#vals do local v=vals[i]\n"
"		vals[i]=v[1]..\"=\"..v[2]\n"
"	end\n"
"	local query=table.concat(vals,\"&\")\n"
"	local base=post..\"&\"..esc(url)..\"&\"..esc(query) -- everything always gets escaped\n"
"	local key=esc(api_secret)..\"&\"..esc(tok_secret) -- the key is built from these strings\n"
"	local sign=hmac_sha1(key,base)\n"
"	\n"
"	return sign , query..\"&oauth_signature=\"..esc(sign) -- sign it\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- turns a responce string into a table of values, this is the oposite of build\n"
"-- and intended to deal with the results\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function decode(s)\n"
"	local ret={}\n"
"	local aa=str_split(\"&\",s) -- first split on &\n"
"	for i=1,#aa do local v=aa[i]\n"
"		local a,b = wet_string.split_equal(v)\n"
"--log(\"decode : \"..v..\" : \"..type(a)..\" : \"..type(b))		\n"
"--		if a and b then\n"
"			ret[unesc(a)]=unesc(b) -- unescape both sides\n"
"--		end\n"
"	end\n"
"	return ret -- return a lookup table, which may be empty\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"",

"wetgenes.gamecake.oven","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"local wzips=require(\"wetgenes.zips\")\r\n"
"local wsbox=require(\"wetgenes.sandbox\")\r\n"
"local wwin=require(\"wetgenes.win\")\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"\r\n"
"-- handle a simple oven for win programs,\r\n"
"-- all it does is call other ovens/mods functions.\r\n"
"\r\n"
"local function print(...) return _G.print(...) end\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(opts)\r\n"
"\r\n"
"	local oven={}\r\n"
"\r\n"
"		oven.opts=opts or {}\r\n"
"\r\n"
"-- pull in info about what art we baked		\r\n"
"		local lson=wzips.readfile(\"lua/init_bake.lua\")\r\n"
"		if lson then\r\n"
"			oven.opts.bake=wsbox.lson(lson)\r\n"
"		end\r\n"
"\r\n"
"		\r\n"
"--opts.disable_sounds=true\r\n"
"		\r\n"
"		oven.baked={}\r\n"
"		oven.mods={}\r\n"
"\r\n"
"--\r\n"
"-- preheat a normal oven\r\n"
"-- you may perform this yourself if you want more oven control\r\n"
"--\r\n"
"		function oven.preheat()\r\n"
"\r\n"
"			oven.frame_rate=1/opts.fps -- how fast we want to run\r\n"
"			oven.frame_time=0\r\n"
"\r\n"
"			local inf={width=opts.width,height=opts.height,title=opts.title}\r\n"
"			local screen=wwin.screen()\r\n"
"\r\n"
"			inf.x=(screen.width-inf.width)/2\r\n"
"			inf.y=(screen.height-inf.height)/2\r\n"
"\r\n"
"			if wwin.flavour==\"raspi\" then -- do fullscreen on raspi\r\n"
"				inf.x=0\r\n"
"				inf.y=0\r\n"
"				inf.width=screen.width\r\n"
"				inf.height=screen.height\r\n"
"				inf.dest_width=screen.width\r\n"
"				inf.dest_height=screen.height\r\n"
"				if inf.height>=480*2 then -- ie a 1080 monitor, double the pixel size\r\n"
"					inf.width=inf.width/2\r\n"
"					inf.height=inf.height/2\r\n"
"				end\r\n"
"			end\r\n"
"\r\n"
"			oven.win=wwin.create(inf)\r\n"
"			oven.win:context({})\r\n"
"\r\n"
"			if opts.show then oven.win:show(opts.show) end\r\n"
"			for i,v in ipairs(opts) do -- check extra options\r\n"
"				if     v==\"windowed\" then\r\n"
"					oven.win:show(\"win\")\r\n"
"				elseif v==\"fullscreen\" then\r\n"
"					oven.win:show(\"full\")\r\n"
"				elseif v==\"maximised\" then\r\n"
"					oven.win:show(\"max\")\r\n"
"				end\r\n"
"			end\r\n"
"--			oven.win:show(\"full\")\r\n"
"--			oven.win:show(\"max\")\r\n"
"\r\n"
"			oven.rebake(\"wetgenes.gamecake.cake\") -- bake the cake in the oven,\r\n"
"\r\n"
"			-- the order these are added is important for priority, top of list is lowest priority, bottom is highest.\r\n"
"			oven.rebake_mod(\"wetgenes.gamecake.mods.escmenu\") -- escmenu gives us a doom style escape menu\r\n"
"			oven.rebake_mod(\"wetgenes.gamecake.mods.console\") -- console gives us a quake style tilda console\r\n"
"			oven.rebake_mod(\"wetgenes.gamecake.mods.keys\") -- touchscreen keys and posix keymaping\r\n"
"			oven.rebake_mod(\"wetgenes.gamecake.mods.mouse\") -- auto fake mouse on non windows builds\r\n"
"			oven.rebake_mod(\"wetgenes.gamecake.mods.layout\") -- screen layout options\r\n"
"			oven.rebake_mod(\"wetgenes.gamecake.mods.snaps\") -- builtin screen snapshot code\r\n"
"\r\n"
"			if opts.start then\r\n"
"				oven.next=oven.rebake(opts.start)\r\n"
"			end\r\n"
"			\r\n"
"			\r\n"
"			return oven\r\n"
"		end\r\n"
"		\r\n"
"\r\n"
"\r\n"
"-- require and bake oven.baked[modules] in such a way that it can have simple circular dependencies\r\n"
"\r\n"
"		function oven.rebake(name)\r\n"
"\r\n"
"			local ret=oven.baked[name]\r\n"
"			\r\n"
"			if not ret then\r\n"
"		\r\n"
"				if type(name)==\"function\" then -- allow bake function instead of a name\r\n"
"					return name(oven,{})\r\n"
"				end\r\n"
"			\r\n"
"				ret={modname=name}\r\n"
"				oven.baked[name]=ret\r\n"
"				ret=assert(require(name)).bake(oven,ret)\r\n"
"				\r\n"
"			end\r\n"
"\r\n"
"			return ret\r\n"
"		end\r\n"
"\r\n"
"\r\n"
"-- this performs a rebake and adds the baked module into every update/draw function\r\n"
"-- so we may insert extra functionality without having to modify the running app\r\n"
"-- eg a console or an onscreen keyboard\r\n"
"		function oven.rebake_mod(name)\r\n"
"		\r\n"
"			if oven.mods[name] then return oven.mods[name] end -- already setup, nothing else to do\r\n"
"			local m=oven.rebake(name) -- rebake mod into this oven\r\n"
"\r\n"
"			oven.mods[name]=m			-- store baked version by its name\r\n"
"			table.insert(oven.mods,m)		-- and put it at the end of the list for easy iteration\r\n"
"			\r\n"
"			m.setup() -- and call setup since it will always be running from now on until it is removed\r\n"
"			\r\n"
"			return m\r\n"
"		end\r\n"
"		\r\n"
"\r\n"
"		if opts.times then\r\n"
"			oven.times={}\r\n"
"			function oven.times.create()\r\n"
"				local t={}\r\n"
"				t.time=0\r\n"
"				t.time_live=0\r\n"
"				\r\n"
"				t.hash=0\r\n"
"				t.hash_live=0\r\n"
"				\r\n"
"				t.started=0\r\n"
"				\r\n"
"				function t.start()\r\n"
"					t.started=oven.win and oven.win.time() or 0\r\n"
"				end\r\n"
"				\r\n"
"				function t.stop()\r\n"
"					local ended=oven.win and oven.win.time() or 0\r\n"
"					\r\n"
"					t.time_live=t.time_live + ended-t.started\r\n"
"					t.hash_live=t.hash_live + 1\r\n"
"				end\r\n"
"				\r\n"
"				function t.done()\r\n"
"					t.time=t.time_live\r\n"
"					t.hash=t.hash_live\r\n"
"					t.time_live=0\r\n"
"					t.hash_live=0\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"				return t\r\n"
"			end\r\n"
"			oven.times.update=oven.times.create()\r\n"
"			oven.times.draw=oven.times.create()\r\n"
"		end\r\n"
"\r\n"
"		function oven.change()\r\n"
"\r\n"
"		-- handle oven changes\r\n"
"\r\n"
"			if oven.next then\r\n"
"			\r\n"
"				oven.clean()\r\n"
"				\r\n"
"				if type(oven.next)==\"string\" then	 -- change by required name\r\n"
"				\r\n"
"					oven.next=oven.rebake(oven.next)\r\n"
"					\r\n"
"				elseif type(oven.next)==\"boolean\" then -- special exit oven\r\n"
"				\r\n"
"					if wwin.hardcore.task_to_back then -- on android there is no quit, only back\r\n"
"						wwin.hardcore.task_to_back()						\r\n"
"						if opts.start then\r\n"
"							oven.next=oven.rebake(opts.start) -- beter than staying on the menu\r\n"
"						else\r\n"
"							oven.next=nil\r\n"
"						end\r\n"
"					else\r\n"
"						oven.next=nil\r\n"
"						oven.finished=true		\r\n"
"					end\r\n"
"					\r\n"
"					oven.last=oven.now\r\n"
"					oven.now=oven.next\r\n"
"					\r\n"
"				end\r\n"
"\r\n"
"				if oven.next then\r\n"
"					oven.last=oven.now\r\n"
"					oven.now=oven.next\r\n"
"					oven.next=nil\r\n"
"					\r\n"
"					oven.setup()\r\n"
"				end\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"		end\r\n"
"\r\n"
"		function oven.setup()	\r\n"
"			if oven.now and oven.now.setup then\r\n"
"				oven.now.setup() -- this will probably load data and call the preloader\r\n"
"			end\r\n"
"--print(\"setup preloader=off\")\r\n"
"			oven.preloader_enabled=false -- disabled preloader after first setup completes\r\n"
"		end\r\n"
"\r\n"
"		function oven.start()	\r\n"
"\r\n"
"			oven.win:start()\r\n"
"			oven.cake.start()\r\n"
"			oven.cake.canvas.start()\r\n"
"			if oven.now and oven.now.start then\r\n"
"				oven.now.start()\r\n"
"			end\r\n"
"--print(\"start preloader=off\")\r\n"
"			if oven.preloader_enabled==\"stop\" then -- we turned on at stop so turn off at start\r\n"
"				oven.preloader_enabled=false\r\n"
"			end\r\n"
"\r\n"
"\r\n"
"		end\r\n"
"\r\n"
"		function oven.stop()\r\n"
"--print(\"stop preloader=on\")\r\n"
"			oven.rebake(opts.preloader or \"wetgenes.gamecake.spew.preloader\").reset()\r\n"
"			oven.preloader_enabled=\"stop\"\r\n"
"			oven.win:stop()\r\n"
"			oven.cake.stop()\r\n"
"			oven.cake.canvas.stop()\r\n"
"			if oven.now and oven.now.stop then\r\n"
"				oven.now.stop()\r\n"
"			end\r\n"
"		end\r\n"
"\r\n"
"		function oven.clean()\r\n"
"			if oven.now and oven.now.clean then\r\n"
"				oven.now.clean()\r\n"
"			end\r\n"
"		end\r\n"
"\r\n"
"		function oven.update()\r\n"
"\r\n"
"			if oven.update_co then -- just continue coroutine until it ends\r\n"
"				if coroutine.status(oven.update_co)~=\"dead\" then\r\n"
"					assert(coroutine.resume(oven.update_co)) -- run it, may need more than one resume before it finishes\r\n"
"					return\r\n"
"				else\r\n"
"					oven.update_co=nil\r\n"
"				end\r\n"
"			end\r\n"
"--[[\r\n"
"collectgarbage()\r\n"
"local gci=gcinfo()		\r\n"
"local gb=oven.gl.counts.buffers				\r\n"
"print(string.format(\"mem=%6.0fk gb=%4d\",math.floor(gci),gb))\r\n"
"]]\r\n"
"\r\n"
"			if oven.frame_rate and oven.frame_time then --  framerate limiter enabled\r\n"
"			\r\n"
"				if oven.frame_time<(oven.win:time()-0.500) then oven.frame_time=oven.win:time() end -- prevent race condition\r\n"
"				\r\n"
"				if wwin.hardcore.sleep then\r\n"
"					while (oven.frame_time-oven.frame_rate)>oven.win:time() do wwin.hardcore.sleep(0.0001) end -- sleep here until we need to update\r\n"
"				else\r\n"
"					if (oven.frame_time-oven.frame_rate)>oven.win:time() then return end -- cant sleep, just skip\r\n"
"				end\r\n"
"							\r\n"
"			end\r\n"
"\r\n"
"			local f\r\n"
"			f=function()\r\n"
"\r\n"
"				oven.change() -- run setup/clean codes if we are asked too\r\n"
"\r\n"
"				if oven.frame_rate and oven.frame_time then --  framerate limiter enabled\r\n"
"					oven.frame_time=oven.frame_time+oven.frame_rate -- step frame forward one tick				\r\n"
"				end\r\n"
"\r\n"
"--print( \"UPDATE\",math.floor(10000000+(oven.win:time()*1000)%1000000) )\r\n"
"\r\n"
"				if oven.times then oven.times.update.start() end\r\n"
"				\r\n"
"				if oven.now and oven.now.update then\r\n"
"					oven.now.update()\r\n"
"				end\r\n"
"				for i,v in ipairs(oven.mods) do\r\n"
"					if v.update then\r\n"
"						v.update()\r\n"
"					end\r\n"
"				end\r\n"
"\r\n"
"				if oven.times then oven.times.update.stop() end\r\n"
"				\r\n"
"				if oven.frame_rate and oven.frame_time then --  framerate limiter enabled\r\n"
"					if (oven.frame_time-oven.frame_rate)<oven.win:time() then -- repeat until we are a frame ahead of real time\r\n"
"						return f() -- tailcall\r\n"
"					end\r\n"
"				end\r\n"
"				\r\n"
"			end\r\n"
"\r\n"
"			if not oven.update_co then -- create a new one\r\n"
"				oven.update_co=coroutine.create(f)\r\n"
"			end\r\n"
"			if coroutine.status(oven.update_co)~=\"dead\" then\r\n"
"				assert(coroutine.resume(oven.update_co)) -- run it, may need more than one resume before it finishes\r\n"
"			end\r\n"
"\r\n"
"		end\r\n"
"\r\n"
"		oven.preloader_enabled=true\r\n"
"		function oven.preloader(...)\r\n"
"			local s=table.concat({...},\" \") or \"\"\r\n"
"print(\"Loading : \"..s)\r\n"
"			if not oven.preloader_enabled then return end\r\n"
"			if oven.win then\r\n"
"\r\n"
"				if wwin.hardcore and wwin.hardcore.swap_pending then -- cock blocked waiting for nacl draw code\r\n"
"					if oven.update_co and (oven.update_co==coroutine.running()) then\r\n"
"						coroutine.yield() -- try and make it finish\r\n"
"--						coroutine.yield()\r\n"
"					end\r\n"
"				end\r\n"
"\r\n"
"--				oven.msgs()\r\n"
"\r\n"
"				oven.cake.canvas.draw()\r\n"
"				local p=oven.rebake(opts.preloader or \"wetgenes.gamecake.spew.preloader\")\r\n"
"				p.setup() -- warning, this is called repeatedly\r\n"
"				p.update(s)\r\n"
"				if wwin.hardcore and wwin.hardcore.swap_pending then -- cock blocked waiting for nacl draw code\r\n"
"\r\n"
"					if oven.update_co and (oven.update_co==coroutine.running()) then\r\n"
"						coroutine.yield()\r\n"
"--						coroutine.yield()\r\n"
"					end\r\n"
"\r\n"
"				else\r\n"
"					p.draw()\r\n"
"					oven.win:swap()\r\n"
"				end\r\n"
"\r\n"
"				if oven.update_co and (oven.update_co==coroutine.running()) then\r\n"
"					coroutine.yield()\r\n"
"--					coroutine.yield()\r\n"
"				end\r\n"
"\r\n"
"			end\r\n"
"		end\r\n"
"\r\n"
"		function oven.draw()\r\n"
"		\r\n"
"			if oven.update_co then\r\n"
"				if coroutine.status(oven.update_co)~=\"dead\" then return end -- draw nothing until it is finished\r\n"
"				oven.update_co=nil -- create a new one next update\r\n"
"			else -- nothing to draw, waiting on update to change things\r\n"
"				return\r\n"
"			end\r\n"
"			\r\n"
"			if wwin.hardcore and wwin.hardcore.swap_pending then\r\n"
"				return\r\n"
"			end -- cock blocked waiting for nacl draw code\r\n"
"		\r\n"
"			oven.cake.canvas.draw() -- prepare tempory buffers\r\n"
"			\r\n"
"--print( \"DRAW\",math.floor(10000000+(oven.win:time()*1000)%1000000) )\r\n"
"\r\n"
"			if oven.times then oven.times.draw.start() end -- between calls to draw\r\n"
"			\r\n"
"			if oven.now and oven.now.draw then\r\n"
"				oven.now.draw()\r\n"
"			end\r\n"
"			\r\n"
"			for i,v in ipairs(oven.mods) do\r\n"
"				if v.draw then\r\n"
"					v.draw()\r\n"
"				end\r\n"
"			end\r\n"
"						\r\n"
"			if oven.times then oven.times.draw.stop() end -- draw is squify so just use it as the total time\r\n"
"\r\n"
"			if oven.win then\r\n"
"				oven.win:swap()\r\n"
"			end\r\n"
"			\r\n"
"		end\r\n"
"\r\n"
"		function oven.msgs() -- read and process any msgs we have from win:msg\r\n"
"\r\n"
"			if oven.win then\r\n"
"				for m in oven.win:msgs() do\r\n"
"\r\n"
"					if m.class==\"close\" then -- window has been closed so do a shutdown\r\n"
"						oven.next=true\r\n"
"					end\r\n"
"\r\n"
"					if m.class==\"mouse\" and m.x and m.y then	-- need to fix x,y numbers\r\n"
"						m.xraw,m.yraw=m.x,m.y					-- remember original\r\n"
"					end\r\n"
"					\r\n"
"					if m.class==\"app\" then -- androidy\r\n"
"--print(\"caught : \",m.class,m.cmd)\r\n"
"						if		m.cmd==\"init_window\" then\r\n"
"							oven.start()\r\n"
"							oven.paused=false\r\n"
"						elseif	m.cmd==\"lost_focus\"  then\r\n"
"							oven.paused=true\r\n"
"						elseif	m.cmd==\"gained_focus\"  then\r\n"
"							oven.paused=false\r\n"
"						elseif	m.cmd==\"term_window\"  then\r\n"
"							oven.paused=true\r\n"
"							oven.stop()\r\n"
"						end\r\n"
"					end\r\n"
"					\r\n"
"\r\n"
"					for i=#oven.mods,1,-1 do -- run it through the mods backwards, so the topmost layer gets first crack at the msgs\r\n"
"						local v=oven.mods[i]\r\n"
"						if m and v and v.msg then\r\n"
"							m=v.msg(m) -- mods can choose to eat the msgs, they must return it for it to bubble down\r\n"
"						end\r\n"
"					end\r\n"
"					if m and oven.now and oven.now.msg then\r\n"
"						oven.now.msg(m)\r\n"
"					end\r\n"
"						\r\n"
"				end\r\n"
"			end\r\n"
"		end\r\n"
"\r\n"
"-- a busy blocking loop, or not, if we are running on the wrong sort\r\n"
"-- of system it just returns and expects the other functions\r\n"
"-- eg oven.serv_pulse to be called when necesary.\r\n"
"		function oven.serv(oven)\r\n"
"		\r\n"
"			if oven.win.noblock then\r\n"
"				return oven -- and expect  serv_pulse to be called as often as possible\r\n"
"			end\r\n"
"			\r\n"
"			local finished\r\n"
"			repeat\r\n"
"				finished=oven.serv_pulse(oven)\r\n"
"			until finished\r\n"
"		end\r\n"
"\r\n"
"		function oven.serv_pulse(oven)\r\n"
"			if oven.finished then return true end\r\n"
"			oven.msgs()\r\n"
"			\r\n"
"			oven.cake.update()\r\n"
"\r\n"
"			if not oven.paused then\r\n"
"				oven.update()\r\n"
"				oven.draw()\r\n"
"			else\r\n"
"				if wwin.hardcore.sleep then\r\n"
"					wwin.hardcore.sleep(1/10)\r\n"
"				end\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"\r\n"
"	return oven\r\n"
"\r\n"
"end\r\n"
"",

"wetgenes.diff","-----------------------------------------------------------------------------\n"
"-- Provides functions for diffing text.\n"
"--\n"
"-- (c) 2007, 2008  Yuri Takhteyev (yuri@freewisdom.org)\n"
"-- (c) 2007 Hisham Muhammad\n"
"--\n"
"-- License: MIT/X, see http://sputnik.freewisdom.org/en/License\n"
"--\n"
"-- the above was used as a base, it is no longer the same code...\n"
"--\n"
"-- this diff now returns a different slightly more compressed format\n"
"-- which is a table of numbers and strings of only the differences\n"
"-- and that format can be used to convert either string into the other string\n"
"--\n"
"-- most of the changes are actually commented and are just mild changes really\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"\n"
"local string=string\n"
"local table=table\n"
"local math=math\n"
"\n"
"local assert=assert\n"
"local setmetatable=setmetatable\n"
"local ipairs=ipairs\n"
"local type=type\n"
"\n"
"module(\"wetgenes.diff\")\n"
"\n"
"-- java version of lua, not so good at strings, so might as well use numbers for these as they are now internal only\n"
"local SAME = 0  -- token statuses\n"
"local IN   = 1\n"
"local OUT  = 2\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Split a string into tokens.  (Adapted from Gavin Kistner's split on\n"
"-- http://lua-users.org/wiki/SplitJoin.\n"
"--\n"
"-- @param text           A string to be split.\n"
"-- @param separator      [optional] the separator pattern (defaults to any\n"
"--                       white space - %s+).\n"
"-- @param skip_separator [optional] don't include the sepator in the results.     \n"
"-- @return               A list of tokens.\n"
"-----------------------------------------------------------------------------\n"
"local function split(text, separator, skip_separator)\n"
"	separator = separator or \"%s+\"\n"
"	local parts = {}  \n"
"	local start = 1\n"
"	local split_start, split_end = text:find(separator, start)\n"
"	while split_start do\n"
"		if skip_separator then\n"
"			table.insert(parts, text:sub(start, split_start-1))\n"
"		else\n"
"			table.insert(parts, text:sub(start, split_end)) -- now includes the seperator *inside* each token\n"
"		end\n"
"		start = split_end + 1\n"
"		split_start, split_end = text:find(separator, start)\n"
"	end\n"
"	if text:sub(start)~=\"\" then\n"
"		table.insert(parts, text:sub(start) )\n"
"	end\n"
"	return parts\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Derives the longest common subsequence of two strings.  This is a faster\n"
"-- implementation than one provided by stdlib.  Submitted by Hisham Muhammad. \n"
"-- The algorithm was taken from:\n"
"-- http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_subsequence\n"
"--\n"
"-- @param t1             the first string.\n"
"-- @param t2             the second string.\n"
"-- @return               the least common subsequence as a matrix.\n"
"-----------------------------------------------------------------------------\n"
"local function quick_LCS(t1, t2)\n"
"   local m = #t1\n"
"   local n = #t2\n"
"\n"
"   -- Build matrix on demand\n"
"   local C = {}\n"
"   local setmetatable = setmetatable\n"
"   local mt_tbl = {\n"
"      __index = function(t, k)\n"
"         t[k] = 0\n"
"         return 0\n"
"      end\n"
"   }\n"
"   local mt_C = {\n"
"      __index = function(t, k)\n"
"         local tbl = {}\n"
"         setmetatable(tbl, mt_tbl)\n"
"         t[k] = tbl\n"
"         return tbl\n"
"      end\n"
"   }\n"
"   setmetatable(C, mt_C)\n"
"   local max = math.max\n"
"   for i = 1, m+1 do\n"
"      local ci1 = C[i+1]\n"
"      local ci = C[i]\n"
"      for j = 1, n+1 do\n"
"         if t1[i-1] == t2[j-1] then\n"
"            ci1[j+1] = ci[j] + 1\n"
"         else\n"
"            ci1[j+1] = max(ci1[j], ci[j+1])\n"
"         end\n"
"      end\n"
"   end\n"
"   return C\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Returns a diff of two strings as a list of pairs, where the first value\n"
"-- represents a token and the second the token's status (\"same\", \"in\", \"out\").\n"
"--\n"
"-- @param old             The \"old\" text string\n"
"-- @param new             The \"new\" text string\n"
"-- @param separator      [optional] the separator pattern (defaults ot any\n"
"--                       white space).\n"
"-- @return               A list of annotated tokens.\n"
"-----------------------------------------------------------------------------\n"
"local function rev_diff(old, new, separator)\n"
"   assert(old); assert(new)\n"
"   new = split(new, separator); old = split(old, separator)\n"
"\n"
"   -- First, compare the beginnings and ends of strings to remove the common\n"
"   -- prefix and suffix.  Chances are, there is only a small number of tokens\n"
"   -- in the middle that differ, in which case  we can save ourselves a lot\n"
"   -- in terms of LCS computation.\n"
"   local prefix = \"\" -- common text in the beginning\n"
"   local suffix = \"\" -- common text in the end\n"
"   while old[1] and old[1] == new[1] do\n"
"      local token = table.remove(old, 1)\n"
"      table.remove(new, 1)\n"
"      prefix = prefix..token\n"
"   end\n"
"   while old[#old] and old[#old] == new[#new] do\n"
"      local token = table.remove(old)\n"
"      table.remove(new)\n"
"      suffix = token..suffix\n"
"   end\n"
"\n"
"   -- Setup a table that will store the diff (an upvalue for get_diff). We'll\n"
"   -- store it in the reverse order to allow for tail calls.  We'll also keep\n"
"   -- in this table functions to handle different events.\n"
"   local rev_diff = {\n"
"      put  = function(self, token, type) table.insert(self, token ) table.insert(self, type ) end, -- no sub tables, so less resources, probably\n"
"      ins  = function(self, token) self:put(token, IN) end,\n"
"      del  = function(self, token) self:put(token, OUT) end,\n"
"      same = function(self, token) if token then self:put(token, SAME) end end,\n"
"   }\n"
"\n"
"   -- Put the suffix as the first token (we are storing the diff in the\n"
"   -- reverse order)\n"
"\n"
"   rev_diff:same(suffix)\n"
"\n"
"   -- Define a function that will scan the LCS matrix backwards and build the\n"
"   -- diff output recursively.\n"
"   local function get_diff(C, old, new, i, j)\n"
"      local old_i = old[i]\n"
"      local new_j = new[j]\n"
"      if i >= 1 and j >= 1 and old_i == new_j then\n"
"         rev_diff:same(old_i)\n"
"         return get_diff(C, old, new, i-1, j-1)\n"
"      else\n"
"         local Cij1 = C[i][j-1]\n"
"         local Ci1j = C[i-1][j]\n"
"         if j >= 1 and (i == 0 or Cij1 >= Ci1j) then\n"
"            rev_diff:ins(new_j)\n"
"            return get_diff(C, old, new, i, j-1)\n"
"         elseif i >= 1 and (j == 0 or Cij1 < Ci1j) then\n"
"            rev_diff:del(old_i)\n"
"            return get_diff(C, old, new, i-1, j)\n"
"         end\n"
"      end\n"
"   end\n"
"   -- Then call it.\n"
"   get_diff(quick_LCS(old, new), old, new, #old + 1, #new + 1)\n"
"\n"
"   -- Put the prefix in at the end\n"
"   rev_diff:same(prefix)\n"
"\n"
"   return rev_diff\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Returns a diff of two strings as a list of pairs, where the first value\n"
"-- represents a token and the second the token's status (\"same\", \"in\", \"out\").\n"
"--\n"
"-- @param old             The \"old\" text string\n"
"-- @param new             The \"new\" text string\n"
"-- @param separator      [optional] the separator pattern (defaults ot any\n"
"--                       white space).\n"
"-- @return\n"
"--\n"
"-- a table containg a list of the following commands\n"
"-- if a number then the length of string that is the same and should be skipped\n"
"-- if a string then it is part of a pair of strings\n"
"-- [1] contains the old string and [2] contains the new string\n"
"-- strings are always in pairs and numbers are always seperated by two strings\n"
"-- this should be reasonably compact data\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function diff(old, new, separator)\n"
"\n"
"	local d=rev_diff(old, new, separator)\n"
"\n"
"	local t={}\n"
"	\n"
"	local same,new,old\n"
"	\n"
"	local function reset() same=0 new=\"\" old=\"\" end\n"
"	\n"
"	reset()\n"
"	\n"
"\n"
"-- scan the data from diff_base\n"
"	for i = #d , 2 , -2 do -- data comes in reversed and in pairs\n"
"	\n"
"	\n"
"	local v1=d[i] 		-- command\n"
"	local v2=d[i-1] 	-- data\n"
"	\n"
"\n"
"		if v1==SAME then\n"
"		\n"
"			if ( new~=\"\" or old~=\"\" ) then -- change state\n"
"			\n"
"				table.insert(t,old)\n"
"				table.insert(t,new)\n"
"				reset()\n"
"			end\n"
"			\n"
"			same=same+v2:len()\n"
"		\n"
"		elseif v1==OUT then \n"
"		\n"
"			if same>0 then -- change state\n"
"			\n"
"				table.insert(t,same)\n"
"				reset()\n"
"			end\n"
"			\n"
"			old=old..v2\n"
"			\n"
"		elseif v1==IN then\n"
"		\n"
"			if same>0 then -- change state\n"
"			\n"
"				table.insert(t,same)\n"
"				reset()\n"
"			end\n"
"			\n"
"			new=new..v2			\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"-- add the final chunk\n"
"	\n"
"	if same>0 then\n"
"	\n"
"		table.insert(t,same)\n"
"		\n"
"	elseif ( new~=\"\" or old~=\"\" ) then\n"
"\n"
"		table.insert(t,old)\n"
"		table.insert(t,new)\n"
"	end\n"
"\n"
"	return t\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- patch a diff against a string and return the new string\n"
"--\n"
"-- set undo to true and the patch will be applied in reverse\n"
"--\n"
"-- s1,s2\n"
"-- d=diff(s1,s2)\n"
"-- s2==patch(s1,d)\n"
"-- s1==patch(s2,d,true)\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function patch(s,t,undo)\n"
"\n"
"	local o={}\n"
"	local idx=1\n"
"\n"
"	local i=1\n"
"	local len=#t\n"
"	while i<=len do\n"
"	\n"
"		local v1,v2\n"
"		v1=t[i]\n"
"		i=i+1\n"
"		\n"
"		if type(v1)==\"string\" then\n"
"		\n"
"			v2=t[i]\n"
"			i=i+1	-- strings come in pairs so get second string\n"
"			\n"
"			if undo then\n"
"			\n"
"				table.insert(o, v1 )\n"
"				idx=idx+v2:len()\n"
"				\n"
"			else\n"
"			\n"
"				table.insert(o, v2 )\n"
"				idx=idx+v1:len()\n"
"				\n"
"			end\n"
"		else\n"
"		\n"
"			table.insert(o, s:sub(idx,idx+v1-1) )\n"
"			idx=idx+v1\n"
"			\n"
"		end\n"
"	end\n"
"	\n"
"	return table.concat(o) -- build a return string\n"
"\n"
"end\n"
"\n"
"-- a more readable way to unpatch\n"
"function unpatch(s,t) return patch(s,t,true) end\n"
"\n"
"",

"wetgenes.gamecake.buffers","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"function M.bake(oven,buffers)\n"
"		\n"
"	local gl=oven.gl\n"
"	local cake=oven.cake\n"
"	\n"
"	buffers.data={}\n"
"\n"
"	buffers.create = function(tab)\n"
"\n"
"		local ret={}\n"
"		for nam,val in pairs(tab) do -- copy\n"
"			ret[nam]=val\n"
"		end\n"
"		\n"
"		ret[0]=gl.GenBuffer()\n"
"		ret.bind=buffers.bind\n"
"		\n"
"		if ret.start then\n"
"			ret:start(buffers) -- and call start now\n"
"		end\n"
"		\n"
"		buffers.data[ret]=ret\n"
"		\n"
"		return ret\n"
"	end\n"
"\n"
"	buffers.bind=function(v)\n"
"		gl.BindBuffer(gl.ARRAY_BUFFER,v[0])\n"
"	end\n"
"\n"
"	buffers.start = function()\n"
"		for v,n in pairs(buffers.data) do\n"
"			if not v[0] then\n"
"				v[0]=gl.GenBuffer()\n"
"				if v.start then\n"
"					v:start(buffers)\n"
"				end\n"
"			end\n"
"		end\n"
"	end\n"
"\n"
"	buffers.stop = function()\n"
"		for v,n in pairs(buffers.data) do\n"
"			gl.DeleteBuffer(v[0])\n"
"			v[0]=nil\n"
"			if v.stop then\n"
"				v:stop(buffers)\n"
"			end\n"
"		end\n"
"\n"
"	end\n"
"\n"
"\n"
"	return buffers\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"",

"wetgenes.fenestra.buffedit","\r\n"
"\r\n"
"\r\n"
"local require=require\r\n"
"\r\n"
"-- a 1 line buffer edit, how you display it is up to you\r\n"
"-- has a simple history, just pass in key presses\r\n"
"-- this is intended for commandline style editing\r\n"
"\r\n"
"module(\"fenestra.buffedit\")\r\n"
"\r\n"
"local string=require(\"string\")\r\n"
"local table=require(\"table\")\r\n"
"\r\n"
"\r\n"
"\r\n"
"function keypress(it,ascii,key,act)\r\n"
"	\r\n"
"	if act==\"down\" or act==\"repeat\" then\r\n"
"	\r\n"
"		if key==\"left\" then\r\n"
"\r\n"
"			it.line_idx=it.line_idx-1\r\n"
"			if it.line_idx<0 then it.line_idx=0 end\r\n"
"			\r\n"
"			it.throb=255\r\n"
"						\r\n"
"		elseif key==\"right\" then\r\n"
"	\r\n"
"			it.line_idx=it.line_idx+1\r\n"
"			if it.line_idx>#it.line then it.line_idx=#it.line end\r\n"
"			\r\n"
"			it.throb=255\r\n"
"			\r\n"
"		elseif key==\"home\" then\r\n"
"		\r\n"
"			it.line_idx=0\r\n"
"		\r\n"
"		elseif key==\"end\" then\r\n"
"		\r\n"
"			it.line_idx=#it.line\r\n"
"		\r\n"
"		elseif key==\"backspace\" then\r\n"
"	\r\n"
"			if it.line_idx >= #it.line then -- at end\r\n"
"			\r\n"
"				it.line=it.line:sub(1,-2)\r\n"
"				it.line_idx=#it.line\r\n"
"			\r\n"
"			elseif it.line_idx == 0 then -- at start\r\n"
"			\r\n"
"			elseif it.line_idx == 1 then -- near start\r\n"
"			\r\n"
"				it.line=it.line:sub(2)\r\n"
"				it.line_idx=it.line_idx-1\r\n"
"			\r\n"
"			else -- somewhere in the line\r\n"
"			\r\n"
"				it.line=it.line:sub(1,it.line_idx-1) .. it.line:sub(it.line_idx+1)\r\n"
"				it.line_idx=it.line_idx-1\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"			it.throb=255\r\n"
"			\r\n"
"		elseif key==\"delete\" then\r\n"
"	\r\n"
"			if it.line_idx >= #it.line then -- at end\r\n"
"			\r\n"
"\r\n"
"			elseif it.line_idx == 0 then -- at start\r\n"
"			\r\n"
"				it.line=it.line:sub(2)\r\n"
"				it.line_idx=0\r\n"
"			\r\n"
"			else -- somewhere in the line\r\n"
"			\r\n"
"				it.line=it.line:sub(1,it.line_idx) .. it.line:sub(it.line_idx+2)\r\n"
"				it.line_idx=it.line_idx\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"			it.throb=255\r\n"
"			\r\n"
"		elseif key==\"enter\" or key==\"return\" then\r\n"
"		\r\n"
"			if act==\"down\" then -- ignore repeats on enter key\r\n"
"			\r\n"
"				local f=it.line\r\n"
"--				fenestra._g.print(\">\"..f)\r\n"
"				\r\n"
"				table.insert(it.history,it.line)\r\n"
"				\r\n"
"				while #it.history > it.history_max do\r\n"
"					table.remove(it.history,1)\r\n"
"				end\r\n"
"		\r\n"
"				it.history_idx=#it.history+1\r\n"
"			\r\n"
"				it.line=\"\"\r\n"
"				it.line_idx=0\r\n"
"				\r\n"
"				if f and it.enter then -- callback?\r\n"
"				\r\n"
"					it:enter(f)\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"			end\r\n"
"			\r\n"
"		elseif key==\"up\" then\r\n"
"		\r\n"
"			it.history_idx=it.history_idx-1\r\n"
"			if it.history_idx<0 then it.history_idx=#it.history end\r\n"
"			it.line=it.history[it.history_idx] or \"\"\r\n"
"			it.line_idx=#it.line\r\n"
"		\r\n"
"		elseif key==\"down\" then\r\n"
"		\r\n"
"			it.history_idx=it.history_idx+1\r\n"
"			if it.history_idx>#it.history then it.history_idx=0 end\r\n"
"			it.line=it.history[it.history_idx] or \"\"\r\n"
"			it.line_idx=#it.line\r\n"
"			\r\n"
"		elseif ascii~=\"\" then -- not a blank string\r\n"
"			local c=string.byte(ascii)\r\n"
"			\r\n"
"			if c>=32 and c<128 then\r\n"
"			\r\n"
"				if it.line_idx >= #it.line then -- put at end\r\n"
"				\r\n"
"					it.line=it.line..ascii\r\n"
"					it.line_idx=#it.line\r\n"
"					\r\n"
"				elseif it.line_idx == 0 then -- put at start\r\n"
"				\r\n"
"					it.line=ascii..it.line\r\n"
"					it.line_idx=it.line_idx+1\r\n"
"					\r\n"
"				else -- need to insert into line\r\n"
"				\r\n"
"					it.line=it.line:sub(1,it.line_idx) .. ascii .. it.line:sub(it.line_idx+1)\r\n"
"					it.line_idx=it.line_idx+1\r\n"
"					\r\n"
"				end\r\n"
"				\r\n"
"				it.throb=255\r\n"
"				\r\n"
"			end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"	return true\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function update(it)\r\n"
"\r\n"
"	it.throb=it.throb-4\r\n"
"	if it.throb<0 then it.throb=255 end\r\n"
"\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function create()\r\n"
"\r\n"
"local it={}\r\n"
"\r\n"
"	it.history={}\r\n"
"	it.history_idx=0\r\n"
"	it.history_max=64\r\n"
"	it.line=\"\"\r\n"
"	it.line_idx=0\r\n"
"\r\n"
"	it.throb=255\r\n"
"	\r\n"
"	it.keypress=keypress\r\n"
"	it.update=update\r\n"
"\r\n"
"	return it\r\n"
"end\r\n"
"",

"wetgenes.gamecake.widgets.master","-- copy all globals into locals\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"-- widget class master\n"
"-- the master widget\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"function M.bake(oven,wmaster)\n"
"wmaster=wmaster or {}\n"
"\n"
"local gl=oven.gl\n"
"local cake=oven.cake\n"
"local canvas=oven.canvas\n"
"\n"
"local framebuffers=oven.rebake(\"wetgenes.gamecake.framebuffers\")\n"
"\n"
"local mkeys=oven.rebake(\"wetgenes.gamecake.mods.keys\")\n"
"\n"
"--\n"
"-- add meta functions\n"
"--\n"
"function wmaster.setup(widget,def)\n"
"\n"
"	local master=widget\n"
"	local meta=widget.meta\n"
"--	local win=def.win\n"
"\n"
"\n"
"	master.throb=0\n"
"--	master.fbo=_G.win.fbo(0,0,0) -- use an fbo\n"
"--	master.fbo=framebuffers.create(0,0,0)\n"
"	master.dirty=true\n"
"\n"
"-- the master gets some special overloaded functions to do a few more things\n"
"	function master.update(widget,resize)\n"
"	\n"
"		if resize then\n"
"			if widget.hx==resize.hx and widget.hy==resize.hy then\n"
"			else\n"
"				widget.hx=resize.hx\n"
"				widget.hy=resize.hy\n"
"				widget:layout()\n"
"			end\n"
"		end\n"
"	\n"
"		local throb=(widget.throb<128)\n"
"		\n"
"		widget.throb=widget.throb-4\n"
"		if widget.throb<0 then widget.throb=255 end\n"
"		\n"
"		if throb ~= (widget.throb<128) then -- dirty throb...\n"
"			local w=widget.focus\n"
"			if w and w.class==\"textedit\" then\n"
"				w:set_dirty()\n"
"			end\n"
"			if w~=widget.edit then\n"
"				w=widget.edit\n"
"				if w and w.class==\"textedit\" then\n"
"					w:set_dirty()\n"
"				end\n"
"			end\n"
"		end\n"
"\n"
"		meta.update(widget)\n"
"	end\n"
"	\n"
"	function master.layout(widget)\n"
"		meta.layout(widget)\n"
"		master.remouse(widget)\n"
"	end\n"
"\n"
"	local dirty_fbos={}\n"
"	local find_dirty_fbos -- to recurse is defined...\n"
"	find_dirty_fbos=function(widget)\n"
"		if widget.fbo and widget.dirty then\n"
"			dirty_fbos[ #dirty_fbos+1 ]=widget\n"
"		end\n"
"		for i,v in ipairs(widget) do\n"
"			find_dirty_fbos(v)\n"
"		end\n"
"	end\n"
"\n"
"	function master.draw(widget)\n"
"\n"
"		dirty_fbos={}\n"
"		find_dirty_fbos(widget)\n"
"\n"
"		gl.Disable(gl.CULL_FACE)\n"
"		gl.Disable(gl.DEPTH_TEST)\n"
"\n"
"		gl.PushMatrix()\n"
"		\n"
"		\n"
"		if #dirty_fbos>0 then\n"
"			for i=#dirty_fbos,1,-1 do -- call in reverse so sub fbos can work\n"
"				meta.draw(dirty_fbos[i]) -- dirty, so this only builds the fbo\n"
"			end\n"
"		end\n"
"\n"
"		meta.draw(widget)\n"
"		\n"
"		gl.PopMatrix()\n"
"	end\n"
"	\n"
"	function master.msg(widget,m)\n"
"		if m.class==\"key\" then\n"
"			widget:key(m.ascii,m.keyname,m.action)\n"
"		elseif m.class==\"mouse\" then\n"
"			widget:mouse(m.action,m.x,m.y,m.keycode)\n"
"		elseif m.class==\"joystick\" then\n"
"		\n"
"			local joydir=mkeys.joystick_msg_to_key(m)\n"
"			\n"
"			if master.last_joydir~=joydir then -- only when we change\n"
"				if master.last_joydir then -- first clear any previous key\n"
"					master.key(widget,\"\",master.last_joydir,-1)\n"
"				end\n"
"				master.last_joydir=joydir\n"
"				if joydir then\n"
"					master.key(widget,\"\",joydir,1) -- then send any new key\n"
"				end\n"
"			end\n"
"\n"
"		elseif m.class==\"joykey\" then\n"
"		\n"
"			if m.action==1 then master.last_keycode=m.keycode end -- slight debounce hack?\n"
"\n"
"--print(wstr.dump(m))\n"
"\n"
"			if m.keycode==4 or ( (oven.opts.smell==\"gamestick\") and (m.keycode==97) ) then --back\n"
"				if master.go_back_id then\n"
"					local v=master.ids and master.ids[master.go_back_id]\n"
"					if v then\n"
"						if m.action==-1 then\n"
"							v:call_hook(\"click\")\n"
"						end\n"
"					end\n"
"				end\n"
"			elseif m.keycode==108 then --forward\n"
"				if master.go_forward_id then\n"
"					local v=master.ids and master.ids[master.go_forward_id]\n"
"					if v then\n"
"						if m.action==-1 then\n"
"							v:call_hook(\"click\")\n"
"						end\n"
"					end\n"
"				end\n"
"			else\n"
"--print(m.keycode)\n"
"				if m.keycode==0 then -- ignore\n"
"				else\n"
"					if m.action==-1 and master.last_keycode==m.keycode then -- key set\n"
"						master.last_keycode=nil\n"
"						master.key(widget,\"\",\"return\",1)\n"
"						master.key(widget,\"\",\"return\",-1)\n"
"					end\n"
"				end\n"
"			end\n"
"\n"
"		end\n"
"	end\n"
"--\n"
"-- handle key input\n"
"--\n"
"	function master.key(widget,ascii,key,act)\n"
"\n"
"		if master.focus then -- key focus, steals all the key presses until we press enter again\n"
"		\n"
"			master.focus:key(ascii,key,act)\n"
"			\n"
"		\n"
"		else\n"
"			if master.edit then\n"
"				if	key==\"left\" or\n"
"					key==\"right\" or\n"
"					key==\"up\" or\n"
"					key==\"down\" or\n"
"					key==\"return\" then\n"
"					-- ignore\n"
"				else\n"
"					master.edit:key(ascii,key,act)\n"
"				end\n"
"			end\n"
"		\n"
"			if act==-1 then\n"
"				if key==\"space\" or key==\"return\" then\n"
"\n"
"					if master.over and master.over.can_focus then\n"
"						master.focus=master.over\n"
"						if master.focus.class==\"textedit\" then\n"
"							master.edit=master.focus\n"
"						end\n"
"					end\n"
"\n"
"					if master.over then\n"
"						master.over:call_hook(\"click\")\n"
"					end\n"
"					return\n"
"				end\n"
"			\n"
"			elseif act==1 then\n"
"			\n"
"--print(1,master.over)\n"
"			\n"
"				local vx=0\n"
"				local vy=0\n"
"				if key==\"left\"  then vx=-1 end\n"
"				if key==\"right\" then vx= 1 end\n"
"				if key==\"up\"    then vy=-1 end\n"
"				if key==\"down\"  then vy= 1 end\n"
"				\n"
"				if vx~=0 or vy~=0 then -- move hover selection\n"
"				\n"
"					if master.over then\n"
"						local over=master.over\n"
"						local best={}\n"
"						local ox=over.pxd+(over.hx/2)\n"
"						local oy=over.pyd+(over.hy/2)\n"
"\n"
"--print(\"over\",ox,oy)\n"
"\n"
"						master:call_descendents(function(w)\n"
"							if w.solid and w.hooks then\n"
"								local wx=w.pxd+(w.hx/2)\n"
"								local wy=w.pyd+(w.hy/2)\n"
"								local dx=wx-ox\n"
"								local dy=wy-oy\n"
"								local dd=0\n"
"								if vx==0 then dd=dd+dx*dx*8 else dd=dd+dx*dx end\n"
"								if vy==0 then dd=dd+dy*dy*8 else dd=dd+dy*dy end\n"
"--print(w,wx,wy,dx,dy,by,by)\n"
"								if	( dx<0 and vx<0 ) or\n"
"									( dx>0 and vx>0 ) or\n"
"									( dy<0 and vy<0 ) or\n"
"									( dy>0 and vy>0 ) then -- right direction\n"
"									\n"
"									if best.over then\n"
"										if best.dd>dd then -- closer\n"
"											best.over=w\n"
"											best.dd=dd\n"
"										end\n"
"									else\n"
"										best.over=w\n"
"										best.dd=dd\n"
"									end\n"
"								end\n"
"							end\n"
"						end)\n"
"						if best.over then\n"
"							over:set_dirty()\n"
"							best.over:set_dirty()\n"
"							master.over=best.over\n"
"							if master.over then master.over:call_hook(\"over\") end\n"
"						end\n"
"					end\n"
"					if not master.over then\n"
"						master:call_descendents(function(v)\n"
"							if not master.over then\n"
"								if v.solid and v.hooks then\n"
"									master.over=v\n"
"									v:set_dirty()\n"
"									master.over:call_hook(\"over\")\n"
"								end\n"
"							end\n"
"						end)\n"
"					end\n"
"					\n"
"				end\n"
"--print(2,master.over)\n"
"			end\n"
"		end\n"
"\n"
"	end\n"
"\n"
"--\n"
"-- set the mouse position to its last position\n"
"-- call this after adding/removing widgets to make sure they highlight properly\n"
"--	\n"
"	function master.remouse(widget)\n"
"		local p=widget.last_mouse_position or {0,0}\n"
"		widget.mouse(widget,nil,p[1],p[2],nil)\n"
"	end\n"
"--\n"
"-- handle mouse input\n"
"--	\n"
"	function master.mouse(widget,act,x,y,key)\n"
"--print(act,x,y,key)	\n"
"		master.last_mouse_position={x,y}\n"
"	\n"
"--		if widget.state==\"ready\" then\n"
"		\n"
"--print(\"active\",master.active,master.active and master.active.class,\n"
"--master.active and master.active.parent,master.active and master.active.parent.class)\n"
"			if master.dragging() then -- slide :)\n"
"			\n"
"				local w=master.active\n"
"				local p=w.parent\n"
"				\n"
"				local minx=p.pxd\n"
"				local miny=p.pyd\n"
"				local maxx=p.pxd+p.hx-w.hx\n"
"				local maxy=p.pyd+p.hy-w.hy\n"
"\n"
"--print(\"slide\",miny,maxy)\n"
"				\n"
"				w.pxd=x-master.active_x\n"
"				w.pyd=y-master.active_y\n"
"				\n"
"				if w.pxd<minx then w.pxd=minx end\n"
"				if w.pxd>maxx then w.pxd=maxx end\n"
"				if w.pyd<miny then w.pyd=miny end\n"
"				if w.pyd>maxy then w.pyd=maxy end\n"
"				\n"
"				w.px=w.pxd-p.pxd\n"
"				w.py=w.pyd-p.pyd\n"
"				\n"
"				if w.parent.snap then\n"
"					w.parent:snap()\n"
"				end\n"
"				\n"
"				w:call_hook(\"slide\")\n"
"				\n"
"				w:set_dirty()\n"
"				\n"
"				w:layout()\n"
"\n"
"			end\n"
"			\n"
"			local old_active=master.active\n"
"			local old_over=master.over\n"
"			for i,v in ipairs(widget) do\n"
"				meta.mouse(v,act,x,y,key)\n"
"			end\n"
"			\n"
"			if act== 1 then\n"
"				master.press=true\n"
"			end\n"
"			if act==-1 then\n"
"				master.press=false\n"
"				master.active=nil\n"
"			end\n"
"			\n"
"--mark as dirty\n"
"			if master.active~=old_active then\n"
"				if master.active then master.active:set_dirty() end\n"
"				if old_active then old_active:set_dirty() end\n"
"			end\n"
"			if master.over~=old_over then\n"
"				if master.over then master.over:set_dirty() end\n"
"				if old_over then old_over:set_dirty() end\n"
"				if master.over then master.over:call_hook(\"over\") end\n"
"			end\n"
"			\n"
"--		end\n"
"	end\n"
"--\n"
"\n"
"	function master.clean_all(m)\n"
"		meta.clean_all(m)\n"
"		master.over=nil\n"
"		master.active=nil\n"
"		master.focus=nil\n"
"		master.edit=nil\n"
"		master.go_back_id=nil\n"
"		master.go_forward_id=nil\n"
"		master.ids={}\n"
"	end\n"
"	\n"
"	function master.dragging()\n"
"\n"
"		if master.active and (master.active.class==\"drag\") and master.press then\n"
"			return true\n"
"		end\n"
"		\n"
"		return false\n"
"	end\n"
"\n"
"--\n"
"-- Select this widget by id, so we can have a simple default action on each screen if the user hammers buttons\n"
"--\n"
"	function master.activate_by_id(id)\n"
"		master:call_descendents(function(w)\n"
"			if w.id==id then\n"
"				master.over=w\n"
"				if w.class==\"textedit\" then\n"
"					master.edit=w\n"
"				end\n"
"				if master.over then master.over:call_hook(\"over\") end\n"
"			end\n"
"		end)\n"
"		\n"
"	end\n"
"	\n"
"end\n"
"\n"
"return wmaster\n"
"end\n"
"",

"wetgenes.gamecake.cake","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"-- gamecake lua is a simple 2D/3D game framework that targets GLESv2 on android/nacl/linux/windows/raspberrypi systems\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,cake)\r\n"
"\r\n"
"	oven.cake=cake\r\n"
"		\r\n"
"	cake.setup = function()\r\n"
"		cake.sounds.setup()\r\n"
"	end\r\n"
"\r\n"
"	cake.clean = function()\r\n"
"		cake.sounds.clean()\r\n"
"	end\r\n"
"\r\n"
"	cake.start = function()\r\n"
"		cake.fonts.start() -- setup 8x8 font for the preloader first\r\n"
"		cake.framebuffers.start()\r\n"
"		cake.buffers.start()\r\n"
"		cake.images.start() -- also need to prioritise image for preloader in here\r\n"
"		cake.sheets.start()\r\n"
"		cake.sounds.start()\r\n"
"	end\r\n"
"\r\n"
"	cake.stop = function()\r\n"
"		cake.fonts.stop()\r\n"
"		cake.sheets.stop()\r\n"
"		cake.images.stop()\r\n"
"		cake.buffers.stop()\r\n"
"		cake.framebuffers.stop()\r\n"
"		cake.sounds.stop()\r\n"
"		if oven.gl.forget then -- any programs will need to be recompiled\r\n"
"			oven.gl.forget()\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	cake.update = function()\r\n"
"		cake.sounds.update()\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"	cake.gles 	 = oven.rebake(\"wetgenes.gamecake.gles\") -- initalise gles and manage our shaders\r\n"
"	cake.buffers = oven.rebake(\"wetgenes.gamecake.buffers\") -- generic buffer memory is now complex thanks to retardroid\r\n"
"	cake.images  = oven.rebake(\"wetgenes.gamecake.images\") -- we will need to load some images\r\n"
"	cake.sheets  = oven.rebake(\"wetgenes.gamecake.sheets\") -- we will need to manage some sprite sheets\r\n"
"	cake.fonts   = oven.rebake(\"wetgenes.gamecake.fonts\") -- we will need to load some fonts\r\n"
"	cake.sounds  = oven.rebake(\"wetgenes.gamecake.sounds\") -- we will need to load some sounds\r\n"
"	cake.canvas  = oven.rebake(\"wetgenes.gamecake.canvas\") -- a canvas contains current drawing state and functions\r\n"
"	cake.layouts = oven.rebake(\"wetgenes.gamecake.layouts\") -- display layout functions, \r\n"
"	cake.framebuffers = oven.rebake(\"wetgenes.gamecake.framebuffers\") -- render to functions, \r\n"
"	\r\n"
"\r\n"
"\r\n"
"-- finally add in some extra simple sugar\r\n"
"\r\n"
"	local images=cake.images\r\n"
"	local canvas=cake.canvas\r\n"
"	local sounds=cake.sounds\r\n"
"\r\n"
"-- simple wrapper for bliting by id/name\r\n"
"	cake.blit = function(id,cx,cy,ix,iy,w,h)\r\n"
"		canvas.blit(images.get(id),cx,cy,ix,iy,w,h)\r\n"
"	end\r\n"
"\r\n"
"-- simple wrapper for beeping by id/name\r\n"
"	cake.beep = function(id)\r\n"
"		sounds.beep(sounds.get(id))\r\n"
"	end\r\n"
"\r\n"
"-- and things must be setup before we return\r\n"
"	cake.setup()\r\n"
"	\r\n"
"	return cake\r\n"
"end\r\n"
"\r\n"
"",

"al","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local al={}\n"
"\n"
"local core=require(\"al.core\")\n"
"\n"
"local base={}\n"
"local meta={}\n"
"meta.__index=base\n"
"\n"
"setmetatable(al,meta)\n"
"\n"
"-- copypasta from AL header\n"
"local import=[[\n"
"/* Enumerant values begin at column 50. No tabs. */\n"
"\n"
"/* \"no distance model\" or \"no buffer\" */\n"
"#define AL_NONE                                   0\n"
"\n"
"/* Boolean False. */\n"
"#define AL_FALSE                                  0\n"
"\n"
"/** Boolean True. */\n"
"#define AL_TRUE                                   1\n"
"\n"
"/** Indicate Source has relative coordinates. */\n"
"#define AL_SOURCE_RELATIVE                        0x202\n"
"\n"
"\n"
"\n"
"/**\n"
" * Directional source, inner cone angle, in degrees.\n"
" * Range:    [0-360] \n"
" * Default:  360\n"
" */\n"
"#define AL_CONE_INNER_ANGLE                       0x1001\n"
"\n"
"/**\n"
" * Directional source, outer cone angle, in degrees.\n"
" * Range:    [0-360] \n"
" * Default:  360\n"
" */\n"
"#define AL_CONE_OUTER_ANGLE                       0x1002\n"
"\n"
"/**\n"
" * Specify the pitch to be applied at source.\n"
" * Range:   [0.5-2.0]\n"
" * Default: 1.0\n"
" */\n"
"#define AL_PITCH                                  0x1003\n"
"  \n"
"/** \n"
" * Specify the current location in three dimensional space.\n"
" * OpenAL, like OpenGL, uses a right handed coordinate system,\n"
" *  where in a frontal default view X (thumb) points right, \n"
" *  Y points up (index finger), and Z points towards the\n"
" *  viewer/camera (middle finger). \n"
" * To switch from a left handed coordinate system, flip the\n"
" *  sign on the Z coordinate.\n"
" * Listener position is always in the world coordinate system.\n"
" */ \n"
"#define AL_POSITION                               0x1004\n"
"  \n"
"/** Specify the current direction. */\n"
"#define AL_DIRECTION                              0x1005\n"
"  \n"
"/** Specify the current velocity in three dimensional space. */\n"
"#define AL_VELOCITY                               0x1006\n"
"\n"
"/**\n"
" * Indicate whether source is looping.\n"
" * Type: ALboolean?\n"
" * Range:   [AL_TRUE, AL_FALSE]\n"
" * Default: FALSE.\n"
" */\n"
"#define AL_LOOPING                                0x1007\n"
"\n"
"/**\n"
" * Indicate the buffer to provide sound samples. \n"
" * Type: ALuint.\n"
" * Range: any valid Buffer id.\n"
" */\n"
"#define AL_BUFFER                                 0x1009\n"
"  \n"
"/**\n"
" * Indicate the gain (volume amplification) applied. \n"
" * Type:   ALfloat.\n"
" * Range:  ]0.0-  ]\n"
" * A value of 1.0 means un-attenuated/unchanged.\n"
" * Each division by 2 equals an attenuation of -6dB.\n"
" * Each multiplicaton with 2 equals an amplification of +6dB.\n"
" * A value of 0.0 is meaningless with respect to a logarithmic\n"
" *  scale; it is interpreted as zero volume - the channel\n"
" *  is effectively disabled.\n"
" */\n"
"#define AL_GAIN                                   0x100A\n"
"\n"
"/*\n"
" * Indicate minimum source attenuation\n"
" * Type: ALfloat\n"
" * Range:  [0.0 - 1.0]\n"
" *\n"
" * Logarthmic\n"
" */\n"
"#define AL_MIN_GAIN                               0x100D\n"
"\n"
"/**\n"
" * Indicate maximum source attenuation\n"
" * Type: ALfloat\n"
" * Range:  [0.0 - 1.0]\n"
" *\n"
" * Logarthmic\n"
" */\n"
"#define AL_MAX_GAIN                               0x100E\n"
"\n"
"/**\n"
" * Indicate listener orientation.\n"
" *\n"
" * at/up \n"
" */\n"
"#define AL_ORIENTATION                            0x100F\n"
"\n"
"/**\n"
" * Source state information.\n"
" */\n"
"#define AL_SOURCE_STATE                           0x1010\n"
"#define AL_INITIAL                                0x1011\n"
"#define AL_PLAYING                                0x1012\n"
"#define AL_PAUSED                                 0x1013\n"
"#define AL_STOPPED                                0x1014\n"
"\n"
"/**\n"
" * Buffer Queue params\n"
" */\n"
"#define AL_BUFFERS_QUEUED                         0x1015\n"
"#define AL_BUFFERS_PROCESSED                      0x1016\n"
"\n"
"/**\n"
" * Source buffer position information\n"
" */\n"
"#define AL_SEC_OFFSET                             0x1024\n"
"#define AL_SAMPLE_OFFSET                          0x1025\n"
"#define AL_BYTE_OFFSET                            0x1026\n"
"\n"
"/*\n"
" * Source type (Static, Streaming or undetermined)\n"
" * Source is Static if a Buffer has been attached using AL_BUFFER\n"
" * Source is Streaming if one or more Buffers have been attached using alSourceQueueBuffers\n"
" * Source is undetermined when it has the NULL buffer attached\n"
" */\n"
"#define AL_SOURCE_TYPE                            0x1027\n"
"#define AL_STATIC                                 0x1028\n"
"#define AL_STREAMING                              0x1029\n"
"#define AL_UNDETERMINED                           0x1030\n"
"\n"
"/** Sound samples: format specifier. */\n"
"#define AL_FORMAT_MONO8                           0x1100\n"
"#define AL_FORMAT_MONO16                          0x1101\n"
"#define AL_FORMAT_STEREO8                         0x1102\n"
"#define AL_FORMAT_STEREO16                        0x1103\n"
"\n"
"/**\n"
" * source specific reference distance\n"
" * Type: ALfloat\n"
" * Range:  0.0 - +inf\n"
" *\n"
" * At 0.0, no distance attenuation occurs.  Default is\n"
" * 1.0.\n"
" */\n"
"#define AL_REFERENCE_DISTANCE                     0x1020\n"
"\n"
"/**\n"
" * source specific rolloff factor\n"
" * Type: ALfloat\n"
" * Range:  0.0 - +inf\n"
" *\n"
" */\n"
"#define AL_ROLLOFF_FACTOR                         0x1021\n"
"\n"
"/**\n"
" * Directional source, outer cone gain.\n"
" *\n"
" * Default:  0.0\n"
" * Range:    [0.0 - 1.0]\n"
" * Logarithmic\n"
" */\n"
"#define AL_CONE_OUTER_GAIN                        0x1022\n"
"\n"
"/**\n"
" * Indicate distance above which sources are not\n"
" * attenuated using the inverse clamped distance model.\n"
" *\n"
" * Default: +inf\n"
" * Type: ALfloat\n"
" * Range:  0.0 - +inf\n"
" */\n"
"#define AL_MAX_DISTANCE                           0x1023\n"
"\n"
"/** \n"
" * Sound samples: frequency, in units of Hertz [Hz].\n"
" * This is the number of samples per second. Half of the\n"
" *  sample frequency marks the maximum significant\n"
" *  frequency component.\n"
" */\n"
"#define AL_FREQUENCY                              0x2001\n"
"#define AL_BITS                                   0x2002\n"
"#define AL_CHANNELS                               0x2003\n"
"#define AL_SIZE                                   0x2004\n"
"\n"
"/**\n"
" * Buffer state.\n"
" *\n"
" * Not supported for public use (yet).\n"
" */\n"
"#define AL_UNUSED                                 0x2010\n"
"#define AL_PENDING                                0x2011\n"
"#define AL_PROCESSED                              0x2012\n"
"\n"
"\n"
"/** Errors: No Error. */\n"
"#define AL_NO_ERROR                               AL_FALSE\n"
"\n"
"/** \n"
" * Invalid Name paramater passed to AL call.\n"
" */\n"
"#define AL_INVALID_NAME                           0xA001\n"
"\n"
"/** \n"
" * Invalid parameter passed to AL call.\n"
" */\n"
"#define AL_INVALID_ENUM                           0xA002\n"
"\n"
"/** \n"
" * Invalid enum parameter value.\n"
" */\n"
"#define AL_INVALID_VALUE                          0xA003\n"
"\n"
"/** \n"
" * Illegal call.\n"
" */\n"
"#define AL_INVALID_OPERATION                      0xA004\n"
"\n"
"  \n"
"/**\n"
" * No mojo.\n"
" */\n"
"#define AL_OUT_OF_MEMORY                          0xA005\n"
"\n"
"\n"
"/** Context strings: Vendor Name. */\n"
"#define AL_VENDOR                                 0xB001\n"
"#define AL_VERSION                                0xB002\n"
"#define AL_RENDERER                               0xB003\n"
"#define AL_EXTENSIONS                             0xB004\n"
"\n"
"/** Global tweakage. */\n"
"\n"
"/**\n"
" * Doppler scale.  Default 1.0\n"
" */\n"
"#define AL_DOPPLER_FACTOR                         0xC000\n"
"\n"
"/**\n"
" * Tweaks speed of propagation.\n"
" */\n"
"#define AL_DOPPLER_VELOCITY                       0xC001\n"
"\n"
"/**\n"
" * Speed of Sound in units per second\n"
" */\n"
"#define AL_SPEED_OF_SOUND                         0xC003\n"
"\n"
"/**\n"
" * Distance models\n"
" *\n"
" * used in conjunction with DistanceModel\n"
" *\n"
" * implicit: NONE, which disances distance attenuation.\n"
" */\n"
"#define AL_DISTANCE_MODEL                         0xD000\n"
"#define AL_INVERSE_DISTANCE                       0xD001\n"
"#define AL_INVERSE_DISTANCE_CLAMPED               0xD002\n"
"#define AL_LINEAR_DISTANCE                        0xD003\n"
"#define AL_LINEAR_DISTANCE_CLAMPED                0xD004\n"
"#define AL_EXPONENT_DISTANCE                      0xD005\n"
"#define AL_EXPONENT_DISTANCE_CLAMPED              0xD006\n"
"]]\n"
"-- parse the above string for constants, makes updates as easy as a cutnpaste from original source code\n"
"\n"
"al.defs={}\n"
"\n"
"for l in import:gmatch(\"([^\\n"
"]*)\") do\n"
"	local define,value\n"
"	local state=\"start\"\n"
"	for w in l:gmatch(\"([^%s]+)\") do\n"
"		if state==\"start\" then\n"
"			if w==\"#define\" then\n"
"				state=\"define\"\n"
"			else\n"
"				break\n"
"			end\n"
"		elseif state==\"define\" then\n"
"			define=w\n"
"			state=\"value\"\n"
"		elseif state==\"value\" then\n"
"			value=w\n"
"				if define:sub(1,3)==\"AL_\" then -- sanity check\n"
"					define=define:sub(4)\n"
"					\n"
"					if value:sub(1,3)==\"AL_\" then -- allow lookback\n"
"						value=al.defs[value:sub(4)]\n"
"					end\n"
"					\n"
"					al.defs[define]=tonumber(value)\n"
"				end\n"
"			break\n"
"		else\n"
"			break\n"
"		end\n"
"	end\n"
"end\n"
"import=nil -- free it just because\n"
"\n"
"for i,v in pairs(al.defs) do -- copy vals into base for shorthand al.FALSE use\n"
"	base[i]=v\n"
"	base[v]=i\n"
"end\n"
"\n"
"function al.numtostring(num)\n"
"	return al.defs[num]\n"
"end\n"
"\n"
"function al.Get(...)\n"
"	return core.Get(...)\n"
"end\n"
"function al.GetError(...)\n"
"	return core.GetError(...)\n"
"end\n"
"function al.CheckError(...)\n"
"	local err=al.GetError()\n"
"	local str=al.numtostring(err) or (\"0x%04x\"):format(err)\n"
"	assert(err==0,str)\n"
"end\n"
"\n"
"function al.Listener(...)\n"
"	return core.Listener(...)\n"
"end\n"
"function al.GetListener(...)\n"
"	return core.GetListener(...)\n"
"end\n"
"\n"
"function al.GenSource(...)\n"
"	return core.GenSource(...)\n"
"end\n"
"function al.DeleteSource(...)\n"
"	return core.DeleteSource(...)\n"
"end\n"
"function al.Source(...)\n"
"	return core.Source(...)\n"
"end\n"
"function al.GetSource(...)\n"
"	return core.GetSource(...)\n"
"end\n"
"function al.SourcePlay(...)\n"
"	return core.SourcePlay(...)\n"
"end\n"
"function al.SourcePause(...)\n"
"	return core.SourcePause(...)\n"
"end\n"
"function al.SourceRewind(...)\n"
"	return core.SourceRewind(...)\n"
"end\n"
"function al.SourceStop(...)\n"
"	return core.SourceStop(...)\n"
"end\n"
"function al.SourceQueueBuffer(...)\n"
"	return core.SourceQueueBuffer(...)\n"
"end\n"
"function al.SourceUnqueueBuffer(...)\n"
"	return core.SourceUnqueueBuffer(...)\n"
"end\n"
"\n"
"function al.GenBuffer(...)\n"
"	return core.GenBuffer(...)\n"
"end\n"
"function al.DeleteBuffer(...)\n"
"	return core.DeleteBuffer(...)\n"
"end\n"
"function al.Buffer(...)\n"
"	return core.Buffer(...)\n"
"end\n"
"function al.GetBuffer(...)\n"
"	return core.GetBuffer(...)\n"
"end\n"
"function al.BufferData(buff,fmt,data,size,freq)\n"
"\n"
"	if type(fmt)==\"table\" then	\n"
"		return core.BufferData(buff,fmt.fmt,fmt.data,fmt.data_sizeof,fmt.freq)\n"
"	else\n"
"		return core.BufferData(buff,fmt,data,size,freq)\n"
"	end\n"
"end\n"
"\n"
"return al\n"
"",

"wetgenes.www.sqlite.data","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"\n"
"local sql=require(\"sqlite\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"local wsql=require(\"wetgenes.www.sqlite\")\n"
"\n"
"local json=require(\"wetgenes.json\")\n"
"\n"
"local ngx=ngx -- only on ngx?\n"
"\n"
"local fixvalue=wsql.fixvalue\n"
"\n"
"module(...)\n"
"local wdata=require(...) -- this is us\n"
"package.loaded[\"wetgenes.www.any.data\"]=wdata\n"
"\n"
"local opts=require(\"opts\")\n"
"\n"
"local cache=require(\"wetgenes.www.any.cache\")\n"
"local wdatadef=require(\"wetgenes.www.any.datadef\")\n"
"\n"
"\n"
"function countzero()\n"
"	count=0\n"
"	api_time=0\n"
"end\n"
"countzero()\n"
"\n"
"local kind_props={}	-- default global props mapped to kinds\n"
"\n"
"local start_time -- handle simple api benchmarking of some calls\n"
"local function apis()\n"
"	start_time=os.time()\n"
"end\n"
"local function apie(...)\n"
"	api_time=api_time+os.time()-start_time\n"
"	return ...\n"
"end\n"
"\n"
"\n"
"local function fixkind(kind) return kind:gsub(\"%p\",\"_\") end\n"
"\n"
"-- can over ride this function to open dbs from other places\n"
"function getdb(kind)\n"
"\n"
"local prefix=\"sqlite/\"\n"
"local postfix=\".sqlite\"\n"
"\n"
"-- at this point we can choose to return a single database no matter what the kind\n"
"-- or open a seperate one for each kind which might make more sense\n"
"\n"
"--	db=wsql.open(wsql.dbs,prefix,fixkind(kind),postfix)\n"
"\n"
"	local vhost=vhost or \"data\"\n"
"	if ngx and ngx.ctx and ngx.ctx.vhost then\n"
"		vhost=ngx.ctx.vhost\n"
"	end\n"
"	db=wsql.open(wsql.dbs,prefix,vhost,postfix)\n"
"	return db\n"
"end\n"
"\n"
"function keyinfo(keystr)\n"
"	local t=wstr.split(keystr,\"/\")	\n"
"	return {kind=t[1],id=tonumber(t[2]) or t[2] }\n"
"end\n"
"\n"
"function keystr(kind,id,parent)\n"
"	return kind..\"/\"..id\n"
"end\n"
"\n"
"\n"
"\n"
"function del(key,t)\n"
"	key=key and ( key.key or key ) -- turn an ent into a key\n"
"	local kind=fixkind(key and key.kind)\n"
"	local id=key and key.id\n"
"	local ret\n"
"--	log(wstr.serialize(ent))\n"
"--	log(\"data.del:\",kind)\n"
"	apis()\n"
"	\n"
"	count=count+0.5\n"
"	\n"
"	local db=getdb(kind)\n"
"\n"
"	local s\n"
"	if type(id)==\"number\" then\n"
"		s=\"DELETE FROM \"..kind..\" WHERE ROWID=\"..fixvalue(id)..\";\"\n"
"	else\n"
"		s=\"DELETE FROM \"..kind..\" WHERE id=\"..fixvalue(id)..\";\"\n"
"	end\n"
"--log(s)\n"
"	ret=wsql.exec(db,s)\n"
"	apie()\n"
"	return true\n"
"end\n"
"\n"
"function put(ent,t)\n"
"	local kind=fixkind(ent and ent.key and ent.key.kind)\n"
"	local id=ent and ent.key and ent.key.id\n"
"	local ret\n"
"--	log(wstr.serialize(ent))\n"
"--	log(\"data.put:\",kind)\n"
"	apis()\n"
"	count=count+0.5\n"
"\n"
"	local db=getdb(kind)\n"
"	\n"
"	local s=wsql.make_replace(kind,ent.props)\n"
"	\n"
"--log(s)\n"
"	ret=wsql.exec(db,s)\n"
"	id=id or db:last_insert_rowid() -- get the new id, unless we forced it\n"
"	\n"
"	ent.key.id=id -- fix id\n"
"	ent.cache.id=id -- fix id\n"
"	\n"
"	apie()\n"
"	return keystr(kind,id)\n"
"end\n"
"\n"
"function get(ent,t)\n"
"	local kind=fixkind(ent and ent.key and ent.key.kind)\n"
"	local id=ent and ent.key and ent.key.id\n"
"	local ret\n"
"--	log(wstr.serialize(ent))\n"
"--	log(\"data.get:\",kind)\n"
"	apis()\n"
"	count=count+0.5\n"
"\n"
"	local db=getdb(kind)\n"
"\n"
"	local s\n"
"	if type(id)==\"number\" then\n"
"		s=\"SELECT *,ROWID FROM \"..kind..\" WHERE ROWID=\"..fixvalue(id)..\";\"\n"
"	else\n"
"		s=\"SELECT *,ROWID FROM \"..kind..\" WHERE id=\"..fixvalue(id)..\";\"\n"
"	end\n"
"\n"
"--log(s)\n"
"	ent.props=wsql.row(db,s)\n"
"	\n"
"	\n"
"if ent.props then\n"
"	if ent.key then\n"
"		ent.key.notsaved=nil\n"
"	end\n"
"--	log(wstr.serialize(ent.props))\n"
"end\n"
"\n"
"	apie()\n"
"	return ent.props and ent\n"
"end\n"
"\n"
"function query(q)\n"
"	local original_kind=q.kind\n"
"	local kind=fixkind(q and q.kind)\n"
"	\n"
"	local ret={list={}}\n"
"--	log(\"data.query:\")\n"
"	apis()\n"
"	count=count+1\n"
"	\n"
"	local db=getdb(kind)\n"
"	q.kind=kind -- patchup kind\n"
"	ret.code=wsql.make_query(q)\n"
"	q.kind=original_kind -- and restore it\n"
"	\n"
"	local el=wsql.rows(db,ret.code)\n"
"	\n"
"	for i,v in ipairs(el) do\n"
"	\n"
"		local e={}\n"
"		ret.list[i]=e\n"
"		\n"
"		e.props=v\n"
"		e.key={kind=original_kind,id=v.id or v.rowid}\n"
"\n"
"	end\n"
"	\n"
"	apie()\n"
"	return ret\n"
"end\n"
"\n"
"function rollback(t)\n"
"end\n"
"function commit(t)\n"
"	return true\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- Begin a transaction, use the functions inside the returned table\n"
"-- to perform actions within this transaction\n"
"--\n"
"-- the basic code flow is that you should begin one transaction per entity(parent)\n"
"-- and then rollback all when one fails. the first del/put/get locks the entity\n"
"-- we are dealing with in this transaction\n"
"--\n"
"-- after the t.fail flag gets set on a put/del then everything apart from rollback just returns nil\n"
"-- and commit is turned into an auto rollback\n"
"--\n"
"-- so this is OK transaction code, just remember that puts may not auto generate a key\n"
"-- and there may be other reasons for fails\n"
"--\n"
"-- for _=1,10 do -- try a few times\n"
"--     t=begin()\n"
"--     if t.get(e) then e.props.data=e.props.data..\"new data\" end\n"
"--     t.put(e)\n"
"--     if t.commit() then break end -- success\n"
"-- end\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function begin()\n"
"--	log(\"data.begin:\")\n"
"\n"
"	local t={}\n"
"--	t.core=core.begin()\n"
"	\n"
"	t.fail=false -- this will be set to true when a transaction action fails and you should rollback and retry\n"
"	t.done=false -- set to true on commit or rollback to disable all methods\n"
"	\n"
" -- these methods are the same as the global ones but operate on this transaction\n"
" 	t.del=function(ent)	if t.fail or t.done then return nil end return del(ent,t) end\n"
"	t.put=function(ent)	if t.fail or t.done then return nil end return put(ent,t) end\n"
"	t.get=function(ent)	if t.fail or t.done then return nil end return get(ent,t) end\n"
"	t.query=function(q)	if t.fail or t.done then return nil end return query(q,t) end\n"
"	\n"
"	t.rollback=function() -- returns false to imply that nothing was commited\n"
"		if t.done then return false end -- safe to rollback repeatedly\n"
"		t.done=true\n"
"		t.fail=not rollback(t) -- we always set fail and return false\n"
"		return not t.fail\n"
"	end	\n"
"	\n"
"	t.commit=function() -- returns true if commited, false if not\n"
"		if t.done then return false end -- safe to rollback repeatedly\n"
"		if t.fail then -- rollback rather than commit\n"
"			return rollback(t)\n"
"		end\n"
"		t.done=true\n"
"		apis()\n"
"		t.fail=not commit(t)\n"
"		return not t.fail\n"
"	end\n"
"\n"
"	return t\n"
"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- build cache which is a mixture of decoded json vars (this may contain sub tables)\n"
"-- overiden by database props which do not contain tables but are mildly searchable\n"
"-- props.json should contain this json data string on input\n"
"-- cache will be a filled in table to be used instead of props\n"
"--\n"
"-- Not sure if this is more compact than just creating many real key/value pairs\n"
"-- but it feels like a better way to organize. :)\n"
"--\n"
"-- At least it is a bit more implicit about what can and cannot be searched for.\n"
"--\n"
"-- the idea is everything we need is copied into the cache, you can edit it there\n"
"-- and then build_props will do the reverse in preperation for a put\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function build_cache(e)\n"
"\n"
"	if e.props.json then -- expand the json data\n"
"	\n"
"		e.cache=json.decode(e.props.json)\n"
"		\n"
"	else\n"
"	\n"
"		e.cache={}\n"
"	\n"
"	end\n"
"\n"
"	for i,v in pairs(e.props) do -- override cache by props\n"
"		e.cache[i]=v\n"
"	end\n"
"	\n"
"	e.cache.json=nil -- not the json prop\n"
"	\n"
"	if e.key then -- copy the key data\n"
"		e.cache.parent=e.key.parent\n"
"		e.cache.kind=e.key.kind\n"
"		e.cache.id=e.props.id or e.key.id -- use string or ROWID?\n"
"	end\n"
"	\n"
"	return e\n"
"\n"
"end\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- a simplistic reverse of build cache\n"
"-- any props of the same name will get updated from this cache\n"
"-- rather than encoded into props.json\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function build_props(e)\n"
"\n"
"	local t={}\n"
"	local ignore={kind=true,id=true,parent=true,json=true,} -- special names to ignore\n"
"	\n"
"	for i,v in pairs(e.cache) do\n"
"		if ignore[i] then -- ignore these special names\n"
"		elseif e.props[i] then\n"
"			e.props[i]=v -- if it exists as a prop then the prop is updated\n"
"		else\n"
"			t[i]=v -- else it just goes into the json prop\n"
"		end\n"
"	end\n"
"	e.props.json=json.encode(t)\n"
"\n"
"	if e.key.id then\n"
"		if type(e.key.id)==\"number\" then\n"
"			e.props.ROWID=e.key.id -- use number id from key\n"
"		else\n"
"			e.props.id=e.key.id -- use string id from key\n"
"		end\n"
"	end\n"
"	\n"
"	return e\n"
"	\n"
"end\n"
"\n"
"\n"
"function set_defs(env)\n"
"	return wdatadef.set_defs(env)\n"
"end\n"
"\n"
"\n"
"function setup_db(env,srv)\n"
"	if opts and opts.vhosts and ngx and ngx.ctx then\n"
"	\n"
"		local old_vhost=ngx.ctx.vhost\n"
"\n"
"		for n,b in pairs(opts.vhosts) do\n"
"			ngx.ctx.vhost=n\n"
"--			log(\"data.setup_vhost:\",ngx.ctx.vhost)\n"
"			setup_dbv(env,ngx.ctx)\n"
"		end\n"
"\n"
"		ngx.ctx.vhost=old_vhost\n"
"		\n"
"	else\n"
"		setup_dbv(env,srv)\n"
"	end\n"
"end\n"
"\n"
"function setup_dbv(env,srv)\n"
"\n"
"-- make sure database exists and is setup\n"
"\n"
"	local kind=env.kind()\n"
"\n"
"--	log(\"data.setup_db:\",kind)\n"
"\n"
"\n"
"	local db=getdb(kind)\n"
"\n"
"-- all data has these fields	\n"
"	local info={\n"
"		{name=\"id\",TEXT=true,UNIQUE=true},\n"
"		{name=\"created\",REAL=true},\n"
"		{name=\"updated\",REAL=true},\n"
"		{name=\"json\",TEXT=true},\n"
"	}\n"
"	\n"
"--check if is already added\n"
"	local function in_table(tab,name)\n"
"		for i,v in ipairs(tab) do\n"
"			if v.name==name then return true end\n"
"		end\n"
"	end\n"
"	\n"
"		\n"
"	for n,v in pairs(env.default_props) do\n"
"		if not in_table(info,n) then -- add to table, simple check for dupes just in case.\n"
"			local t={name=n}\n"
"			local tp=type(v)\n"
"			if tp==\"number\" then -- only have numbers or strings and numbers are real\n"
"				t.REAL=true\n"
"			else\n"
"				t.TEXT=true\n"
"			end\n"
"			info[#info+1]=t\n"
"		end\n"
"	end\n"
"	\n"
"\n"
"-- check or update database\n"
"	wsql.set_info(db,kind,info)\n"
"	\n"
"end\n"
"",

"wetgenes.speak","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local wzips=require(\"wetgenes.zips\")\n"
"\n"
"local speak={}\n"
"\n"
"local core=require(\"wetgenes.speak.core\")\n"
"\n"
"for n,f in pairs(core) do speak[n]=f end\n"
"\n"
"\n"
"speak.setup=function()\n"
"\n"
"	speak.slt_data=assert(wzips.readfile(\"data/wvoices/cmu_us_slt/model_data.bin\"))\n"
"	speak.slt_idxs=assert(wzips.readfile(\"data/wvoices/cmu_us_slt/model_data.idx\"))\n"
"\n"
"print(\"speak loaded \",#speak.slt_data,#speak.slt_idxs)\n"
"\n"
"	core.setup(speak.slt_data,speak.slt_idxs)\n"
"end\n"
"\n"
"\n"
"-- safe to call setup now?\n"
"speak.setup()\n"
"\n"
"return speak\n"
"",

"profiler.summary","-- LuaProfiler\n"
"-- Copyright Kepler Project 2005-2007 (http://www.keplerproject.org/luaprofiler)\n"
"-- $Id: summary.lua,v 1.6 2009-03-16 15:55:32 alessandrohc Exp $\n"
"\n"
"-- Function that reads one profile file\n"
"function ReadProfile(file)\n"
"\n"
"	local profile\n"
"\n"
"	-- Check if argument is a file handle or a filename\n"
"	if io.type(file) == \"file\" then\n"
"		profile = file\n"
"	else\n"
"		-- Open profile\n"
"		profile = io.open(file)\n"
"	end\n"
"\n"
"	-- Table for storing each profile's set of lines\n"
"	line_buffer = {}\n"
"\n"
"	-- Get all profile lines\n"
"	local i = 1\n"
"	for line in profile:lines() do\n"
"		line_buffer[i] = line\n"
"		i = i + 1\n"
"    end\n"
"\n"
"	-- Close file\n"
"	profile:close()\n"
"	return line_buffer\n"
"end\n"
"\n"
"-- Function that creates the summary info\n"
"function CreateSummary(lines, summary)\n"
"\n"
"	local global_time = 0\n"
"\n"
"	-- Note: ignore first line\n"
"	for i = 2, table.getn(lines) do\n"
"		local word = string.match(lines[i], \"[^\\t]+\\t[^\\t]+\\t([^\\t]+)\")\n"
"		local local_time, total_time = string.match(lines[i], \"[^\\t]+\\t[^\\t]+\\t[^\\t]+\\t[^\\t]+\\t[^\\t]+\\t([^\\t]+)\\t([^\\t]+)\")\n"
"        local_time = tonumber((string.gsub(local_time, \",\", \".\")))\n"
"        total_time = tonumber((string.gsub(total_time, \",\", \".\")))\n"
"        \n"
"        if not (local_time and total_time) then return global_time end\n"
"        if summary[word] == nil then\n"
"			summary[word] = {};\n"
"			summary[word][\"info\"] = {}\n"
"			summary[word][\"info\"][\"calls\"] = 1\n"
"			summary[word][\"info\"][\"total\"] = local_time\n"
"			summary[word][\"info\"][\"func\"] = word\n"
"		else\n"
"			summary[word][\"info\"][\"calls\"] = summary[word][\"info\"][\"calls\"] + 1\n"
"			summary[word][\"info\"][\"total\"] = summary[word][\"info\"][\"total\"] + local_time;\n"
"		end\n"
"\n"
"		global_time = global_time + local_time;\n"
"	end\n"
"\n"
"	return global_time\n"
"end\n"
"\n"
"-- Global time\n"
"global_t = 0\n"
"\n"
"-- Summary table\n"
"profile_info = {}\n"
"\n"
"-- Check file type\n"
"local verbose = false\n"
"local filename\n"
"if arg[1] == \"-v\" or arg[1] == \"-V\" then\n"
"  verbose = true\n"
"  filename = arg[2]\n"
"else\n"
"  filename = arg[1]\n"
"end\n"
"if filename then\n"
"  file = io.open(filename)\n"
"else\n"
"  print(\"Usage\")\n"
"  print(\"-----\")\n"
"  print(\"lua summary.lua [-v] <profile_log>\")\n"
"  os.exit()\n"
"end\n"
"if not file then\n"
"  print(\"File \" .. filename .. \" does not exist!\")\n"
"  os.exit()\n"
"end\n"
"firstline = file:read(11)\n"
"\n"
"-- File is single profile\n"
"if firstline == \"stack_level\" then\n"
"\n"
"	-- Single profile\n"
"	local lines = ReadProfile(file)\n"
"	global_t = CreateSummary(lines, profile_info)\n"
"\n"
"else\n"
"\n"
"	-- File is list of profiles\n"
"	-- Reset position in file\n"
"	file:seek(\"set\")\n"
"\n"
"	-- Loop through profiles and create summary table\n"
"	for line in file:lines() do\n"
"\n"
"		local profile_lines\n"
"\n"
"		-- Read current profile\n"
"		profile_lines = ReadProfile(line)\n"
"\n"
"		-- Build a table with profile info\n"
"		global_t = global_t + CreateSummary(profile_lines, profile_info)\n"
"	end\n"
"\n"
"	file:close()\n"
"end\n"
"\n"
"-- Sort table by total time\n"
"sorted = {}\n"
"for k, v in pairs(profile_info) do table.insert(sorted, v) end\n"
"table.sort(sorted, function (a, b) return tonumber(a[\"info\"][\"total\"]) > tonumber(b[\"info\"][\"total\"]) end)\n"
"\n"
"-- Output summary\n"
"if verbose then\n"
"  print(\"Node name\\tCalls\\tAverage per call\\tTotal time\\t%Time\")\n"
"else\n"
"  print(\"Node name\\tTotal time\")\n"
"end\n"
"for k, v in pairs(sorted) do\n"
"	if v[\"info\"][\"func\"] ~= \"(null)\" then\n"
"		local average = v[\"info\"][\"total\"] / v[\"info\"][\"calls\"]\n"
"		local percent = 100 * v[\"info\"][\"total\"] / global_t\n"
"		if verbose then\n"
"		  print(v[\"info\"][\"func\"] .. \"\\t\" .. v[\"info\"][\"calls\"] .. \"\\t\" .. average .. \"\\t\" .. v[\"info\"][\"total\"] .. \"\\t\" .. percent)\n"
"		else\n"
"		  print(v[\"info\"][\"func\"] .. \"\\t\" .. v[\"info\"][\"total\"])\n"
"		end\n"
"	end\n"
"end\n"
"",

"wetgenes.www.gae.sys","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local core=require(\"wetgenes.www.gae.sys.core\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.sys\"]=_M\n"
"\n"
"\n"
"function sleep(...)\n"
"\n"
"	return core.sleep(...)\n"
"\n"
"end\n"
"\n"
"function file_read(filename)\n"
"\n"
"	return core.file_read(filename)\n"
"end\n"
"\n"
"function bytes_split(bytes,size)\n"
"	return core.bytes_split(bytes,size)\n"
"end\n"
"function bytes_join(tab)\n"
"	return core.bytes_join(tab)\n"
"end\n"
"\n"
"function bytes_to_string(bytes)\n"
"	return core.bytes_to_string(bytes)\n"
"end\n"
"\n"
"function bin_encode(t,b)\n"
"	return core.bin_encode(t,b)\n"
"end\n"
"\n"
"function md5(s,f)\n"
"	return core.md5(s,f)\n"
"end\n"
"function sha1(s,f)\n"
"	return core.sha1(s,f)\n"
"end\n"
"function hmac_sha1(k,s,f)\n"
"	return core.hmac_sha1(k,s,f)\n"
"end\n"
"\n"
"function zip_list(z)\n"
"	return core.zip_list(z)\n"
"end\n"
"function zip_read(z,n)\n"
"	return core.zip_read(z,n)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- check if the given file exists\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function file_exists(filename)\n"
"\n"
"--[[\n"
"	local f=io.open(filename,\"r\")\n"
"	if f then\n"
"		f:close()\n"
"		return true\n"
"	end\n"
"\n"
"	return false\n"
"]]\n"
"\n"
"	return core.file_exists(filename)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- find a given lua file, within the lua path\n"
"-- do not pass in the .lua extension\n"
"-- returns a path to a file you can then open\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function file_find_lua(name)\n"
"\n"
"	return \"lua/\"..name..\".lua\"\n"
"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function redirect(srv,url)\n"
"\n"
"--	if not srv.redirect(url) then -- header write failed, spit out some java script instead?\n"
"	\n"
"		srv.put([[<script type=\"text/javascript\" >window.location = \"]]..url..[[\";</script>]])\n"
"		\n"
"--	end\n"
"\n"
"end\n"
"\n"
"",

"wetgenes.ogg","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local ogg={}\n"
"\n"
"local core=require(\"wetgenes.ogg.core\")\n"
"\n"
"local meta={__index=ogg}\n"
"\n"
"ogg.create=function()\n"
"	local od={}\n"
"	setmetatable(od,meta)\n"
"	\n"
"	od[0]=assert( core.create() )\n"
"	\n"
"	core.info(od[0],od)\n"
"	return od\n"
"end\n"
"\n"
"ogg.destroy=function(od)\n"
"	core.destroy(od[0])\n"
"end\n"
"\n"
"ogg.open=function(od)\n"
"	core.open(od[0])\n"
"	core.info(od[0],od)\n"
"	return od\n"
"end\n"
"ogg.close=function(od)\n"
"	core.close(od[0])\n"
"	core.info(od[0],od)\n"
"	return od\n"
"end\n"
"\n"
"ogg.push=function(od,dat)\n"
"	if not dat then return end\n"
"	local r1,r2=core.push(od[0],dat)\n"
"	core.info(od[0],od)\n"
"	return r1,r2\n"
"end\n"
"\n"
"ogg.pull=function(od)\n"
"	local r1,r2=core.pull(od[0])\n"
"	core.info(od[0],od)\n"
"	return r1,r2\n"
"end\n"
"\n"
"return ogg\n"
"",

"wetgenes.fred","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"\n"
"function M.create(f)\n"
"\n"
"	f.setup= function(f) for i,v in ipairs(f) do if v.setup  then v:setup(f)  end end end\n"
"	f.clean= function(f) for i,v in ipairs(f) do if v.clean  then v:clean(f)  end end end\n"
"	f.update=function(f) for i,v in ipairs(f) do if v.update then v:update(f) end end end\n"
"	f.draw=  function(f) for i,v in ipairs(f) do if v.draw   then v:draw(f)   end end end\n"
"	\n"
"	f.sort=function(f) table.sort(f,function(a,b) return (a.sort or 0) < (b.sort or 0) end) end\n"
"\n"
"	f.insert=function(f,v) table.insert(f,v) return v end\n"
"	\n"
"	f.remove=function(f,v) for i,vv in ipairs(f) do if v==vv then table.remove(f,i) return end end end\n"
"\n"
"	return f\n"
"end\n"
"\n"
"\n"
"function M.co(f,c)\n"
"	f=f or {}\n"
"	f.fred=coroutine.create(c)\n"
"	f.yield =function(f,...) coroutine.yield(...) end\n"
"	f.resume=function(f,...) coroutine.resume(f.fred,...) end\n"
"	return f\n"
"end\n"
"\n"
"",

"wetgenes.bake.ngx","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"local lfs=require(\"lfs\")\r\n"
"local wstr=require(\"wetgenes.string\")\r\n"
"\r\n"
"module(...)\r\n"
"\r\n"
"function build(tab)\r\n"
"\r\n"
"	local bake=require(\"wetgenes.bake\")\r\n"
"	\r\n"
"	-- where we are building from\r\n"
"	bake.cd_base	=	tab.cd_base or bake.get_cd()\r\n"
"	-- where we are building to\r\n"
"	bake.cd_out		=	tab.cd_out or '.ngx'\r\n"
"	-- where we are building from\r\n"
"	bake.cd_root	=	bake.cd_base .. \"/../..\"\r\n"
"\r\n"
"-- we need this one\r\n"
"	lfs.mkdir(bake.cd_out)\r\n"
"-- and these\r\n"
"	lfs.mkdir(bake.cd_out..\"/conf\")\r\n"
"	lfs.mkdir(bake.cd_out..\"/logs\")\r\n"
"	lfs.mkdir(bake.cd_out..\"/sqlite\")\r\n"
"\r\n"
"\r\n"
"-- combine all possible lua files into one lua dir in the .ngx output dir\r\n"
"\r\n"
"	local opts={basedir=bake.cd_root..\"/../bin\",dir=\"lua\",filter=\"\"}\r\n"
"	local r=bake.findfiles(opts)\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		local fname=bake.cd_out..\"/\"..v\r\n"
"		bake.create_dir_for_file(fname)\r\n"
"		bake.copyfile(opts.basedir..\"/\"..v,fname)\r\n"
"	end\r\n"
"\r\n"
"	local opts={basedir=bake.cd_base..\"/public\",dir=\"lua\",filter=\"\"}\r\n"
"	local r=bake.findfiles(opts)\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		local fname=bake.cd_out..\"/\"..v\r\n"
"		bake.create_dir_for_file(fname)\r\n"
"		bake.copyfile(opts.basedir..\"/\"..v,fname)\r\n"
"	end\r\n"
"\r\n"
"	local opts={basedir=bake.cd_base,dir=\"lua\",filter=\"\"}\r\n"
"	local r=bake.findfiles(opts)\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		local fname=bake.cd_out..\"/\"..v\r\n"
"		bake.create_dir_for_file(fname)\r\n"
"		bake.copyfile(opts.basedir..\"/\"..v,fname)\r\n"
"	end\r\n"
"\r\n"
"\r\n"
"-- now do the same with the modules datas, should auto find these\r\n"
"\r\n"
"	local modnames={\r\n"
"		\"admin\",\r\n"
"		\"base\",\r\n"
"		\"blog\",\r\n"
"		\"chan\",\r\n"
"		\"comic\",\r\n"
"		\"console\",\r\n"
"		\"data\",\r\n"
"		\"dice\",\r\n"
"		\"dimeload\",\r\n"
"		\"dumid\",\r\n"
"		\"forum\",\r\n"
"		\"mirror\",\r\n"
"		\"note\",\r\n"
"		\"port\",\r\n"
"		\"profile\",\r\n"
"		\"score\",\r\n"
"		\"shoop\",\r\n"
"		\"thumbcache\",\r\n"
"		\"todo\",\r\n"
"		\"waka\",\r\n"
"		\"hoe\",\r\n"
"	}\r\n"
"	for i,n in ipairs(modnames) do\r\n"
"		for i,s in ipairs{\"art\",\"css\",\"js\"} do\r\n"
"			local opts={basedir=bake.cd_root..\"/mods/\"..n..\"/\"..s,dir=\"\",filter=\"\"}\r\n"
"			local r=bake.findfiles(opts)\r\n"
"			for i,v in ipairs(r.ret) do\r\n"
"				local fname=bake.cd_out..\"/public/\"..s..\"/\"..n..\"/\"..v\r\n"
"				bake.create_dir_for_file(fname)\r\n"
"				bake.copyfile(opts.basedir..\"/\"..v,fname)\r\n"
"			end\r\n"
"		end\r\n"
"		\r\n"
"		local opts={basedir=bake.cd_root..\"/mods/\"..n..\"/lua\",dir=\"\",filter=\"\"}\r\n"
"		local r=bake.findfiles(opts)\r\n"
"		for i,v in ipairs(r.ret) do\r\n"
"			local fname=bake.cd_out..\"/lua/\"..n..\"/\"..v\r\n"
"			bake.create_dir_for_file(fname)\r\n"
"			bake.copyfile(opts.basedir..\"/\"..v,fname)\r\n"
"		end\r\n"
"	end\r\n"
"\r\n"
"	local opts={basedir=bake.cd_base,dir=\"public\",filter=\"\"}\r\n"
"	local r=bake.findfiles(opts)\r\n"
"	for i,v in ipairs(r.ret) do\r\n"
"		local fname=bake.cd_out..\"/\"..v\r\n"
"		bake.create_dir_for_file(fname)\r\n"
"		bake.copyfile(opts.basedir..\"/\"..v,fname)\r\n"
"	end\r\n"
"\r\n"
"tab.ngx_listen	=tab.ngx_listen or \"127.0.0.1:8888\"\r\n"
"tab.ngx_user	=tab.ngx_user	or \"kriss\"\r\n"
"tab.ngx_debug	=tab.ngx_debug	or \"debug\"\r\n"
"\r\n"
"\r\n"
"	local ngx_config=bake.readfile(bake.cd_base..\"/nginx.conf\")\r\n"
"	ngx_config=wstr.replace(ngx_config,tab)\r\n"
"\r\n"
"	local fname=bake.cd_out..\"/conf/nginx.conf\"\r\n"
"	bake.writefile(fname,ngx_config)\r\n"
"\r\n"
"	if (tab.arg[1] or \"\")==\"serv\" then\r\n"
"	\r\n"
"		print(\"Starting anlua on nginx\\n"
"\\n"
"\")\r\n"
"		\r\n"
"		bake.execute(bake.cd_out,\"../../../../bin/dbg/nginx\",\"-p. -sstop\")\r\n"
"		bake.execute(bake.cd_out,\"../../../../bin/dbg/nginx\",\"-p.\")\r\n"
"--		bake.execute(bake.cd_out,\"tail\",\"-n0 -f logs/error.log\")\r\n"
"		\r\n"
"		local fp=io.popen(\"tail -n0 -f logs/error.log\",\"r\") -- should probably just open the file myself...\r\n"
"		local finished\r\n"
"		while true do\r\n"
"			local l=fp:read(\"*l\")\r\n"
"			if l then\r\n"
"				local s=l\r\n"
"				s=s:gsub(\", client: .*$\",\" .\")\r\n"
"				s=s:gsub(\"^.*: %*%d* \",\". \")\r\n"
"				print(s)\r\n"
"			else break end\r\n"
"		end\r\n"
"	end\r\n"
"	\r\n"
"end\r\n"
"",

"wetgenes.www.gae.mail","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"\n"
"local core=require(\"wetgenes.www.gae.mail.core\")\n"
"\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.mail\"]=_M\n"
"\n"
"\n"
"function send(...)\n"
"--	return core.send(...)\n"
"end\n"
"",

"wetgenes.www.any.opts","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local dat=require(\"wetgenes.www.any.data\")\n"
"local cache=require(\"wetgenes.www.any.cache\")\n"
"\n"
"\n"
"-- a place to keep options such as passwords that\n"
"-- the server needs to know about but are different per app\n"
"-- and obviously should not be included in code\n"
"\n"
"-- data is kept in the datastore and also cached in the memcache (todo)\n"
"\n"
"module(\"wetgenes.www.any.opts\")\n"
"local _M=require(...)\n"
"\n"
"default_props=\n"
"{\n"
"}\n"
"\n"
"default_cache=\n"
"{\n"
"}\n"
"\n"
"function kind()\n"
"	return \"opts\"\n"
"end\n"
"\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- check that entity has initial data and set any missing defaults\n"
"-- the second return value is false if this is not a valid entity\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function check(srv,ent)\n"
"\n"
"	local c=ent.cache\n"
"		\n"
"	return ent\n"
"end\n"
"\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- read a string\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function get_dat(id)\n"
"	local e=get(nil,id,t)\n"
"	if e then return e.cache.dat end\n"
"	return nil\n"
"end\n"
"--------------------------------------------------------------------------------\n"
"--\n"
"-- write a string\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"function put_dat(id,dat)\n"
"	local e=create(nil)\n"
"	e.key.id=id\n"
"	e.cache.dat=dat\n"
"	local r=put(nil,e)\n"
"	\n"
"	return r\n"
"end\n"
"\n"
"\n"
"\n"
"dat.set_defs(_M) -- create basic data handling funcs\n"
"\n"
"dat.setup_db(_M) -- make sure DB exists and is ready\n"
"",

"apps","\n"
"-- create a global function that can be called to fix lua paths so we can find things\n"
"-- unfortunatly you still have to know where this file is first and run a \n"
"-- dofile(\"thisfile\") need to come up with a better plan, possibly preload a module?\n"
"--\n"
"-- yup this module is assumed to be preloaded, afterwhich all other modules can be found\n"
"-- and loaded.\n"
"\n"
"local package=package\n"
"local require=require\n"
"local string=string\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local print=print\n"
"local os=os\n"
"local io=io\n"
"local pcall=pcall\n"
"\n"
"module(\"apps\")\n"
"\n"
"--\n"
"-- get/set current dir\n"
"--\n"
"local get_cd=function()\n"
"	local lfs=require(\"lfs\")\n"
"\n"
"	return string.gsub(lfs.currentdir(),'\\\\','/')\n"
"\n"
"end\n"
"local set_cd=function(str)\n"
"	local lfs=require(\"lfs\")\n"
"\n"
"	lfs.chdir(str)\n"
"\n"
"end\n"
"local file_exists=function(str)\n"
"	local fp=io.open(str,\"r\")\n"
"	if fp then fp:close() return true end\n"
"	return false\n"
"end\n"
"\n"
"	\n"
"function setpaths(dll,dirs)\n"
"\n"
"	if dll then\n"
"		local cpath={}\n"
"		for i,v in ipairs(dirs) do\n"
"			cpath[#cpath+1]=v .. \"?.\" .. dll\n"
"			cpath[#cpath+1]=v .. \"?/init.\" .. dll\n"
"		end\n"
"		cpath[#cpath+1]=package.cpath\n"
"		package.cpath=table.concat(cpath,\";\")\n"
"	end\n"
"	\n"
"	local path={}\n"
"	for i,v in ipairs(dirs) do\n"
"		path[#path+1]=v .. \"?.lua\"\n"
"		path[#path+1]=v .. \"?/init.lua\"\n"
"		path[#path+1]=v .. \"lua/?.lua\"\n"
"		path[#path+1]=v .. \"lua/?/init.lua\"\n"
"	end\n"
"	path[#path+1]=package.path\n"
"	package.path=table.concat(path,\";\")\n"
"\n"
"end\n"
"\n"
"--\n"
"-- find where our exe lives\n"
"--\n"
"function find_bin()\n"
"\n"
"	local dir=get_cd()\n"
"\n"
"	local tdirs={ -- look in these dirs\n"
"		dir,\n"
"		dir..\"/bin\",\n"
"		dir..\"/..\",\n"
"		dir..\"/../bin\",\n"
"		dir..\"/../lua\",\n"
"		dir..\"/../lua/bin\",\n"
"		dir..\"/../..\",\n"
"		dir..\"/../../bin\",\n"
"		dir..\"/../../..\",\n"
"		dir..\"/../../../bin\",\n"
"	}\n"
"	local bin_dir=dir..\"/\"\n"
"	for i=1,#tdirs do local v=tdirs[i]\n"
"		if file_exists(v..\"/lua/apps.lua\") then bin_dir=v..\"/\" break end -- found a bin dir?\n"
"	end\n"
"\n"
"	return bin_dir\n"
"end\n"
"\n"
"--\n"
"-- find our bin dir and set search for all lua files under there, makes debuging a bit easier\n"
"-- than using the builtin strings. Also lets us pick up any dlls in there.\n"
"--\n"
"function default_paths()\n"
"\n"
"-- we are looking for a dir/lua/name.lua and dir will be our base dir so look in various places\n"
"\n"
"	if not pcall( function() return require(\"lfs\") end ) then return end -- not possible without lfs\n"
"\n"
"	local osflavour=\"win\"\n"
"	local os_shell=os.getenv(\"SHELL\")\n"
"	if os_shell and string.sub(os_shell,1,5)== \"/bin/\" then -- if your shell is not here then we assume windows...\n"
"		osflavour=\"nix\"\n"
"	end\n"
"\n"
"	local dll=\"dll\"\n"
"	if osflavour==\"nix\" then dll=\"so\" end\n"
"\n"
"	local bin_dir=find_bin()\n"
"	\n"
"	setpaths(dll,{bin_dir,\"./\"})\n"
"	\n"
"	dir=get_cd() -- use cd as base dir\n"
"	\n"
"end\n"
"\n"
"--\n"
"-- this needs to get more searchy so it can find where the lua app is without any explicit values\n"
"--\n"
"function find(name)\n"
"\n"
"	local lfs=require(\"lfs\")\n"
"\n"
"\n"
"-- we are looking for a dir/lua/name.lua and dir will be our base dir so look in various places\n"
"\n"
"	local osflavour=\"win\"\n"
"	local os_shell=os.getenv(\"SHELL\")\n"
"	if os_shell and string.sub(os_shell,1,5)== \"/bin/\" then -- if your shell is not here then we assume windows...\n"
"		osflavour=\"nix\"\n"
"	end\n"
"\n"
"	local dll=\"dll\"\n"
"	if osflavour==\"nix\" then dll=\"so\" end\n"
"\n"
"	bin_dir=find_bin()\n"
"	\n"
"print(\"BIN PATH\",bin_dir,dll)\n"
"\n"
"\n"
"	local dir=get_cd()\n"
"	local tdirs={ -- look in these dirs\n"
"	\n"
"		dir,\n"
"		dir..\"/\"..name,\n"
"		dir..\"/apps/\"..name,\n"
"		dir..\"/lua/\"..name,\n"
"		dir..\"/lua/apps/\"..name,\n"
"		\n"
"		dir..\"/..\",\n"
"		dir..\"/../\"..name,\n"
"		dir..\"/../apps/\"..name,\n"
"		dir..\"/../lua/\"..name,\n"
"		dir..\"/../lua/apps/\"..name,\n"
"		\n"
"		dir..\"/../..\",\n"
"		dir..\"/../../\"..name,\n"
"		dir..\"/../../apps/\"..name,\n"
"		dir..\"/../../lua/\"..name,\n"
"		dir..\"/../../lua/apps/\"..name,\n"
"		\n"
"	}\n"
"	local app_dir=dir..\"/\"\n"
"	local app_name=name\n"
"	for i=1,#tdirs do local v=tdirs[i]\n"
"		if file_exists(v..\"/lua/\"..name..\".lua\") then app_dir=v..\"/\" break end -- found a base dir?\n"
"		if file_exists(v..\"/lua/app.lua\") then app_dir=v..\"/\" app_name=\"app\" break end -- found a base dir?\n"
"	end\n"
"\n"
"print(\"APP PATH\",app_dir,dll)\n"
"\n"
"	setpaths(dll,{app_dir,bin_dir})\n"
"\n"
"	return app_dir,app_name\n"
"end\n"
"\n"
"\n"
"-- only call this once\n"
"-- probably on the commandline\n"
"function start(_name,...)\n"
"\n"
"	path_orig=package.path\n"
"	cpath_orig=package.cpath\n"
"\n"
"	exe=\"exe\"\n"
"	name=_name\n"
"	dll=\"so\"\n"
"\n"
"	dir,appname=find(name)\n"
"\n"
"	path=package.path\n"
"	cpath=package.cpath\n"
"	\n"
"	args=(...)\n"
"	\n"
"	print(\"appname \",appname)\n"
"	print(\"apps.exe\",exe)\n"
"	print(\"apps.name\",name)\n"
"	print(\"apps.dll\",dll)\n"
"	print(\"apps.dir\",dir)\n"
"	print(\"apps.args\",args)\n"
"\n"
"	return require(appname).start(...)\n"
"end\n"
"",

"wetgenes.www.ngx.mail","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"local socket=require(\"socket\")\n"
"local http=require(\"socket.http\")\n"
"local smtp = require(\"socket.smtp\") \n"
"local mime = require(\"mime\") \n"
"local ltn12 = require(\"ltn12\") \n"
"\n"
"local ngx = require(\"ngx\") \n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.mail\"]=_M\n"
"\n"
"\n"
"\n"
"local function create()\n"
"\n"
"--log(\"CREATE\")\n"
"	local p={}\n"
"	local tcp=ngx.socket.tcp()\n"
"\n"
"	p.accept=function(_,...)\n"
"--log(\"accept\")\n"
"--log(...)\n"
"		return tcp:accept(...)\n"
"	end\n"
"\n"
"	p.bind=function(_,...)\n"
"--log(\"bind\")\n"
"--log(...)\n"
"		return tcp:bind(...)\n"
"	end\n"
"\n"
"	p.close=function(_,...)\n"
"--log(\"close\")\n"
"--log(...)\n"
"		return tcp:close(...)\n"
"	end\n"
"	\n"
"	p.connect=function(_,...)\n"
"--log(\"connect\")\n"
"--log(...)\n"
"		tcp:connect(...)\n"
"		return true\n"
"	end\n"
"\n"
"	p.getpeername=function(_,...)\n"
"--log(\"getpeername\")\n"
"--log(...)\n"
"		return tcp:getpeername(...)\n"
"	end\n"
"\n"
"	p.getsockname=function(_,...)\n"
"--log(\"getsockname\")\n"
"--log(...)\n"
"		return tcp:getsockname(...)\n"
"	end\n"
"\n"
"	p.getstats=function(_,...)\n"
"--log(\"getstats\")\n"
"--log(...)\n"
"		return tcp:getstats(...)\n"
"	end\n"
"\n"
"	p.listen=function(_,...)\n"
"--log(\"listen\")\n"
"--log(...)\n"
"		return tcp:listen(...)\n"
"	end\n"
"\n"
"	p.receive=function(_,...)\n"
"--log(\"receive\")\n"
"--log(...)\n"
"		local r=tcp:receive(...)\n"
"		return r\n"
"	end\n"
"\n"
"	p.send=function(_,...)\n"
"--log(\"send\")\n"
"--log(...)\n"
"		return tcp:send(...)\n"
"	end\n"
"\n"
"	p.setoption=function(_,...)\n"
"--log(\"setoption\")\n"
"--log(...)\n"
"		return tcp:setoption(...)\n"
"	end\n"
"\n"
"	p.setstats=function(_,...)\n"
"--log(\"setstats\")\n"
"--log(...)\n"
"		return tcp:setstats(...)\n"
"	end\n"
"\n"
"	p.settimeout=function(_,n)\n"
"--log(\"settimeout\")\n"
"--log(n)\n"
"		tcp:settimeout(n*1000)\n"
"		return true\n"
"	end\n"
"\n"
"	p.shutdown=function(_,...)\n"
"--log(\"shutdown\")\n"
"--log(...)\n"
"		return tcp:shutdown(...)\n"
"	end\n"
"\n"
"--log(wstr.dump(p))\n"
"\n"
"	return p\n"
"end\n"
"\n"
"\n"
"function send(tab)\n"
"	log(\"mail.send:\")\n"
"--	return core.send(...)\n"
"\n"
"\n"
"\n"
"	local source = smtp.message{ \n"
"      headers = { \n"
"         from = \"<\"..tab.from..\">\", \n"
"         to = \"<\"..tab.to..\">\", \n"
"         subject = tab.subject,\n"
"      }, \n"
"      body = { \n"
"        preamble = \"preamble\", \n"
"        [1] = { body = mime.eol(0, tab.body) }, \n"
"      } \n"
"    } \n"
"\n"
"    r, e = smtp.send{ \n"
"        from = \"<\"..tab.from..\">\", \n"
"        rcpt = \"<\"..tab.to..\">\", \n"
"        source = source, \n"
"        server = \"127.0.0.1\", \n"
"        port = 25, \n"
"        create=create,\n"
"    } \n"
"\n"
"    if not r then \n"
"        log(\"failed to send: \", e) \n"
"    end \n"
"    \n"
"    log(wstr.dump(r))\n"
"\n"
"    log(\"done!\") \n"
"    \n"
"end\n"
"",

"wetgenes.www.any.fetch","if ngx then\r	return require(\"wetgenes.www.ngx.fetch\")\relse\r	return require(\"wetgenes.www.gae.fetch\")\rend\r",

"wetgenes.gamecake.spew.preloader","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local pack=require(\"wetgenes.pack\")\n"
"local wwin=require(\"wetgenes.win\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"local wzips=require(\"wetgenes.zips\")\n"
"local tardis=require(\"wetgenes.tardis\")	-- matrix/vector math\n"
"\n"
"local snames=require(\"wetgenes.gamecake.spew.names\")\n"
"\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"local t_randumbs={\n"
"	\"Holding the {adjective} {thing}.\",\n"
"	\"Giant {adjective} {thing} aproaching.\",\n"
"	\"This is not my {adjective} {thing}.\",\n"
"	\"Beware of {adjective} {thing}.\",\n"
"	\"Lost {adjective} {thing}.\",\n"
"	\"Found {adjective} {thing}.\",\n"
"	\"Searching for {adjective} {thing}.\",\n"
"	\"Testing {adjective} {thing}.\",\n"
"	\"Checking {adjective} {thing}.\",\n"
"	\"Dropped {adjective} {thing}.\",\n"
"	\"Disabled {adjective} {thing}.\",\n"
"	\"Enabled {adjective} {thing}.\",\n"
"	\"Buying {adjective} {thing}.\",\n"
"	\"Selling {adjective} {thing}.\",\n"
"}\n"
"\n"
"local ts={\"Bios OK.\",\"Looking for boot.\",\"Other shoe found.\",\"Bable mode initiated!\"}\n"
"\n"
"\n"
"\n"
"M.bake=function(oven,main)\n"
"	local main=main or {}\n"
"		\n"
"	local gl=oven.gl\n"
"	local cake=oven.cake\n"
"	local opts=oven.opts\n"
"	local canvas=cake.canvas\n"
"	local font=canvas.font\n"
"	local flat=canvas.flat\n"
"	local sheets=oven.cake.sheets\n"
"	local layout=cake.layouts.create{}\n"
"	\n"
"	\n"
"\n"
"	\n"
"main.config=function(opts)\n"
"	opts=opts or {}\n"
"	\n"
"	main.screen_hx=opts.screen_hx or 256\n"
"	main.screen_hy=opts.screen_hy or 256\n"
"	main.screen_argb=opts.screen_argb or  0xff000011\n"
"\n"
"-- the origin is in the center and you can guarantee that the above screen size is visible, there may be much more border\n"
"	main.text_dx=opts.text_dx or -128\n"
"	main.text_dy=opts.text_dy or -128\n"
"	main.text_hx=opts.text_hx or  256\n"
"	main.text_hy=opts.text_hy or  256\n"
"	main.text_argb=opts.text_argb or  0xff1188ff\n"
"	main.text_rz=opts.text_rz or  0\n"
"	\n"
"	main.img=opts.img or nil -- a background image name, will also be loaded before we load anything else\n"
"	main.img_hx=opts.img_hx or nil -- size of image to draw, relative to screen_hx/hy size\n"
"	main.img_hy=opts.img_hy or nil -- always positioned in the center of the screen\n"
"\n"
"--[[\n"
"main.img=\"imgs/title\"\n"
"main.img_hx=512\n"
"main.img_hy=256\n"
"]]\n"
"\n"
"	if main.img then\n"
"		oven.cake.images.preload={ [main.img]=main.img } -- high priority load first\n"
"		sheets.loads_and_chops{\n"
"			{main.img,1,1,0.5,0.5},\n"
"		}\n"
"	else\n"
"		oven.cake.images.preload=nil\n"
"	end\n"
"\n"
"end\n"
"\n"
"main.config() -- call this if you want to chage the settings\n"
"\n"
"main.config_as=function(name)\n"
"\n"
"	if name==\"kittychair\" then\n"
"		if oven.cake.images.exists(\"imgs/preloader/kittychair\") then\n"
"			main.config{\n"
"				screen_hx=256,\n"
"				screen_hy=512,\n"
"				screen_argb=0x00000000,\n"
"				text_dx=(630/2)-512,\n"
"				text_dy=(460/2)-256,\n"
"				text_hx=(930-630)/2,\n"
"				text_hy=(640-460)/2,\n"
"				text_argb=0xff008800,\n"
"				text_rz=0,\n"
"				img=\"imgs/preloader/kittychair\",\n"
"				img_hx=1024,\n"
"				img_hy=512,\n"
"			}\n"
"		end\n"
"	elseif name==\"kittyscreen\" then\n"
"		if oven.cake.images.exists(\"imgs/preloader/kittyscreen\") then\n"
"			main.config{\n"
"				screen_hx=256,\n"
"				screen_hy=512,\n"
"				screen_argb=0x00000000,\n"
"				text_dx=(850/2)-512,\n"
"				text_dy=(380/2)-256,\n"
"				text_hx=(1250-860)/2,\n"
"				text_hy=(570-380)/2,\n"
"				text_argb=0xff008800,\n"
"				text_rz=-3,\n"
"				img=\"imgs/preloader/kittyscreen\",\n"
"				img_hx=1024,\n"
"				img_hy=512,\n"
"			}\n"
"		end\n"
"	else\n"
"		main.config()\n"
"	end\n"
"\n"
"end\n"
"\n"
"	\n"
"main.loads=function()\n"
"	oven.cake.fonts.loads({1}) -- load 1st builtin font, a basic 8x8 font\n"
"	if main.img then\n"
"	sheets.loads_and_chops{\n"
"		{main.img,1,1,0.5,0.5},\n"
"	}\n"
"	end\n"
"end\n"
"\n"
"main.setup=function()\n"
"\n"
"	if main.setup_done then return end -- warning, this is called repeatedly...\n"
"\n"
"	main.title=\"\"\n"
"	main.count=0\n"
"\n"
"	main.setup_done=true\n"
"	main.loads()\n"
"end\n"
"\n"
"main.reset=function()\n"
"	main.title=\"\"\n"
"	main.count=0\n"
"end\n"
"\n"
"main.clean=function()\n"
"	main.setup_done=false\n"
"end\n"
"\n"
"main.msg=function(m)\n"
"end\n"
"\n"
"main.update=function(title)\n"
"\n"
"	main.title=title or \"\"\n"
"	\n"
"	local s=t_randumbs[math.random(1,#t_randumbs)]\n"
"	local t={}\n"
"	t.thing    =snames.random_noun()\n"
"	t.adjective=snames.random_adjective()\n"
"	\n"
"	s=wstr.replace(s,t)\n"
"	for i,v in ipairs( wstr.smart_wrap(s,30) ) do\n"
"		ts[#ts+1]=v\n"
"	end\n"
"--	ts[#ts+1]=\"\"\n"
"	\n"
"	\n"
"	while #ts>(32-3) do\n"
"		table.remove(ts,1)\n"
"	end\n"
"\n"
"	main.count=main.count+1\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"-- this is the only function we expect to be called\n"
"-- and we expect it to be called very sporadically\n"
"main.draw=function()\n"
"\n"
"	layout.viewport() -- did our window change?\n"
"	layout.project23d(main.screen_hx,main.screen_hy,1/4,main.screen_hy*4)\n"
"	canvas.gl_default() -- reset gl state\n"
"\n"
"	gl.ClearColor(gl.C8(main.screen_argb))\n"
"	gl.Clear(gl.COLOR_BUFFER_BIT)--+gl.DEPTH_BUFFER_BIT)\n"
"\n"
"	gl.MatrixMode(gl.PROJECTION)\n"
"	gl.LoadMatrix( layout.pmtx )\n"
"\n"
"	gl.MatrixMode(gl.MODELVIEW)\n"
"	gl.LoadIdentity()\n"
"	gl.Translate(0,0,-main.screen_hy*2) -- z depth fixed\n"
"\n"
"\n"
"	if main.img then\n"
"		local s=sheets.get(main.img)\n"
"		sheets.start() -- safe to call multiple times\n"
"		if s and s.img then\n"
"			s:draw(1,0,0,nil,main.img_hx,main.img_hy)\n"
"		end\n"
"	end\n"
"\n"
"	gl.Translate(main.text_dx,main.text_dy,0) -- now top left corner is origin\n"
"	gl.Rotate(main.text_rz,0,0,1)\n"
"\n"
"	gl.Scale( main.text_hx / 256 , main.text_hy / 256 , 1 )\n"
"\n"
"	gl.PushMatrix()\n"
"	\n"
"	font.set(cake.fonts.get(1)) -- default font\n"
"	font.set_size(8,0) -- 32 pixels high\n"
"\n"
"	gl.Color(pack.argb8_pmf4(main.text_argb))\n"
"\n"
"	font.set_xy( 8 , 8 )\n"
"	font.draw(\"MemCheck: \"..main.count..\" \"..main.title:sub(1,30-13))\n"
"--print(\"MemCheck: \"..main.count..\" : \"..tostring(oven.preloader_enabled))\n"
"\n"
"	for i=1,#ts do\n"
"		font.set_xy( 8, 16+i*8 )\n"
"		font.draw(ts[i])\n"
"	end\n"
"\n"
"	gl.PopMatrix()	\n"
"\n"
"end\n"
"		\n"
"	return main\n"
"end\n"
"\n"
"",

"wetgenes.gamecake.widgets.scroll","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"\r\n"
"-- a scrolling area, the widget is biger than display area but scroll bars allow you to see it all\r\n"
"\r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,wscroll)\r\n"
"wscroll=wscroll or {}\r\n"
"\r\n"
"local widget_data=oven.rebake(\"wetgenes.gamecake.widgets.data\")\r\n"
"\r\n"
"function wscroll.mouse(widget,act,x,y,key)\r\n"
"--	widget.master.focus=widget\r\n"
"	return widget.meta.mouse(widget,act,x,y,key)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wscroll.key(widget,ascii,key,act)\r\n"
"	return widget.meta.key(widget,ascii,key,act)\r\n"
"end\r\n"
"\r\n"
"\r\n"
"function wscroll.update(widget)\r\n"
"\r\n"
"	local pan=widget.pan\r\n"
"	\r\n"
"	local pan_px=-widget.datx.num\r\n"
"	local pan_py=widget.daty.num\r\n"
"	\r\n"
"	if pan_px~=pan.pan_px or pan_py~=pan.pan_py then\r\n"
"	\r\n"
"--print(\"update\",pan_px,pan_py)\r\n"
"\r\n"
"		pan.pan_px=pan_px\r\n"
"		pan.pan_py=pan_py\r\n"
"		\r\n"
"		pan:set_dirty()\r\n"
"	end\r\n"
"\r\n"
"	return widget.meta.update(widget)\r\n"
"end\r\n"
"\r\n"
"function wscroll.draw(widget)\r\n"
"\r\n"
"--	local it=widget.scroll\r\n"
"	\r\n"
"	return widget.meta.draw(widget)\r\n"
"end\r\n"
"\r\n"
"function wscroll.layout(widget)\r\n"
"\r\n"
"--	local it=widget.scroll\r\n"
"	\r\n"
"	widget.meta.layout(widget.pan) -- creates hx_max,hy_max\r\n"
"\r\n"
"	widget.datx.max=widget.pan.hx_max-widget.pan.hx\r\n"
"	if widget.datx.max<0 then widget.datx.max=0 end\r\n"
"	widget.datx.size=widget.pan.hx/widget.pan.hx_max\r\n"
"	\r\n"
"	widget.daty.max=widget.pan.hy_max-widget.pan.hy\r\n"
"	if widget.daty.max<0 then widget.daty.max=0 end\r\n"
"	widget.daty.size=widget.pan.hy/widget.pan.hy_max\r\n"
"	\r\n"
"	widget.meta.layout(widget)\r\n"
"end\r\n"
"\r\n"
"function wscroll.setup(widget,def)\r\n"
"--	local it={}\r\n"
"--	widget.scroll=it\r\n"
"	widget.class=\"scroll\"\r\n"
"	\r\n"
"	widget.key=wscroll.key\r\n"
"	widget.mouse=wscroll.mouse\r\n"
"	widget.update=wscroll.update\r\n"
"	widget.layout=wscroll.layout\r\n"
"	widget.draw=wscroll.draw\r\n"
"\r\n"
"-- auto add the draging button as a child\r\n"
"	local ss=16\r\n"
"	if widget.hx<ss*2 then ss=widget.hx/2 end\r\n"
"	if widget.hy<ss*2 then ss=widget.hy/2 end\r\n"
"	\r\n"
"	widget.datx=widget_data.new_data{max=1}\r\n"
"	widget.daty=widget_data.new_data{max=1}\r\n"
"	widget.solid=true\r\n"
"\r\n"
"	widget.pan=		widget:add({class=\"pan\",	hx=widget.hx-ss,	hy=widget.hy-ss	,fbo=true})\r\n"
"	widget.slidey=	widget:add({class=\"slide\",	hx=ss,				hy=widget.hy-ss,	px=widget.hx-ss,	py=0,\r\n"
"		daty=widget.daty,color=0xffffffff})\r\n"
"	widget.slidex=	widget:add({class=\"slide\",	hx=widget.hx-ss,	hy=ss,           	px=0,           	py=widget.hy-ss,\r\n"
"		datx=widget.datx,color=0xffffffff})\r\n"
"\r\n"
"	return widget\r\n"
"end\r\n"
"\r\n"
"return wscroll\r\n"
"end\r\n"
"",

"wetgenes.www.gae.data","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local json=require(\"wetgenes.json\")\n"
"\n"
"local core=require(\"wetgenes.www.gae.data.core\")\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"local wstr=require(\"wetgenes.string\")\n"
"\n"
"module(...)\n"
"local wdata=require(...) -- this is us\n"
"package.loaded[\"wetgenes.www.any.data\"]=wdata\n"
"local cache=require(\"wetgenes.www.any.cache\")\n"
"local wdatadef=require(\"wetgenes.www.any.datadef\")\n"
"\n"
"\n"
"function countzero()\n"
"	count=0\n"
"	api_time=0\n"
"end\n"
"countzero()\n"
"\n"
"local kind_props={}	-- default global props mapped to kinds\n"
"\n"
"local start_time -- handle simple api benchmarking of some calls\n"
"local function apis()\n"
"	start_time=os.time()\n"
"end\n"
"local function apie(...)\n"
"	api_time=api_time+os.time()-start_time\n"
"	return ...\n"
"end\n"
"\n"
"\n"
"\n"
"function keyinfo(keystr)\n"
"	\n"
"	return core.keyinfo(keystr)\n"
"end\n"
"\n"
"function keystr(kind,id,parent)\n"
"\n"
"	return core.keystr(kind,id,parent)\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"function del(ent)\n"
"	apis()\n"
"	\n"
"	count=count+0.5\n"
"	\n"
"	return apie(core.del(nil,ent))\n"
"end\n"
"\n"
"function put(ent)\n"
"	apis()\n"
"	count=count+0.5\n"
"	\n"
"	return apie(core.put(nil,ent))\n"
"end\n"
"\n"
"function get(ent)\n"
"	apis()\n"
"	count=count+0.5\n"
"	return apie(core.get(nil,ent))\n"
"end\n"
"\n"
"function query(q)\n"
"	apis()\n"
"	count=count+1\n"
"--log(tostring(q))	\n"
"\n"
"	return apie(core.query(nil,q))\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- Begin a transaction, use the functions inside the returned table\n"
"-- to perform actions within this transaction\n"
"--\n"
"-- the basic code flow is that you should begin one transaction per entity(parent)\n"
"-- and then rollback all when one fails. the first del/put/get locks the entity\n"
"-- we are dealing with in this transaction\n"
"--\n"
"-- after the t.fail flag gets set on a put/del then everything apart from rollback just returns nil\n"
"-- and commit is turned into an auto rollback\n"
"--\n"
"-- so this is OK transaction code, just remember that puts may not auto generate a key\n"
"-- and there may be other reasons for fails\n"
"--\n"
"-- for _=1,10 do -- try a few times\n"
"--     t=begin()\n"
"--     if t.get(e) then e.props.data=e.props.data..\"new data\" end\n"
"--     t.put(e)\n"
"--     if t.commit() then break end -- success\n"
"-- end\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function begin()\n"
"\n"
"	local t={}\n"
"	t.core=core.begin()\n"
"	\n"
"	t.fail=false -- this will be set to true when a transaction action fails and you should rollback and retry\n"
"	t.done=false -- set to true on commit or rollback to disable all methods\n"
"	\n"
" -- these methods are the same as the global ones but operate on this transaction\n"
" 	t.del=function(ent)	if t.fail or t.done then return nil end apis() return apie(core.del(t,ent)) end\n"
"	t.put=function(ent)	if t.fail or t.done then return nil end apis() return apie(core.put(t,ent)) end\n"
"	t.get=function(ent)	if t.fail or t.done then return nil end apis() return apie(core.get(t,ent)) end\n"
"	t.query=function(q)	if t.fail or t.done then return nil end apis() return apie(core.query(t,q)) end\n"
"	\n"
"	t.rollback=function() -- returns false to imply that nothing was commited\n"
"		if t.done then return false end -- safe to rollback repeatedly\n"
"		t.done=true\n"
"		apis()\n"
"		t.fail=not apie(core.rollback(t.core)) -- we always set fail and return false\n"
"		return not t.fail\n"
"	end	\n"
"	\n"
"	t.commit=function() -- returns true if commited, false if not\n"
"		if t.done then return false end -- safe to rollback repeatedly\n"
"		if t.fail then -- rollback rather than commit\n"
"			apis()\n"
"			return apie(t.rollback())\n"
"		end\n"
"		t.done=true\n"
"		apis()\n"
"		t.fail=not apie(core.commit(t.core))\n"
"		return not t.fail\n"
"	end\n"
"\n"
"	return t\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- build cache which is a mixture of decoded json vars (this may contain sub tables)\n"
"-- overiden by database props which do not contain tables but are mildly searchable\n"
"-- props.json should contain this json data string on input\n"
"-- cache will be a filled in table to be used instead of props\n"
"--\n"
"-- Not sure if this is more compact than just creating many real key/value pairs\n"
"-- but it feels like a better way to organize. :)\n"
"--\n"
"-- At least it is a bit more implicit about what can and cannot be searched for.\n"
"--\n"
"-- the idea is everything we need is copied into the cache, you can edit it there\n"
"-- and then build_props will do the reverse in preperation for a put\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function build_cache(e)\n"
"\n"
"	if e.props.json then -- expand the json data\n"
"	\n"
"		e.cache=json.decode(e.props.json)\n"
"		\n"
"	else\n"
"	\n"
"		e.cache={}\n"
"	\n"
"	end\n"
"\n"
"	for i,v in pairs(e.props) do -- override cache by props\n"
"		e.cache[i]=v\n"
"	end\n"
"	\n"
"	e.cache.json=nil -- not the json prop\n"
"	\n"
"	if e.key then -- copy the key data\n"
"		e.cache.parent=e.key.parent\n"
"		e.cache.kind=e.key.kind\n"
"		e.cache.id=e.key.id\n"
"	end\n"
"	\n"
"	return e\n"
"end\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- a simplistic reverse of build cache\n"
"-- any props of the same name will get updated from this cache\n"
"-- rather than encoded into props.json\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function build_props(e)\n"
"\n"
"	local t={}\n"
"	local ignore={kind=true,id=true,parent=true,json=true,} -- special names to ignore\n"
"	\n"
"	for i,v in pairs(e.cache) do\n"
"		if ignore[i] then -- ignore these special names\n"
"		elseif e.props[i] then\n"
"			e.props[i]=v -- if it exists as a prop then the prop is updated\n"
"		else\n"
"			t[i]=v -- else it just goes into the json prop\n"
"		end\n"
"	end\n"
"	e.props.json=json.encode(t)\n"
"	\n"
"	return e\n"
"end\n"
"\n"
"\n"
"\n"
"function set_defs(env)\n"
"	return wdatadef.set_defs(env)\n"
"end\n"
"\n"
"--no need for this, so just a stub\n"
"function setup_db(env,srv)\n"
"end\n"
"\n"
"\n"
"",

"wetgenes","local string=string\n"
"local table=table\n"
"local math=math\n"
"\n"
"local type=type\n"
"local pairs=pairs\n"
"local ipairs=ipairs\n"
"local tostring=tostring\n"
"local setmetatable=setmetatable\n"
"local unpack=unpack\n"
"local setfenv=setfenv\n"
"\n"
"--\n"
"-- Some generic and useful functions, pull them into locals like so:\n"
"--[[\n"
"\n"
"local export,lookup,set_env=require(\"wetgenes\"):export(\"export\",\"lookup\",\"set_env\")\n"
"\n"
"]]--\n"
"\n"
"--local _ENV=require(\"wetquire\").remodule(\"wetgenes\")\n"
"module(\"wetgenes\")\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- export given names from this table as multiple returns\n"
"-- can be used to pull function pointers out of a module\n"
"--\n"
"-- local lookup=require(\"wetgenes.util\"):export(\"lookup\")\n"
"--\n"
"-- shove it into your module to have a similar effect\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"function export(env,...)\n"
"	local tab={}\n"
"	for i,v in ipairs{...} do\n"
"		tab[i]=env[v]\n"
"	end\n"
"	return unpack(tab)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- safe lookup within a table that returns nil if any part of the lookup is nil\n"
"-- so we never cause an error, just returns nil\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function lookup(tab,...)\n"
"	for i,v in ipairs{...} do\n"
"		if type(tab)~=\"table\" then return nil end\n"
"		tab=tab[v]\n"
"	end\n"
"	return tab\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- since setfenv is going byebyes here is a plan to future proof code\n"
"--\n"
"-- we set the envirtonment of the code that called us only if setfenv exists\n"
"-- and we allways return the new environment\n"
"--\n"
"-- so the following can be used to change the current environment\n"
"-- and it should work in lua 5.1 or 5.2\n"
"--\n"
"-- local _ENV=set_env(new_environment)\n"
"--\n"
"-- the same is also done in the require overload provided by wetquire.lua\n"
"-- so once you wetquire and overload the environment then the following can be used\n"
"--\n"
"-- local _ENV=module(\"name\")\n"
"--\n"
"-- or using wetquire without overloading\n"
"--\n"
"-- local _ENV=require(\"wetquire\").remodule(\"name\")\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function set_env(env)\n"
"	if setfenv then setfenv(2,env) end\n"
"	return env\n"
"end\n"
"",

"wetgenes.spew.util","\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"local string=string\n"
"local math=math\n"
"local os=os\n"
"local print=print\n"
"local tonumber=tonumber\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"--\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"module(\"spew.util\")\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- split a string into a table\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"local function str_split(div,str,enable_special_chars)\n"
"\n"
"  if (div=='') or not div then error(\"div expected\", 2) end\n"
"  if (str=='') or not str then error(\"str expected\", 2) end\n"
"  \n"
"  local pos,arr = 0,{}\n"
"  \n"
"  -- for each divider found\n"
"  for st,sp in function() return string.find(str,div,pos,not enable_special_chars) end do\n"
"	table.insert(arr,string.sub(str,pos,st-1)) -- Attach chars left of current divider\n"
"	pos = sp + 1 -- Jump past current divider\n"
"  end\n"
"  \n"
"  if pos~=0 then\n"
"	table.insert(arr,string.sub(str,pos)) -- Attach chars right of last divider\n"
"  else\n"
"	table.insert(arr,str) -- return entire string\n"
"  end\n"
"  \n"
"  \n"
"  return arr\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace any %xx with the intended char, eg \"%20\" becomes a \" \"\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_decode(str)\n"
"    return string.gsub(str, \"%%(%x%x)\", function(hex)\n"
"        return string.char(tonumber(hex, 16))\n"
"    end)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- replace % , & and = chars with %xx codes\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function url_encode(str)\n"
"    return string.gsub(str, \"([&=%%])\", function(c)\n"
"        return string.format(\"%%%02x\", string.byte(c))\n"
"    end)\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- decode a string into a msg\n"
"-- if last is passed in then this table is adjusted rather than a new table being created\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function str_to_msg(str,last)\n"
"local msg=last or {}\n"
"local arr\n"
"local set\n"
"\n"
"	arr=str_split(\"&\",str)\n"
"	\n"
"	for i,v in ipairs(arr) do\n"
"	\n"
"		if v~=\"\" then\n"
"		\n"
"			set=str_split(\"=\",v)\n"
"			\n"
"			if set[1] and set[2] then\n"
"			\n"
"				msg[ set[1] ]=url_decode(set[2])\n"
"			end\n"
"			\n"
"		end\n"
"	end\n"
"\n"
"	return msg\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- encode a msg into a string\n"
"-- if last is available then only *changes* from msg to last are encoded, last is also updated with these changes\n"
"-- this gives a very simple delta compression\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function msg_to_str(msg,last)\n"
"local str\n"
"local line=\"&\"\n"
"\n"
"	for i,v in pairs(msg) do\n"
"	\n"
"		if (not last) or (last[i]~=v) then -- only store changes in string\n"
"		\n"
"			line=line.. i ..\"=\".. url_encode(v) ..\"&\"\n"
"			\n"
"			if last then last[i]=v end\n"
"			\n"
"		end\n"
"		\n"
"	end\n"
"	\n"
"	return line\n"
"end\n"
"\n"
"",

"wetgenes.waka","--\n"
"-- Copyright (C) 2012 Kriss Blank < Kriss@XIXs.com >\n"
"-- This file is distributed under the terms of the MIT license.\n"
"-- http://en.wikipedia.org/wiki/MIT_License\n"
"-- Please ping me if you use it for anything cool...\n"
"--\n"
"\n"
"--\n"
"-- a waka is made of chunks\n"
"-- chunks are made of text that contains links\n"
"-- a word that begins with / or http: is a link\n"
"-- there is no waka markup, if you want markup then use xhtml\n"
"--\n"
"\n"
"local table=table\n"
"local string=string\n"
"\n"
"\n"
"local ipairs=ipairs\n"
"local pairs=pairs\n"
"\n"
"local string=string\n"
"local type=type\n"
"local tostring=tostring\n"
"\n"
"local require=require\n"
"local loadstring=loadstring\n"
"local setfenv=setfenv\n"
"local setmetatable=setmetatable\n"
"local pcall=pcall\n"
"local error=error\n"
"\n"
"-- my string functions\n"
"local str=require(\"wetgenes.string\")\n"
"local sbox=require(\"wetgenes.sandbox\")\n"
"\n"
"\n"
"module(\"wetgenes.waka\")\n"
"\n"
"local split_lines		=str.split_lines\n"
"local split_words		=str.split_words\n"
"local split_whitespace	=str.split_whitespace\n"
"local split_equal		=str.split_equal\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- turn a string into a tag array\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function text_to_tags(text)\n"
"	local r={}\n"
"	\n"
"	if text then\n"
"		if string.find(text,\",\") then -- coma seperated\n"
"			local a=split_words(text,\",\")\n"
"			for i,v in ipairs(a) do\n"
"				local s=str.trim(v)\n"
"				if #s>0 then r[s]=true end\n"
"			end\n"
"		else -- white space seperated\n"
"			local a=split_words(text)\n"
"			for i,v in ipairs(a) do\n"
"				local s=str.trim(v)\n"
"				if #s>0 then r[s]=true end\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	return r\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- take some text and break it into named chunks\n"
"-- returns a lookup table of chunks and numerical list of these chunks in the order they where first defined\n"
"-- body is the default chunk name\n"
"--\n"
"-- a chunk is a line that begins with #\n"
"-- the part after the # and ending with whitespace is the chunk name\n"
"-- all text following this line is part of that chunk\n"
"-- the default section if none is give is \"body\", so any whitespace at the start of the file\n"
"-- before the first # line will be assigned to this chunk\n"
"-- data may follow this chunk name, if multiple chunks of the same name\n"
"-- are defined they are simple merged into one\n"
"-- and each #chunk line is combined into one chunk data\n"
"--\n"
"-- use option=value after the section name to provide options, so somthing like this\n"
"--\n"
"-- #name opt=val opt=val opt=val\n"
"-- # opt=val\n"
"-- here is some text\n"
"-- # opt=val\n"
"-- here is some more text\n"
"-- ## special comment, this line is ignored\n"
"-- ## comments are just a line that begins with two hashes\n"
"--\n"
"-- is a valid chunk, all of the opt=val will be assigned to the same chunk\n"
"-- and all the other text will be joined as that chunks body\n"
"--\n"
"-- pass in chunks and you can merge multiple texts into one chunk\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function text_to_chunks(text,chunks)\n"
"\n"
"local chunkend -- special end of chunk test\n"
"\n"
"	chunks=chunks or {}\n"
"\n"
"	local function manifest_chunk(line,oldchunk)\n"
"		local opts=split_words( line:sub(2) ) -- skip # at start of line\n"
"		local name=string.lower( opts[1] or \"body\" )\n"
"		local chunk\n"
"		local c2=line:sub(2,2)\n"
"				\n"
"		if c2:find(\"%s\") then -- if first char after # is whitespace, then use the old chunk \n"
"			chunk=oldchunk\n"
"		end\n"
"		\n"
"		if not chunk then\n"
"			chunk=chunks[name] -- do we already have this chunk?\n"
"		end\n"
"		\n"
"		if chunk then -- update an old chunk\n"
"		\n"
"			for i=1,#opts do local v=opts[i]\n"
"				table.insert( chunk.opts , v ) -- add extra opts\n"
"				local a,b=split_equal(v)\n"
"				if a then chunk.opts[a]=b end\n"
"			end\n"
"			\n"
"		else -- create a new chunk\n"
"		\n"
"			chunk={} -- make default chunk\n"
"\n"
"-- set some default options depending on the chunk name\n"
"\n"
"			if name:sub(1,4)==\"body\" then -- all chunks begining with \"body\" are waka format by default\n"
"				opts.form=\"waka\"\n"
"			end\n"
"\n"
"			if name:sub(1,5)==\"title\" then -- all chunks begining with \"title\" are trimed by default\n"
"				opts.trim=\"ends\"\n"
"			end\n"
"\n"
"			if name:sub(1,3)==\"css\" then -- all chunks begining with \"css\" append children by default\n"
"				opts.append=\"on\"\n"
"			end\n"
"		\n"
"			if name:sub(1,3)==\"lua\" then -- all chunks begining with \"lua\" are lua code by default\n"
"				opts.form=\"lua\"\n"
"			end\n"
"			\n"
"-- the actual options will overide the defaults\n"
"\n"
"			for i=1,#opts do local v=opts[i]\n"
"				local a,b=split_equal(v)\n"
"				if a then opts[a]=b end\n"
"			end\n"
"			\n"
"			chunk.id=#chunks+1\n"
"			chunk.name=name\n"
"			chunk.opts=opts\n"
"			chunk.lines={}\n"
"			\n"
"			chunks[chunk.id]=chunk		-- save chunk in chunks as numbered id\n"
"			chunks[chunk.name]=chunk	-- and as name\n"
"		end\n"
"		\n"
"		return chunk\n"
"	end\n"
"		\n"
"	local lines=split_lines(text)\n"
"	\n"
"	local chunk\n"
"	\n"
"	for i=1,#lines do local v=lines[i] -- ipairs\n"
"		\n"
"		local c=v:sub(1,1) -- the first char is special\n"
"		\n"
"		if c==\"#\" then -- start of chunk\n"
"		\n"
"			if chunkend then -- waiting for special end everything is inserted\n"
"			\n"
"				if chunkend==v:sub(1,#chunkend) then -- got it\n"
"					chunkend=nil\n"
"				else\n"
"					if not chunk then chunk=manifest_chunk(\"#body\") end --sanity				\n"
"					table.insert(chunk.lines , v)\n"
"				end\n"
"				\n"
"			else\n"
"\n"
"				if \"#[[\"==v:sub(1,3) then -- special open\n"
"				\n"
"					chunkend=\"#]]\"..v:sub(4) -- any special hash we need to close\n"
"				\n"
"				elseif v:sub(2,2)~=\"#\" then -- skip all comments\n"
"\n"
"					chunk=manifest_chunk(v,chunk)\n"
"\n"
"				end\n"
"				\n"
"			end\n"
"			\n"
"		else -- normal lime add to the current chunk\n"
"		\n"
"			if not chunk then chunk=manifest_chunk(\"#body\") end --sanity\n"
"			\n"
"			table.insert(chunk.lines , v)\n"
"		end\n"
"	\n"
"	end\n"
"	\n"
"	for i=1,#chunks do local v=chunks[i] -- perform some final actions on all chunks\n"
"	\n"
"		v.text=table.concat(v.lines) -- merge the split lines back together into one string\n"
"		\n"
"	end\n"
"	\n"
"	return chunks\n"
"	\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- merge source data into dest data, dest data may be nil in which case this \n"
"-- works like a copy. Return the dest chunk. It is intended that you have a\n"
"-- a number of chunks and then merge them together into a final data chunk\n"
"-- using this function, the first merge creates a new dest chunk. the final result\n"
"-- will have a new ordering depending on the merged chunks but the numerical array\n"
"-- can still be used to loop through chunks\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function chunks_merge(dest,source)\n"
"\n"
"	local dest=dest or {}\n"
"	\n"
"	local locked=dest.opts and dest.opts.opts.lock==\"on\" -- parent chunk locked\n"
"			\n"
"	for i,v in ipairs(source) do\n"
"	\n"
"		local c=dest[v.name] -- merge or\n"
"		\n"
"		local function set_data()\n"
"			if c.opts.append==\"on\" then -- add new lines to the end of the chunk rather than replace\n"
"				c.text=(c.text or \"\") .. ( v.text or \"\" )\n"
"				c.lines=split_lines(c.text) -- also need to build lines?\n"
"			else -- just replace\n"
"				c.lines=v.lines -- set or override\n"
"				c.text=v.text -- set or override\n"
"			end\n"
"			for ii,vv in pairs(v.opts) do\n"
"				c.opts[ii]=vv\n"
"			end\n"
"		end\n"
"		\n"
"		if not c then -- make a new chunk\n"
"			c={}\n"
"			c.id=#dest+1\n"
"			c.name=v.name\n"
"			c.opts={}\n"
"			dest[c.id]=c -- link it into dest by array\n"
"			dest[c.name]=c -- and by name\n"
"			\n"
"			set_data()\n"
"		else\n"
"			if not locked then -- skip lock\n"
"				set_data()\n"
"			end\n"
"		end\n"
"\n"
"	end\n"
"\n"
"	return dest\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get a html given some simple waka text\n"
"--\n"
"-- \\n"
" are turned into <br/> tags\n"
"-- and words that look like links are turned into links\n"
"-- any included html should get escaped so this is \"safe\" to use on user input\n"
"--\n"
"-- aditional opts\n"
"--\n"
"-- we need to know the base_url of this page when building links, if this is not given\n"
"-- then relative links may bork?\n"
"--\n"
"-- setting escape_html to true prevents any html from getting through\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function waka_to_html(input,opts)\n"
"	opts=opts or {}\n"
"\n"
"local base_url=opts.base_url or \"\"\n"
"local escape_html=opts.escape_html or false\n"
"\n"
"	local r={}\n"
"	local esc\n"
"	if escape_html then -- simple html escape\n"
"		esc=function(s) \n"
"			local escaped = { ['<']='&lt;', ['>']='&gt;', [\"&\"]='&amp;' , [\"\\n"
"\"]='<br/>\\n"
"' }\n"
"			return (s:gsub(\"[<>&\\n"
"]\", function(c) return escaped[c] or c end))\n"
"		end\n"
"	else -- no escape just convert \\n"
" to <br/>\n"
"		esc=function(s) \n"
"			local escaped = { [\"\\n"
"\"]='<br/>\\n"
"' }\n"
"			return (s:gsub(\"[\\n"
"]\", function(c) return escaped[c] or c end))\n"
"		end\n"
"	end\n"
"	\n"
"	local function link( url , str )\n"
"		table.insert(r,\"<a href=\\\"\"..url..\"\\\">\"..esc(str)..\"</a>\")\n"
"	end\n"
"	local function text( str )\n"
"		table.insert(r,esc(str))\n"
"	end\n"
"\n"
"	local tokens=split_whitespace(input)\n"
"	\n"
"	for i2=1,#tokens do local token=tokens[i2]\n"
"	\n"
"		local done=false\n"
"		\n"
"		local len=token:len()\n"
"		\n"
"		if len>=2 then -- too short to be a link\n"
"		\n"
"			local c1=token:sub(1,1) -- some chars to check\n"
"			\n"
"			if c1 == \"/\" then -- a very simple link relative to where we are\n"
"			\n"
"				local chars=\"[%w/%-%+_#%.:]+\"\n"
"				\n"
"--				if token:sub(1,3)==\"///\" then chars=\"[%w/%-%+_#%.:]+\" end -- allow common domain chars\n"
"			\n"
"				local s=token:sub(2) -- skip this first char\n"
"				\n"
"				local f1,f2=s:find(chars)\n"
"				if f1 then -- must find a word\n"
"					local s1=s:sub(f1,f2)\n"
"					if s1:sub(-1)==\".\" then -- trim trailing dot\n"
"						f2=f2-1\n"
"						s1=s:sub(f1,f2)\n"
"					end\n"
"					local ss=split_words(s1,\"/\")\n"
"					local tail=ss[#ss] \n"
"					link(s1,tail or s1)\n"
"					if f2<s:len() then -- some left over string\n"
"						text(s:sub(f2+1))\n"
"					end\n"
"					done=true\n"
"				end\n"
"				\n"
"			elseif token:sub(1,7)==\"http://\" then\n"
"					link(token,token)\n"
"					done=true\n"
"\n"
"			elseif token:sub(1,8)==\"https://\" then\n"
"					link(token,token)\n"
"					done=true\n"
"			end\n"
"			\n"
"		end\n"
"		\n"
"		\n"
"		if not done then -- unhandled token, just add it\n"
"			text(token)				\n"
"		end\n"
"	\n"
"	end\n"
"	\n"
"	return table.concat(r)\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- turn some chunks into their prefered form, escape, trim and expand\n"
"--\n"
"-- i need a naming convention that make sense so this is now calledm\n"
"-- refine_chunks with coarse meaning unrefined\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function form_chunks(srv,chunks,opts) return refine_chunks(srv,chunks,opts) end\n"
"function refine_chunks(srv,chunks,opts)\n"
"\n"
"	opts=opts or {}\n"
"\n"
"	local refined={}\n"
"	\n"
"	for i,v in pairs(opts) do -- copy opts into refined\n"
"		refined[i]=v\n"
"	end\n"
"\n"
"-- start by compiling the lua chunks and running its pageopts hook\n"
"	for i,v in ipairs(chunks) do\n"
"	\n"
"		if v.opts.form==\"lua\" then -- we have some lua code for this page\n"
"			local a,b=pcall( function() return sbox.ini(v.text) end )\n"
"			if a then v.env=b end -- success\n"
"			if not a then v.text=b end -- fail, set text to error text\n"
"--[[\n"
"			local e=sbox.make_env()\n"
"			v.env=e -- store it for later\n"
"			e.text=v.text -- let code know its sourcecode\n"
"			local f,err=loadstring(v.text)\n"
"			e.text=err or v.text -- replace with error for simple parse display\n"
"			if f then\n"
"				setfenv(f, e)\n"
"				pcall(f)\n"
"			end\n"
"]]			\n"
"			if v.env and v.env.hook_pageopts then\n"
"				local a,b = pcall(function() v.env.hook_pageopts(srv.pageopts) end) -- update pageopts?\n"
"			end\n"
"\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"	\n"
"	for i,v in ipairs(chunks) do -- do basic process of all of the page chunks into their prefered form \n"
"		local s=v.env or v.text\n"
"		\n"
"		local format=v.opts.form\n"
"		local trim=v.opts.trim\n"
"		\n"
"		if trim==\"ends\" then s=str.trim(s) end -- trim whitespace, useful for one word chunks?\n"
"\n"
"		if format==\"nohtml\" then -- like normal but all html is escaped\n"
"\n"
"			s=waka_to_html(s,{base_url=opts.baseurl,escape_html=true}) \n"
"\n"
"		elseif format==\"import\" then -- very special import, treat as chunk of lua import opts/code\n"
"		\n"
"			local e=sbox.make_env()\n"
"			local f,err=loadstring(s)\n"
"			if f then\n"
"				setfenv(f, e)\n"
"				local a,b=pcall(f)\n"
"				if not a then s=b e={} end -- error running chunk, set chunk to error string and clear chunk data\n"
"			else\n"
"				s=err\n"
"			end\n"
"\n"
"-- this should be split off into a plugin system...\n"
"			\n"
"			if e.import==\"dimeload\" then -- include some dimeload info\n"
"			\n"
"				e.hook   = e.hook   or opts.hook\n"
"				\n"
"				if not opts.nodimeload then -- prevent recursions\n"
"					local dl=require(\"dimeload\")\n"
"					s=dl.chunk_import(srv,e)\n"
"				end\n"
"				\n"
"			elseif e.import==\"blog\" then\n"
"			\n"
"				e.hook   = e.hook   or opts.hook\n"
"				e.limit=e.limit or 5\n"
"				e.layer=e.layer or 0\n"
"				e.sort=e.sort or \"pubdate\"\n"
"				\n"
"				if not opts.noblog then -- prevent recursions\n"
"					local blog=require(\"blog\")\n"
"					s=blog.chunk_import(srv,e)\n"
"				end\n"
"				\n"
"			elseif e.import==\"note\" then\n"
"				e.hook   = e.hook   or opts.hook\n"
"				e.limit=e.limit or 5\n"
"				e.sort=e.sort or \"pubdate\"\n"
"				\n"
"				if not opts.nonote then -- prevent recursions\n"
"					local note=require(\"note\")\n"
"					s=note.chunk_import(srv,e)\n"
"				end\n"
"				\n"
"			elseif e.import==\"comic\" then\n"
"			\n"
"				e.hook   = e.hook   or opts.hook\n"
"				e.limit=e.limit or 5\n"
"				e.sort=e.sort or \"pubdate\"\n"
"				\n"
"				if not opts.nocomic then -- prevent recursions\n"
"					local comic=require(\"comic\")\n"
"					s=comic.chunk_import(srv,e)\n"
"				end\n"
"				\n"
"			elseif e.import==\"gsheet\" then -- we need to grab some json from google\n"
"			\n"
"				local gsheet=require(\"waka.gsheet\")\n"
"				e.offset = e.offset or opts.offset -- can choose new pages\n"
"				e.limit  = e.limit  or opts.limit -- can choose new pages\n"
"				e.query  = e.query  or opts.query\n"
"				e.plate  = e.plate  or opts.plate\n"
"				e.key    = e.key    or opts.key\n"
"				e.hook   = e.hook   or opts.hook -- callback function to fixup data\n"
"				s=gsheet.getwaka(srv,e) -- get a string\n"
"				\n"
"			elseif e.import==\"wikipedia\" then -- we need to import some xml from wikipedia\n"
"			\n"
"				local wikipedia=require(\"waka.wikipedia\")\n"
"				e.offset = e.offset or opts.offset -- can choose new pages\n"
"				e.limit  = e.limit  or opts.limit -- can choose new pages\n"
"				e.name  = e.name  or opts.name -- get this page\n"
"				e.search  = e.search  or opts.search -- search for\n"
"				e.hook   = e.hook   or opts.hook -- callback function to fixup data\n"
"				\n"
"				s=wikipedia.getwaka(srv,e) -- get a string\n"
"				\n"
"			elseif e.import==\"picasa\" then -- we need to import some imagedata from picasssa\n"
"			\n"
"				local picassa=require(\"waka.picasa\")\n"
"				e.offset = e.offset or opts.offset -- can choose new pages\n"
"				e.limit  = e.limit  or opts.limit -- can choose new pages\n"
"				e.user  = e.user  or opts.user -- user name\n"
"				e.album  = e.album  or opts.album -- album name\n"
"				e.authkey  = e.authkey  or opts.authkey -- authkey if needed\n"
"				e.hook   = e.hook   or opts.hook -- callback function to fixup data\n"
"				e.plate   = e.plate   or opts.plate -- display plate\n"
"				\n"
"				s=picassa.getwaka(srv,e) -- get a string or tab\n"
"				\n"
"			elseif e.import==\"json\" then -- we need to import some json from somewhere\n"
"			\n"
"				local waka_json=require(\"waka.json\")\n"
"				e.url  = e.url  or opts.url -- what to get\n"
"				e.cachetime  = e.cachetime  or opts.cachetime -- how long to cache for\n"
"				e.hook   = e.hook   or opts.hook -- callback function to fixup data\n"
"				e.plate   = e.plate   or opts.plate -- display plate\n"
"				\n"
"				s=waka_json.getwaka(srv,e) -- get a string or tab\n"
"			\n"
"			else -- raw\n"
"			\n"
"				if e.chunk then\n"
"					local chunk=str.table_lookup(e.chunk,refined)\n"
"--error(str.dump(chunk))\n"
"					if chunk then\n"
"						local meta={__index=chunk}\n"
"						setmetatable(e, meta)\n"
"					end\n"
"				end\n"
"\n"
"				s=e\n"
"			\n"
"			end\n"
"		\n"
"		elseif format==\"waka\" then -- basic waka format, html allowed but links are upgraded and line ends are <br/>\n"
"\n"
"			s=waka_to_html(s,{base_url=opts.baseurl,escape_html=false})\n"
"\n"
"		end\n"
"\n"
"		refined[v.name]=s\n"
"	end\n"
"	\n"
"-- end by running any refined lua hooks\n"
"	for i,v in ipairs(chunks) do\n"
"--		if v.opts.form==\"lua\" then -- we have some lua code for this page\n"
"		if v.env and v.env.hook_refined then\n"
"			pcall(function() v.env.hook_refined(refined) end) -- update refined data\n"
"		end\n"
"--		end\n"
"	end\n"
"\n"
"	\n"
"	return refined\n"
"end\n"
"",

"wetgenes.www.any.data","if ngx then\n"
"	return require(\"wetgenes.www.sqlite.data\")\n"
"else\n"
"	return require(\"wetgenes.www.gae.data\")\n"
"end\n"
"",

"gles","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local gles={}\n"
"\n"
"local core=require(\"gles.core\")\n"
"gles.core=core -- expose the core\n"
"\n"
"--local base={}\n"
"--local meta={}\n"
"--meta.__index=base\n"
"--setmetatable(gles,meta)\n"
"\n"
"\n"
"-- copypasta from GLES header, we are now v2 focused but we keep some old v1 defines around\n"
"local import=\n"
"[[\n"
"\n"
"#define GL_MODELVIEW                      0x1700\n"
"#define GL_PROJECTION                     0x1701\n"
"#define GL_TEXTURE                        0x1702\n"
"\n"
"#define GL_VERTEX_ARRAY                   0x8074\n"
"#define GL_NORMAL_ARRAY                   0x8075\n"
"#define GL_COLOR_ARRAY                    0x8076\n"
"#define GL_TEXTURE_COORD_ARRAY            0x8078\n"
"\n"
"#define GL_LIGHTING                       0x0B50\n"
"\n"
"/*************************************************************/\n"
"/*\n"
" *\n"
" *  Above is selected copypasta GLES1 defines\n"
" *  below is a full GLES2 dump\n"
" *\n"
" */\n"
"/*************************************************************/\n"
"\n"
"/* OpenGL ES core versions */\n"
"#define GL_ES_VERSION_2_0                 1\n"
"\n"
"/* ClearBufferMask */\n"
"#define GL_DEPTH_BUFFER_BIT               0x00000100\n"
"#define GL_STENCIL_BUFFER_BIT             0x00000400\n"
"#define GL_COLOR_BUFFER_BIT               0x00004000\n"
"\n"
"/* Boolean */\n"
"#define GL_FALSE                          0\n"
"#define GL_TRUE                           1\n"
"\n"
"/* BeginMode */\n"
"#define GL_POINTS                         0x0000\n"
"#define GL_LINES                          0x0001\n"
"#define GL_LINE_LOOP                      0x0002\n"
"#define GL_LINE_STRIP                     0x0003\n"
"#define GL_TRIANGLES                      0x0004\n"
"#define GL_TRIANGLE_STRIP                 0x0005\n"
"#define GL_TRIANGLE_FAN                   0x0006\n"
"\n"
"/* AlphaFunction (not supported in ES20) */\n"
"/*      GL_NEVER */\n"
"/*      GL_LESS */\n"
"/*      GL_EQUAL */\n"
"/*      GL_LEQUAL */\n"
"/*      GL_GREATER */\n"
"/*      GL_NOTEQUAL */\n"
"/*      GL_GEQUAL */\n"
"/*      GL_ALWAYS */\n"
"\n"
"/* BlendingFactorDest */\n"
"#define GL_ZERO                           0\n"
"#define GL_ONE                            1\n"
"#define GL_SRC_COLOR                      0x0300\n"
"#define GL_ONE_MINUS_SRC_COLOR            0x0301\n"
"#define GL_SRC_ALPHA                      0x0302\n"
"#define GL_ONE_MINUS_SRC_ALPHA            0x0303\n"
"#define GL_DST_ALPHA                      0x0304\n"
"#define GL_ONE_MINUS_DST_ALPHA            0x0305\n"
"\n"
"/* BlendingFactorSrc */\n"
"/*      GL_ZERO */\n"
"/*      GL_ONE */\n"
"#define GL_DST_COLOR                      0x0306\n"
"#define GL_ONE_MINUS_DST_COLOR            0x0307\n"
"#define GL_SRC_ALPHA_SATURATE             0x0308\n"
"/*      GL_SRC_ALPHA */\n"
"/*      GL_ONE_MINUS_SRC_ALPHA */\n"
"/*      GL_DST_ALPHA */\n"
"/*      GL_ONE_MINUS_DST_ALPHA */\n"
"\n"
"/* BlendEquationSeparate */\n"
"#define GL_FUNC_ADD                       0x8006\n"
"#define GL_BLEND_EQUATION                 0x8009\n"
"#define GL_BLEND_EQUATION_RGB             0x8009    /* same as BLEND_EQUATION */\n"
"#define GL_BLEND_EQUATION_ALPHA           0x883D\n"
"\n"
"/* BlendSubtract */\n"
"#define GL_FUNC_SUBTRACT                  0x800A\n"
"#define GL_FUNC_REVERSE_SUBTRACT          0x800B\n"
"\n"
"/* Separate Blend Functions */\n"
"#define GL_BLEND_DST_RGB                  0x80C8\n"
"#define GL_BLEND_SRC_RGB                  0x80C9\n"
"#define GL_BLEND_DST_ALPHA                0x80CA\n"
"#define GL_BLEND_SRC_ALPHA                0x80CB\n"
"#define GL_CONSTANT_COLOR                 0x8001\n"
"#define GL_ONE_MINUS_CONSTANT_COLOR       0x8002\n"
"#define GL_CONSTANT_ALPHA                 0x8003\n"
"#define GL_ONE_MINUS_CONSTANT_ALPHA       0x8004\n"
"#define GL_BLEND_COLOR                    0x8005\n"
"\n"
"/* Buffer Objects */\n"
"#define GL_ARRAY_BUFFER                   0x8892\n"
"#define GL_ELEMENT_ARRAY_BUFFER           0x8893\n"
"#define GL_ARRAY_BUFFER_BINDING           0x8894\n"
"#define GL_ELEMENT_ARRAY_BUFFER_BINDING   0x8895\n"
"\n"
"#define GL_STREAM_DRAW                    0x88E0\n"
"#define GL_STATIC_DRAW                    0x88E4\n"
"#define GL_DYNAMIC_DRAW                   0x88E8\n"
"\n"
"#define GL_BUFFER_SIZE                    0x8764\n"
"#define GL_BUFFER_USAGE                   0x8765\n"
"\n"
"#define GL_CURRENT_VERTEX_ATTRIB          0x8626\n"
"\n"
"/* CullFaceMode */\n"
"#define GL_FRONT                          0x0404\n"
"#define GL_BACK                           0x0405\n"
"#define GL_FRONT_AND_BACK                 0x0408\n"
"\n"
"/* DepthFunction */\n"
"/*      GL_NEVER */\n"
"/*      GL_LESS */\n"
"/*      GL_EQUAL */\n"
"/*      GL_LEQUAL */\n"
"/*      GL_GREATER */\n"
"/*      GL_NOTEQUAL */\n"
"/*      GL_GEQUAL */\n"
"/*      GL_ALWAYS */\n"
"\n"
"/* EnableCap */\n"
"#define GL_TEXTURE_2D                     0x0DE1\n"
"#define GL_CULL_FACE                      0x0B44\n"
"#define GL_BLEND                          0x0BE2\n"
"#define GL_DITHER                         0x0BD0\n"
"#define GL_STENCIL_TEST                   0x0B90\n"
"#define GL_DEPTH_TEST                     0x0B71\n"
"#define GL_SCISSOR_TEST                   0x0C11\n"
"#define GL_POLYGON_OFFSET_FILL            0x8037\n"
"#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E\n"
"#define GL_SAMPLE_COVERAGE                0x80A0\n"
"\n"
"/* ErrorCode */\n"
"#define GL_NO_ERROR                       0\n"
"#define GL_INVALID_ENUM                   0x0500\n"
"#define GL_INVALID_VALUE                  0x0501\n"
"#define GL_INVALID_OPERATION              0x0502\n"
"#define GL_OUT_OF_MEMORY                  0x0505\n"
"\n"
"/* FrontFaceDirection */\n"
"#define GL_CW                             0x0900\n"
"#define GL_CCW                            0x0901\n"
"\n"
"/* GetPName */\n"
"#define GL_LINE_WIDTH                     0x0B21\n"
"#define GL_ALIASED_POINT_SIZE_RANGE       0x846D\n"
"#define GL_ALIASED_LINE_WIDTH_RANGE       0x846E\n"
"#define GL_CULL_FACE_MODE                 0x0B45\n"
"#define GL_FRONT_FACE                     0x0B46\n"
"#define GL_DEPTH_RANGE                    0x0B70\n"
"#define GL_DEPTH_WRITEMASK                0x0B72\n"
"#define GL_DEPTH_CLEAR_VALUE              0x0B73\n"
"#define GL_DEPTH_FUNC                     0x0B74\n"
"#define GL_STENCIL_CLEAR_VALUE            0x0B91\n"
"#define GL_STENCIL_FUNC                   0x0B92\n"
"#define GL_STENCIL_FAIL                   0x0B94\n"
"#define GL_STENCIL_PASS_DEPTH_FAIL        0x0B95\n"
"#define GL_STENCIL_PASS_DEPTH_PASS        0x0B96\n"
"#define GL_STENCIL_REF                    0x0B97\n"
"#define GL_STENCIL_VALUE_MASK             0x0B93\n"
"#define GL_STENCIL_WRITEMASK              0x0B98\n"
"#define GL_STENCIL_BACK_FUNC              0x8800\n"
"#define GL_STENCIL_BACK_FAIL              0x8801\n"
"#define GL_STENCIL_BACK_PASS_DEPTH_FAIL   0x8802\n"
"#define GL_STENCIL_BACK_PASS_DEPTH_PASS   0x8803\n"
"#define GL_STENCIL_BACK_REF               0x8CA3\n"
"#define GL_STENCIL_BACK_VALUE_MASK        0x8CA4\n"
"#define GL_STENCIL_BACK_WRITEMASK         0x8CA5\n"
"#define GL_VIEWPORT                       0x0BA2\n"
"#define GL_SCISSOR_BOX                    0x0C10\n"
"/*      GL_SCISSOR_TEST */\n"
"#define GL_COLOR_CLEAR_VALUE              0x0C22\n"
"#define GL_COLOR_WRITEMASK                0x0C23\n"
"#define GL_UNPACK_ALIGNMENT               0x0CF5\n"
"#define GL_PACK_ALIGNMENT                 0x0D05\n"
"#define GL_MAX_TEXTURE_SIZE               0x0D33\n"
"#define GL_MAX_VIEWPORT_DIMS              0x0D3A\n"
"#define GL_SUBPIXEL_BITS                  0x0D50\n"
"#define GL_RED_BITS                       0x0D52\n"
"#define GL_GREEN_BITS                     0x0D53\n"
"#define GL_BLUE_BITS                      0x0D54\n"
"#define GL_ALPHA_BITS                     0x0D55\n"
"#define GL_DEPTH_BITS                     0x0D56\n"
"#define GL_STENCIL_BITS                   0x0D57\n"
"#define GL_POLYGON_OFFSET_UNITS           0x2A00\n"
"/*      GL_POLYGON_OFFSET_FILL */\n"
"#define GL_POLYGON_OFFSET_FACTOR          0x8038\n"
"#define GL_TEXTURE_BINDING_2D             0x8069\n"
"#define GL_SAMPLE_BUFFERS                 0x80A8\n"
"#define GL_SAMPLES                        0x80A9\n"
"#define GL_SAMPLE_COVERAGE_VALUE          0x80AA\n"
"#define GL_SAMPLE_COVERAGE_INVERT         0x80AB\n"
"\n"
"/* GetTextureParameter */\n"
"/*      GL_TEXTURE_MAG_FILTER */\n"
"/*      GL_TEXTURE_MIN_FILTER */\n"
"/*      GL_TEXTURE_WRAP_S */\n"
"/*      GL_TEXTURE_WRAP_T */\n"
"\n"
"#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2\n"
"#define GL_COMPRESSED_TEXTURE_FORMATS     0x86A3\n"
"\n"
"/* HintMode */\n"
"#define GL_DONT_CARE                      0x1100\n"
"#define GL_FASTEST                        0x1101\n"
"#define GL_NICEST                         0x1102\n"
"\n"
"/* HintTarget */\n"
"#define GL_GENERATE_MIPMAP_HINT            0x8192\n"
"\n"
"/* DataType */\n"
"#define GL_BYTE                           0x1400\n"
"#define GL_UNSIGNED_BYTE                  0x1401\n"
"#define GL_SHORT                          0x1402\n"
"#define GL_UNSIGNED_SHORT                 0x1403\n"
"#define GL_INT                            0x1404\n"
"#define GL_UNSIGNED_INT                   0x1405\n"
"#define GL_FLOAT                          0x1406\n"
"#define GL_FIXED                          0x140C\n"
"\n"
"/* PixelFormat */\n"
"#define GL_DEPTH_COMPONENT                0x1902\n"
"#define GL_ALPHA                          0x1906\n"
"#define GL_RGB                            0x1907\n"
"#define GL_RGBA                           0x1908\n"
"#define GL_LUMINANCE                      0x1909\n"
"#define GL_LUMINANCE_ALPHA                0x190A\n"
"\n"
"/* PixelType */\n"
"/*      GL_UNSIGNED_BYTE */\n"
"#define GL_UNSIGNED_SHORT_4_4_4_4         0x8033\n"
"#define GL_UNSIGNED_SHORT_5_5_5_1         0x8034\n"
"#define GL_UNSIGNED_SHORT_5_6_5           0x8363\n"
"\n"
"/* Shaders */\n"
"#define GL_FRAGMENT_SHADER                  0x8B30\n"
"#define GL_VERTEX_SHADER                    0x8B31\n"
"#define GL_MAX_VERTEX_ATTRIBS               0x8869\n"
"#define GL_MAX_VERTEX_UNIFORM_VECTORS       0x8DFB\n"
"#define GL_MAX_VARYING_VECTORS              0x8DFC\n"
"#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D\n"
"#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS   0x8B4C\n"
"#define GL_MAX_TEXTURE_IMAGE_UNITS          0x8872\n"
"#define GL_MAX_FRAGMENT_UNIFORM_VECTORS     0x8DFD\n"
"#define GL_SHADER_TYPE                      0x8B4F\n"
"#define GL_DELETE_STATUS                    0x8B80\n"
"#define GL_LINK_STATUS                      0x8B82\n"
"#define GL_VALIDATE_STATUS                  0x8B83\n"
"#define GL_ATTACHED_SHADERS                 0x8B85\n"
"#define GL_ACTIVE_UNIFORMS                  0x8B86\n"
"#define GL_ACTIVE_UNIFORM_MAX_LENGTH        0x8B87\n"
"#define GL_ACTIVE_ATTRIBUTES                0x8B89\n"
"#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH      0x8B8A\n"
"#define GL_SHADING_LANGUAGE_VERSION         0x8B8C\n"
"#define GL_CURRENT_PROGRAM                  0x8B8D\n"
"\n"
"/* StencilFunction */\n"
"#define GL_NEVER                          0x0200\n"
"#define GL_LESS                           0x0201\n"
"#define GL_EQUAL                          0x0202\n"
"#define GL_LEQUAL                         0x0203\n"
"#define GL_GREATER                        0x0204\n"
"#define GL_NOTEQUAL                       0x0205\n"
"#define GL_GEQUAL                         0x0206\n"
"#define GL_ALWAYS                         0x0207\n"
"\n"
"/* StencilOp */\n"
"/*      GL_ZERO */\n"
"#define GL_KEEP                           0x1E00\n"
"#define GL_REPLACE                        0x1E01\n"
"#define GL_INCR                           0x1E02\n"
"#define GL_DECR                           0x1E03\n"
"#define GL_INVERT                         0x150A\n"
"#define GL_INCR_WRAP                      0x8507\n"
"#define GL_DECR_WRAP                      0x8508\n"
"\n"
"/* StringName */\n"
"#define GL_VENDOR                         0x1F00\n"
"#define GL_RENDERER                       0x1F01\n"
"#define GL_VERSION                        0x1F02\n"
"#define GL_EXTENSIONS                     0x1F03\n"
"\n"
"/* TextureMagFilter */\n"
"#define GL_NEAREST                        0x2600\n"
"#define GL_LINEAR                         0x2601\n"
"\n"
"/* TextureMinFilter */\n"
"/*      GL_NEAREST */\n"
"/*      GL_LINEAR */\n"
"#define GL_NEAREST_MIPMAP_NEAREST         0x2700\n"
"#define GL_LINEAR_MIPMAP_NEAREST          0x2701\n"
"#define GL_NEAREST_MIPMAP_LINEAR          0x2702\n"
"#define GL_LINEAR_MIPMAP_LINEAR           0x2703\n"
"\n"
"/* TextureParameterName */\n"
"#define GL_TEXTURE_MAG_FILTER             0x2800\n"
"#define GL_TEXTURE_MIN_FILTER             0x2801\n"
"#define GL_TEXTURE_WRAP_S                 0x2802\n"
"#define GL_TEXTURE_WRAP_T                 0x2803\n"
"\n"
"/* TextureTarget */\n"
"/*      GL_TEXTURE_2D */\n"
"#define GL_TEXTURE                        0x1702\n"
"\n"
"#define GL_TEXTURE_CUBE_MAP               0x8513\n"
"#define GL_TEXTURE_BINDING_CUBE_MAP       0x8514\n"
"#define GL_TEXTURE_CUBE_MAP_POSITIVE_X    0x8515\n"
"#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X    0x8516\n"
"#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y    0x8517\n"
"#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y    0x8518\n"
"#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z    0x8519\n"
"#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z    0x851A\n"
"#define GL_MAX_CUBE_MAP_TEXTURE_SIZE      0x851C\n"
"\n"
"/* TextureUnit */\n"
"#define GL_TEXTURE0                       0x84C0\n"
"#define GL_TEXTURE1                       0x84C1\n"
"#define GL_TEXTURE2                       0x84C2\n"
"#define GL_TEXTURE3                       0x84C3\n"
"#define GL_TEXTURE4                       0x84C4\n"
"#define GL_TEXTURE5                       0x84C5\n"
"#define GL_TEXTURE6                       0x84C6\n"
"#define GL_TEXTURE7                       0x84C7\n"
"#define GL_TEXTURE8                       0x84C8\n"
"#define GL_TEXTURE9                       0x84C9\n"
"#define GL_TEXTURE10                      0x84CA\n"
"#define GL_TEXTURE11                      0x84CB\n"
"#define GL_TEXTURE12                      0x84CC\n"
"#define GL_TEXTURE13                      0x84CD\n"
"#define GL_TEXTURE14                      0x84CE\n"
"#define GL_TEXTURE15                      0x84CF\n"
"#define GL_TEXTURE16                      0x84D0\n"
"#define GL_TEXTURE17                      0x84D1\n"
"#define GL_TEXTURE18                      0x84D2\n"
"#define GL_TEXTURE19                      0x84D3\n"
"#define GL_TEXTURE20                      0x84D4\n"
"#define GL_TEXTURE21                      0x84D5\n"
"#define GL_TEXTURE22                      0x84D6\n"
"#define GL_TEXTURE23                      0x84D7\n"
"#define GL_TEXTURE24                      0x84D8\n"
"#define GL_TEXTURE25                      0x84D9\n"
"#define GL_TEXTURE26                      0x84DA\n"
"#define GL_TEXTURE27                      0x84DB\n"
"#define GL_TEXTURE28                      0x84DC\n"
"#define GL_TEXTURE29                      0x84DD\n"
"#define GL_TEXTURE30                      0x84DE\n"
"#define GL_TEXTURE31                      0x84DF\n"
"#define GL_ACTIVE_TEXTURE                 0x84E0\n"
"\n"
"/* TextureWrapMode */\n"
"#define GL_REPEAT                         0x2901\n"
"#define GL_CLAMP_TO_EDGE                  0x812F\n"
"#define GL_MIRRORED_REPEAT                0x8370\n"
"\n"
"/* Uniform Types */\n"
"#define GL_FLOAT_VEC2                     0x8B50\n"
"#define GL_FLOAT_VEC3                     0x8B51\n"
"#define GL_FLOAT_VEC4                     0x8B52\n"
"#define GL_INT_VEC2                       0x8B53\n"
"#define GL_INT_VEC3                       0x8B54\n"
"#define GL_INT_VEC4                       0x8B55\n"
"#define GL_BOOL                           0x8B56\n"
"#define GL_BOOL_VEC2                      0x8B57\n"
"#define GL_BOOL_VEC3                      0x8B58\n"
"#define GL_BOOL_VEC4                      0x8B59\n"
"#define GL_FLOAT_MAT2                     0x8B5A\n"
"#define GL_FLOAT_MAT3                     0x8B5B\n"
"#define GL_FLOAT_MAT4                     0x8B5C\n"
"#define GL_SAMPLER_2D                     0x8B5E\n"
"#define GL_SAMPLER_CUBE                   0x8B60\n"
"\n"
"/* Vertex Arrays */\n"
"#define GL_VERTEX_ATTRIB_ARRAY_ENABLED        0x8622\n"
"#define GL_VERTEX_ATTRIB_ARRAY_SIZE           0x8623\n"
"#define GL_VERTEX_ATTRIB_ARRAY_STRIDE         0x8624\n"
"#define GL_VERTEX_ATTRIB_ARRAY_TYPE           0x8625\n"
"#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED     0x886A\n"
"#define GL_VERTEX_ATTRIB_ARRAY_POINTER        0x8645\n"
"#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F\n"
"\n"
"/* Read Format */\n"
"#define GL_IMPLEMENTATION_COLOR_READ_TYPE   0x8B9A\n"
"#define GL_IMPLEMENTATION_COLOR_READ_FORMAT 0x8B9B\n"
"\n"
"/* Shader Source */\n"
"#define GL_COMPILE_STATUS                 0x8B81\n"
"#define GL_INFO_LOG_LENGTH                0x8B84\n"
"#define GL_SHADER_SOURCE_LENGTH           0x8B88\n"
"#define GL_SHADER_COMPILER                0x8DFA\n"
"\n"
"/* Shader Binary */\n"
"#define GL_SHADER_BINARY_FORMATS          0x8DF8\n"
"#define GL_NUM_SHADER_BINARY_FORMATS      0x8DF9\n"
"\n"
"/* Shader Precision-Specified Types */\n"
"#define GL_LOW_FLOAT                      0x8DF0\n"
"#define GL_MEDIUM_FLOAT                   0x8DF1\n"
"#define GL_HIGH_FLOAT                     0x8DF2\n"
"#define GL_LOW_INT                        0x8DF3\n"
"#define GL_MEDIUM_INT                     0x8DF4\n"
"#define GL_HIGH_INT                       0x8DF5\n"
"\n"
"/* Framebuffer Object. */\n"
"#define GL_FRAMEBUFFER                    0x8D40\n"
"#define GL_RENDERBUFFER                   0x8D41\n"
"\n"
"#define GL_RGBA4                          0x8056\n"
"#define GL_RGB5_A1                        0x8057\n"
"#define GL_RGB565                         0x8D62\n"
"#define GL_DEPTH_COMPONENT16              0x81A5\n"
"#define GL_STENCIL_INDEX8                 0x8D48\n"
"\n"
"#define GL_RENDERBUFFER_WIDTH             0x8D42\n"
"#define GL_RENDERBUFFER_HEIGHT            0x8D43\n"
"#define GL_RENDERBUFFER_INTERNAL_FORMAT   0x8D44\n"
"#define GL_RENDERBUFFER_RED_SIZE          0x8D50\n"
"#define GL_RENDERBUFFER_GREEN_SIZE        0x8D51\n"
"#define GL_RENDERBUFFER_BLUE_SIZE         0x8D52\n"
"#define GL_RENDERBUFFER_ALPHA_SIZE        0x8D53\n"
"#define GL_RENDERBUFFER_DEPTH_SIZE        0x8D54\n"
"#define GL_RENDERBUFFER_STENCIL_SIZE      0x8D55\n"
"\n"
"#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           0x8CD0\n"
"#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           0x8CD1\n"
"#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         0x8CD2\n"
"#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3\n"
"\n"
"#define GL_COLOR_ATTACHMENT0              0x8CE0\n"
"#define GL_DEPTH_ATTACHMENT               0x8D00\n"
"#define GL_STENCIL_ATTACHMENT             0x8D20\n"
"\n"
"#define GL_NONE                           0\n"
"\n"
"#define GL_FRAMEBUFFER_COMPLETE                      0x8CD5\n"
"#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT         0x8CD6\n"
"#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7\n"
"#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS         0x8CD9\n"
"#define GL_FRAMEBUFFER_UNSUPPORTED                   0x8CDD\n"
"\n"
"#define GL_FRAMEBUFFER_BINDING            0x8CA6\n"
"#define GL_RENDERBUFFER_BINDING           0x8CA7\n"
"#define GL_MAX_RENDERBUFFER_SIZE          0x84E8\n"
"\n"
"#define GL_INVALID_FRAMEBUFFER_OPERATION  0x0506\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"]]\n"
"-- parse the above string for constants, makes updates as easy as a cutnpaste from original source code\n"
"\n"
"gles.defs={}\n"
"\n"
"for l in import:gmatch(\"([^\\n"
"]*)\") do\n"
"	local define,value\n"
"	local state=\"start\"\n"
"	for w in l:gmatch(\"([^%s]+)\") do\n"
"		if state==\"start\" then\n"
"			if w==\"#define\" then\n"
"				state=\"define\"\n"
"			else\n"
"				break\n"
"			end\n"
"		elseif state==\"define\" then\n"
"			define=w\n"
"			state=\"value\"\n"
"		elseif state==\"value\" then\n"
"			value=w\n"
"				if define:sub(1,3)==\"GL_\" then -- sanity check\n"
"					define=define:sub(4)\n"
"					\n"
"					if value:sub(1,3)==\"GL_\" then -- allow lookback\n"
"						value=gles.defs[value:sub(4)]\n"
"					end\n"
"					\n"
"					gles.defs[define]=tonumber(value)\n"
"				end\n"
"			break\n"
"		else\n"
"			break\n"
"		end\n"
"	end\n"
"end\n"
"import=nil -- free it just because\n"
"\n"
"gles.nums={}\n"
"for i,v in pairs(gles.defs) do -- copy vals into base for shorthand gl.FALSE use\n"
"	gles[i]=v\n"
"	gles.nums[v]=i\n"
"end\n"
"\n"
"if core.fixed_pipeline_available then -- the old way\n"
"\n"
"elseif core.programmable_pipeline_available then -- the new way\n"
"\n"
"end\n"
"\n"
"\n"
"-- keep track of basic allocations\n"
"do\n"
"	local counts={}\n"
"	gles.counts=counts\n"
"	\n"
"	counts.reset=function()\n"
"		counts.buffers=0\n"
"		counts.framebuffers=0\n"
"		counts.programs=0\n"
"		counts.renderbuffers=0\n"
"		counts.shaders=0\n"
"		counts.textures=0\n"
"		counts.calls=0\n"
"	end\n"
"	counts.reset()\n"
"\n"
"	gles.   GenBuffer=function(  ) counts.buffers=counts.buffers+1 counts.calls=counts.calls+1 return core.   GenBuffer()   end\n"
"	gles.DeleteBuffer=function(id) counts.buffers=counts.buffers-1 counts.calls=counts.calls+1 return core.DeleteBuffer(id) end\n"
"\n"
"	gles.   GenFramebuffer=function(  ) counts.framebuffers=counts.framebuffers+1 counts.calls=counts.calls+1 return core.   GenFramebuffer()   end\n"
"	gles.DeleteFramebuffer=function(id) counts.framebuffers=counts.framebuffers-1 counts.calls=counts.calls+1 return core.DeleteFramebuffer(id) end\n"
"\n"
"	gles.   GenProgram=function(  ) counts.programs=counts.programs+1 counts.calls=counts.calls+1 return core.   GenProgram()   end\n"
"	gles.DeleteProgram=function(id) counts.programs=counts.programs-1 counts.calls=counts.calls+1 return core.DeleteProgram(id) end\n"
"\n"
"	gles.   GenRenderbuffer=function(  ) counts.renderbuffers=counts.renderbuffers+1 counts.calls=counts.calls+1 return core.   GenRenderbuffer()   end\n"
"	gles.DeleteRenderbuffer=function(id) counts.renderbuffers=counts.renderbuffers-1 counts.calls=counts.calls+1 return core.DeleteRenderbuffer(id) end\n"
"\n"
"	gles.   GenShader=function(  ) counts.shaders=counts.shaders+1 counts.calls=counts.calls+1 return core.   GenShader()   end\n"
"	gles.DeleteShader=function(id) counts.shaders=counts.shaders-1 counts.calls=counts.calls+1 return core.DeleteShader(id) end\n"
"\n"
"	gles.   GenTexture=function(  ) counts.textures=counts.textures+1 counts.calls=counts.calls+1 return core.   GenTexture()   end\n"
"	gles.DeleteTexture=function(id) counts.textures=counts.textures-1 counts.calls=counts.calls+1 return core.DeleteTexture(id) end\n"
"\n"
"-- export all core functions that have not been explicitly defined *above*\n"
"	for n,v in pairs(core) do\n"
"		if type(v)==\"function\" then\n"
"			if not gles[n] then -- already used\n"
"				gles[n]=function(...) counts.calls=counts.calls+1 return v(...) end\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"-- add optional debuggery to every function defined *above*\n"
"local gles_old_functions\n"
"gles.patch_functions_method=\"none\"\n"
"function gles.patch_functions(method)\n"
"\n"
"	if gles_old_functions then assert(method==\"none\") end -- can only restore\n"
"\n"
"	if method~=\"none\" then\n"
"		gles_old_functions={}\n"
"	end\n"
"\n"
"print(\"Patching GLES \",method)\n"
"\n"
"	for n,f in pairs(gles) do\n"
"		if type(f)==\"function\" and not ( \n"
"											n==\"CheckError\" or \n"
"--											n==\"GetError\" or \n"
"											n==\"numtostring\" or\n"
"--											n==\"GetExtensions\" or\n"
"--											n==\"Get\" or\n"
"											n==\"patch_functions\"\n"
"										) then	\n"
"		\n"
"			if     method==\"none\" then\n"
"			\n"
"				gles[n]=gles_old_functions[n] or gles[n]\n"
"				\n"
"			elseif method==\"disable\" then\n"
"			\n"
"--This disables all gles functions so we can profile with no GL calls\n"
"				gles[n]=function() return \"\" end\n"
"				\n"
"			elseif method==\"check\" then\n"
"			\n"
"--This foces a CheckError after each function which can catch bugs but stalls rendering\n"
"				gles[n]=function(...) local r=f(...) gles.CheckError() return r end\n"
"				\n"
"			end\n"
"		end\n"
"	end\n"
"	\n"
"	if method==\"none\" then\n"
"		gles_old_functions=nil\n"
"	end\n"
"\n"
"	gles.patch_functions_method=method\n"
"	\n"
"end\n"
"\n"
"--gles.patch_functions(\"disable\")\n"
"\n"
"\n"
"function gles.numtostring(num)\n"
"	return gles.nums[num]\n"
"end\n"
"\n"
"function gles.CheckError(...)\n"
"	local err=gles.GetError()\n"
"	if err==\"\" then err=0 end\n"
"	local str=gles.numtostring(err)\n"
"	assert(err==0,str)\n"
"end\n"
"\n"
"-- add all extensions as flags to gles.extensions\n"
"-- this may need to be called after setting up a context to be valid...\n"
"gles.extensions={}\n"
"function gles.GetExtensions()\n"
"	local s=gles.Get(gles.EXTENSIONS)\n"
"	for w in s:gmatch(\"([^%s]+)\") do\n"
"		if w:sub(1,3)==\"GL_\" then\n"
"			gles.extensions[w:sub(4)]=true -- skip the \"GL_\" at the start\n"
"		end\n"
"	end\n"
"end\n"
"\n"
"if core.fixed_pipeline_available then\n"
"	gles.gles1=gles\n"
"end\n"
"if core.programmable_pipeline_available then\n"
"	gles.gles2=gles\n"
"else\n"
"\n"
"\n"
"end\n"
"\n"
"return gles\n"
"",

"wetgenes.gamecake.layouts","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"local wgrd=require(\"wetgenes.grd\")\r\n"
"local pack=require(\"wetgenes.pack\")\r\n"
"local core=require(\"wetgenes.gamecake.core\")\r\n"
"\r\n"
"local tcore=require(\"wetgenes.tardis.core\")\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,layouts)\r\n"
"		\r\n"
"	local gl=oven.gl\r\n"
"	local cake=oven.cake\r\n"
"	local win=oven.win\r\n"
"	local canvas=cake.canvas\r\n"
"\r\n"
"-- manage a simple stack of layouts\r\n"
"	local stack\r\n"
"	layouts.reset=function()\r\n"
"		stack={}\r\n"
"		layouts.push( layouts.create{} )\r\n"
"		return layouts.get()\r\n"
"	end\r\n"
"	layouts.pop=function()\r\n"
"		local l=assert(stack[#stack])\r\n"
"		stack[#stack]=nil\r\n"
"		return l\r\n"
"	end\r\n"
"	layouts.push=function(l)\r\n"
"		stack[#stack+1]=l\r\n"
"		return l\r\n"
"	end\r\n"
"	layouts.get=function()\r\n"
"		return assert(stack[#stack])\r\n"
"	end\r\n"
"	layouts.push_child=function(opts)\r\n"
"		opts=opts or {}\r\n"
"		opts.parent=layouts.get()\r\n"
"		return layouts.push( layouts.create(opts) )\r\n"
"	end\r\n"
"	layouts.project23d=function(...) return layouts.get().project23d(...) end\r\n"
"	layouts.xyscale   =function(...) return layouts.get().xyscale(...)    end\r\n"
"	layouts.build     =function(...) return layouts.get().build(...)      end\r\n"
"	layouts.restore   =function(...) return layouts.get().restore(...)    end\r\n"
"	layouts.viewport  =function(...) return layouts.get().viewport(...)   end\r\n"
"	layouts.apply     =function(...) return layouts.get().apply(...)      end\r\n"
"\r\n"
"-- generate functions locked to the canvas\r\n"
"	layouts.create = function(opts)\r\n"
"\r\n"
"	local layout={}\r\n"
"	\r\n"
"	layout.parent=opts.parent\r\n"
"	\r\n"
"	if layout.parent then\r\n"
"		layout.x=opts.x or layout.parent.x\r\n"
"		layout.y=opts.y or layout.parent.y\r\n"
"		layout.w=opts.w or layout.parent.w\r\n"
"		layout.h=opts.h or layout.parent.h\r\n"
"	else\r\n"
"		layout.x=opts.x or 0\r\n"
"		layout.y=opts.y or 0\r\n"
"		layout.w=opts.w or win.width\r\n"
"		layout.h=opts.h or win.height\r\n"
"	end\r\n"
"\r\n"
"-- set all vars to 1 so anycode using them before they get set will not crash\r\n"
"	layout.view_width=1\r\n"
"	layout.view_height=1\r\n"
"	layout.view_fov=1\r\n"
"	layout.view_depth=1\r\n"
"	layout.x_scale=1\r\n"
"	layout.y_scale=1\r\n"
"	layout.x_origin=1\r\n"
"	layout.y_origin=1\r\n"
"	layout.x_size=1\r\n"
"	layout.y_size=1\r\n"
"	\r\n"
"--\r\n"
"-- build a simple field of view projection matrix designed to work in 2d or 3d and keep the numbers\r\n"
"-- easy for 2d positioning.\r\n"
"--\r\n"
"-- setting aspect to 640,480 and fov of 1 would mean at a z depth of 240 (which is y/2) then your view area would be\r\n"
"-- -320 to +320 in the x and -240 to +240 in the y.\r\n"
"--\r\n"
"-- fov is a tan like value (a view size inverse scalar) so 1 would be 90deg, 0.5 would be 45deg and so on\r\n"
"--\r\n"
"-- the depth parameter is only used to limit the range of the zbuffer so it covers 0 to depth\r\n"
"--\r\n"
"-- The following would be a reasonable default for a 640x480 canvas.\r\n"
"--\r\n"
"-- build_project23d(640,480,0.5,1024)\r\n"
"--\r\n"
"-- then at z=((480/2)/0.5)=480 we would have one to one pixel scale...\r\n"
"-- the total view area volume from there would be -320 +320 , -240 +240 , -480 +(1024-480)\r\n"
"--\r\n"
"-- canvas needs to contain width and height of the display which we use to work\r\n"
"-- out where to place our view such that it is always visible and keeps its aspect.\r\n"
"--\r\n"
"	layout.project23d = function(width,height,fov,depth)\r\n"
"		\r\n"
"		local l=layout -- we always have layout\r\n"
"		\r\n"
"		local aspect=height/width\r\n"
"		\r\n"
"		layout.view_width=width\r\n"
"		layout.view_height=height\r\n"
"		layout.view_fov=fov\r\n"
"		layout.view_depth=depth\r\n"
"\r\n"
"		local m={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} -- defaults\r\n"
"		layout.pmtx=m\r\n"
"		\r\n"
"		local f=depth\r\n"
"		local n=1\r\n"
"\r\n"
"		local layout_aspect=(l.h/l.w)\r\n"
"			\r\n"
"		if (layout_aspect > (aspect) ) 	then 	-- fit width to screen\r\n"
"			m[1] = ((aspect)*1)/fov\r\n"
"			m[6] = -((aspect)/layout_aspect)/fov\r\n"
"			\r\n"
"			layout.x_scale=1\r\n"
"			layout.y_scale=layout_aspect/aspect\r\n"
"		else									-- fit height to screen\r\n"
"		\r\n"
"			m[1] = layout_aspect/fov\r\n"
"			m[6] = -1/fov\r\n"
"			\r\n"
"			layout.x_scale=aspect/layout_aspect\r\n"
"			layout.y_scale=1\r\n"
"		end\r\n"
"\r\n"
"		layout.x_origin=l.x+l.w/2\r\n"
"		layout.y_origin=l.y+l.h/2\r\n"
"		layout.x_size=l.w\r\n"
"		layout.y_size=l.h\r\n"
"\r\n"
"	-- we reposition with the viewport, so only need to fix the size in the matrix when using a layout.	\r\n"
"		\r\n"
"		m[11] = -(f+n)/(f-n)\r\n"
"		m[12] = -1\r\n"
"\r\n"
"		m[15] = -2*f*n/(f-n)\r\n"
"		\r\n"
"		return m -- return the matrix but we also updated the layout size/scale for later use\r\n"
"	end\r\n"
"	\r\n"
"\r\n"
"-- convert raw xy coords (IE mouse win width and height) into local coords (view width and height) centered on origin\r\n"
"-- basically do whatever transform we came up with in project23d\r\n"
"	layout.xyscale=function(x,y)\r\n"
"\r\n"
"		-- centered and scaled\r\n"
"		x=layout.view_width  * ( (x-layout.x_origin) * layout.x_scale ) / layout.x_size\r\n"
"		y=layout.view_height * ( (y-layout.y_origin) * layout.y_scale ) / layout.y_size\r\n"
"		\r\n"
"		return x,y\r\n"
"	end\r\n"
"\r\n"
"	layout.xyunscale=function(x,y)\r\n"
"\r\n"
"		x=((x * layout.x_size/layout.view_width )/layout.x_scale)+layout.x_origin\r\n"
"		y=((y * layout.y_size/layout.view_height)/layout.y_scale)+layout.y_origin\r\n"
"		\r\n"
"		return x,y\r\n"
"	end\r\n"
"\r\n"
"-- a viewport clip, resize an area of this aspect ratio to fit into the current layout\r\n"
"-- use this before layout.project23d and you will not have any pixels escaping out of\r\n"
"-- your draw area\r\n"
"	layout.build=function(width,height,x,y)\r\n"
"\r\n"
"		local l=layout.parent or {x=0,y=0,w=win.width,h=win.height}\r\n"
"		\r\n"
"		if not width or not height then -- full screen\r\n"
"\r\n"
"			layout.x=l.x\r\n"
"			layout.y=l.y\r\n"
"			layout.w=l.w\r\n"
"			layout.h=l.h\r\n"
"\r\n"
"			return\r\n"
"			\r\n"
"		elseif x and y then -- force size and position\r\n"
"		\r\n"
"			layout.x=x\r\n"
"			layout.y=y\r\n"
"			layout.w=width\r\n"
"			layout.h=height\r\n"
"\r\n"
"			return\r\n"
"			\r\n"
"		else\r\n"
"			layout.x=l.x\r\n"
"			layout.y=l.y\r\n"
"			layout.w=l.w\r\n"
"			layout.h=l.h\r\n"
"			\r\n"
"			local layout_aspect=(l.h/l.w)\r\n"
"			local aspect=height/width		\r\n"
"				\r\n"
"			if layout_aspect > aspect then 			-- fit width to screen\r\n"
"			\r\n"
"				layout.h=l.w*aspect -- our new display height				\r\n"
"				layout.y=l.y+((l.h-layout.h)*0.5) -- centered\r\n"
"				\r\n"
"				return\r\n"
"\r\n"
"			else											-- fit height to screen\r\n"
"			\r\n"
"				layout.w=l.h/aspect -- our new display width\r\n"
"				layout.x=l.x+((l.w-layout.w)*0.5) -- centered\r\n"
"				\r\n"
"				return\r\n"
"			end\r\n"
"		end\r\n"
"\r\n"
"	end\r\n"
"\r\n"
"	layout.restore=function()\r\n"
"\r\n"
"		canvas.layout=layout -- remember current layout in canvas\r\n"
"\r\n"
"		if layout.parent then\r\n"
"			gl.Viewport( layout.x , (layout.parent.h-(layout.y+layout.h)) , layout.w , layout.h )\r\n"
"		else\r\n"
"			gl.Viewport( layout.x , win.height-(layout.y+layout.h) , layout.w , layout.h )\r\n"
"		end\r\n"
"\r\n"
"	end\r\n"
"	\r\n"
"	layout.viewport=function(width,height,x,y)\r\n"
"	\r\n"
"		-- adjust the fake root layout\r\n"
"		win:info()\r\n"
"		stack[1].x=0\r\n"
"		stack[1].y=0\r\n"
"		stack[1].w=win.width\r\n"
"		stack[1].h=win.height\r\n"
"		\r\n"
"		layout.build(width,height,x,y)\r\n"
"		\r\n"
"		layout.restore()\r\n"
"		\r\n"
"	end\r\n"
"\r\n"
"-- this applys a full viewport and adjusts opengls projection and model view stacks\r\n"
"-- push and pop these if you wish to preserve old values\r\n"
"-- returns last applied layout, so you can restore it to undo these changes\r\n"
"	layout.apply=function(w,h,fov,d,clip)\r\n"
"		layout.revert=function() return layout.apply(w,h,fov,d,clip) end\r\n"
"	\r\n"
"		local flag if type(w)==\"boolean\" then flag=w w=nil end\r\n"
"	\r\n"
"		local ret=canvas.layout\r\n"
"	\r\n"
"		w=w or layout.w\r\n"
"		h=h or layout.h\r\n"
"		d=d or layout.h*4\r\n"
"		fov=fov or 0.25\r\n"
"		\r\n"
"		if clip then\r\n"
"\r\n"
"			layout.viewport(w,h)\r\n"
"			\r\n"
"		elseif flag then -- use preset viewport?\r\n"
"		\r\n"
"			layout.viewport(w,h,layout.x,layout.y)\r\n"
"\r\n"
"		else\r\n"
"\r\n"
"			layout.viewport()\r\n"
"\r\n"
"		end\r\n"
"		layout.project23d(w,h,fov,d)\r\n"
"	\r\n"
"		gl.MatrixMode(gl.PROJECTION)\r\n"
"		gl.LoadMatrix( layout.pmtx )\r\n"
"\r\n"
"		gl.MatrixMode(gl.MODELVIEW)\r\n"
"		gl.LoadIdentity()\r\n"
"		gl.Translate(-w/2,-h/2,(-h/2)/fov) -- top left corner is origin\r\n"
"		\r\n"
"		return ret\r\n"
"	end\r\n"
"\r\n"
"-- does nothing?\r\n"
"--	layout.setup=layout.apply\r\n"
"--	layout.clean=function()\r\n"
"--	end\r\n"
"	\r\n"
"	return layout\r\n"
"end\r\n"
"\r\n"
"-- init with a default layout\r\n"
"	layouts.reset()\r\n"
"	layouts.apply()\r\n"
"\r\n"
"	return layouts\r\n"
"end\r\n"
"",

"wetgenes.gamecake.widgets","-- copy all globals into locals\r\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\r\n"
"\r\n"
"--\r\n"
"-- handle widgets\r\n"
"--\r\n"
"\r\n"
"\r\n"
"-- this all needs to be baked into thecake, just hax for now\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"--module\r\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\r\n"
"\r\n"
"function M.bake(oven,widgets)\r\n"
"widgets=widgets or {}\r\n"
"\r\n"
"local wmeta=oven.rebake(\"wetgenes.gamecake.widgets.meta\")\r\n"
"local wskin=oven.rebake(\"wetgenes.gamecake.widgets.skin\")\r\n"
"\r\n"
"--\r\n"
"-- create a master widget\r\n"
"--\r\n"
"function widgets.setup(def)\r\n"
"\r\n"
"	local meta={}\r\n"
"	meta.__index=meta\r\n"
"	local master={} -- the master widget, all numerical keys of a widget are the widgets children\r\n"
"	setmetatable(master,meta)\r\n"
"	master.parent=master -- we are our own parent, probably safer than setting as null\r\n"
"	master.master=master -- and our own master\r\n"
"	\r\n"
"	master.font=def.font\r\n"
"	\r\n"
"	def.master=master\r\n"
"	def.meta=meta\r\n"
"\r\n"
"	wmeta.setup(def)\r\n"
"	wskin.setup(def)\r\n"
"	\r\n"
"-- default GUI size if no other is specified\r\n"
"	def.hx=def.hx or oven.opts.width\r\n"
"	def.hy=def.hy or oven.opts.height\r\n"
"	def.px=def.px or (oven.opts.width-def.hx)/2\r\n"
"	def.py=def.py or (oven.opts.height-def.hy)/2\r\n"
"	def.pxd=def.pxd or def.px\r\n"
"	def.pyd=def.pyd or def.py\r\n"
"\r\n"
"	def.class=def.class or \"master\"\r\n"
"	\r\n"
"	master:setup(def)\r\n"
"	\r\n"
"	return master -- our new widget is ready\r\n"
"\r\n"
"end\r\n"
"\r\n"
"return widgets\r\n"
"end\r\n"
"",

"wetgenes.www.ngx.sys","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"local ngx=require(\"ngx\")\n"
"\n"
"local lash=require(\"lash\")\n"
"local bit=require(\"bit\")\n"
"local zip=require(\"zip\")\n"
"local wstr=require(\"wetgenes.string\")\n"
"local wpack=require(\"wetgenes.pack\")\n"
"\n"
"module(...)\n"
"local _M=require(...)\n"
"package.loaded[\"wetgenes.www.any.sys\"]=_M\n"
"\n"
"\n"
"-- build HMAX using lash?\n"
"\n"
"local xor_with_0x5c = {}\n"
"local xor_with_0x36 = {}\n"
"for i=0,0xff do\n"
"	xor_with_0x5c[string.char(i)] = string.char(bit.bxor(i,0x5c))\n"
"	xor_with_0x36[string.char(i)] = string.char(bit.bxor(i,0x36))\n"
"end\n"
"\n"
"local blocksize = 64 -- 512 bits\n"
"\n"
"local sha1hex=function(s) local h,b = lash.SHA1.string2hex(s) ; return h end\n"
"local sha1bin=function(s) local h,b = lash.SHA1.string2hex(s) ; return b end\n"
"\n"
"function do_hmac_sha1(key, text)\n"
"\n"
"	if #key > blocksize then\n"
"		key = sha1bin(key)\n"
"	end\n"
"\n"
"	local key_xord_with_0x36 = key:gsub('.', xor_with_0x36) .. string.rep(string.char(0x36), blocksize - #key)\n"
"	local key_xord_with_0x5c = key:gsub('.', xor_with_0x5c) .. string.rep(string.char(0x5c), blocksize - #key)\n"
"\n"
"	return sha1bin(key_xord_with_0x5c .. sha1bin(key_xord_with_0x36 .. text))\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"function sleep(t)\n"
"--	log(\"sys.sleep:\")\n"
"\n"
"	local res = ngx.location.capture(\"/@sleep/\"..t)\n"
"\n"
"--	return core.sleep(...)\n"
"\n"
"end\n"
"\n"
"function file_read(filename)\n"
"	local d\n"
"	local fp=io.open(filename,\"r\")\n"
"	if fp then\n"
"		d=fp:read(\"*a\")\n"
"		fp:close()\n"
"	end\n"
"	return d\n"
"--	return core.file_read(filename)\n"
"end\n"
"\n"
"function bytes_split(bytes,size)\n"
"--	log(\"sys.bytes_split:\")\n"
"	\n"
"	local t={}\n"
"	for i=1,#bytes,size do\n"
"		local d=bytes:sub(i,i+size-1)\n"
"		t[#t+1]={data=d,size=#d}\n"
"	end\n"
"	return t\n"
"end\n"
"\n"
"function bytes_join(tab)\n"
"--[[\n"
"	local t={}\n"
"	for i,v in ipairs(tab) do\n"
"		t[i]=v.data\n"
"	end\n"
"]]\n"
"	return table.concat(tab)\n"
"end\n"
"\n"
"function bytes_to_string(bytes)\n"
"	if type(bytes)~=\"string\" then\n"
"		return wpack.tostring(bytes)\n"
"	end\n"
"	return bytes\n"
"end\n"
"\n"
"function bin_encode(enc,s)\n"
"--	log(\"sys.bin_encode:\")\n"
"\n"
"	if enc==\"hex\" then\n"
"		r=str_to_hex(s)\n"
"	elseif enc==\"base64\" then\n"
"		r=b64_enc(s)\n"
"	else\n"
"		r=s\n"
"	end\n"
"	\n"
"	return r \n"
"--	return core.bin_encode(t,b)\n"
"end\n"
"\n"
"function md5(s,f)\n"
"--	log(\"sys.md5:\")\n"
"	if f==\"bin\" then return ngx.md5_bin(s) end\n"
"	return ngx.md5(s)\n"
"end\n"
"function sha1(s,f)\n"
"--	log(\"sys.sha1:\")\n"
"--	if f==\"bin\" then return ngx.sha1_bin(s) end\n"
"--	return ngx.sha1(s)\n"
"--	return core.sha1(s,f)\n"
"end\n"
"function hmac_sha1(k,s,f)\n"
"--	log(\"sys.hmac_sha1:\")\n"
"	if f==\"bin\" then return do_hmac_sha1(k,s) end\n"
"	return str_to_hex(do_hmac_sha1(k,s))\n"
"end\n"
"\n"
"function zip_list(z)\n"
"--	log(\"sys.zip_list:\")\n"
"	local r={}\n"
"	local zf=zip.open_mem(z,#z)\n"
"	if zf then\n"
"		for file in zf:files() do\n"
"			r[#r+1]={ name=file.filename , size=file.uncompressed_size}\n"
"		end\n"
"		zf:close()\n"
"	end\n"
"	return r\n"
"end\n"
"\n"
"function zip_read(z,n)\n"
"--	log(\"zip.read:\")\n"
"	\n"
"	local r\n"
"	local zf=zip.open_mem(z,#z)	\n"
"--print(n,#z,wstr.dump(zf))\n"
"	if zf then\n"
"	\n"
"		local f=zf:open(n)\n"
"		\n"
"		if f then\n"
"			r=f:read(\"*a\")\n"
"			f:close()\n"
"		end\n"
"		\n"
"		zf:close()\n"
"	end\n"
"	return r\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- convert a string into a hex string\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function str_to_hex(s)\n"
"	return (string.gsub(s, \".\", function (c)\n"
"		return string.format(\"%02x\", string.byte(c))\n"
"	end))\n"
"end\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- check if the given file exists\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function file_exists(filename)\n"
"\n"
"	local f=io.open(filename,\"r\")\n"
"	if f then\n"
"		f:close()\n"
"		return true\n"
"	end\n"
"\n"
"	return false\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- find a given lua file, within the lua path\n"
"-- do not pass in the .lua extension\n"
"-- returns a path to a file you can then open\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function file_find_lua(name)\n"
"\n"
"	return \"lua/\"..name..\".lua\"\n"
"\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function redirect(srv,url)\n"
"\n"
"	if not srv.redirect(url) then -- header write failed, spit out some java script instead?\n"
"	\n"
"		srv.put([[<script type=\"text/javascript\" >window.location = \"]]..url..[[\";</script>]])\n"
"		\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"-- character table string\n"
"local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n"
"\n"
"-- encoding\n"
"function b64_enc(data)\n"
"    return ((data:gsub('.', function(x) \n"
"        local r,b='',x:byte()\n"
"        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\n"
"        return r;\n"
"    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\n"
"        if (#x < 6) then return '' end\n"
"        local c=0\n"
"        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\n"
"        return b:sub(c+1,c+1)\n"
"    end)..({ '', '==', '=' })[#data%3+1])\n"
"end\n"
"\n"
"-- decoding\n"
"function b64_dec(data)\n"
"    data = string.gsub(data, '[^'..b..'=]', '')\n"
"    return (data:gsub('.', function(x)\n"
"        if (x == '=') then return '' end\n"
"        local r,f='',(b:find(x)-1)\n"
"        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end\n"
"        return r;\n"
"    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)\n"
"        if (#x ~= 8) then return '' end\n"
"        local c=0\n"
"        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end\n"
"        return string.char(c)\n"
"    end))\n"
"end\n"
"\n"
"--[[\n"
"log('HMAC_SHA1(\"\", \"\") = 0xfbdb1d1b18aa6c08324b7d64b71fb76370690e1d')\n"
"log('HMAC_SHA1(\"key\", \"The quick brown fox jumps over the lazy dog\") = 0xde7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9')\n"
"log(str_to_hex(do_hmac_sha1(\"\",\"\")))\n"
"log(str_to_hex(do_hmac_sha1(\"key\", \"The quick brown fox jumps over the lazy dog\"))..\"POOP\")\n"
"]]\n"
"",

"wetgenes.www.gae","\r\r\r\rmodule(...)\r\r",

"wetgenes.www.ngx","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local log=require(\"wetgenes.www.any.log\").log\n"
"\n"
"module(...)\n"
"\n"
"",

"start","\n"
"local apps=require(\"apps\")\n"
"\n"
"-- try hard to find any files wemay need\n"
"apps.default_paths()\n"
"\n"
"local wzips=require(\"wetgenes.zips\")\n"
"\n"
"-- strip some args before passing on to main code\n"
"local a=arg or {}\n"
"local argx={}\n"
"\n"
"local done_start=false -- only remove the first\n"
"local done_zip=false\n"
"\n"
"for i=1,#a do\n"
"	local v=tostring(a[i])\n"
"\n"
"	if v==\"-lstart\" and not done_start then\n"
"		done_start=true\n"
"		v=nil\n"
"	elseif v:sub(-4)==\".zip\" and not done_zip then -- the first zip only\n"
"		wzips.add_zip_file(v)\n"
"		done_zip=true	\n"
"		v=nil\n"
"	elseif v:sub(-5)==\".cake\" then -- all .cake files we are given\n"
"		wzips.add_zip_file(v)\n"
"		v=nil\n"
"	end\n"
"\n"
"	if v then argx[#argx+1]=v end \n"
"end\n"
"\n"
"local str=wzips.readfile(\"lua/init.lua\")\n"
"\n"
"if str then\n"
"\n"
"	if str:sub(1,2)==\"#!\" then\n"
"		str=\"--\"..str -- ignore hashbang on first line\n"
"	end\n"
"\n"
"	local func=assert(loadstring(str,name))\n"
"\n"
"	func(unpack(argx))\n"
"\n"
"	os.exit(0) -- force close so that we do not end up at a console?\n"
"end\n"
"",

"wetgenes.www.any.cache","\n"
"if ngx then\n"
"	return require(\"wetgenes.www.ngx.cache\")\n"
"else\n"
"	return require(\"wetgenes.www.gae.cache\")\n"
"end\n"
"",

"wetgenes.gamecake.sounds","-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes\n"
"local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require\n"
"\n"
"local print=function(...) return _G.print(...) end\n"
"\n"
"local zips=require(\"wetgenes.zips\")\n"
"local grd=require(\"wetgenes.grd\")\n"
"local sod=require(\"wetgenes.sod\")\n"
"\n"
"\n"
"--module\n"
"local M={ modname=(...) } ; package.loaded[M.modname]=M\n"
"\n"
"function M.bake(oven,sounds)\n"
"\n"
"	local str_func={}\n"
"	local str_meta={__index=str_func}\n"
"	\n"
"	local sfx_func={}\n"
"	local sfx_meta={__index=sfx_func}\n"
"	\n"
"	local opts=oven.opts\n"
"	local cake=oven.cake\n"
"\n"
"\n"
"	local sfxmax=opts.sfxmax or 4\n"
"	local strmax=opts.strmax or 2\n"
"		\n"
"-- probably nil but we may need to override?\n"
"	sounds.al=opts.al\n"
"	sounds.alc=opts.alc	\n"
"	local al=sounds.al\n"
"	local alc=sounds.alc\n"
"	\n"
"	sounds.vol_stream=1\n"
"	sounds.vol_beep=1\n"
"	\n"
"	sounds.data={}\n"
"	\n"
"	sounds.prefix=opts.sodprefix or \"data/\"\n"
"	sounds.postfix=opts.sodpostfix or \".wav\"\n"
"	\n"
"\n"
"sounds.setup=function()\n"
"\n"
"	sounds.al=sounds.al or require(\"al\")\n"
"	sounds.alc=sounds.alc or require(\"alc\")\n"
"\n"
"-- copy into locals\n"
"	al=sounds.al\n"
"	alc=sounds.alc\n"
"\n"
"	sounds.start()\n"
"\n"
"end\n"
"\n"
"sounds.clean=function()\n"
"	sounds.stop()\n"
"end\n"
"\n"
"sounds.get=function(id)\n"
"	return sounds.data[id]\n"
"end\n"
"\n"
"sounds.set=function(d,id)\n"
"	sounds.data[id]=d\n"
"end\n"
"\n"
"sounds.beep_idx=1\n"
"sounds.beep_max=sfxmax\n"
"sounds.beep=function(d)\n"
"\n"
"	local inc=true\n"
"	local sfx=sounds.sfxs[sounds.beep_idx]\n"
"	if d.idx then sfx=sounds.sfxs[d.idx] inc=false end\n"
"	\n"
"	al.SourceStop(sfx.source)\n"
"\n"
"	al.Source(sfx.source, al.BUFFER, d.buff)\n"
"	al.Source(sfx.source, al.LOOPING, d.loop or al.FALSE)\n"
"\n"
"	al.Source(sfx.source, al.PITCH, (d.pitch or 1) )\n"
"	al.Source(sfx.source, al.GAIN, sounds.vol_beep * (d.gain or 1) )\n"
"\n"
"	al.SourcePlay(sfx.source)\n"
"\n"
"	if inc then\n"
"--print(\"SFX\",sounds.beep_idx,d.name)\n"
"		sounds.beep_idx=sounds.beep_idx+1\n"
"		if sounds.beep_idx > sounds.beep_max then sounds.beep_idx=1 end\n"
"--	else\n"
"--print(\"SFI\",d.idx,d.name)\n"
"	end\n"
"end\n"
"\n"
"sounds.queue_talk=function(d)\n"
"\n"
"	local str=sounds.strs[1]\n"
"\n"
"end\n"
"\n"
"--\n"
"-- unload a previously loaded image\n"
"--\n"
"sounds.unload=function(id)\n"
"	\n"
"	local t=sounds.get(id)\n"
"\n"
"	if t then\n"
"		sounds.set(nil,id)\n"
"	end\n"
"end\n"
"\n"
"\n"
"--\n"
"-- pre bake some speech, and make it easy to lookup by the given ids\n"
"--\n"
"sounds.load_speak=function(tab,id)\n"
"	if type(tab)==\"string\" then tab={text=tab} end -- default options\n"
"\n"
"	local t=sounds.get(id)\n"
"	if t then return t end --first check it is not already loaded\n"
"	\n"
"	t={}\n"
"	t.filename=tab\n"
"	\n"
"	t.loop=al.FALSE\n"
"	\n"
"	t.buff=al.GenBuffer()\n"
"\n"
"	local dat,len=require(\"wetgenes.speak.core\").test(tab.text)\n"
"	al.BufferData(t.buff,al.FORMAT_MONO16,dat,len,261.626*8*8) -- C4 hopefully?\n"
"	\n"
"	sounds.set(t,id) -- remember\n"
"\n"
"oven.preloader(id)\n"
"\n"
"end\n"
"\n"
"--\n"
"-- Load an ogg for use in a soundeffect so read it all in and then push it over to opengl\n"
"--\n"
"sounds.load_ogg=function(filename,id)\n"
"\n"
"	local t=sounds.get(id)\n"
"	\n"
"	if t then return t end --first check it is not already loaded\n"
"\n"
"	local fname=sounds.prefix..filename..\".ogg\"\n"
"	\n"
"	local d=assert(zips.readfile(fname))\n"
"\n"
"	t={}\n"
"	t.filename=filename\n"
"	\n"
"\n"
"--do return false end	\n"
"		\n"
"	local ogg=require(\"wetgenes.ogg\")\n"
"	local og=ogg.create()\n"
"	og:open()\n"
"	\n"
"	local rr={}\n"
"	repeat\n"
"		local done=false\n"
"		local r=og:pull()\n"
"		if not r then\n"
"			if og.err==\"push\" then\n"
"				og:push(d)\n"
"			elseif og.err==\"end\" then done=true\n"
"			elseif og.err then error( og.err ) end\n"
"		else\n"
"			rr[#rr+1]=r\n"
"			if og.err==\"end\" then done=true\n"
"			elseif og.err then error( og.err ) end\n"
"		end\n"
"		\n"
"	until done\n"
"\n"
"\n"
"	local fmt=al.FORMAT_MONO16\n"
"	if og.channels==2 then fmt=al.FORMAT_STEREO16 end\n"
"	local rate=og.rate\n"
"\n"
"	t.loop=al.FALSE		\n"
"	t.buff=al.GenBuffer()\n"
"\n"
"	local r=table.concat(rr)\n"
"	al.BufferData(t.buff,fmt,r,#r,rate)\n"
"\n"
"	sounds.set(t,id) -- remember\n"
"\n"
"--print(\"load\",filename)\n"
"--print(#rr,\"chunks\",#table.concat(rr))\n"
"\n"
"--[[\n"
"if filename==\"oggs/munch\" then\n"
"	print(filename)\n"
"	print(\"in\",#d)\n"
"	print(\"buffs\",#rr)\n"
"	print(\"out\",#r)\n"
"\n"
"exit(0)\n"
"end\n"
"]]\n"
"\n"
"	og:close()\n"
"\n"
"--print(\"loaded ogg\",filename)\n"
"oven.preloader(filename)\n"
"\n"
"	return t\n"
"end\n"
"\n"
"--\n"
"-- load a single sound, and make it easy to lookup by the given id\n"
"--\n"
"sounds.load=function(filename,id)\n"
"\n"
"	local t=sounds.get(id)\n"
"	\n"
"	if t then return t end --first check it is not already loaded\n"
"\n"
"	if zips.exists(sounds.prefix..filename..\".ogg\") then return sounds.load_ogg(filename,id) end\n"
"\n"
"	local fname=sounds.prefix..filename..sounds.postfix\n"
"	\n"
"	local x=assert(sod.create())\n"
"	\n"
"	local d=assert(zips.readfile(fname),fname)\n"
"	assert(x:load_data(d,\"wav\"))\n"
"	t={}\n"
"	t.filename=filename\n"
"	\n"
"\n"
"	t.loop=al.FALSE\n"
"	\n"
"	t.buff=al.GenBuffer()\n"
"	al.BufferData(t.buff,x) -- all loaded\n"
"	\n"
"	sounds.set(t,id) -- remember\n"
"\n"
"--print(\"loaded\",filename)\n"
"oven.preloader(filename)\n"
"\n"
"	return t\n"
"	\n"
"end\n"
"\n"
"--\n"
"-- load many sounds from id=filename table\n"
"--\n"
"sounds.loads=function(tab)\n"
"\n"
"	for i,v in pairs(tab) do\n"
"	\n"
"		if type(i)==\"number\" then -- just use filename twice\n"
"			sounds.load(v,v)\n"
"		else\n"
"			sounds.load(v,i)\n"
"		end\n"
"		\n"
"	end\n"
"\n"
"end\n"
"\n"
"\n"
"sounds.start = function()\n"
"\n"
"	if not sounds.context then\n"
"	\n"
"		sounds.context=alc.setup()\n"
"		\n"
"		al.Listener(al.POSITION, 0, 0, 0)\n"
"		al.Listener(al.VELOCITY, 0, 0, 0)\n"
"		al.Listener(al.ORIENTATION, 0, 0, -1, 0,1,0 )\n"
"\n"
"-- one off sound effect type things		\n"
"		sounds.sfxs={}\n"
"		for i=1,sfxmax do\n"
"			local sfx={idx=i}\n"
"			sounds.sfxs[i]=sfx\n"
"			local s=al.GenSource()\n"
"			sfx.source=s\n"
"			al.Source(s, al.PITCH, 1)\n"
"			al.Source(s, al.GAIN, 1)\n"
"			al.Source(s, al.POSITION, 0, 0, 0)\n"
"			al.Source(s, al.VELOCITY, 0, 0, 0)\n"
"			al.Source(s, al.LOOPING, al.FALSE)\n"
"			setmetatable(sfx,sfx_meta)\n"
"		end\n"
"		\n"
"-- streaming music type things\n"
"		sounds.strs={}\n"
"		for i=1,strmax do\n"
"			local str={idx=i}\n"
"			sounds.strs[i]=str\n"
"			local s=al.GenSource()\n"
"			str.source=s\n"
"			al.Source(s, al.PITCH, 1)\n"
"			al.Source(s, al.GAIN, 1)\n"
"			al.Source(s, al.POSITION, 0, 0, 0)\n"
"			al.Source(s, al.VELOCITY, 0, 0, 0)\n"
"			al.Source(s, al.LOOPING, al.FALSE)\n"
"\n"
"			str.buffers={al.GenBuffer(),al.GenBuffer(),al.GenBuffer()} -- triple buffer sound renderer\n"
"			str.full={} -- these buffers are full and queued\n"
"			str.empty={} -- these buffers are empty and waiting to be queued\n"
"			for i,v in ipairs(str.buffers) do str.empty[#str.empty+1]=v end\n"
"			\n"
"			setmetatable(str,str_meta)\n"
"		end\n"
"\n"
"-- queues contain data that is kept valid between stop/starts\n"
"-- this way we can kind of keep playing at more or less the same point in a stream\n"
"		if not sounds.queues then\n"
"			sounds.queues={}\n"
"			for i=1,strmax do\n"
"				local r={idx=i}\n"
"				sounds.queues[i]=r\n"
"\n"
"				r.push=function(qq,t)\n"
"					if not t then -- pass in an empty table if you just want it filled\n"
"						t={}\n"
"						qq.stack[#qq.stack+1]=t\n"
"					end\n"
"						\n"
"					for i,v in pairs(qq) do -- copy state into stack\n"
"						t[i]=v\n"
"					end\n"
"\n"
"					return t\n"
"				end\n"
"				r.pop=function(qq,t)\n"
"					local t=t or qq.stack[#qq.stack] -- from the top of the stack or a given table\n"
"					if not t then return end -- ignore bad pops\n"
"					qq.stack[#qq]=nil\n"
"					\n"
"					for i,v in pairs(qq) do -- clear current state\n"
"						qq[i]=nil\n"
"					end\n"
"					for i,v in pairs(t) do -- copy state from stack\n"
"						qq[i]=v\n"
"					end\n"
"\n"
"				end\n"
"				r.clear=function(qq)\n"
"					qq.stack={}\n"
"				end\n"
"				r:clear()\n"
"\n"
"				r.stream_ogg=function(qq,d)\n"
"					local str=sounds.strs[qq.idx]\n"
"					\n"
"					if d.mode==\"stop\" then\n"
"					\n"
"						qq.state=nil\n"
"						qq.ogg_loop=false\n"
"						qq.og=false\n"
"						qq.oggs=nil\n"
"						\n"
"					else\n"
"						\n"
"						qq.ogg_loop=true\n"
"						qq.state=\"play_queue\"\n"
"						if not qq.oggs then\n"
"							qq.oggs={d.name}\n"
"						end\n"
"						if d.mode==\"restart\" then -- force a restart of the ogg\n"
"							qq.og=false\n"
"							qq.oggs={d.name}\n"
"							al.SourceStop(str.source)\n"
"						else -- otherwise continue playing what we already are if we can\n"
"							if #qq.oggs==1 and qq.oggs[1]==d.name then -- nothing to change\n"
"							else\n"
"								qq.og=false\n"
"								qq.oggs={d.name}\n"
"								al.SourceStop(str.source)\n"
"							end\n"
"						end\n"
"					end\n"
"				end\n"
"			end\n"
"		end\n"
"\n"
"		for v,n in pairs(sounds.remember or {}) do\n"
"			if type(v)==\"table\" then\n"
"				sounds.load_speak(v,n)\n"
"			else\n"
"				sounds.load(v,n)\n"
"			end\n"
"		end\n"
"		sounds.remember=nil\n"
"	end\n"
"end\n"
"\n"
"sounds.stop = function()\n"
"\n"
"	sounds.remember={}\n"
"	\n"
"	for n,t in pairs(sounds.data) do\n"
"		\n"
"		sounds.remember[t.filename]=n		\n"
"		sounds.unload(n)\n"
"\n"
"	end\n"
"\n"
"	for i,v in pairs(sounds.sfxs) do\n"
"		al.DeleteSource(v.source)\n"
"	end\n"
"	sounds.sfxs={}\n"
"	for i,v in pairs(sounds.strs) do\n"
"		al.DeleteSource(v.source)\n"
"	end\n"
"	sounds.strs={}\n"
"\n"
"	sounds.context:clean()\n"
"\n"
"	sounds.context=nil\n"
"end\n"
"\n"
"\n"
"sounds.update = function()\n"
"\n"
"	for i,v in ipairs(sounds.strs) do\n"
"		v:update()\n"
"	end\n"
"\n"
"end\n"
"\n"
"local dbgfp\n"
"\n"
"function str_func.fill(str,b)\n"
"\n"
"local qq=sounds.queues[str.idx]\n"
"\n"
"	if qq.talks and qq.talks[1] then\n"
"	\n"
"--	al.Source(str.source, al.GAIN, 1)\n"
"	\n"
"		local wspeak=require(\"wetgenes.speak\")\n"
"		local voice=qq.voice or {} -- make sure we have a voide\n"
"\n"
"		local t=table.remove(qq.talks,1)\n"
"		wspeak.voice(voice)\n"
"		local dat,len=wspeak.text(t)\n"
"		al.BufferData(b,al.FORMAT_MONO16,dat,len,0x4000 )--this depends on the voice used\n"
"		qq.pitch=voice.pitch -- use the pitch from the voice\n"
"		return true\n"
"		\n"
"	elseif qq.oggs then\n"
"--do return false end	\n"
"		\n"
"		if not qq.og and qq.oggs[1] then\n"
"			local ogg=require(\"wetgenes.ogg\")\n"
"			local fnam=table.remove(qq.oggs,1)\n"
"			if qq.fname~=fnam then -- need reload only if the off changes?\n"
"-- streaming from within a zip seems to fuckup, possibly having multiple files of a zip open is the problem?\n"
"-- reading it all in at once fixed this			\n"
"				qq.fname=fnam\n"
"				qq.fpdat=zips.readfile(\"data/\"..qq.fname..\".ogg\")\n"
"			end\n"
"			qq.fpidx=1\n"
"			qq.fpsiz=#qq.fpdat\n"
"			qq.og=ogg.create()\n"
"			qq.og:open()\n"
"		end\n"
"		\n"
"		if qq.og then\n"
"--			local rr\n"
"			local function save(f)\n"
"				if qq.rr then\n"
"--print(\"buff\",#qq.rr)\n"
"					local fmt=al.FORMAT_MONO16\n"
"					if qq.og.channels==2 then fmt=al.FORMAT_STEREO16 end\n"
"					local rate=qq.og.rate\n"
"					if qq.BufferData then -- special munge callback function\n"
"						qq.BufferData(b,fmt,qq.rr,#qq.rr,rate) -- C4 hopefully?\n"
"					else\n"
"						al.BufferData(b,fmt,qq.rr,#qq.rr,rate) -- C4 hopefully?\n"
"					end\n"
"					qq.rr=nil\n"
"				end\n"
"			end\n"
"			local function done(f)\n"
"--				save() -- save what we have\n"
"				if qq.ogg_loop then\n"
"					qq.oggs[#qq.oggs+1]=qq.fname -- insert ogg back into the end of the list\n"
"				end\n"
"				qq.og:close()\n"
"				qq.og=nil -- flag end of file\n"
"				return f\n"
"			end\n"
"			for i=1,128 do -- may take a few loops before we can return any data\n"
"				local r=qq.og:pull()\n"
"				if not r then\n"
"					if qq.og.err==\"push\" or qq.og.err==\"end\" then\n"
"--print(qq.fpidx , #qq.fpdat , qq.og.err)\n"
"						if qq.fpidx<#qq.fpdat then -- not the end, squirt some more data in\n"
"							local dat=string.sub(qq.fpdat,qq.fpidx,qq.fpidx+4096-1)\n"
"							qq.fpidx=qq.fpidx+4096\n"
"							qq.og:push(dat)\n"
"						elseif qq.og.err==\"end\" then -- really really the end\n"
"							return done(false)\n"
"						end\n"
"					elseif qq.og.err then error( qq.og.err ) end\n"
"				else\n"
"--print(#r,qq.og.err)\n"
"					if not qq.rr then qq.rr=r else qq.rr=qq.rr..r end\n"
"\n"
"					if #qq.rr>=4096*8 then -- prefer a reasonable chunk of data\n"
"						save()\n"
"						if qq.og.err then error( qq.og.err ) end\n"
"						return true\n"
"					end\n"
"					\n"
"				end\n"
"			end\n"
"		end\n"
"\n"
"	end\n"
"end\n"
"\n"
"-- default stream update func\n"
"function str_func.update(str)\n"
"local qq=sounds.queues[str.idx]\n"
"\n"
"-- remove finished buffers\n"
"	local processed=al.GetSource(str.source,al.BUFFERS_PROCESSED)\n"
"	for i=1,processed do\n"
"		local b=al.SourceUnqueueBuffer(str.source)\n"
"		local idx\n"
"		for i,v in ipairs(str.full) do -- find and remove, it should be the first one.\n"
"			if v==b then idx=i break end\n"
"		end\n"
"		assert(idx)\n"
"		table.remove(str.full,idx)\n"
"		table.insert(str.empty,b)\n"
"--print(\"unqueue \",b,idx)\n"
"	end\n"
"\n"
"	while str.empty[1] do -- fill the empty queue\n"
"		local b=str.empty[1]\n"
"		if str:fill(b) then\n"
"			al.SourceQueueBuffer(str.source,b)	\n"
"--print(\"queue \",b)\n"
"--al.CheckError()\n"
"			table.remove(str.empty,1)\n"
"			table.insert(str.full,b)\n"
"		else\n"
"			break\n"
"		end\n"
"	end\n"
"	\n"
"	if qq.state==\"play_queue\" and str.full[1] then -- start to play whenever we have a buffer filled\n"
"		local astate=al.GetSource(str.source, al.SOURCE_STATE)\n"
"		if astate ~= al.PLAYING then\n"
"--print(\"astate\",astate)\n"
"			al.SourceStop(str.source)\n"
"			al.SourcePlay(str.source)\n"
"		end\n"
"	end\n"
"\n"
"--update every frame\n"
"	al.Source(str.source, al.GAIN, (qq.gain or 1) * sounds.vol_stream )\n"
"	al.Source(str.source, al.PITCH, qq.pitch or 1)\n"
"\n"
"end\n"
"\n"
"\n"
"\n"
"	if opts.disable_sounds then -- disable all function in this file\n"
"		for n,v in pairs(sounds) do\n"
"			if type(v)==\"function\" then\n"
"				sounds[n]=function() end\n"
"			end\n"
"		end\n"
"		sounds.queues={{},{}}\n"
"		sounds.disabled=true\n"
"	end\n"
"\n"
"	return sounds\n"
"end\n"
"\n"
"\n"
"",

"wetgenes.spew.comm","\n"
"\n"
"\n"
"local table=table\n"
"local ipairs=ipairs\n"
"local string=string\n"
"local math=math\n"
"local os=os\n"
"local print=print\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"--\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"module(\"spew.comm\")\n"
"\n"
"\n"
"-- all connections look up by client\n"
"cons=cons or {}\n"
"\n"
"-- waiting with data to read\n"
"active=active or {}\n"
"\n"
"-- create table of connections for use in socket.select\n"
"recvt=recvt or {}\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- create a con for this client\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function setup(client,opts)\n"
"\n"
"	if not client then return nil end\n"
"	\n"
"opts=opts or {}\n"
"\n"
"	local con={}\n"
"	cons[client]=con\n"
"	\n"
"	con.client=client\n"
"	con.format=opts.format\n"
"	con.linein={} -- lines come in here\n"
"	con.msg={} -- our current incoming msg for spew communication deltas\n"
"\n"
"-- keep a table for connect to use\n"
"	local n=#recvt+1\n"
"	recvt[n]=client\n"
"	recvt[client]=n\n"
"\n"
"	client:settimeout(0.00001) -- this is a hack fix?\n"
"	\n"
"	return con\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- remove this client from active clients, destroying the con\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function clean(client)\n"
"\n"
"local con=cons[client]\n"
"\n"
"	client:close()\n"
"	\n"
"	local n=recvt[client]\n"
"	recvt[client]=nil\n"
"	table.remove(recvt,n)\n"
"	\n"
"	cons[client]=nil\n"
"	active[client]=nil\n"
"\n"
"	return con\n"
"end\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- get con from client\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function con(client)\n"
"	return cons[client]\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- client connect\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function connected(client,format)\n"
"\n"
"local con=cons[client]\n"
"\n"
"	client:settimeout(0.00001) -- this is a hack fix?\n"
"\n"
"	return con\n"
"end\n"
"				\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- client disconnect\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function disconnect(client)\n"
"	return clean(client)\n"
"end\n"
"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- send a line to a client\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function send(client,line)\n"
"\n"
"local con=cons[client]\n"
"\n"
"	if ( not client ) or ( not line ) or ( not con ) then return end\n"
"	\n"
"	if line~=\"\" then\n"
"	\n"
"		client:send(line)\n"
"		\n"
"--print(line)\n"
"\n"
"	end\n"
"\n"
"	return con\n"
"end\n"
"\n"
"	\n"
"-----------------------------------------------------------------------------\n"
"--\n"
"-- receive some data from a client\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"function received(client,line)\n"
"\n"
"local con=cons[client]\n"
"\n"
"local line_term=\"\\0\" -- spew default\n"
"\n"
"	if con.format==\"spew\" then -- default\n"
"--		line_term=\"\\0\"\n"
"	elseif con.format==\"telnet\" then -- break on \\n"
" not \\0\n"
"		line_term=\"\\n"
"\"\n"
"	elseif con.format==\"irc\" then -- break on \\n"
" not \\0\n"
"		line_term=\"\\n"
"\"\n"
"	elseif con.format==\"websocket\" then -- break on \\255 not \\0\n"
"		line_term=\"\\255\"\n"
"	end\n"
"	\n"
"	if con.lineparts then -- continue our cache\n"
"	\n"
"		con.lineparts=con.lineparts..line			\n"
"		\n"
"	else -- start new cache\n"
"	\n"
"		con.lineparts=line\n"
"		\n"
"	end\n"
"	\n"
"	if string.len(con.lineparts)>16384 then -- catch large packets\n"
"		return clean(client) -- and close connection on spam\n"
"	end\n"
"	\n"
"	local zero,linepart\n"
"	\n"
"	zero=string.find(con.lineparts,line_term)\n"
"	\n"
"	while zero do -- we have a command or more to split up\n"
"	\n"
"		if zero>1 then\n"
"		\n"
"			linepart=string.sub(con.lineparts,1,zero-1) -- command\n"
"			con.lineparts=string.sub(con.lineparts,zero+1) -- remainder\n"
"		\n"
"			table.insert(con.linein,linepart) -- handle this line later\n"
"		else\n"
"			con.lineparts=string.sub(con.lineparts,zero+1) -- remainder\n"
"		end\n"
"		\n"
"		zero=string.find(con.lineparts,line_term)\n"
"	end\n"
"\n"
"	if con.linein[1] then active[client]=con end -- flag the connection as waiting\n"
"\n"
"	return con\n"
"end\n"
"\n"
"\n"
"\n"
"",


0,0};

