/*+-----------------------------------------------------------------------------------------------------------------+*/
//
// (C) Kriss Daniels 2003 http://www.XIXs.com
//
/*+-----------------------------------------------------------------------------------------------------------------+*/
#include "all.h"





/*+-----------------------------------------------------------------------------------------------------------------+*/
//
// allocate a stream
//
/*+-----------------------------------------------------------------------------------------------------------------+*/
bool t3d_stream::setup(struct thunk3d *_thunk3d)
{
	DMEM_ZERO(this);

	master=_thunk3d;

	DHEAD_INIT(keys);

	return true;
}

/*+-----------------------------------------------------------------------------------------------------------------+*/
//
// reset a stream
//
/*+-----------------------------------------------------------------------------------------------------------------+*/
bool t3d_stream::reset(void)
{
thunk3d *_thunk3d;

	_thunk3d=master;

	clean();
	return setup(_thunk3d);
}

/*+-----------------------------------------------------------------------------------------------------------------+*/
//
// free a stream
//
/*+-----------------------------------------------------------------------------------------------------------------+*/
void t3d_stream::clean(void)
{

t3d_key	*key,*keynext;

	for( key=keys->first ; keynext=key->next ; key=keynext )
	{
		master->FreeKey(key);
	}

}

/*+-----------------------------------------------------------------------------------------------------------------+*/
//
// allocate an stream
//
/*+-----------------------------------------------------------------------------------------------------------------+*/
t3d_stream *thunk3d::AllocStream(void)
{
t3d_stream *ret;


	if(!(ret=(t3d_stream *)streams->alloc()))
	{
		DBG_Error("Failed to allocate thunk3D.stream.\n");
		goto bogus;
	}

	if(!ret->setup(this))
	{
		DBG_Error("Failed to setup thunk3D.stream.\n");
		goto bogus;
	}

	DLIST_PASTE(streams->atoms->last,ret,0);

	return ret;

bogus:
	FreeStream(ret);
	return 0;
}

/*+-----------------------------------------------------------------------------------------------------------------+*/
//
// free an stream
//
/*+-----------------------------------------------------------------------------------------------------------------+*/
void thunk3d::FreeStream(t3d_stream *stream)
{
	if(stream)
	{
		DLIST_CUT(stream);

		stream->clean();

		streams->free((llatom*)stream);
	}
}


/*+-----------------------------------------------------------------------------------------------------------------+*/
//
// find a key
//
/*+-----------------------------------------------------------------------------------------------------------------+*/
t3d_key *t3d_stream::find_key(s32 index)
{
t3d_key *key;
s32 i;

// first try to find

	for( key=keys->first , i=0 ; key->next ; key=key->next , i++ )
	{
		if( i==index )
		{
			return key;
		}
	}

	return 0;
}
/*+-----------------------------------------------------------------------------------------------------------------+*/
//
// sort the keys by their time value
//
/*+-----------------------------------------------------------------------------------------------------------------+*/
void t3d_stream::sort_keys(void)
{
t3d_key *key;
t3d_key *key_next;
t3d_key *key_prev;

	for( key=keys->first ; (key_next=key->next) ; key=key_next )
	{
		for( key_prev=key->prev ; key_prev->prev ; key_prev=key_prev->prev )
		{
			if(key_prev->time <= key->time) // as far as we go, insert here
			{
				break;
			}
		}
		DLIST_CUTPASTE(key_prev,key,0);
	}
}
/*+-----------------------------------------------------------------------------------------------------------------+*/
//
// re ID all keys
//
/*+-----------------------------------------------------------------------------------------------------------------+*/
void t3d_stream::reID_keys(void)
{
t3d_key *key;
s32 i;

	for( key=keys->first , i=0 ; key->next ; key=key->next , i++ )
	{
		key->id=i;
	}
}
/*+-----------------------------------------------------------------------------------------------------------------+*/
//
// remove all keys
//
/*+-----------------------------------------------------------------------------------------------------------------+*/
void t3d_stream::delete_keys(void)
{
t3d_key *key;
t3d_key *key_next;

	for( key=keys->first ; (key_next=key->next) ; key=key_next )
	{
		master->FreeKey(key);
	}

	numof_keys=0;

}
