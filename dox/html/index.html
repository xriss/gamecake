<html>
	<head>
		<link rel='stylesheet' href='dox.css' />
		<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/sunburst.min.css">
		<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>
	<body>
<h1><a href="index.html">index</a></h1><h1><a href="wetgenes.html">wetgenes</a></h1>
<div>

<pre><code>local wetgenes=require("wetgenes")
</code></pre>

<p>Simple generic functions that are intended to be useful for all 
wetgenes.* modules.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.html">wetgenes.chipmunk</a></h1>
<div>

<pre><code>local chipmunk=require("wetgenes.chipmunk")
</code></pre>

<p>We use chipmunk as the local name of this library.</p>

<p>A lua binding to the Chipmunk2D physics library https://chipmunk-physics.net/</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.arbiter.ignore.html">wetgenes.chipmunk.arbiter.ignore</a></h1>
<div>

<pre><code>return arbiter:ignore()
</code></pre>

<p>Ignore this collision, from now until the shapes separate.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.arbiter.points.html">wetgenes.chipmunk.arbiter.points</a></h1>
<div>

<pre><code>points=arbiter:points()
points=arbiter:points(points)
</code></pre>

<p>Get and/or Set the points data for this arbiter.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.arbiter.surface_velocity.html">wetgenes.chipmunk.arbiter.surface_velocity</a></h1>
<div>

<pre><code>vx,vy=arbiter:surface_velocity()
vx,vy=arbiter:surface_velocity(vx,vy)
</code></pre>

<p>Get and/or Set the surface velocity for this arbiter.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.body.html">wetgenes.chipmunk.body</a></h1>
<div>

<pre><code>body=chipmunk.body(mass,inertia)
</code></pre>

<p>Create a dynamic body, with the given mass and inertia.</p>

<p>You will need to add the body to a space before it exists so it is 
normally preferable to use the space:body function which will call this 
function and then automatically add the body into the space.</p>

<pre><code>body=chipmunk.body("kinematic")
</code></pre>

<p>Create a kinematic body, these are bodies that we can move around, by 
setting its velocity, but are not effected by collisions with other 
bodies. EG a moving platform.</p>

<pre><code>body=chipmunk.body("static")
</code></pre>

<p>Create a static body, mostly you can just use space.static as the 
default static body but you may create more if you wish to group your 
static shapes into multiple bodies.</p>



</div><hr/>
<h1><a href="wetgenes.chipmunk.body.angle.html">wetgenes.chipmunk.body.angle</a></h1>
<div>

<pre><code>a=body:angle()
a=body:angle(a)
</code></pre>

<p>Get and/or Set the rotation angle in radians for this body.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.body.angular_velocity.html">wetgenes.chipmunk.body.angular_velocity</a></h1>
<div>

<pre><code>a=body:angular_velocity()
a=body:angular_velocity(a)
</code></pre>

<p>Get and/or Set the angular velocity in radians for this body.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.body.apply_force.html">wetgenes.chipmunk.body.apply_force</a></h1>
<div>

<pre><code>body:apply_force(fx,fy,px,py)
body:apply_force(fx,fy,px,py,"world")
</code></pre>

<p>Apply a force to this body at a specific point, the point can be in 
world coordinates if you include the "world" flag but defaults to local 
object coordinates.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.body.apply_impulse.html">wetgenes.chipmunk.body.apply_impulse</a></h1>
<div>

<pre><code>body:apply_impulse(ix,iy,px,py)
body:apply_impulse(ix,iy,px,py,"world")
</code></pre>

<p>Apply a force to this body at a specific point, the point can be in 
world coordinates if you include the "world" flag but defaults to local 
object coordinates.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.body.force.html">wetgenes.chipmunk.body.force</a></h1>
<div>

<pre><code>vx,vy=body:force()
vx,vy=body:force(vx,vy)
</code></pre>

<p>Get and/or Set the force for this body. This is reset back to 0 after 
each step.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.body.position.html">wetgenes.chipmunk.body.position</a></h1>
<div>

<pre><code>vx,vy=body:position()
vx,vy=body:position(vx,vy)
</code></pre>

<p>Get and/or Set the position for this body.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.body.position_func.html">wetgenes.chipmunk.body.position_func</a></h1>
<div>

<pre><code>body:position_func(position_callback)
body:position_func()
</code></pre>

<p>Set or clear the position callback update function for this body.</p>

<pre><code>position_callback(body)

body.delta_time
</code></pre>

<p>This callback will be called with the above values set into body, you 
can adjust these and return true to perform a normal position update 
but with these new values.</p>

<p>Alternatively you can update the bodys position directly and return 
false so the normal position update code will not be run.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.body.shape.html">wetgenes.chipmunk.body.shape</a></h1>
<div>

<pre><code>shape=body:shape(form,...)
</code></pre>

<p>Add a new shape to this body, returns the shape for further 
modification.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.body.velocity.html">wetgenes.chipmunk.body.velocity</a></h1>
<div>

<pre><code>vx,vy=body:velocity()
vx,vy=body:velocity(vx,vy)
</code></pre>

<p>Get and/or Set the velocity for this body.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.body.velocity_func.html">wetgenes.chipmunk.body.velocity_func</a></h1>
<div>

<pre><code>body:velocity_func(velocity_callback)
body:velocity_func()
</code></pre>

<p>Set or clear the velocity callback update function for this body.</p>

<pre><code>velocity_callback(body)

body.gravity_x
body.gravity_y
body.damping
body.delta_time
</code></pre>

<p>This callback will be called with the above values set into body, you 
can adjust these and return true to perform a normal velocity update 
but with these new values.</p>

<p>IE you can choose a new gravity vector for this body which is the 
simplest change to make.</p>

<p>Alternatively you can update the bodys velocity directly and return 
false so the normal velocity update code will not be run.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.constraint.html">wetgenes.chipmunk.constraint</a></h1>
<div>

<pre><code>constraint=chipmunk.constraint(abody,bbody,form,...)
</code></pre>

<p>Create a constraint between two bodies.</p>

<p>You will need to add the constraint to a space before it has any effect 
so it is normally preferable to use the space:constraint function which 
will call this function and then automatically add the constraint into 
the space.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.shape.html">wetgenes.chipmunk.shape</a></h1>
<div>

<pre><code>shape=chipmunk.shape(body,form...)
</code></pre>

<p>Create a shape, added to the given body. Shapes are always added to a 
body but must be added to a space before they have any effect. So it is 
normally preferable to use the body:shape function which will 
automatically add the shape into the space that the body belongs to.</p>

<pre><code>shape=chipmunk.shape(space.static,form...)
</code></pre>

<p>Create a static shape in world space. We use space.static as the body. </p>

<pre><code>shape=chipmunk.shape(body,"circle",radius,x,y)
</code></pre>

<p>Form of "circle" needs a radius and a centre point.</p>

<pre><code>shape=chipmunk.shape(body,"segment",ax,ay,bx,by,radius)
</code></pre>

<p>Form of "segment" needs two points and a radius.</p>

<pre><code>shape=chipmunk.shape(body,"poly",...)
</code></pre>

<p>Form of "poly" is not wired up to anything yet but probably a stream of 
points?</p>

<pre><code>shape=chipmunk.shape(body,"box",minx,miny,maxx,maxy,radius)
</code></pre>

<p>Form of "box" needs two points for opposite corners, lowest pair 
followed by highest pair and a radius. The radius should be 0 unless 
you want rounded corners</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.shape.bounding_box.html">wetgenes.chipmunk.shape.bounding_box</a></h1>
<div>

<pre><code>min_x,min_y,max_x,max_y=shape:bounding_box()
</code></pre>

<p>Get the current bounding box for this shape.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.shape.collision_type.html">wetgenes.chipmunk.shape.collision_type</a></h1>
<div>

<pre><code>f=shape:collision_type()
f=shape:collision_type(f)
</code></pre>

<p>Get and/or Set the collision type for this shape.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.shape.elasticity.html">wetgenes.chipmunk.shape.elasticity</a></h1>
<div>

<pre><code>f=shape:elasticity()
f=shape:elasticity(f)
</code></pre>

<p>Get and/or Set the elasticity for this shape.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.shape.filter.html">wetgenes.chipmunk.shape.filter</a></h1>
<div>

<pre><code>f=shape:filter()
f=shape:filter(f)
</code></pre>

<p>Get and/or Set the filter for this shape.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.shape.friction.html">wetgenes.chipmunk.shape.friction</a></h1>
<div>

<pre><code>f=shape:friction()
f=shape:friction(f)
</code></pre>

<p>Get and/or Set the friction for this shape.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.shape.radius.html">wetgenes.chipmunk.shape.radius</a></h1>
<div>

<pre><code>radius=shape:radius()
radius=shape:radius(radius)
</code></pre>

<p>Get and/or Set the radius for this shape. Setting is unsafe and may 
break the physics simulation.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.shape.surface_velocity.html">wetgenes.chipmunk.shape.surface_velocity</a></h1>
<div>

<pre><code>vx,vy=shape:surface_velocity()
vx,vy=shape:surface_velocity(vx,vy)
</code></pre>

<p>Get and/or Set the surface velocity for this shape.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.space.html">wetgenes.chipmunk.space</a></h1>
<div>

<pre><code>space=chipmunk.space()
</code></pre>

<p>Create the space you will be simulating physics in.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.space.add.html">wetgenes.chipmunk.space.add</a></h1>
<div>

<pre><code>space:add(body)
space:add(shape)
space:add(constraint)
</code></pre>

<p>Add a body/shape/constraint to the space.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.space.add_handler.html">wetgenes.chipmunk.space.add_handler</a></h1>
<div>

<pre><code>space:add_handler(handler,id1,id2)
space:add_handler(handler,id1)
space:add_handler(handler)
</code></pre>

<p>Add collision callback handler, for the given collision types.</p>

<p>The handler table will have other values inserted in it and will be 
used as an arbiter table in callbacks. So <em>always</em> pass in a new one to 
this function. There does not seem to be a way to free handlers so be 
careful what you add.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.space.body.html">wetgenes.chipmunk.space.body</a></h1>
<div>

<pre><code>space:body(...)
</code></pre>

<p>Create and add this body to the space.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.space.collision_bias.html">wetgenes.chipmunk.space.collision_bias</a></h1>
<div>

<pre><code>v=space:collision_bias()
v=space:collision_bias(v)
</code></pre>

<p>Get and/or Set the colision bias for this space.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.space.collision_slop.html">wetgenes.chipmunk.space.collision_slop</a></h1>
<div>

<pre><code>v=space:collision_slop()
v=space:collision_slop(v)
</code></pre>

<p>Get and/or Set the colision slop for this space.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.space.constraint.html">wetgenes.chipmunk.space.constraint</a></h1>
<div>

<pre><code>space:constraint(...)
</code></pre>

<p>Create and add this constraint to the space.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.space.contains.html">wetgenes.chipmunk.space.contains</a></h1>
<div>

<pre><code>space:contains(body)
space:contains(shape)
space:contains(constraint)
</code></pre>

<p>Does the space contain this body/shape/constraint, possibly superfluous 
as we can check our own records.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.space.damping.html">wetgenes.chipmunk.space.damping</a></h1>
<div>

<pre><code>v=space:damping()
v=space:damping(v)
</code></pre>

<p>Get and/or Set the damping for this space.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.space.gravity.html">wetgenes.chipmunk.space.gravity</a></h1>
<div>

<pre><code>vx,vy=space:gravity()
vx,vy=space:gravity(vx,vy)
</code></pre>

<p>Get and/or Set the gravity vector for this space.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.space.iterations.html">wetgenes.chipmunk.space.iterations</a></h1>
<div>

<pre><code>v=space:iterations()
v=space:iterations(v)
</code></pre>

<p>Get and/or Set the iterations for this space.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.space.remove.html">wetgenes.chipmunk.space.remove</a></h1>
<div>

<pre><code>space:remove(body)
space:remove(shape)
space:remove(constraint)
</code></pre>

<p>Remove a body/shape/constraint from this space.</p>


</div><hr/>
<h1><a href="wetgenes.chipmunk.space.step.html">wetgenes.chipmunk.space.step</a></h1>
<div>

<pre><code>space:step(time)
</code></pre>

<p>Run the simulation for time in seconds. EG 1/60.</p>


</div><hr/>
<h1><a href="wetgenes.export.html">wetgenes.export</a></h1>
<div>

<pre><code>... = wetgenes.export(table,...)
</code></pre>

<p>Export multiple names from this table as multiple returns, can be 
used to pull functions out of this module and into locals like so</p>

<pre><code>local export,lookup,set_env=require("wetgenes"):export("export","lookup","set_env")
</code></pre>

<p>Or copy it into other modules to provide them with the same functionality.</p>

<pre><code>M.lookup=require("wetgenes").lookup
</code></pre>


</div><hr/>
<h1><a href="wetgenes.gamecake.oven.html">wetgenes.gamecake.oven</a></h1>
<div>

<pre><code>oven=require("wetgenes.gamecake.oven").bake(opts)
</code></pre>

<p>The oven module must be baked so only exposes a bake function.</p>

<p>All the other functions are returned from within the bake function.</p>

<p>possible ENV settings</p>

<pre><code>gamecake_tongue=english
gamecake_flavour=sdl
</code></pre>


</div><hr/>
<h1><a href="wetgenes.gamecake.oven.bake.html">wetgenes.gamecake.oven.bake</a></h1>
<div>


<pre><code>oven=wetgenes.gamecake.oven.bake(opts)
</code></pre>

<p>Bake creates an instance of a lua module bound to a state. Here we 
are creating the main state that other modules will then bind to.</p>

<p>We call each state an OVEN to fit into the gamecake naming scheme 
then we bake a module in this oven to bind them to the common state.</p>

<p>Think of it as a sub version of require, so require gets the global 
pointer for a module and bake is used to get the a module bound to 
an oven.</p>

<p>By using this bound state we reduce the verbosity of connecting 
modules and sharing state between them.</p>



</div><hr/>
<h1><a href="wetgenes.gamecake.widgets.html">wetgenes.gamecake.widgets</a></h1>
<div>


<pre><code>widgets=require("wetgenes.gamecake.widgets").bake(oven,widgets)
</code></pre>


<p>The widgets value returned will be the same table passed in or a new 
one if you did not. It will be filled with functions/data bound to 
the oven state which you must supply.</p>


<p>A collection of widgets, rendered using gles2 code and controlled 
using the mouse, keyboard or a joystick. EG click fire and move 
left/right to adjust a slider value.</p>

<p>This has undergone a number of rewrites as we try to simplify the 
widget creation and layout process. Eventually we ended up with a 
fixed size system of widget placement so every widget must have a 
known size in advance, however we allow scaling to occur so for 
instance building a 256x256 widget does not mean that it has to be 
displayed at 256x256 it just means it will be square.</p>

<p>The basic layout just lets you place these widgets in other widgets 
as left to right lines. So as long as you get your sizes right you 
can easily place things just using a list and without keeping track 
of the current position.</p>

<p>Other layout options are available, such as absolute positioning for 
full control and we have simple custom skin versions of the buttons 
as well rather than the built in skins.</p>

<p>All value data is handled by data structures that contain ranges and 
resolutions for data allowing the same data to be bound to multiple 
display widgets. For instance the same data can be linked to the 
position of a slider as well as the content of a text display. I 
think the kids call this sort of thing an MVC pattern but that's a 
terribly dull name.</p>

<p>Swanky paint is probably the most advanced used of the widgets so far
but I suspect we will be making a simple text editor in the near 
future. Designed for advanced in game tweaking of text files.</p>



</div><hr/>
<h1><a href="wetgenes.grd.html">wetgenes.grd</a></h1>
<div>

<pre><code>local wgrd=require("wetgenes.grd")
</code></pre>

<p>We use wgrd as the local name of this library.</p>

<p>Handle bitmap creation, loading, saving and blitting. The bitmap and 
the colormap for indexed bitmaps are represented by the same data 
structure which describes a continuous chunk of memory with optional 
ability to select an area of a larger chunk using simple byte spans.</p>

<p>Swanky Paint uses this to manage its bitmaps and its also used to 
convert art into data at build time for use in the GameCake engine. The 
PageCake engine uses this for image management, creating live thumbnails 
and so on.</p>

<p>We load and save jpeg, png and gif. The png lib contains extensions for 
apng which allows animation chunks. Animations are contained in the Z 
(depth) dimension of the grd.</p>

<p>The following are possible format options that we support. Most of them 
are OpenGL friendly.</p>

<pre><code>wgrd.FMT_U8_RGBA
</code></pre>

<p>32 bits per pixel with a byte order of red, green, blue, alpha and a 
little endian U32 of ABGR. We prefer this byte order because OpenGL.</p>

<pre><code>wgrd.FMT_U8_ARGB
</code></pre>

<p>32 bits per pixel with a byte order of alpha, red, green, blue and a 
little endian U32 of BGRA.</p>

<pre><code>wgrd.FMT_U8_RGB
</code></pre>

<p>24 bits per pixel with a byte order of red, green, blue.</p>

<pre><code>wgrd.FMT_U8_INDEXED
</code></pre>

<p>8 bits per pixel which indexes a wgrd.FMT<em>U8</em>RGBA palette.</p>

<pre><code>wgrd.FMT_U8_LUMINANCE
</code></pre>

<p>8 bits per pixel, grey scale only.</p>

<pre><code>wgrd.FMT_U8_ALPHA
</code></pre>

<p>8 bits per pixel, alpha only.</p>

<pre><code>wgrd.FMT_U16_RGBA_5551
</code></pre>

<p>16 bits per pixel with 5 bits each of red,green,blue and 1 bit of alpha 
packed into a single U16.</p>

<pre><code>wgrd.FMT_U16_RGBA_4444
</code></pre>

<p>16 bits per pixel with 4 bits each of red,green,blue,alpha packed into 
a single U16.</p>

<pre><code>wgrd.FMT_U16_RGBA_5650
</code></pre>

<p>16 bits per pixel with 4 bits of red, 5 bits of green and 4 bits of 
blue packed into a single U16.</p>


<pre><code>wgrd.FMT_U8_RGBA_PREMULT
wgrd.FMT_U8_ARGB_PREMULT
wgrd.FMT_U8_INDEXED_PREMULT
wgrd.FMT_U16_RGBA_5551_PREMULT
wgrd.FMT_U16_RGBA_4444_PREMULT
wgrd.FMT_U16_RGBA_5650_PREMULT
</code></pre>

<p>Are all just pre-multiplied alpha versions of the base format described 
above.</p>

<p>Check this link out for why pre-multiplied alpha is a good idea for any 
image that will be used as a texture 
http://blogs.msdn.com/b/shawnhar/archive/2009/11/06/premultiplied-alpha.aspx</p>


<pre><code>wgrd.GRD_FMT_HINT_PNG
wgrd.GRD_FMT_HINT_JPG
wgrd.GRD_FMT_HINT_GIF
</code></pre>

<p>These are used to choose a specific file format when loading or saving.</p>


</div><hr/>
<h1><a href="wetgenes.grd.attr_redux.html">wetgenes.grd.attr_redux</a></h1>
<div>

<pre><code>g:attr_redux(cw,ch,num,sub,bak)
</code></pre>

<p>Perform attribute clash simulation on an indexed image.</p>

<p>cw,ch are the width and height of each character we are simulating, 8x8 
is the right size for spectrum attrs but could be 4x8 for c64 multicolor 
mode.</p>

<p>num is the number of colors allowed within this area, so 2 for spectrum mode.</p>

<p>sub is the size of sub pallete groups, eg 16 in nes mode or 8 in 
spectrum mode, EG bright simulation in spectrum mode requires all 
colors in a attr block to be from the bright palette or the dark 
palette no mixing so this forces that grouping. Set to 0 or 256 and 
this restriction will be disabled.</p>

<p>bak is the index of the background color that is shared across all 
characters, set to -1 if there is no shared background color.</p>

<p>Returns nil,error if something goes wrong so can be used with assert 
otherwise returns g so that we can chain the result.</p>


</div><hr/>
<h1><a href="wetgenes.grd.blit.html">wetgenes.grd.blit</a></h1>
<div>

<pre><code>g:blit(gb,x,y,cx,cy,cw,ch)
</code></pre>

<p>Blit a 2D area from one grd into another.</p>

<p>gb is the grd to blit from.</p>

<p>x,y is the location to blit too.</p>

<p>cx,cy,cw,ch is a clip area that should be applied to gb before it is 
blitted. EG to specify an area within gb. If not provided it will 
default to the entirety of gb,</p>

<p>g (destination) must be FMT<em>U8</em>RGBA and gb (source) must be 
FMT<em>U8</em>RGBA_PREMULT this function will blend the images using normal 
alpha blending.</p>

<p>This is not overly optimised but should be reasonably fast.</p>


</div><hr/>
<h1><a href="wetgenes.grd.clear.html">wetgenes.grd.clear</a></h1>
<div>

<pre><code>g:clear(color)
</code></pre>

<p>Fill this grd with a single color, the color passed in depends on the 
format of the grd, it could be an index value for 8bit images or a 
32bit value for rgba images.</p>

<p>Returns nil,error if something goes wrong so can be used with assert 
otherwise returns g so that we can chain the result.</p>


</div><hr/>
<h1><a href="wetgenes.grd.clip.html">wetgenes.grd.clip</a></h1>
<div>

<pre><code>gr=g:clip(x,y,z,w,h,d)
</code></pre>

<p>create a clipped window into this grd</p>

<p>the actual data is still stored in the original, so any changes there will effect the newly returned grd</p>

<p>x,y,z are the staring pixel and w,h,d are the width height and depth in pixels.</p>

<p>If you intend to use this clipped area for an extended period of time then you should duplicate this grd once you do this.</p>

<p>This returns a new grd with gr.parent set to g (the original grd)</p>

<p>This is a very shallow dangerous copy and should only really be used for temporary actions.</p>


</div><hr/>
<h1><a href="wetgenes.grd.convert.html">wetgenes.grd.convert</a></h1>
<div>

<pre><code>g:convert(fmt)
</code></pre>

<p>Convert this grd to a new format, eg start with an 8 bit indexed grd 
and convert it to 32 bit like by passing in wgrd.FMT<em>U8</em>RGBA as the fmt.</p>

<p>Returns nil,error if something goes wrong so can be used with assert 
otherwise returns g so that we can chain the result.</p>


</div><hr/>
<h1><a href="wetgenes.grd.copy_data.html">wetgenes.grd.copy_data</a></h1>
<div>

<pre><code>g:copy_data(gb)
</code></pre>

<p>Copy all of the bitmap data from gb into g.</p>


</div><hr/>
<h1><a href="wetgenes.grd.copy_data_layer.html">wetgenes.grd.copy_data_layer</a></h1>
<div>

<pre><code>g:copy_data_layer(gb,z,zb)
</code></pre>

<p>Copy one layer (frame) of the bitmap data from gb into g. z is the 
depth of the layer to copy into zb is the depth of the layer to copy 
from.</p>


</div><hr/>
<h1><a href="wetgenes.grd.create.html">wetgenes.grd.create</a></h1>
<div>

<pre><code>ga=wgrd.create(gb)
</code></pre>

<p>Duplicate the grd.</p>

<pre><code>ga=wgrd.create(format,width,height,depth)
</code></pre>

<p>Create a grd in the given format with the given width height and depth. </p>

<pre><code>ga=wgrd.create(filename,opts)
</code></pre>

<p>Load an image from the file system.</p>

<pre><code>ga=wgrd.create()
</code></pre>

<p>Create a blank grd of 0 dimensions.</p>

<p>This is usually the only wgrd function you would need to call as once you 
have a grd you can use the : calling convention to modify it. The other 
functions will be shown as examples using the : calling convention.</p>

<pre><code>wgrd.create():load(opts)
</code></pre>

<p>For instance could be used if you wish to perform a more esoteric load 
than from the file system.</p>

<p>Returns nil,error if something goes wrong so can be used with assert 
otherwise returns a grd object.</p>


</div><hr/>
<h1><a href="wetgenes.grd.create_convert.html">wetgenes.grd.create_convert</a></h1>
<div>

<pre><code>g:create_convert(fmt)
</code></pre>

<p>Like convert but returns a new grd rather than converting in place.</p>


</div><hr/>
<h1><a href="wetgenes.grd.create_normal.html">wetgenes.grd.create_normal</a></h1>
<div>

<pre><code>gr=g:create_normal()
</code></pre>

<p>convert a greyscale height map  into an rgb normal map using the sobel filter.</p>


</div><hr/>
<h1><a href="wetgenes.grd.destroy.html">wetgenes.grd.destroy</a></h1>
<div>

<pre><code>g:destroy()
</code></pre>

<p>Free the grd and associated memory. This will of course be done 
automatically by garbage collection but you can force it explicitly 
using this function.</p>


</div><hr/>
<h1><a href="wetgenes.grd.duplicate.html">wetgenes.grd.duplicate</a></h1>
<div>

<pre><code>ga = g:duplicate()
</code></pre>

<p>Create a duplicate of this grd and return it.</p>

<p>Returns nil,error if something goes wrong so can be used with assert 
otherwise returns g so that we can chain the result.</p>


</div><hr/>
<h1><a href="wetgenes.grd.flipy.html">wetgenes.grd.flipy</a></h1>
<div>

<pre><code>g:flipy()
</code></pre>

<p>This function flips the image reversing the y axis.</p>

<p>Some image formats and rendering engines like to use upside down images 
so this is rather useful.</p>


<pre><code>g:flipx()
</code></pre>

<p>This function flips the image reversing the x axis.</p>


</div><hr/>
<h1><a href="wetgenes.grd.info.html">wetgenes.grd.info</a></h1>
<div>

<pre><code>g:info()
</code></pre>

<p>This function looks at the userdata stored in g[0] and fills in the g 
table with its values. So it refreshes the width height etc values to 
reflect any changes. This should not need to be called explicitly as it 
is called whenever we change anything.</p>


</div><hr/>
<h1><a href="wetgenes.grd.load.html">wetgenes.grd.load</a></h1>
<div>

<pre><code>g:load(opts)
</code></pre>

<p>Load an image from memory or file system depending on settings in opts.</p>

<pre><code>opts.fmt
</code></pre>

<p>Lets you choose an image format, the strings "jpg","png" or "gif" will 
be converted to the appropriate wgrd.FMT<em>HINT</em>* value.</p>

<pre><code>opts.data
</code></pre>

<p>Flags this as a load from memory and provides the data string to load 
from.</p>

<pre><code>opts.filename
</code></pre>

<p>Flags this as a load the file system and provides the file name to 
open.</p>

<p>Returns nil,error if something goes wrong so can be used with assert 
otherwise returns g so that we can chain the result.</p>


</div><hr/>
<h1><a href="wetgenes.grd.load_data.html">wetgenes.grd.load_data</a></h1>
<div>

<pre><code>g:load_data(datastring,format)
</code></pre>

<p>Load an image from memory.</p>

<p>Returns nil,error if something goes wrong so can be used with assert 
otherwise returns g so that we can chain the result.</p>


</div><hr/>
<h1><a href="wetgenes.grd.load_file.html">wetgenes.grd.load_file</a></h1>
<div>

<pre><code>g:load_file(filename,format)
</code></pre>

<p>Load an image from the file system.</p>

<p>Returns nil,error if something goes wrong so can be used with assert 
otherwise returns g so that we can chain the result.</p>


</div><hr/>
<h1><a href="wetgenes.grd.paint.html">wetgenes.grd.paint</a></h1>
<div>

<pre><code>g:paint(gb,x,y,cx,cy,cw,ch,mode,trans,color)
</code></pre>

<p>Blit a 2D area from one grd into another using dpaint style paint modes.</p>

<p>Both grids must be indexed - FMT<em>U8</em>INDEXED</p>

<p>gb is the grd to blit from.</p>

<p>x,y is the location to blit too.</p>

<p>cx,cy,cw,ch is a clip area that should be applied to gb before it is 
blitted. EG to specify an area within gb. If not provided it will 
default to the entirety of gb,</p>

<p>mode is one of the following</p>

<pre><code>PAINT_MODE_TRANS
</code></pre>

<p>Skip the transparent color.</p>

<pre><code>GRD_PAINT_MODE_COLOR
</code></pre>

<p>Skip the transparent color and make every solid pixel the same color.</p>

<pre><code>GRD_PAINT_MODE_COPY
</code></pre>

<p>Copy the entire area.</p>

<pre><code>GRD_PAINT_MODE_XOR
</code></pre>

<p>XOR the values. (Can be used to find differences in an image)</p>

<pre><code>GRD_PAINT_MODE_ALPHA
</code></pre>

<p>Skip the transparent colors as defined in the palette.</p>


<p>trans is the index of the transparent color, bground color, for use in 
the appropriate modes.</p>

<p>color is the index of the drawing color, foreground color, for use in 
the appropriate modes. </p>


<p>This is not overly optimised but should be reasonably fast.</p>


</div><hr/>
<h1><a href="wetgenes.grd.palette.html">wetgenes.grd.palette</a></h1>
<div>

<pre><code>g:palette(x,w)
g:palette(x,w,"")
g:palette(x,w,tab)
g:palette(x,w,str)
g:palette(x,w,grd)
</code></pre>

<p>These are the same as g:pixels() but refer to the palette information 
which is stored as a 1 pixel high 256 pixel wide rgba image. The use of 
"" to read a string of bytes and passing in either a table of numerical 
values or string of bytes to write into the palette is the same system 
as used with pixels.</p>


</div><hr/>
<h1><a href="wetgenes.grd.pixels.html">wetgenes.grd.pixels</a></h1>
<div>

<pre><code>g:pixels(x,y,w,h)
g:pixels(x,y,z,w,h,d)
</code></pre>

<p>Read the area of pixels as a table of numerical values, the amount of 
numbers you get per pixel <em>depends</em> on the format of the grd.</p>

<pre><code>g:pixels(x,y,w,h,"")
g:pixels(x,y,z,w,h,d,"")
</code></pre>

<p>Read the area of pixels as a string of byte values, the amount of bytes 
you get per pixel <em>depends</em> on the format of the grd. Note the passing 
in of an empty string to indicate that you with to receive a string.</p>

<pre><code>g:pixels(x,y,w,h,tab)
g:pixels(x,y,z,w,h,d,tab)
</code></pre>

<p>Write the area of pixels from a table of numerical values which is 
provided in tab, the amount of numbers you need to provide per pixel 
<em>depends</em> on the format of the grd.</p>

<pre><code>g:pixels(x,y,w,h,str)
g:pixels(x,y,z,w,h,d,str)
</code></pre>

<p>Write the area of pixels from a string of bytes which is provided in 
str, the amount of bytes you need to provide per pixel <em>depends</em> on the 
format of the grd.</p>

<pre><code>g:pixels(x,y,w,h,grd)
g:pixels(x,y,z,w,h,d,grd)
</code></pre>

<p>Write the area of pixels from a grd which is provided in grd. use 
clip/layer functions to select a portion of a larger grd.</p>

<p>As you can see depending on the arguments given this does one of two 
things, read some pixels or write some pixels. The area that is to be 
used is provided first, as a 2d(x,y,w,h) or 3d(x,y,z,w,h,d) area. To 
read or write the entire 2d image or the first frame of an animation 
use (0,0,g.width,g.height)</p>

<p>Returns nil,error if something goes wrong so can be used with assert 
otherwise returns the requested data.</p>


</div><hr/>
<h1><a href="wetgenes.grd.quant.html">wetgenes.grd.quant</a></h1>
<div>

<pre><code>g:quant(num)
</code></pre>

<p>Convert to an 8bit indexed image containing a palette of the requested size.</p>

<p>Returns nil,error if something goes wrong so can be used with assert 
otherwise returns g so that we can chain the result.</p>


</div><hr/>
<h1><a href="wetgenes.grd.remap.html">wetgenes.grd.remap</a></h1>
<div>

<pre><code>ga:remap(gb)
</code></pre>

<p>Fill gb with a remaped version of ga, each pixel is mapped to the closest palette entry.</p>


</div><hr/>
<h1><a href="wetgenes.grd.reset.html">wetgenes.grd.reset</a></h1>
<div>

<pre><code>g:reset()
</code></pre>

<p>Reset the grd which will now be a blank image of 0 dimensions.</p>

<p>Returns nil,error if something goes wrong so can be used with assert 
otherwise returns g so that we can chain the result.</p>


</div><hr/>
<h1><a href="wetgenes.grd.resize.html">wetgenes.grd.resize</a></h1>
<div>

<pre><code>g:resize(w,h,d)
</code></pre>

<p>Resize the image to the given dimensions, this does not scale the image 
data so instead each pixel will be in the same place after the resize. 
This gives a crop effect when shrinking and extra blank area at the 
bottom right when growing. Useful if for instance you want to upload a 
texture to OpenGL and need to change the size to be a power of two in 
width and height so you can mipmap it.</p>


</div><hr/>
<h1><a href="wetgenes.grd.save.html">wetgenes.grd.save</a></h1>
<div>

<pre><code>g:save(opts)
</code></pre>

<p>Save an image to memory or filesytem depending on settings in opts.</p>

<pre><code>opts.fmt
</code></pre>

<p>Lets you choose an image format, the strings "jpg","png" or "gif" will 
be converted to the appropriate wgrd.FMT<em>HINT</em>* value.</p>

<p>We will guess opts.fmt from the file name extension if it is not 
provided and a file name is.</p>

<pre><code>opts.filename
</code></pre>

<p>Flags this as a load the file system and provides the file name to 
write to. If no filename is given then we will be saving into memory 
and be returning that data string as the first return value.</p>

<p>Returns nil,error if something goes wrong so can be used with assert.</p>

<p>If no file name is given then we <em>return</em> the data string that we saved.</p>


</div><hr/>
<h1><a href="wetgenes.grd.scale.html">wetgenes.grd.scale</a></h1>
<div>

<pre><code>g:scale(w,h,d)
</code></pre>

<p>Scale the image to the given dimensions, this is currently using a 
terrible scale filter that is only any good at halving or doubling the 
size.</p>

<p>This should only be used to create mipmaps until it is replaced with a 
better scale filter.</p>


</div><hr/>
<h1><a href="wetgenes.grd.shrink.html">wetgenes.grd.shrink</a></h1>
<div>

<pre><code>g:shrink(area)
</code></pre>

<p>area is an {x=0,y=0,z=0,w=100,h=100,d=100} style table specifying a 3D
area, set {z=0,d=1} for a 2D area.</p>

<p>You should set this to the full size of the image.</p>

<p>This function looks at the pixels in that area and shrinks each edge 
inwards if it is fully transparent then return this new area in the 
same table that was passed in.</p>

<p>You can then use this information to crop this image resulting is a 
smaller sized grd containing all the solid pixels.</p>


</div><hr/>
<h1><a href="wetgenes.grd.stream.html">wetgenes.grd.stream</a></h1>
<div>

<pre><code>stream=g:stream(filename)
stream=g:stream({filename=filename,...})
</code></pre>

<p>Open a GIF stream, returns a table with the following functions,</p>

<pre><code>stream:write(ga)
</code></pre>

<p>Add a frame to the gif, each frame should be the same size and color map.</p>

<pre><code>stream:close(ga)
</code></pre>

<p>Close the stream and finalise the GIF.</p>


</div><hr/>
<h1><a href="wetgenes.grdsvg.html">wetgenes.grdsvg</a></h1>
<div>

<pre><code>wgrdsvg=require("wetgenes.grdsvg")
</code></pre>

<p>Build svg files from grd data (bitmaps)</p>


</div><hr/>
<h1><a href="wetgenes.grdsvg.string.html">wetgenes.grdsvg.string</a></h1>
<div>

<pre><code>local svgstring=wgrdsvg.string(grd,opts)
</code></pre>

<p>Return an svg formated string that represents the input grd which must 
be an indexed (8bit) format. Each pixel will be converted into a filled 
svg rectangle element. Opts can contain the following options to 
control the generation of the svg file.</p>

<pre><code>opts.skip_transparent_pixels=true
</code></pre>

<p>Do not export a rectangle for fully transparent pixels.</p>

<pre><code>opts.scalex=1
</code></pre>

<p>Width of each exported pixel.</p>

<pre><code>opts.scaley=1
</code></pre>

<p>Height of each exported pixel.</p>


</div><hr/>
<h1><a href="wetgenes.json.html">wetgenes.json</a></h1>
<div>

<pre><code>local wjson=require("wetgenes.json")
</code></pre>

<p>other json encode/decode using pure lua library seemed too slow, 
here is a fast and loose one lets see if it goes any faster :) 
should be a direct replacement for JSON4Lua which is what I was 
using before I profiled where all the time was getting spent...</p>

<p>I needed it to be pure json as I was running it on googles appengine so
the lua was actually running in java, no C available.</p>

<p>Anyhow I hope it is useful, in order to get it running faster I cut 
across some corners so you may find some obscure problems.</p>


</div><hr/>
<h1><a href="wetgenes.json.decode.html">wetgenes.json.decode</a></h1>
<div>

<pre><code>json_table = wjson.decode(json_string,opts)
</code></pre>

<p>Convert a json string into a lua table.</p>

<p>Set opts.null to wetgenes.json.null (or indeed any othe value) if 
you would like to have nulls in your results. By default nulls are 
replaced with nil.</p>


</div><hr/>
<h1><a href="wetgenes.json.encode.html">wetgenes.json.encode</a></h1>
<div>

<pre><code>json_string = wjson.encode(json_table)
</code></pre>

<p>Convert a lua table into a json string. Note it must be valid json, 
primarily make sure that the table is either an array or a dictionary 
but never both.</p>

<p>Also some of the internal lua types will cause errors, eg functions 
as these can not be converted into json.</p>

<p>include nulls in the output by using wetgenes.json.null</p>


</div><hr/>
<h1><a href="wetgenes.lookup.html">wetgenes.lookup</a></h1>
<div>

<pre><code>value = wetgenes.lookup(table,...)
</code></pre>

<p>Safe recursive lookup within a table that returns nil if any part of 
the lookup is nil so we never cause an error but just return nil. 
This is intended to replace the following sort of code</p>

<pre><code>a = b and b.c and b.c.d and b.c.d.e
</code></pre>

<p>To get e only if all of its parent bits exist and not to cause any 
error if they do not. instead use</p>

<pre><code>a = lookup(b,"c","d","e")
</code></pre>


</div><hr/>
<h1><a href="wetgenes.package.html">wetgenes.package</a></h1>
<div>

<pre><code>wpackage=require("wetgenes.package")
</code></pre>

<p>Some generic lowlevel functions for messing about with how lua works, 
eg how modules are loaded.</p>


</div><hr/>
<h1><a href="wetgenes.package.reload.html">wetgenes.package.reload</a></h1>
<div>

<pre><code>local module=wpackage.reload(modulename)
</code></pre>

<p>A wrapper for require that forces a very dumb module reload by merging 
a newly loaded module into the old module table if one already exists 
this can easily break everything but should mostly work out of dumb 
luck.</p>


</div><hr/>
<h1><a href="wetgenes.plate.replace_lookup.html">wetgenes.plate.replace_lookup</a></h1>
<div>

<pre><code>value=wetgenes.plate.replace_lookup(name,data)
</code></pre>

<p>Calls "wetgenes.plate.table_lookup" then performs special formatting on 
table returns.</p>

<p>Always returns a string or nil, so number values will converted to a 
string.</p>



</div><hr/>
<h1><a href="wetgenes.plate.replace_lookup_istable.html">wetgenes.plate.replace_lookup_istable</a></h1>
<div>

<pre><code>bool=wetgenes.plate.replace_lookup_istable(name,data)
</code></pre>

<p>Test if the return from "wplate.table_lookup" is a table.</p>



</div><hr/>
<h1><a href="wetgenes.plate.table_lookup.html">wetgenes.plate.table_lookup</a></h1>
<div>

<pre><code>value=wetgenes.plate.table_lookup(name,data)
</code></pre>

<p>look up name inside data and return the value we found if we don't 
find anything then we return nil</p>

<p>name.name.name syntax may be used to reference tables within tables.</p>

<p>A name that looks like a number may be converted into a number if it 
doesnt exist as a string key, so "array.1" can be used to return the 
first item from an array.</p>



</div><hr/>
<h1><a href="wetgenes.set_env.html">wetgenes.set_env</a></h1>
<div>

<pre><code>local _ENV=set_env(new_environment)
</code></pre>

<p>Since setfenv is going away in lua 5.2 here is a plan to future 
proof code that wants to control its own environment</p>

<p>Specifically this is for loading functions sabdboxed into a given 
table, which we need to do from time to time.</p>

<p>we set the environment of the code that called us only if setfenv 
exists and we always return the new environment</p>

<p>So the following incantation can be used to change the current environment and 
it should work exactly the same in lua 5.1 or 5.2</p>

<pre><code>local _ENV=set_env(new_environment)
</code></pre>


</div><hr/>
<h1><a href="wetgenes.snippets.html">wetgenes.snippets</a></h1>
<div>

<pre><code>-- copy all globals into locals, some locals are prefixed with a G to reduce name clashes
local coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,Gload,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require=coroutine,package,string,table,math,io,os,debug,assert,dofile,error,_G,getfenv,getmetatable,ipairs,load,loadfile,loadstring,next,pairs,pcall,print,rawequal,rawget,rawset,select,setfenv,setmetatable,tonumber,tostring,type,unpack,_VERSION,xpcall,module,require

-- grab some util functions
local export,lookup,set_env=require("wetgenes"):export("export","lookup","set_env")

-- single line replacement for the module creation function
local M={} ; package.loaded[(...)]=M ; M.module_name=(...) ; M.export=export
</code></pre>


<p>A place to keep bits of code that needs to be copypasta into most 
modules, for instance above is the current boilerplate code to be 
used when starting a new module.</p>


</div><div id="disqus_thread"></div>
<script type="text/javascript">
	var disqus_shortname = 'gamecake';
	var disqus_identifier = 'index';
	var disqus_title=disqus_identifier;
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
	</body>
</html>
