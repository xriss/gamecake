<html>
	<head>
	</head>
	<body>


<div>

<pre><code>oven=require("wetgenes.gamecake.oven").bake(opts)
</code></pre>

<p>The oven module must be baked so only exposes a bake function.</p>

<p>All the other functions are returned from within the bake function.</p>


</div><hr/>
<div>


<pre><code>oven=wetgenes.gamecake.oven.bake(opts)
</code></pre>

<p>Bake creates an instance of a lua module bound to a state. Here we 
are creating the main state that other modules will then bind to.</p>

<p>We call each state an OVEN to fit into the gamecake naming scheme 
then we bake a module in this oven to bind them to the common state.</p>

<p>Think of it as a sub version of require, so require gets the global 
pointer for a module and bake is used to get the a module bound to 
an oven.</p>

<p>By using this bound state we reduce the verbosity of connecting 
modules and sharing state between them.</p>



</div><hr/>
<div>

<pre><code>value=wetgenes.plate.replace_lookup(name,data)
</code></pre>

<p>Calls "wetgenes.plate.table_lookup" then performs special formatting on 
table returns.</p>

<p>Always returns a string or nil, so number values will converted to a 
string.</p>



</div><hr/>
<div>

<pre><code>bool=wetgenes.plate.replace_lookup_istable(name,data)
</code></pre>

<p>Test if the return from "wplate.table_lookup" is a table.</p>



</div><hr/>
<div>

<pre><code>value=wetgenes.plate.table_lookup(name,data)
</code></pre>

<p>look up name inside data and return the value we found if we don't 
find anything then we return nil</p>

<p>name.name.name syntax may be used to reference tables within tables.</p>

<p>A name that looks like a number may be converted into a number if it 
doesnt exist as a string key, so "array.1" can be used to return the 
first item from an array.</p>



</div>

	</body>
</html>
