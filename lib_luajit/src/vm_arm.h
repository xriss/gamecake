/*
** This file has been pre-processed with DynASM.
** http://luajit.org/dynasm.html
** DynASM version 1.3.0, DynASM arm version 1.3.0
** DO NOT EDIT! The original file is in "vm_arm.dasc".
*/

#if DASM_VERSION != 10300
#error "Version mismatch between DynASM and included encoding engine"
#endif

# 1 "vm_arm.dasc"
//|// Low-level VM code for ARM CPUs.
//|// Bytecode interpreter, fast functions and helper functions.
//|// Copyright (C) 2005-2012 Mike Pall. See Copyright Notice in luajit.h
//|
//|.arch arm
//|.section code_op, code_sub
#define DASM_SECTION_CODE_OP	0
#define DASM_SECTION_CODE_SUB	1
#define DASM_MAXSECTION		2
# 7 "vm_arm.dasc"
//|
//|.actionlist build_actionlist
static const unsigned int build_actionlist[5553] = {
0x00010001,
0x00060014,
0xe3160000,
0x000a0000,
0x0a000000,
0x00050015,
0xe51c6004,
0xe3e01000,
0x000a0000,
0xe1a0900c,
0xe50a1004,
0xe24aa008,
0x00060016,
0xe29bb008,
0xe3a00000,
0x000a0000,
0x0a000000,
0x00050017,
0xe58db004,
0xe2160000,
0x000a0000,
0x0a000000,
0x00050018,
0x00060019,
0xe3c6c000,
0x000a0000,
0xe3500000,
0x000a0000,
0xe049c00c,
0x1a000000,
0x00050014,
0xe508c000,
0x000d8180,
0xe59d5014,
0xe3e03000,
0x000a0000,
0xe2499008,
0xe25b2008,
0xe1a05185,
0xe5073000,
0x000d8180,
0x0a000000,
0x00050002,
0x0006000b,
0xe2522008,
0xe0ca00d8,
0xe0c900f8,
0x1a000000,
0x0005000b,
0x0006000c,
0xe155000b,
0x1a000000,
0x00050006,
0x0006000d,
0x00000000,
0xe5089000,
0x000d8180,
0x0006001a,
0xe59db010,
0xe3a00000,
0xe508b000,
0x000d8180,
0x0006001b,
0xe59d401c,
0xe28dd000,
0x000a0000,
0xecbd8b10,
0xe8bd8fe0,
0x00060010,
0xba000000,
0x00050007,
0xe5182000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xe1590002,
0x2a000000,
0x00050008,
0xe5891004,
0xe28bb008,
0xe2899008,
0xea000000,
0x0005000c,
0x00060011,
0xe04b0005,
0xe3550000,
0x10499000,
0xea000000,
0x0005000d,
0x00060012,
0xe5089000,
0x000d8180,
0xe1a01005,
0xe1a00008,
0xeb000000,
0x00030000,
0xe5189000,
0x000d8180,
0xea000000,
0x0005000c,
0x0006001c,
0xe1a0d000,
0xe1a00001,
0x00060017,
0xe59d800c,
0xe3e03000,
0x000a0000,
0xe5182000,
0x000d8180,
0x00000000,
0xe5023000,
0x000d8180,
0xea000000,
0x0005001b,
0x0006001d,
0xe3c00000,
0x000a0000,
0xe1a0d000,
0x0006001e,
0xe59d800c,
0xe3a040ff,
0xe3a0b010,
0xe1a04184,
0xe5189000,
0x000d8180,
0xe5187000,
0x000d8180,
0xe3e00000,
0x000a0000,
0xe249a008,
0xe5196004,
0xe2877000,
0x000a0000,
0xe3e01000,
0x000a0000,
0xe5090004,
0xe5071000,
0x000d8180,
0xea000000,
0x00050016,
0x0006001f,
0xe3a01000,
0x000a0000,
0xea000000,
0x00050002,
0x00060020,
0xe089b00b,
0xe04aa009,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe2866004,
0xe508b000,
0x000d8180,
0xe1a021aa,
0x0006000c,
0xe58d6008,
0xeb000000,
0x00030000,
0xe5189000,
0x000d8180,
0xe518b000,
0x000d8180,
0x00000000,
0xe5192008,
0xe04bb009,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x00060021,
0xe92d4fe0,
0xed2d8b10,
0xe24dd000,
0x000a0000,
0xe58d401c,
0xe1a08000,
0xe5107000,
0x000d8180,
0xe1a09001,
0xe2877000,
0x000a0000,
0xe58d800c,
0xe3a06000,
0x000a0000,
0xe58d2014,
0xe28d1000,
0x000a0000,
0xe5580000,
0x000d8180,
0xe58d2018,
0xe5081000,
0x000d8180,
0xe58d2010,
0xe3500000,
0xe58d8008,
0x0a000000,
0x00050003,
0xe1a0a009,
0xe5189000,
0x000d8180,
0xe5180000,
0x000d8180,
0xe3a040ff,
0xe5482000,
0x000d8180,
0xe040b009,
0xe5196004,
0xe1a04184,
0xe3e01000,
0x000a0000,
0xe28bb008,
0xe2160000,
0x000a0000,
0xe5071000,
0x000d8180,
0xe58db004,
0x0a000000,
0x00050018,
0xea000000,
0x00050019,
0x00060022,
0xe92d4fe0,
0xed2d8b10,
0xe24dd000,
0x000a0000,
0xe58d401c,
0xe3a06000,
0x000a0000,
0xe58d3018,
0xea000000,
0x00050001,
0x00060023,
0x00000000,
0xe92d4fe0,
0xed2d8b10,
0xe24dd000,
0x000a0000,
0xe58d401c,
0xe3a06000,
0x000a0000,
0x0006000b,
0xe510b000,
0x000d8180,
0xe58d2014,
0xe1a08000,
0xe58d000c,
0xe1a09001,
0xe508d000,
0x000d8180,
0xe5187000,
0x000d8180,
0xe58d0008,
0xe58db010,
0xe2877000,
0x000a0000,
0x0006000d,
0xe518c000,
0x000d8180,
0xe5180000,
0x000d8180,
0xe3a040ff,
0xe0866009,
0xe1a04184,
0xe046600c,
0xe3e01000,
0x000a0000,
0xe040b009,
0xe5071000,
0x000d8180,
0x00060024,
0xe14920d8,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050025,
0x00060026,
0xe5096004,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x00060027,
0xe92d4fe0,
0xed2d8b10,
0xe24dd000,
0x000a0000,
0xe58d401c,
0xe1a08000,
0xe510a000,
0x000d8180,
0xe58d000c,
0xe518c000,
0x000d8180,
0xe58d0008,
0xe518b000,
0x000d8180,
0x00000000,
0xe04aa00c,
0xe508d000,
0x000d8180,
0xe3a0c000,
0xe58da014,
0xe58dc018,
0xe58db010,
0xe12fff33,
0xe5187000,
0x000d8180,
0xe1b09000,
0xe3a06000,
0x000a0000,
0xe2877000,
0x000a0000,
0x1a000000,
0x0005000d,
0xea000000,
0x0005001a,
0x00060015,
0xe51c2008,
0xe5190010,
0xe1a03009,
0xe1a0900c,
0xe3500001,
0xe513600c,
0xe5122000,
0x000d8180,
0xe3e0e000,
0x000a0000,
0xe08a100b,
0xe501e004,
0x9a000000,
0x00050001,
0xe5125000,
0x000d8180,
0xe12fff10,
0x0006000b,
0x0a000000,
0x00050028,
0xe5192008,
0xe2433010,
0xe043b009,
0xea000000,
0x00050029,
0x0006002a,
0xe516e004,
0xe2431010,
0xe1ca20d0,
0xe5089000,
0x000d8180,
0xe004baae,
0xe004a2ae,
0xe089000b,
0xe0510000,
0x11c120f0,
0x11a02000,
0x1a000000,
0x0005002b,
0xe18920fa,
0xea000000,
0x0005002c,
0x0006002d,
0xe089100c,
0xea000000,
0x00050002,
0x0006002e,
0xe2471000,
0x000a0000,
0x00000000,
0xe3e03000,
0x000a0000,
0xe581c000,
0xe5813004,
0x0006000c,
0xe3e03000,
0x000a0000,
0xe58db000,
0xe58d3004,
0xe1a0200d,
0xea000000,
0x00050001,
0x0006002f,
0xe004caae,
0xe58db000,
0xe3e03000,
0x000a0000,
0xe089100c,
0xe58d3004,
0xe1a0200d,
0xea000000,
0x00050001,
0x00060030,
0xe089100c,
0xe089200b,
0x0006000b,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xeb000000,
0x00030001,
0xe3500000,
0x0a000000,
0x00050003,
0xe1c020d0,
0xe5d6c000,
0xe496e004,
0xe18920fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000d,
0xe2690000,
0x000a0000,
0xe5189000,
0x000d8180,
0xe3a0b010,
0xe509600c,
0xe0806009,
0xe5192008,
0xea000000,
0x00050026,
0x00060031,
0xe089100c,
0xea000000,
0x00050002,
0x00060032,
0xe2471000,
0x000a0000,
0xe3e03000,
0x000a0000,
0xe581c000,
0xe5813004,
0x0006000c,
0x00000000,
0xe3e03000,
0x000a0000,
0xe58db000,
0xe58d3004,
0xe1a0200d,
0xea000000,
0x00050001,
0x00060033,
0xe004caae,
0xe58db000,
0xe3e03000,
0x000a0000,
0xe089100c,
0xe58d3004,
0xe1a0200d,
0xea000000,
0x00050001,
0x00060034,
0xe089100c,
0xe089200b,
0x0006000b,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xeb000000,
0x00030002,
0xe3500000,
0xe18920da,
0x0a000000,
0x00050003,
0xe5d6c000,
0xe1c020f0,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000d,
0xe2690000,
0x000a0000,
0xe5189000,
0x000d8180,
0xe3a0b018,
0xe1c921f0,
0xe509600c,
0xe0806009,
0xe5192008,
0xea000000,
0x00050026,
0x00060035,
0xe1a00008,
0xe2466004,
0xe1a0100a,
0xe5089000,
0x000d8180,
0xe1a0200b,
0xe58d6008,
0xe20e30ff,
0xeb000000,
0x00030003,
0x0006000d,
0xe3500001,
0x8a000000,
0x00050036,
0x0006000e,
0xe1d6c0b2,
0xe2866004,
0xe086c10c,
0x224c6b80,
0x0006002c,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00060037,
0x00000000,
0xe516e004,
0xe1ca00d0,
0xe00422ae,
0xe18900f2,
0xea000000,
0x0005002c,
0x00060038,
0xe59a1004,
0xe3e00000,
0x000a0000,
0xe1500001,
0xea000000,
0x0005000e,
0x00060039,
0xe59a1004,
0xe3710000,
0x000a0000,
0xea000000,
0x0005000e,
0x0006003a,
0xe2466004,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xeb000000,
0x00030004,
0xea000000,
0x0005000d,
0x0006003b,
0xe2466004,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe1a0100e,
0xe58d6008,
0xeb000000,
0x00030005,
0xea000000,
0x0005000d,
0x0006003c,
0xe004caae,
0xe004b6ae,
0xe089200c,
0xe085300b,
0xea000000,
0x00050001,
0x0006003d,
0xe004caae,
0xe004b6ae,
0xe089300c,
0xe085200b,
0xea000000,
0x00050001,
0x0006003e,
0xe516e008,
0xe2466004,
0xe089200b,
0xe089300b,
0xea000000,
0x00050001,
0x0006003f,
0x00000000,
0xe004caae,
0xe004b6ae,
0xe089200c,
0xe089300b,
0x0006000b,
0xe20ec0ff,
0xe089100a,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xe58dc000,
0xeb000000,
0x00030006,
0xe3500000,
0x0a000000,
0x0005002c,
0x00060036,
0xe0401009,
0xe500600c,
0xe2816000,
0x000a0000,
0xe1a09000,
0xe3a0b010,
0xea000000,
0x00050024,
0x00060040,
0xe089100b,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xeb000000,
0x00030007,
0x00000000,
0xe3500000,
0x1a000000,
0x00050036,
0xe799000b,
0xea000000,
0x00050041,
0x00000000,
0xea000000,
0x00050036,
0x00000000,
0x00060025,
0xe1a00008,
0xe508c000,
0x000d8180,
0xe2491008,
0xe58d6008,
0xe089200b,
0xeb000000,
0x00030008,
0xe5192008,
0xe28bb008,
0xe5096004,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x00060042,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe24a1008,
0xe58d6008,
0xe08a200b,
0xeb000000,
0x00030008,
0xe51a2008,
0xe5196004,
0xe28bb008,
0xea000000,
0x00050043,
0x00060044,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe1a0100a,
0xe58d6008,
0xeb000000,
0x00030009,
0xe556c004,
0xe516e004,
0xe35c0000,
0x000a0000,
0xe004a2ae,
0xe1a0b82e,
0x0a000000,
0x00070000,
0xea000000,
0x00070000,
0x00060045,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x8a000000,
0x00050046,
0xe5196004,
0xe14900f8,
0xe1a0c009,
0xe25ba008,
0xe28bb008,
0x0a000000,
0x00050047,
0x0006000b,
0xe1cc00d8,
0xe25aa008,
0xe0cc00f8,
0x1a000000,
0x0005000b,
0xea000000,
0x00050047,
0x00060048,
0x00000000,
0xe5991004,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x33e01000,
0x000a0000,
0xe2613000,
0x000a0000,
0xe1a03183,
0xe18200d3,
0xea000000,
0x00050049,
0x0006004a,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x13710000,
0x000a0000,
0x1a000000,
0x00050006,
0x0006000b,
0xe510c000,
0x000d8180,
0x0006000c,
0xe3e01000,
0x000a0000,
0xe517b000,
0x000d8180,
0xe35c0000,
0x0a000000,
0x00050049,
0xe51c2000,
0x000d8180,
0xe51b3000,
0x000d8180,
0xe51ce000,
0x000d8180,
0xe0022003,
0xe0822082,
0xe08ee182,
0x0006000d,
0xe14e20d0,
0x000c8100,
0xe14e00d0,
0x000c8100,
0x00000000,
0xe51ee000,
0x000d8180,
0xe3730000,
0x000a0000,
0x0152000b,
0x0a000000,
0x00050005,
0xe35e0000,
0x1a000000,
0x0005000d,
0x0006000e,
0xe1a0000c,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x0006000f,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050049,
0xea000000,
0x0005000e,
0x00060010,
0xe3710000,
0x000a0000,
0x21e01001,
0x33a01000,
0x000a0000,
0xe0873101,
0xe513c000,
0x000d8180,
0xea000000,
0x0005000c,
0x0006004b,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x0510c000,
0x000d8180,
0x03730000,
0x000a0000,
0x05503000,
0x000d8180,
0x00000000,
0x035c0000,
0x1a000000,
0x00050046,
0xe3130000,
0x000a0000,
0xe5002000,
0x000d8180,
0x0a000000,
0x00050049,
0xe5172000,
0x000d8180,
0xe3c33000,
0x000a0000,
0xe5070000,
0x000d8180,
0xe5403000,
0x000d8180,
0xe5002000,
0x000d8180,
0xea000000,
0x00050049,
0x0006004c,
0xe1c920d0,
0xe35b0010,
0x3a000000,
0x00050046,
0xe1a01002,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050046,
0xe1a00008,
0xe2892008,
0xeb000000,
0x0003000a,
0xe1c000d0,
0xea000000,
0x00050049,
0x0006004d,
0xe1c900d0,
0xe35b0008,
0x1a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x9a000000,
0x00050049,
0xea000000,
0x00050046,
0x0006004e,
0x00000000,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x0a000000,
0x00050049,
0xe5173000,
0x000d8180,
0xe5089000,
0x000d8180,
0xe3710000,
0x000a0000,
0x93530000,
0xe58d6008,
0x8a000000,
0x00050046,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004f,
0xe1a00008,
0xe1a01009,
0xeb000000,
0x0003000b,
0xe5189000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x00060050,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3e03000,
0x000a0000,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050046,
0xe18920fb,
0xe5196004,
0xe1a01000,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe2892008,
0xe58d6008,
0xeb000000,
0x0003000c,
0x00000000,
0xe3500000,
0x03e01000,
0x000a0000,
0x0a000000,
0x00050049,
0xe1c900d8,
0xe1c921d0,
0xe3a0b000,
0x000a0000,
0xe14900f8,
0xe1c920f0,
0xea000000,
0x00050047,
0x00060051,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050046,
0x00000000,
0xe510c000,
0x000d8180,
0x00000000,
0xe14220d0,
0x000c8100,
0xe5196004,
0x00000000,
0xe35c0000,
0x1a000000,
0x00050046,
0x00000000,
0xe3e01000,
0x000a0000,
0xe3a0b000,
0x000a0000,
0xe14920f8,
0xe589100c,
0xea000000,
0x00050047,
0x00060052,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x03730000,
0x000a0000,
0x1a000000,
0x00050046,
0xe510c000,
0x000d8180,
0xe510b000,
0x000d8180,
0xe2822001,
0xe5196004,
0xe152000c,
0xe08bb182,
0xe14920f8,
0x31cb00d0,
0xe3a0b000,
0x000a0000,
0x2a000000,
0x00050002,
0x0006000b,
0xe3710000,
0x000a0000,
0x13a0b000,
0x000a0000,
0x11c900f0,
0xea000000,
0x00050047,
0x0006000c,
0xe510c000,
0x000d8180,
0xe1a01002,
0xe35c0000,
0x0a000000,
0x00050047,
0xeb000000,
0x0003000d,
0xe3500000,
0x0a000000,
0x00050047,
0xe1c000d0,
0xea000000,
0x0005000b,
0x00060053,
0x00000000,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050046,
0x00000000,
0xe510c000,
0x000d8180,
0x00000000,
0xe14220d0,
0x000c8100,
0xe5196004,
0x00000000,
0xe35c0000,
0x1a000000,
0x00050046,
0x00000000,
0xe3a00000,
0xe3e01000,
0x000a0000,
0xe3a0b000,
0x000a0000,
0xe14920f8,
0xe1c900f8,
0xea000000,
0x00050047,
0x00060054,
0xe557a000,
0x000d8180,
0xe35b0008,
0x3a000000,
0x00050046,
0xe31a0000,
0x000a0000,
0xe1a0c009,
0xe2899008,
0x03a06000,
0x000a0000,
0x13a06000,
0x000a0000,
0xe24bb008,
0xea000000,
0x00050024,
0x00060055,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050046,
0xe557a000,
0x000d8180,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050046,
0xe1a0c009,
0xe1c900f8,
0xe1c920f0,
0xe31a0000,
0x000a0000,
0xe2899010,
0x03a06000,
0x000a0000,
0x13a06000,
0x000a0000,
0xe24bb010,
0xea000000,
0x00050024,
0x00060056,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050046,
0xe5196004,
0xe5089000,
0x000d8180,
0xe5101000,
0x000d8180,
0xe550a000,
0x000d8180,
0xe510c000,
0x000d8180,
0xe081200b,
0xe081300a,
0xe58d6008,
0xe153000c,
0x0a000000,
0x00050046,
0xe5103000,
0x000d8180,
0xe510c000,
0x000d8180,
0xe35a0000,
0x000a0000,
0x91520003,
0x935c0000,
0x8a000000,
0x00050046,
0x0006000b,
0xe2422008,
0xe2899008,
0xe24bb008,
0xe5002000,
0x000d8180,
0xe5089000,
0x000d8180,
0x0006000c,
0xe18920dc,
0xe15c000b,
0x118120fc,
0xe28cc008,
0x1a000000,
0x0005000c,
0xe3a02000,
0xe1a0a000,
0xe3a03000,
0xeb000000,
0x00050021,
0x0006000e,
0xe51a2000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xe51a3000,
0x000d8180,
0xe5071000,
0x000d8180,
0xe3500000,
0x000a0000,
0x00000000,
0xe5189000,
0x000d8180,
0x8a000000,
0x00050008,
0xe053b002,
0xe5180000,
0x000d8180,
0xe089100b,
0x0a000000,
0x00050006,
0xe1510000,
0xe3a0c000,
0x8a000000,
0x00050009,
0xe24b3008,
0xe50a2000,
0x000d8180,
0x0006000f,
0xe18200dc,
0xe15c0003,
0xe18900fc,
0xe28cc008,
0x1a000000,
0x0005000f,
0x00060010,
0xe3e02000,
0x000a0000,
0xe28bb010,
0x00060011,
0xe5092004,
0xe249a008,
0xe2160000,
0x000a0000,
0xe58d6008,
0xe58db004,
0x0a000000,
0x00050018,
0xea000000,
0x00050019,
0x00060012,
0xe16300d8,
0xe3e02000,
0x000a0000,
0xe3a0b000,
0x000a0000,
0xe50a3000,
0x000d8180,
0xe1c900f0,
0xea000000,
0x00050011,
0x00060013,
0xe1a00008,
0xe1a011ab,
0xeb000000,
0x00030000,
0xe3a00000,
0xea000000,
0x0005000e,
0x00060057,
0x00000000,
0xe5120000,
0x000d8180,
0xe5196004,
0xe5089000,
0x000d8180,
0xe5101000,
0x000d8180,
0xe550a000,
0x000d8180,
0xe510c000,
0x000d8180,
0xe081200b,
0xe081300a,
0xe58d6008,
0xe153000c,
0x0a000000,
0x00050046,
0xe5103000,
0x000d8180,
0xe510c000,
0x000d8180,
0xe35a0000,
0x000a0000,
0x91520003,
0x935c0000,
0x8a000000,
0x00050046,
0x0006000b,
0xe5002000,
0x000d8180,
0xe5089000,
0x000d8180,
0x0006000c,
0xe18920dc,
0xe15c000b,
0x118120fc,
0xe28cc008,
0x1a000000,
0x0005000c,
0xe3a02000,
0xe1a0a000,
0xe3a03000,
0xeb000000,
0x00050021,
0x0006000e,
0xe51a2000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xe51a3000,
0x000d8180,
0xe5071000,
0x000d8180,
0xe3500000,
0x000a0000,
0x00000000,
0xe5189000,
0x000d8180,
0x8a000000,
0x00050008,
0xe053b002,
0xe5180000,
0x000d8180,
0xe089100b,
0x0a000000,
0x00050006,
0xe1510000,
0xe3a0c000,
0x8a000000,
0x00050009,
0xe24b3008,
0xe50a2000,
0x000d8180,
0x0006000f,
0xe18200dc,
0xe15c0003,
0xe18900fc,
0xe28cc008,
0x1a000000,
0x0005000f,
0x00060010,
0xe1a0a009,
0xe28bb008,
0xe2160000,
0x000a0000,
0xe58d6008,
0xe58db004,
0x0a000000,
0x00050018,
0xea000000,
0x00050019,
0x00060012,
0xe1a00008,
0xe1a0100a,
0xeb000000,
0x0003000e,
0x00060013,
0xe1a00008,
0xe1a011ab,
0xeb000000,
0x00030000,
0xe3a00000,
0xea000000,
0x0005000e,
0x00060058,
0xe5180000,
0x000d8180,
0xe089100b,
0xe5089000,
0x000d8180,
0xe3100000,
0x000a0000,
0xe5081000,
0x000d8180,
0x00000000,
0xe3a00000,
0x000a0000,
0xe3a02000,
0x0a000000,
0x00050046,
0xe5082000,
0x000d8180,
0xe5480000,
0x000d8180,
0xea000000,
0x0005001b,
0x00060059,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x0a000000,
0x00050049,
0x8a000000,
0x00050046,
0xe1a02081,
0xe292c980,
0x5a000000,
0x00050002,
0xe3e03ff8,
0xe053cacc,
0xe1a03581,
0xe1a02580,
0xe3833480,
0xe26ce020,
0xe1833aa0,
0x9a000000,
0x00050003,
0xe1822e13,
0xe1a00c33,
0xe1120fc1,
0x12800001,
0xe3510000,
0xb2600000,
0x0006000b,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x0006000c,
0x2a000000,
0x00050049,
0xe1822000,
0xe1120fc1,
0x03a00000,
0x13e00000,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x0006000d,
0x03530480,
0x03520000,
0x1a000000,
0x00050004,
0xe3510000,
0x43a00480,
0x4a000000,
0x0005000b,
0x0006000e,
0x00000000,
0xeb000000,
0x0005005a,
0xea000000,
0x00050049,
0x0006005b,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x0a000000,
0x00050049,
0x8a000000,
0x00050046,
0xe1a02081,
0xe292c980,
0x5a000000,
0x00050002,
0xe3e03ff8,
0xe053cacc,
0xe1a03581,
0xe1a02580,
0xe3833480,
0xe26ce020,
0xe1833aa0,
0x9a000000,
0x00050003,
0xe1822e13,
0xe1a00c33,
0xe1d22fc1,
0x12900001,
0x614f00d0,
0x00051809,
0x6a000000,
0x00050049,
0xe3510000,
0xb2600000,
0x0006000b,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x0006000c,
0x2a000000,
0x00050049,
0xe1822000,
0xe1d22fc1,
0x03a00000,
0x13a00001,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x0006000d,
0x03530480,
0x1a000000,
0x00050004,
0xe3510000,
0x43a00480,
0x4a000000,
0x0005000b,
0x0006000e,
0x00000000,
0xeb000000,
0x0005005c,
0xea000000,
0x00050049,
0x00040007,
0x00060013,
0x00020000,
0x00000000,
0x41e00000,
0x0006005d,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x8a000000,
0x00050046,
0x13c11480,
0x1a000000,
0x00050049,
0xe3500000,
0xb2700000,
0x614f00d0,
0x00051813,
0x00060049,
0xe5196004,
0xe14900f8,
0x0006005e,
0xe3a0b000,
0x000a0000,
0x00060047,
0xe2160000,
0x000a0000,
0x0516e004,
0xe58db004,
0xe249a008,
0x1a000000,
0x00050019,
0xe004caae,
0x0006000f,
0xe15c000b,
0x8a000000,
0x00050006,
0xe00402ae,
0xe5d6c000,
0xe496e004,
0xe04a9000,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00060010,
0xe08a100b,
0xe3e00000,
0x000a0000,
0xe28bb008,
0xe5010004,
0xea000000,
0x0005000f,
0x0006005f,
0x00000000,
0xe5991004,
0xe35b0008,
0xed190b00,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xeeb10bc0,
0x00060060,
0xe5196004,
0xed090b02,
0xea000000,
0x0005005e,
0x00060061,
0xe1c900d0,
0xe35b0008,
0x1a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xeb000000,
0x0003000f,
0xea000000,
0x00050049,
0x00060062,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xeb000000,
0x00030010,
0xea000000,
0x00050049,
0x00060063,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xeb000000,
0x00030011,
0x00000000,
0xea000000,
0x00050049,
0x00060064,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xeb000000,
0x00030012,
0xea000000,
0x00050049,
0x00060065,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xeb000000,
0x00030013,
0xea000000,
0x00050049,
0x00060066,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xeb000000,
0x00030014,
0xea000000,
0x00050049,
0x00060067,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x00000000,
0x2a000000,
0x00050046,
0xeb000000,
0x00030015,
0xea000000,
0x00050049,
0x00060068,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xeb000000,
0x00030016,
0xea000000,
0x00050049,
0x00060069,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xeb000000,
0x00030017,
0xea000000,
0x00050049,
0x0006006a,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xeb000000,
0x00030018,
0xea000000,
0x00050049,
0x0006006b,
0x00000000,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xeb000000,
0x00030019,
0xea000000,
0x00050049,
0x0006006c,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xeb000000,
0x0003001a,
0xea000000,
0x00050049,
0x0006006d,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x2a000000,
0x00050046,
0xeb000000,
0x0003001b,
0xea000000,
0x00050049,
0x0006006e,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x00050046,
0xeb000000,
0x0003001c,
0xea000000,
0x00050049,
0x0006006f,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x2a000000,
0x00050046,
0xeb000000,
0x0003001d,
0xea000000,
0x00050049,
0x00060070,
0x00060071,
0xe5991004,
0xe35b0008,
0xed190b00,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xed121b00,
0x000e8100,
0xee200b01,
0xea000000,
0x00050060,
0x00060072,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xe3730000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050046,
0xeb000000,
0x0003001e,
0xea000000,
0x00050049,
0x00060073,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xe1a0200d,
0xeb000000,
0x0003001f,
0xe59d2000,
0xe3e03000,
0x000a0000,
0xe5196004,
0xe14900f8,
0xe3a0b000,
0x000a0000,
0xe1c920f0,
0xea000000,
0x00050047,
0x00060074,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050046,
0xe2492008,
0xe5196004,
0xeb000000,
0x00030020,
0xe3a0b000,
0x000a0000,
0xe1c900f0,
0xea000000,
0x00050047,
0x00060075,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe089c00b,
0xe3710000,
0x000a0000,
0xe289a008,
0x1a000000,
0x00050004,
0x0006000b,
0x00000000,
0xe1ca20d0,
0xe15a000c,
0x2a000000,
0x00050049,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050003,
0xe1500002,
0xe28aa008,
0xc1a00002,
0xea000000,
0x0005000b,
0x0006000d,
0xee020a10,
0x8a000000,
0x00050046,
0xed1a1b00,
0xeeb80bc2,
0xea000000,
0x00050006,
0x0006000e,
0xed190b00,
0x8a000000,
0x00050046,
0x0006000f,
0xe1ca20d0,
0xed1a1b00,
0xe15a000c,
0x2a000000,
0x00050060,
0xe3730000,
0x000a0000,
0x2a000000,
0x00050007,
0x00060010,
0xeeb40b41,
0xeef1fa10,
0xe28aa008,
0x8eb00b41,
0xea000000,
0x0005000f,
0x00060011,
0xee022a10,
0x8a000000,
0x00050046,
0xeeb81bc2,
0xea000000,
0x00050010,
0x00060076,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe089c00b,
0xe3710000,
0x000a0000,
0xe289a008,
0x1a000000,
0x00050004,
0x0006000b,
0x00000000,
0xe1ca20d0,
0xe15a000c,
0x2a000000,
0x00050049,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050003,
0xe1500002,
0xe28aa008,
0xb1a00002,
0xea000000,
0x0005000b,
0x0006000d,
0xee020a10,
0x8a000000,
0x00050046,
0xed1a1b00,
0xeeb80bc2,
0xea000000,
0x00050006,
0x0006000e,
0xed190b00,
0x8a000000,
0x00050046,
0x0006000f,
0xe1ca20d0,
0xed1a1b00,
0xe15a000c,
0x2a000000,
0x00050060,
0xe3730000,
0x000a0000,
0x2a000000,
0x00050007,
0x00060010,
0xeeb40b41,
0xeef1fa10,
0xe28aa008,
0x3eb00b41,
0xea000000,
0x0005000f,
0x00060011,
0xee022a10,
0x8a000000,
0x00050046,
0xeeb81bc2,
0xea000000,
0x00050010,
0x00060077,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050046,
0x00000000,
0xe5100000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x00060078,
0xe1c900d0,
0xe5196004,
0xe35b0008,
0x03710000,
0x000a0000,
0x1a000000,
0x00050046,
0xe5102000,
0x000d8180,
0xe5500000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xe3520000,
0x03a0b000,
0x000a0000,
0x13a0b000,
0x000a0000,
0xe14900f8,
0xea000000,
0x00050047,
0x00060079,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004f,
0xe1c900d0,
0xe5196004,
0xe35b0008,
0x03710000,
0x000a0000,
0x03d030ff,
0xe3a02001,
0x1a000000,
0x00050046,
0xe58d0000,
0xe1a0100d,
0x0006007a,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xeb000000,
0x00030021,
0xe5189000,
0x000d8180,
0x00000000,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x0006007b,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004f,
0xe1c900d0,
0xe1c921d0,
0xe35b0010,
0xe3e0c000,
0x0a000000,
0x00050001,
0x3a000000,
0x00050046,
0xe3730000,
0x000a0000,
0xe1a0c002,
0x1a000000,
0x00050046,
0x0006000b,
0xe1c920d8,
0xe3710000,
0x000a0000,
0x05101000,
0x000d8180,
0x03730000,
0x000a0000,
0x1a000000,
0x00050046,
0xe2813001,
0xe3520000,
0xb0822003,
0xe3520001,
0xb3a02001,
0xe35c0000,
0xb08cc003,
0xe1cccfcc,
0xe15c0001,
0xe2800000,
0x000a0000,
0xc1a0c001,
0xe0801002,
0xe05c2002,
0xe2822001,
0xaa000000,
0x0005007a,
0x0006007c,
0xe2470000,
0x000a0000,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x0006007d,
0x00000000,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004f,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x1a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x03730000,
0x000a0000,
0x1a000000,
0x00050046,
0xe2523001,
0xe5101000,
0x000d8180,
0xba000000,
0x0005007c,
0xe3510001,
0x3a000000,
0x0005007c,
0x1a000000,
0x00050046,
0xe517c000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe5100000,
0x000d8180,
0xe15c0002,
0x3a000000,
0x00050046,
0x0006000b,
0xe7c10003,
0xe2533001,
0xaa000000,
0x0005000b,
0xea000000,
0x0005007a,
0x0006007e,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004f,
0x00000000,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050046,
0xe5102000,
0x000d8180,
0xe517c000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1a03002,
0xe2800000,
0x000a0000,
0xe15c0002,
0x3a000000,
0x00050046,
0x0006000b,
0xe4d0c001,
0xe2533001,
0xba000000,
0x0005007a,
0xe7c1c003,
0xea000000,
0x0005000b,
0x0006007f,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004f,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050046,
0xe5102000,
0x000d8180,
0xe517c000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe3a03000,
0xe2800000,
0x000a0000,
0x00000000,
0xe15c0002,
0x3a000000,
0x00050046,
0x0006000b,
0xe7d0c003,
0xe1530002,
0x2a000000,
0x0005007a,
0xe24cb041,
0xe35b001a,
0x322cc020,
0xe7c1c003,
0xe2833001,
0xea000000,
0x0005000b,
0x00060080,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004f,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050046,
0xe5102000,
0x000d8180,
0xe517c000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe3a03000,
0xe2800000,
0x000a0000,
0xe15c0002,
0x3a000000,
0x00050046,
0x0006000b,
0xe7d0c003,
0xe1530002,
0x2a000000,
0x0005007a,
0xe24cb061,
0xe35b001a,
0x322cc020,
0xe7c1c003,
0xe2833001,
0xea000000,
0x0005000b,
0x00060081,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050046,
0xeb000000,
0x00030022,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x00060082,
0x8a000000,
0x00050046,
0x00060083,
0xe1a0c081,
0xe29cc980,
0x53a00000,
0x512fff1e,
0xe3e03ff8,
0xe053cacc,
0x4a000000,
0x00050001,
0xe1a03581,
0xe3833480,
0xe1833aa0,
0xe3510000,
0xe1a00c33,
0xb2600000,
0xe12fff1e,
0x0006000b,
0xe28cc015,
0xe1a03c30,
0xe26cc014,
0xe1a00601,
0xe3510000,
0xe1830c10,
0xb2600000,
0xe12fff1e,
0x00060084,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x00060085,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe1a02000,
0xe3a0a008,
0x0006000b,
0xe18900da,
0xe15a000b,
0xe28aa008,
0xaa000000,
0x00050002,
0xe3710000,
0x000a0000,
0x00000000,
0x1b000000,
0x00050082,
0xe0022000,
0xea000000,
0x0005000b,
0x00060086,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe1a02000,
0xe3a0a008,
0x0006000b,
0xe18900da,
0xe15a000b,
0xe28aa008,
0xaa000000,
0x00050002,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe1822000,
0xea000000,
0x0005000b,
0x00060087,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe1a02000,
0xe3a0a008,
0x0006000b,
0xe18900da,
0xe15a000b,
0xe28aa008,
0xaa000000,
0x00050002,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe0222000,
0xea000000,
0x0005000b,
0x0006000c,
0xe3e03000,
0x000a0000,
0x00000000,
0xe5196004,
0xe14920f8,
0xea000000,
0x0005005e,
0x00060088,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe0202860,
0xe3c228ff,
0xe1a00460,
0xe3e01000,
0x000a0000,
0xe0200422,
0xea000000,
0x00050049,
0x00060089,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe1e00000,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x0006008a,
0xe1c900d8,
0xe35b0010,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe200a01f,
0xe1c900d0,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe1a00a10,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x0006008b,
0x00000000,
0xe1c900d8,
0xe35b0010,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe200a01f,
0xe1c900d0,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe1a00a30,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x0006008c,
0xe1c900d8,
0xe35b0010,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe200a01f,
0xe1c900d0,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe1a00a50,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x0006008d,
0xe1c900d8,
0xe35b0010,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe260a000,
0xe1c900d0,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe1a00a70,
0xe3e01000,
0x000a0000,
0x00000000,
0xea000000,
0x00050049,
0x0006008e,
0xe1c900d8,
0xe35b0010,
0x3a000000,
0x00050046,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe200a01f,
0xe1c900d0,
0xe3710000,
0x000a0000,
0x1b000000,
0x00050082,
0xe1a00a70,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050049,
0x00060046,
0xe5192008,
0xe5181000,
0x000d8180,
0xe089000b,
0xe5196004,
0xe5080000,
0x000d8180,
0xe5122000,
0x000d8180,
0xe5089000,
0x000d8180,
0xe2800000,
0x000a0000,
0xe58d6008,
0xe1500001,
0xe1a00008,
0x8a000000,
0x00050005,
0xe12fff32,
0xe5189000,
0x000d8180,
0xe3500000,
0xe1a0b180,
0xe249a008,
0xca000000,
0x00050047,
0x0006000b,
0xe5180000,
0x000d8180,
0xe5192008,
0xe040b009,
0x1a000000,
0x00050029,
0xe5126000,
0x000d8180,
0x00000000,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x00060029,
0xe2160000,
0x000a0000,
0xe3c61000,
0x000a0000,
0x0516e004,
0x00020000,
0x000412ae,
0x02811008,
0xe049c001,
0xea000000,
0x00050024,
0x0006000f,
0xe3a01000,
0x000a0000,
0xeb000000,
0x00030000,
0xe5189000,
0x000d8180,
0xe1500000,
0xea000000,
0x0005000b,
0x0006004f,
0xe1a0a00e,
0xe5089000,
0x000d8180,
0xe089100b,
0xe58d6008,
0xe5081000,
0x000d8180,
0xe1a00008,
0xeb000000,
0x00030023,
0xe5189000,
0x000d8180,
0xe1a0e00a,
0xe5192008,
0xe12fff1e,
0x0006008f,
0xe5570000,
0x000d8180,
0xe3100000,
0x000a0000,
0x1a000000,
0x00050005,
0xe5171000,
0x000d8180,
0xe3100000,
0x000a0000,
0x1a000000,
0x00050001,
0xe2411001,
0xe3100000,
0x000a0000,
0x00000000,
0x15071000,
0x000d8180,
0xea000000,
0x00050001,
0x00060090,
0xe5570000,
0x000d8180,
0xe3100000,
0x000a0000,
0x0a000000,
0x00050001,
0x0006000f,
0xe20ec0ff,
0xe087c10c,
0xe51cf000,
0x000d8180,
0x00060091,
0xe5570000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe3100000,
0x000a0000,
0x1a000000,
0x0005000f,
0xe3100000,
0x000a0000,
0x0a000000,
0x0005000f,
0xe2511001,
0xe5071000,
0x000d8180,
0x0a000000,
0x00050001,
0xe3100000,
0x000a0000,
0x0a000000,
0x0005000f,
0x0006000b,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe1a01006,
0xeb000000,
0x00030024,
0x0006000d,
0x00000000,
0xe5189000,
0x000d8180,
0x0006000e,
0xe556c004,
0xe516e004,
0xe087c10c,
0xe51cc000,
0x000d8180,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00060092,
0xe5130018,
0xe2866004,
0xe58d0004,
0xea000000,
0x0005000e,
0x00060093,
0xe5192008,
0xe2470000,
0x000a0000,
0xe58d6008,
0xe5122000,
0x000d8180,
0xe1a01006,
0xe5078000,
0x000d8180,
0xe5522000,
0x000d8180,
0xe5089000,
0x000d8180,
0xe0892182,
0xe5082000,
0x000d8180,
0xeb000000,
0x00030025,
0xea000000,
0x0005000d,
0x00060094,
0xe1a01006,
0xea000000,
0x00050001,
0x00060095,
0xe3861001,
0x0006000b,
0xe089300b,
0xe58d6008,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe04aa009,
0xe5083000,
0x000d8180,
0xeb000000,
0x00030026,
0xe5189000,
0x000d8180,
0x00000000,
0xe5183000,
0x000d8180,
0xe3a01000,
0xe089a00a,
0xe043b009,
0xe58d1008,
0xe5192008,
0xe516e004,
0xe12fff10,
0x00060096,
0xe24dd00c,
0xe92d1fff,
0xe59d0040,
0xe59e7000,
0xe28d2040,
0xe3e03000,
0x000a0000,
0xe58d2034,
0xe5073000,
0x000d8180,
0xe5301004,
0xe58d0038,
0xe58d003c,
0xed2d0b20,
0xe1a01401,
0xe0800341,
0xe59e1004,
0xe040000e,
0xe5178000,
0x000d8180,
0xe0810120,
0xe5179000,
0x000d8180,
0xe5070000,
0x000d8180,
0xe3a03000,
0xe5078000,
0x000d8180,
0xe5089000,
0x000d8180,
0xe5073000,
0x000d8180,
0xe2470000,
0x000a0000,
0xe1a0100d,
0xeb000000,
0x00030027,
0xe5181000,
0x000d8180,
0xe5189000,
0x000d8180,
0xe3c11000,
0x000a0000,
0xe1a0d001,
0xe59d6008,
0xe58d800c,
0xea000000,
0x00050001,
0x00060097,
0xe59d800c,
0x0006000b,
0xe3500000,
0xba000000,
0x00050003,
0xe1a0b180,
0xe5191008,
0xe58db004,
0xe3a02000,
0xe5111000,
0x000d8180,
0xe5072000,
0x000d8180,
0xe3e03000,
0x000a0000,
0x00000000,
0xe5115000,
0x000d8180,
0xe5d6c000,
0xe3a040ff,
0xe496e004,
0xe1a04184,
0xe5073000,
0x000d8180,
0xe35c0000,
0x000a0000,
0xe797c10c,
0xe004a2ae,
0x31a0b82e,
0x224bb008,
0x208aa009,
0xe12fff1c,
0x0006000d,
0xe2601000,
0xe1a00008,
0xeb000000,
0x00030028,
0x00060013,
0x3ff00000,
0x00060098,
0x0006005a,
0xe1a02081,
0xe292c980,
0x5a000000,
0x00050002,
0xe3e03ff3,
0xe053cacc,
0x312fff1e,
0xe3e03001,
0xe1c02c13,
0xe0000c13,
0xe25cc020,
0x51c13c13,
0x51822003,
0x53e03001,
0x50011c13,
0xe1120fc1,
0x012fff1e,
0xe3e03001,
0xe35c0000,
0x51a02c13,
0x43e02000,
0xe28cc020,
0xe0500c13,
0xe0c11002,
0xe12fff1e,
0x0006000c,
0x212fff1e,
0xe1822000,
0xe1120fc1,
0xe3a00000,
0xe2011480,
0x151f3000,
0x00050813,
0x11811003,
0xe12fff1e,
0x00060099,
0x0006005c,
0xe1a02081,
0xe292c980,
0x5a000000,
0x00050002,
0xe3e03ff3,
0xe053cacc,
0x312fff1e,
0xe3e03001,
0xe1c02c13,
0xe0000c13,
0xe25cc020,
0x51c13c13,
0x51822003,
0x53e03001,
0x50011c13,
0xe1d22fc1,
0x012fff1e,
0xe3e03001,
0xe35c0000,
0x51a02c13,
0x43e02000,
0xe28cc020,
0xe0500c13,
0xe0c11002,
0xe12fff1e,
0x0006000c,
0x212fff1e,
0xe1822000,
0xe1d22fc1,
0xe3a00000,
0xe2011480,
0x151f3000,
0x00050813,
0x11811003,
0xe12fff1e,
0x0006009a,
0x0006009b,
0xe1a02081,
0xe292c980,
0x52011480,
0x53a00000,
0x512fff1e,
0xe3e03ff3,
0xe053cacc,
0x312fff1e,
0xe3e03001,
0xe0000c13,
0xe25cc020,
0x50011c13,
0xe12fff1e,
0x0006009c,
0xee860b07,
0xe1a0b00e,
0xec510b10,
0xeb000000,
0x0005005a,
0xec410b10,
0xee200b07,
0xe1a0e00b,
0xee366b40,
0xe12fff1e,
0x0006009d,
0xe210c480,
0x42600000,
0xe02cc0c1,
0xe3510000,
0x42611000,
0xe2513001,
0x11500001,
0x03a00000,
0x81110003,
0x00020000,
0x00000003,
0x9a000000,
0x00050001,
0x00000000,
0xe16f2f10,
0xe16f3f11,
0xe0433002,
0xe273201f,
0x108ff182,
0xe1a00000,
0x00000000,
0xe1500001,
0x000900a7,
0x20400001,
0x000900a7,
0x00000000,
0x0006000b,
0xe3500000,
0x135c0000,
0x40400001,
0xe030108c,
0x42600000,
0xe12fff1e,
0x0006009e,
0xe51c6000,
0x000d8180,
0xe28c7000,
0x000a0000,
0xe58d401c,
0xe28d4000,
0x000a0000,
0xed248b10,
0xe14620f0,
0x000c8100,
0xe14600f0,
0x000c8100,
0xe59d3000,
0xe28d2000,
0x000a0000,
0xe1a00006,
0xe1a031a3,
0xe5062000,
0x000d8180,
0xe1a0100d,
0xe5063000,
0x000d8180,
0xe58d6008,
0xeb000000,
0x00030029,
0xe5109000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xe510b000,
0x000d8180,
0xe3a040ff,
0xe5192008,
0xe1a08000,
0xe04bb009,
0xe1a04184,
0xe5071000,
0x000d8180,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x00060028,
0xe5176000,
0x000d8180,
0xe5089000,
0x000d8180,
0xe5083000,
0x000d8180,
0xe5068000,
0x000d8180,
0xe1a00006,
0xe1a0100a,
0xeb000000,
0x0003002a,
0x00000000,
0xe14600d0,
0x000c8100,
0xea000000,
0x0005001b,
0x0006009f,
0xe92d4830,
0xe1a04000,
0xe5100000,
0x000d8180,
0xe5541000,
0x000d8180,
0xe2842000,
0x000a0000,
0xe1a0b00d,
0xe04dd000,
0xe2511001,
0xe514c000,
0x000d8180,
0x4a000000,
0x00050002,
0x0006000b,
0xe7923101,
0xe78d3101,
0xe2511001,
0x5a000000,
0x0005000b,
0x0006000c,
0xe14400d0,
0x000c8100,
0xe14420d0,
0x000c8100,
0xe12fff3c,
0xe1a0d00b,
0xe14400f0,
0x000c8100,
0xe8bd8830,
0x00000000,
0x00080000,
0x00000000,
0xe1a0b18b,
0xe1aa00d9,
0xe1d6c0b2,
0xe1ab20d9,
0xe2866004,
0xe086c10c,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050003,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050004,
0xe1500002,
0x00000000,
0xb24c6b80,
0x00000000,
0xa24c6b80,
0x00000000,
0xd24c6b80,
0x00000000,
0xc24c6b80,
0x00000000,
0x0006000b,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000d,
0xed1a0b00,
0x8a000000,
0x00050035,
0xe3730000,
0x000a0000,
0xed1b1b00,
0x3a000000,
0x00050005,
0x8a000000,
0x00050035,
0xee022a10,
0xeeb81bc2,
0xea000000,
0x00050005,
0x0006000e,
0xed1b1b00,
0x8a000000,
0x00050035,
0xee020a10,
0xeeb80bc2,
0x0006000f,
0xeeb40b41,
0xeef1fa10,
0x00000000,
0x324c6b80,
0x00000000,
0x224c6b80,
0x00000000,
0x924c6b80,
0x00000000,
0x824c6b80,
0x00000000,
0xea000000,
0x0005000b,
0x00000000,
0xe1a0b18b,
0xe1aa00d9,
0xe1d6c0b2,
0xe1ab20d9,
0xe2866004,
0xe086c10c,
0xe3710000,
0x000a0000,
0x93730000,
0x000a0000,
0x00000000,
0x9a000000,
0x000500a0,
0x00000000,
0x9a000000,
0x000500a1,
0x00000000,
0xe3710000,
0x000a0000,
0x13730000,
0x000a0000,
0x0a000000,
0x0005003b,
0xe1510003,
0x1a000000,
0x00050002,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050001,
0xe1500002,
0x00000000,
0x1a000000,
0x00050003,
0x0006000b,
0xe24c6b80,
0x0006000c,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000d,
0xe3710000,
0x000a0000,
0x8a000000,
0x0005000c,
0x00000000,
0x0a000000,
0x00050001,
0xe3710000,
0x000a0000,
0x8a000000,
0x00050002,
0x00000000,
0xe510a000,
0x000d8180,
0xe35a0000,
0x00000000,
0x0a000000,
0x0005000c,
0x00000000,
0x0a000000,
0x00050002,
0x00000000,
0xe55aa000,
0x000d8180,
0xe3a03000,
0x000a0000,
0xe1a01000,
0xe31a0000,
0x000a0000,
0x0a000000,
0x0005003a,
0x00000000,
0xea000000,
0x0005000c,
0x00000000,
0x0006000c,
0xe24c6b80,
0x0006000b,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1e0b00b,
0xe18900da,
0xe1d6c0b2,
0xe795210b,
0xe2866004,
0xe086c10c,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050007,
0xe1500002,
0x00000000,
0x024c6b80,
0x0006000b,
0x00000000,
0x0006000b,
0x124c6b80,
0x00000000,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00060011,
0xe3710000,
0x000a0000,
0x1a000000,
0x0005000b,
0xea000000,
0x0005003b,
0x00000000,
0xe1a0b18b,
0xe1aa00d9,
0xe1d6c0b2,
0xe1ab20d5,
0xe2866004,
0xe086c10c,
0x00000000,
0x000600a0,
0x00000000,
0x000600a1,
0x00000000,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050003,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050004,
0xe1500002,
0x00000000,
0x024c6b80,
0x0006000b,
0x00000000,
0x0006000b,
0x124c6b80,
0x00000000,
0x0006000c,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000d,
0x8a000000,
0x00050007,
0x00000000,
0xe3730000,
0x000a0000,
0xee022a10,
0xed1a0b00,
0x3d1b1b00,
0x2eb81bc2,
0xea000000,
0x00050005,
0x0006000e,
0xee020a10,
0xed1b1b00,
0xeeb80bc2,
0x0006000f,
0xeeb40b41,
0xeef1fa10,
0x00000000,
0x024c6b80,
0x00000000,
0x124c6b80,
0x00000000,
0xea000000,
0x0005000c,
0x00000000,
0x00060011,
0xe3710000,
0x000a0000,
0x1a000000,
0x0005000b,
0xea000000,
0x0005003b,
0x00000000,
0xe18900da,
0xe1d6c0b2,
0xe2866004,
0xe1e0b00b,
0xe086c10c,
0xe3710000,
0x000a0000,
0x0a000000,
0x0005003b,
0xe151000b,
0x00000000,
0x024c6b80,
0x00000000,
0x124c6b80,
0x00000000,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe089b18b,
0xe1d6c0b2,
0xe1cb00d0,
0xe2866004,
0xe086c10c,
0xe3710000,
0x000a0000,
0x00000000,
0x924c6b80,
0x00000000,
0x918900fa,
0x00000000,
0x824c6b80,
0x00000000,
0x818900fa,
0x00000000,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1a0b18b,
0xe5d6c000,
0xe18900db,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe089b18b,
0xe5d6c000,
0xe59b0004,
0xe089a00a,
0xe496e004,
0xe3700000,
0x000a0000,
0x93e01000,
0x000a0000,
0x83e01000,
0x000a0000,
0xe58a1004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1a0b18b,
0xe18900db,
0xe5d6c000,
0xe496e004,
0xe3710000,
0x000a0000,
0x8a000000,
0x0005003e,
0x12211480,
0x1a000000,
0x00050005,
0x02700000,
0x614f00d0,
0x00051809,
0x0006000f,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00040007,
0x00060013,
0x00020000,
0x00000000,
0x41e00000,
0x00000000,
0xe1a0b18b,
0xe18900db,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050002,
0xe5100000,
0x000d8180,
0x0006000b,
0xe3e01000,
0x000a0000,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000c,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050040,
0x00000000,
0xe5102000,
0x000d8180,
0xe3520000,
0x1a000000,
0x00050009,
0x0006000d,
0x00000000,
0x00060041,
0xeb000000,
0x00030022,
0xea000000,
0x0005000b,
0x00000000,
0x00060013,
0xe5523000,
0x000d8180,
0xe3130000,
0x000a0000,
0x1a000000,
0x0005000d,
0xea000000,
0x00050040,
0x00000000,
0xe004caae,
0xe004b6ae,
0x00000000,
0xe1ac00d9,
0xe1ab20d5,
0x00000000,
0xe1ac20d9,
0xe1ab00d5,
0x00000000,
0xe1ac00d9,
0xe1ab20d9,
0x00000000,
0xe3730000,
0x000a0000,
0x03710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x03730000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050005,
0xe0900002,
0x00000000,
0x6a000000,
0x0005003c,
0x00000000,
0x6a000000,
0x0005003d,
0x00000000,
0x6a000000,
0x0005003f,
0x00000000,
0x0006000e,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0x00000000,
0xed1c7b00,
0xed1b6b00,
0x00000000,
0xed1c6b00,
0xed1b7b00,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003c,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003d,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003f,
0x00000000,
0xee366b07,
0xe5d6c000,
0xe089a00a,
0xe496e004,
0xed0a6b00,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe004caae,
0xe004b6ae,
0x00000000,
0xe1ac00d9,
0xe1ab20d5,
0x00000000,
0xe1ac20d9,
0xe1ab00d5,
0x00000000,
0xe1ac00d9,
0xe1ab20d9,
0x00000000,
0xe3730000,
0x000a0000,
0x03710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x03730000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050005,
0xe0500002,
0x00000000,
0x6a000000,
0x0005003c,
0x00000000,
0x6a000000,
0x0005003d,
0x00000000,
0x6a000000,
0x0005003f,
0x00000000,
0x0006000e,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0x00000000,
0xed1c7b00,
0xed1b6b00,
0x00000000,
0xed1c6b00,
0xed1b7b00,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003c,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003d,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003f,
0x00000000,
0xee366b47,
0xe5d6c000,
0xe089a00a,
0xe496e004,
0xed0a6b00,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe004caae,
0xe004b6ae,
0x00000000,
0xe1ac00d9,
0xe1ab20d5,
0x00000000,
0xe1ac20d9,
0xe1ab00d5,
0x00000000,
0xe1ac00d9,
0xe1ab20d9,
0x00000000,
0xe3730000,
0x000a0000,
0x03710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x03730000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050005,
0xe0cb0092,
0xe15b0fc0,
0x00000000,
0x1a000000,
0x0005003c,
0x00000000,
0x1a000000,
0x0005003d,
0x00000000,
0x1a000000,
0x0005003f,
0x00000000,
0x0006000e,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0x00000000,
0xed1c7b00,
0xed1b6b00,
0x00000000,
0xed1c6b00,
0xed1b7b00,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003c,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003d,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003f,
0x00000000,
0xee266b07,
0xe5d6c000,
0xe089a00a,
0xe496e004,
0xed0a6b00,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe004caae,
0xe004b6ae,
0x00000000,
0xe1ac00d9,
0xe1ab20d5,
0x00000000,
0xe1ac20d9,
0xe1ab00d5,
0x00000000,
0xe1ac00d9,
0xe1ab20d9,
0x00000000,
0xed1c1b00,
0xed1b0b00,
0x00000000,
0xed1c0b00,
0xed1b1b00,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003c,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003d,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003f,
0x00000000,
0xee800b01,
0xe5d6c000,
0xe089a00a,
0xe496e004,
0xed0a0b00,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe004caae,
0xe004b6ae,
0x00000000,
0xe1ac00d9,
0xe1ab20d5,
0x00000000,
0xe1ac20d9,
0xe1ab00d5,
0x00000000,
0xe1ac00d9,
0xe1ab20d9,
0x00000000,
0xe3730000,
0x000a0000,
0x03710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x03730000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050005,
0xe1b01002,
0x00000000,
0x0a000000,
0x0005003c,
0x00000000,
0x0a000000,
0x0005003d,
0x00000000,
0x0a000000,
0x0005003f,
0x00000000,
0xeb000000,
0x0005009d,
0xe3e01000,
0x000a0000,
0x0006000e,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0x00000000,
0xed1c7b00,
0xed1b6b00,
0x00000000,
0xed1c6b00,
0xed1b7b00,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003c,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003d,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003f,
0x00000000,
0xeb000000,
0x0005009c,
0xe5d6c000,
0xe089a00a,
0xe496e004,
0xed0a6b00,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe004caae,
0xe004b6ae,
0x00000000,
0xe1ac00d9,
0xe1ab20d5,
0x00000000,
0xe1ac20d9,
0xe1ab00d5,
0x00000000,
0xe1ac00d9,
0xe1ab20d9,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003c,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003d,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003f,
0x00000000,
0xeb000000,
0x0003001b,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe004baae,
0xe004c6ae,
0xe04c200b,
0xe5089000,
0x000d8180,
0xe089100c,
0x0006002b,
0xe1a00008,
0xe58d6008,
0xe1a021a2,
0xeb000000,
0x0003002b,
0xe5189000,
0x000d8180,
0xe3500000,
0x1a000000,
0x00050036,
0xe18920db,
0xe5d6c000,
0xe496e004,
0xe18920fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1e0b00b,
0xe5d6c000,
0xe795010b,
0xe3e01000,
0x000a0000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1e0b00b,
0xe5d6c000,
0xe795010b,
0xe3e01000,
0x000a0000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1a0084e,
0xe3e01000,
0x000a0000,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1a0b18b,
0xe5d6c000,
0xe18500db,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe089a00a,
0xe1e0b00b,
0xe5d6c000,
0xe496e004,
0xe58ab004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe089a00a,
0xe089b18b,
0xe3e00000,
0x000a0000,
0xe58a0004,
0xe28aa008,
0x0006000b,
0xe58a0004,
0xe15a000b,
0xe28aa008,
0xba000000,
0x0005000b,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe5191008,
0xe1a0b10b,
0xe28bb000,
0x000a0000,
0xe791100b,
0xe5111000,
0x000d8180,
0xe1c120d0,
0xe5d6c000,
0xe496e004,
0xe18920fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe5191008,
0xe1a0a0aa,
0xe28aa000,
0x000a0000,
0xe1a0b18b,
0xe791100a,
0xe18920db,
0xe551c000,
0x000d8180,
0xe551b000,
0x000d8180,
0xe5111000,
0x000d8180,
0xe31c0000,
0x000a0000,
0xe283c000,
0x000a0000,
0x135b0000,
0xe1c120f0,
0x1a000000,
0x00050002,
0x0006000b,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000c,
0xe37c0000,
0x000a0000,
0x8552b000,
0x000d8180,
0x9a000000,
0x0005000b,
0xe2470000,
0x000a0000,
0xe31b0000,
0x000a0000,
0x1b000000,
0x0003002c,
0xea000000,
0x0005000b,
0x00000000,
0xe5191008,
0xe1a0a0aa,
0xe28aa000,
0x000a0000,
0xe1e0b00b,
0xe791100a,
0xe795210b,
0xe3e03000,
0x000a0000,
0xe551c000,
0x000d8180,
0xe5111000,
0x000d8180,
0xe551b000,
0x000d8180,
0xe31c0000,
0x000a0000,
0xe552c000,
0x000d8180,
0xe1c120f0,
0x1a000000,
0x00050002,
0x0006000b,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000c,
0xe31c0000,
0x000a0000,
0x135b0000,
0xe2470000,
0x000a0000,
0x1b000000,
0x0003002c,
0xea000000,
0x0005000b,
0x00000000,
0xe5191008,
0xe1a0a0aa,
0xe28aa000,
0x000a0000,
0xe1a0b18b,
0xe791100a,
0xe18520db,
0xe5111000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe1c120f0,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe5191008,
0xe1a0a0aa,
0xe28aa000,
0x000a0000,
0xe791100a,
0xe1e0b00b,
0xe5111000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe581b004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe5182000,
0x000d8180,
0xe086b10b,
0xe5089000,
0x000d8180,
0xe3520000,
0xe24b6b80,
0x0a000000,
0x00050001,
0xe1a00008,
0xe089100a,
0xeb000000,
0x0003002d,
0xe5189000,
0x000d8180,
0x0006000b,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1e0b00b,
0xe5089000,
0x000d8180,
0xe795110b,
0xe58d6008,
0xe5192008,
0xe1a00008,
0xeb000000,
0x0003002e,
0xe5189000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1e0b00b,
0x00000000,
0xe5172000,
0x000d8180,
0xe5173000,
0x000d8180,
0xe5089000,
0x000d8180,
0xe58d6008,
0xe1520003,
0xe1a00008,
0x2a000000,
0x00050005,
0x0006000b,
0x00000000,
0xe1a01a8b,
0xe1a025ab,
0xe1a0bac1,
0xe1a01aa1,
0xe37b0001,
0x02811002,
0xeb000000,
0x0003002f,
0x00000000,
0xe795110b,
0xeb000000,
0x00030030,
0x00000000,
0xe5189000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xeb000000,
0x00030031,
0xe1a00008,
0xea000000,
0x0005000b,
0x00000000,
0xe5191008,
0xe1e0b00b,
0xe5110000,
0x000d8180,
0xe795b10b,
0x00000000,
0xea000000,
0x000500a2,
0x00000000,
0xea000000,
0x000500a3,
0x00000000,
0xe004caae,
0xe004b6ae,
0xe18900dc,
0xe18920db,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050030,
0xe3730000,
0x000a0000,
0x05103000,
0x000d8180,
0x05101000,
0x000d8180,
0x1a000000,
0x00050009,
0xe0833182,
0xe1520001,
0x31c320d0,
0x2a000000,
0x00050030,
0xe5d6c000,
0xe3730000,
0x000a0000,
0x0a000000,
0x00050005,
0x0006000b,
0xe496e004,
0xe18920fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe5101000,
0x000d8180,
0xe3510000,
0x0a000000,
0x0005000b,
0xe5511000,
0x000d8180,
0xe3110000,
0x000a0000,
0x1a000000,
0x0005000b,
0xe004caae,
0xea000000,
0x00050030,
0x00060013,
0xe3730000,
0x000a0000,
0x01a0b002,
0x0a000000,
0x000500a2,
0xea000000,
0x00050030,
0x00000000,
0xe004caae,
0xe20bb0ff,
0xe18900dc,
0xe1e0b00b,
0xe795b10b,
0xe3710000,
0x000a0000,
0x1a000000,
0x0005002d,
0x000600a2,
0xe5102000,
0x000d8180,
0xe51b3000,
0x000d8180,
0xe510e000,
0x000d8180,
0xe1a0c000,
0xe0022003,
0xe0822082,
0xe08ee182,
0x0006000b,
0xe14e00d0,
0x000c8100,
0xe14e20d0,
0x000c8100,
0xe51ee000,
0x000d8180,
0xe3710000,
0x000a0000,
0x0150000b,
0x1a000000,
0x00050004,
0xe3730000,
0x000a0000,
0x0a000000,
0x00050005,
0x0006000d,
0xe5d6c000,
0xe496e004,
0xe18920fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000e,
0xe35e0000,
0x1a000000,
0x0005000b,
0x0006000f,
0xe51c0000,
0x000d8180,
0xe3a02000,
0xe3e03000,
0x000a0000,
0xe3500000,
0x0a000000,
0x0005000d,
0xe5501000,
0x000d8180,
0x00000000,
0xe3110000,
0x000a0000,
0x1a000000,
0x0005000d,
0xea000000,
0x0005002e,
0x00000000,
0xe004caae,
0xe20bb0ff,
0xe18900dc,
0xe3710000,
0x000a0000,
0x1a000000,
0x0005002f,
0xe5102000,
0x000d8180,
0xe5103000,
0x000d8180,
0xe1a0118b,
0xe15b0002,
0x318320d1,
0x2a000000,
0x0005002f,
0xe5d6c000,
0xe3730000,
0x000a0000,
0x0a000000,
0x00050005,
0x0006000b,
0xe496e004,
0xe18920fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe5101000,
0x000d8180,
0xe3510000,
0x0a000000,
0x0005000b,
0xe5511000,
0x000d8180,
0xe3110000,
0x000a0000,
0x1a000000,
0x0005000b,
0xea000000,
0x0005002f,
0x00000000,
0xe004caae,
0xe004b6ae,
0xe18900dc,
0xe18920db,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050034,
0xe3730000,
0x000a0000,
0x05101000,
0x000d8180,
0x05103000,
0x000d8180,
0x1a000000,
0x00050009,
0xe0811182,
0xe1520003,
0x3591e004,
0x2a000000,
0x00050034,
0xe5d6c000,
0xe37e0000,
0x000a0000,
0xe550e000,
0x000d8180,
0xe18920da,
0x0a000000,
0x00050005,
0x0006000b,
0xe31e0000,
0x000a0000,
0xe1c120f0,
0x1a000000,
0x00050007,
0x0006000c,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe510a000,
0x000d8180,
0xe35a0000,
0x0a000000,
0x0005000b,
0xe55aa000,
0x000d8180,
0xe31a0000,
0x000a0000,
0x1a000000,
0x0005000b,
0xe516e004,
0xe004caae,
0xe004a2ae,
0xea000000,
0x00050034,
0x00060011,
0x00000000,
0xe5172000,
0x000d8180,
0xe3cee000,
0x000a0000,
0xe5070000,
0x000d8180,
0xe540e000,
0x000d8180,
0xe5002000,
0x000d8180,
0xea000000,
0x0005000c,
0x00060013,
0xe3730000,
0x000a0000,
0x01a0b002,
0x0a000000,
0x000500a3,
0xea000000,
0x00050034,
0x00000000,
0xe004caae,
0xe20bb0ff,
0xe18900dc,
0xe1e0b00b,
0xe795b10b,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050031,
0x000600a3,
0xe5102000,
0x000d8180,
0xe51b3000,
0x000d8180,
0xe510e000,
0x000d8180,
0xe1a0c000,
0xe0022003,
0xe0822082,
0xe3a03000,
0xe08ee182,
0xe54c3000,
0x000d8180,
0x0006000b,
0xe14e00d0,
0x000c8100,
0xe51e3000,
0x000d8180,
0xe51e2000,
0x000d8180,
0xe3710000,
0x000a0000,
0x0150000b,
0x1a000000,
0x00050005,
0xe55c1000,
0x000d8180,
0xe3730000,
0x000a0000,
0xe18920da,
0x0a000000,
0x00050004,
0x0006000c,
0xe3110000,
0x000a0000,
0xe14e20f0,
0x000c8100,
0x1a000000,
0x00050007,
0x0006000d,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000e,
0x00000000,
0xe51c0000,
0x000d8180,
0xe3500000,
0x0a000000,
0x0005000c,
0xe5500000,
0x000d8180,
0xe3100000,
0x000a0000,
0x1a000000,
0x0005000c,
0xea000000,
0x00050032,
0x0006000f,
0xe1b0e002,
0x1a000000,
0x0005000b,
0xe51c0000,
0x000d8180,
0xe1a0200d,
0xe58d6008,
0xe3500000,
0xe5089000,
0x000d8180,
0x15501000,
0x000d8180,
0xe1a00008,
0x0a000000,
0x00050006,
0xe3110000,
0x000a0000,
0x0a000000,
0x00050032,
0x00060010,
0xe3e03000,
0x000a0000,
0xe58db000,
0xe1a0100c,
0xe58d3004,
0xeb000000,
0x00030032,
0xe5189000,
0x000d8180,
0xe18920da,
0xe1c020f0,
0xea000000,
0x0005000d,
0x00060011,
0xe5172000,
0x000d8180,
0xe3c11000,
0x000a0000,
0x00000000,
0xe507c000,
0x000d8180,
0xe54c1000,
0x000d8180,
0xe50c2000,
0x000d8180,
0xea000000,
0x0005000d,
0x00000000,
0xe004caae,
0xe20bb0ff,
0xe18900dc,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050033,
0xe5102000,
0x000d8180,
0xe510c000,
0x000d8180,
0xe1a0118b,
0xe15b0002,
0x31a120dc,
0x2a000000,
0x00050033,
0xe5d6c000,
0xe3730000,
0x000a0000,
0xe550e000,
0x000d8180,
0xe18920da,
0x0a000000,
0x00050005,
0x0006000b,
0xe31e0000,
0x000a0000,
0xe1c120f0,
0x1a000000,
0x00050007,
0x0006000c,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe510a000,
0x000d8180,
0xe35a0000,
0x0a000000,
0x0005000b,
0xe55aa000,
0x000d8180,
0xe31a0000,
0x000a0000,
0x1a000000,
0x0005000b,
0xe516e004,
0xe004a2ae,
0xea000000,
0x00050033,
0x00060011,
0xe5172000,
0x000d8180,
0xe3cee000,
0x000a0000,
0x00000000,
0xe5070000,
0x000d8180,
0xe540e000,
0x000d8180,
0xe5002000,
0x000d8180,
0xea000000,
0x0005000c,
0x00000000,
0xe089a00a,
0x0006000b,
0xe59dc004,
0xe51a1008,
0xe795018b,
0xe25cc008,
0xe5113000,
0x000d8180,
0x0a000000,
0x00050004,
0xe08021ac,
0xe1520003,
0xe5113000,
0x000d8180,
0xe08ac00c,
0x8a000000,
0x00050005,
0xe083e180,
0xe5510000,
0x000d8180,
0x0006000d,
0xe0ca20d8,
0xe0ce20f8,
0xe15a000c,
0x3a000000,
0x0005000d,
0xe3100000,
0x000a0000,
0x1a000000,
0x00050007,
0x0006000e,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xeb000000,
0x00030033,
0xea000000,
0x0005000b,
0x00060011,
0xe5172000,
0x000d8180,
0xe3c00000,
0x000a0000,
0xe5071000,
0x000d8180,
0xe5410000,
0x000d8180,
0xe5012000,
0x000d8180,
0xea000000,
0x0005000e,
0x00000000,
0xe59d0004,
0xe004b6ae,
0xe08bb000,
0xea000000,
0x000500a4,
0x00000000,
0xe004b6ae,
0x000600a4,
0xe1a0c009,
0xe1a920da,
0xe24bb008,
0xe2899008,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050025,
0xe5096004,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x00000000,
0xe59d0004,
0xe080b18b,
0xea000000,
0x000500a5,
0x00000000,
0xe1a0b18b,
0x000600a5,
0xe1aa20d9,
0xe24bb008,
0xe28aa008,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050042,
0xe5196004,
0x00060043,
0xe3a0c000,
0xe5523000,
0x000d8180,
0xe3160000,
0x000a0000,
0x1a000000,
0x00050007,
0x0006000b,
0xe5092008,
0xe35b0000,
0x0a000000,
0x00050003,
0x0006000c,
0xe18a00dc,
0xe28ce008,
0xe15e000b,
0xe18900fc,
0xe1a0c00e,
0x1a000000,
0x0005000c,
0x0006000d,
0xe3530001,
0x8a000000,
0x00050005,
0x0006000e,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x0006000f,
0xe516e004,
0xe004a2ae,
0xe049000a,
0xe5100010,
0xe5100000,
0x000d8180,
0xe5105000,
0x000d8180,
0xea000000,
0x0005000e,
0x00060011,
0xe2266000,
0x000a0000,
0xe3160000,
0x000a0000,
0x00000000,
0x13a03000,
0x1a000000,
0x0005000b,
0xe0499006,
0xe5196004,
0xe3160000,
0x000a0000,
0x13a03000,
0xea000000,
0x0005000b,
0x00000000,
0xe089a00a,
0xe1a0c009,
0xe14a21d0,
0xe14a00d8,
0xe28a9008,
0xe1ca20f8,
0xe1ca01f0,
0xe14a21d8,
0xe3a0b010,
0xe1ca20f0,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050025,
0xe5096004,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x00000000,
0xe089a00a,
0xe51ac010,
0xe51a0008,
0xe51ce000,
0x000d8180,
0xe51c1000,
0x000d8180,
0xe2866004,
0x0006000b,
0xe050b00e,
0xe0812180,
0x2a000000,
0x00050005,
0xe1c220d0,
0xe3730000,
0x000a0000,
0x02800001,
0x0a000000,
0x0005000b,
0xe156b0b2,
0xe3e01000,
0x000a0000,
0xe1ca20f8,
0xe086b10b,
0xe280c001,
0xe1ca00f0,
0xe24b6b80,
0xe50ac008,
0x0006000d,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe51c3000,
0x000d8180,
0xe51cc000,
0x000d8180,
0x00060010,
0xe08b008b,
0xe15b0003,
0xe08c2180,
0x8a000000,
0x0005000d,
0xe14200d0,
0x000c8100,
0xe3710000,
0x000a0000,
0xe28bb001,
0x0a000000,
0x00050010,
0xe156c0b2,
0xe08bb00e,
0xe14220d0,
0x000c8100,
0xe50ab008,
0xe1ca00f8,
0xe086b10c,
0xe24b6b80,
0xe1ca20f0,
0xea000000,
0x0005000d,
0x00000000,
0xe089a00a,
0xe086b10b,
0xe14a01d8,
0xe51a200c,
0xe51a3004,
0xe3710000,
0x000a0000,
0x05500000,
0x000d8180,
0x03720000,
0x000a0000,
0x03730000,
0x000a0000,
0x03500000,
0x000a0000,
0x024b6b80,
0x1a000000,
0x00050005,
0xe5d6c000,
0xe496e004,
0xe3a00000,
0xe3e01b60,
0xe14a00f8,
0x0006000b,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe3a00000,
0x000a0000,
0xe3a0c000,
0x000a0000,
0xe5460004,
0xe24b6b80,
0xe5c6c000,
0xe496e004,
0xea000000,
0x0005000b,
0x00000000,
0xe004caae,
0xe004b6ae,
0xe5190004,
0xe089b00b,
0xe089a00a,
0xe28bb000,
0x000a0000,
0xe08a300c,
0xe2492008,
0xe04bb000,
0xe35c0000,
0xe042000b,
0x0a000000,
0x00050005,
0xe2433010,
0x0006000b,
0xe15b0002,
0x30cb00d8,
0x23e01000,
0x000a0000,
0xe15a0003,
0xe0ca00f8,
0x3a000000,
0x0005000b,
0x0006000c,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe5183000,
0x000d8180,
0xe3500000,
0xd3a0c008,
0xc280c008,
0xe08a1000,
0xe58dc004,
0xda000000,
0x0005000c,
0xe1510003,
0x8a000000,
0x00050007,
0x00060010,
0xe0cb00d8,
0xe0ca00f8,
0xe15b0002,
0x3a000000,
0x00050010,
0xea000000,
0x0005000c,
0x00060011,
0xe1a011a0,
0xe508a000,
0x000d8180,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe04bb009,
0xe58d6008,
0xe04aa009,
0xeb000000,
0x00030000,
0xe5189000,
0x000d8180,
0xe089a00a,
0xe089b00b,
0xe2492008,
0xea000000,
0x00050010,
0x00000000,
0xe59d0004,
0xe5196004,
0xe089a00a,
0xe080b18b,
0xea000000,
0x000500a6,
0x00000000,
0xe5196004,
0xe1a0b18b,
0xe089a00a,
0x000600a6,
0xe58db004,
0x0006000b,
0xe2160000,
0x000a0000,
0xe2261000,
0x000a0000,
0x1a000000,
0x000500a7,
0x00060018,
0xe516e004,
0xe25b3008,
0xe2492008,
0x0a000000,
0x00050003,
0x0006000c,
0xe0ca00d8,
0xe2899008,
0xe2533008,
0xe14901f0,
0x1a000000,
0x0005000c,
0x0006000d,
0xe004a2ae,
0xe042300a,
0xe004caae,
0xe5130008,
0x0006000f,
0xe15c000b,
0x8a000000,
0x00050006,
0xe1a09003,
0xe5101000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe5115000,
0x000d8180,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00060010,
0xe3e01000,
0x000a0000,
0xe2899008,
0xe28bb008,
0xe509100c,
0xea000000,
0x0005000f,
0x000600a8,
0xe089a00a,
0x000600a7,
0xe3110000,
0x000a0000,
0x1a000000,
0x00050019,
0xe0499001,
0xe5196004,
0xea000000,
0x0005000b,
0x00000000,
0xe5196004,
0xe1a0b18b,
0xe58db004,
0xe2160000,
0x000a0000,
0xe2261000,
0x000a0000,
0x0516e004,
0x1a000000,
0x000500a8,
0x00000000,
0xe18900da,
0x00000000,
0xe2493008,
0xe004a2ae,
0x00000000,
0xe1c300f0,
0x00000000,
0xe043900a,
0xe004caae,
0xe5190008,
0x0006000f,
0xe15c000b,
0x8a000000,
0x00050006,
0xe5101000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe5115000,
0x000d8180,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00060010,
0xe2431004,
0xe3e02000,
0x000a0000,
0xe781200b,
0xe28bb008,
0xea000000,
0x0005000f,
0x00000000,
0xe1a000a6,
0xe200007e,
0xe2400000,
0x000a0000,
0xe19710b0,
0xe2511000,
0x000a0000,
0xe18710b0,
0x3a000000,
0x00050093,
0x00000000,
0xe1aa00d9,
0x00000000,
0xe086b10b,
0x00000000,
0xe1ca20d8,
0xe3710000,
0x000a0000,
0xe59ac014,
0x1a000000,
0x00050005,
0xe3730000,
0x000a0000,
0xe59a3010,
0x037c0000,
0x000a0000,
0x1a000000,
0x00050044,
0xe3530000,
0xba000000,
0x00050004,
0xe1500002,
0x00000000,
0xe1ca21d0,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050005,
0xe0900002,
0xe59a3008,
0x00000000,
0x6286bb80,
0x00000000,
0x6a000000,
0x00050002,
0x00000000,
0xe3520000,
0xba000000,
0x00050004,
0xe1500003,
0x00000000,
0x0006000b,
0x00000000,
0xc24b6b80,
0x00000000,
0xe24b6b80,
0xd156b0b2,
0x00000000,
0xd24b6b80,
0x00000000,
0xe1ca00f0,
0x00000000,
0x0006000c,
0xe5d6c000,
0xe496e004,
0xe1ca01f8,
0x00000000,
0xda000000,
0x00070000,
0x00000000,
0x0006000d,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000e,
0x00000000,
0xe1520000,
0x00000000,
0xe1530000,
0x00000000,
0xea000000,
0x0005000b,
0x0006000f,
0x00000000,
0x33730000,
0x000a0000,
0x337c0000,
0x000a0000,
0x2a000000,
0x00050044,
0xed1a0b00,
0xed9a1b02,
0xe35c0000,
0xed8a0b06,
0x00000000,
0xed1a0b00,
0xed9a2b04,
0xed9a1b02,
0xe3530000,
0xee300b02,
0x00000000,
0x00060010,
0xaeb40b41,
0xbeb41b40,
0xeef1fa10,
0x00000000,
0xed0a0b00,
0xed8a0b06,
0x00000000,
0x824b6b80,
0x00000000,
0xe24b6b80,
0x9156b0b2,
0x9a000000,
0x00070000,
0x00000000,
0x924b6b80,
0x00000000,
0x9a000000,
0x00070000,
0x00000000,
0xe5d6c000,
0xe496e004,
0xea000000,
0x0005000d,
0x00000000,
0xe1a000a6,
0xe200007e,
0xe2400000,
0x000a0000,
0xe19710b0,
0xe2511000,
0x000a0000,
0xe18710b0,
0x3a000000,
0x00050093,
0x00000000,
0xe1aa00d9,
0x00000000,
0xe3710000,
0x000a0000,
0x114a00f8,
0x1a000000,
0x00070000,
0x00000000,
0xe086b10b,
0xe3710000,
0x000a0000,
0x124b6b80,
0x114a00f8,
0x00000000,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1a000a6,
0xe200007e,
0xe2400000,
0x000a0000,
0xe19710b0,
0xe2511000,
0x000a0000,
0xe18710b0,
0x3a000000,
0x00050093,
0x00000000,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe5170000,
0x000d8180,
0xe3a01000,
0xe790b10b,
0xe5071000,
0x000d8180,
0xe51ba000,
0x000d8180,
0xe5079000,
0x000d8180,
0xe5078000,
0x000d8180,
0xe12fff1a,
0x00000000,
0xe086b10b,
0xe24b6b80,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1a000a6,
0xe200007e,
0xe2400000,
0x000a0000,
0xe19710b0,
0xe2511000,
0x000a0000,
0xe18710b0,
0x3a000000,
0x00050095,
0x00000000,
0xe5180000,
0x000d8180,
0xe5561000,
0x000d8180,
0xe5165000,
0x000d8180,
0xe15a0000,
0x8a000000,
0x00050020,
0x00000000,
0xe5d6c000,
0xe496e004,
0x00000000,
0x0006000c,
0xe15b0181,
0xe3e03000,
0x000a0000,
0x3a000000,
0x00050003,
0x00000000,
0xe1a0b82e,
0xea000000,
0x00070000,
0x00000000,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0x0006000d,
0xe18920fb,
0xe28bb008,
0xea000000,
0x0005000c,
0x00000000,
0xe7f001f0,
0x00000000,
0xe5180000,
0x000d8180,
0xe089300b,
0xe08aa00b,
0xe5832000,
0xe28b1000,
0x000a0000,
0xe5165000,
0x000d8180,
0xe15a0000,
0xe5831004,
0x2a000000,
0x00050020,
0xe556c000,
0x000d8180,
0xe1a0a009,
0xe1a0b003,
0xe35c0000,
0xe2839008,
0x0a000000,
0x00050003,
0xe3e02000,
0x000a0000,
0x0006000b,
0xe15a000b,
0x30ca00d8,
0x21a01002,
0x350a2004,
0x0006000c,
0xe25cc001,
0xe1e300f8,
0x1a000000,
0x0005000b,
0x0006000d,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe5123000,
0x000d8180,
0x00000000,
0xe5173000,
0x000d8180,
0x00000000,
0xe08a100b,
0xe5180000,
0x000d8180,
0xe089b00b,
0xe5089000,
0x000d8180,
0xe1510000,
0xe508b000,
0x000d8180,
0x00000000,
0xe5121000,
0x000d8180,
0x00000000,
0xe3e02000,
0x000a0000,
0xe1a00008,
0x8a000000,
0x0005001f,
0xe5072000,
0x000d8180,
0xe12fff33,
0xe5189000,
0x000d8180,
0xe3e02000,
0x000a0000,
0xe5181000,
0x000d8180,
0xe1a0b180,
0xe5072000,
0x000d8180,
0xe5196004,
0xe041a00b,
0xea000000,
0x00050016,
0x00000000,
0x00010000
};

# 9 "vm_arm.dasc"
//|.globals GLOB_
enum {
  GLOB_vm_returnp,
  GLOB_cont_dispatch,
  GLOB_vm_returnc,
  GLOB_vm_unwind_c_eh,
  GLOB_BC_RET_Z,
  GLOB_vm_return,
  GLOB_vm_leave_cp,
  GLOB_vm_leave_unw,
  GLOB_vm_unwind_c,
  GLOB_vm_unwind_ff,
  GLOB_vm_unwind_ff_eh,
  GLOB_vm_growstack_c,
  GLOB_vm_growstack_l,
  GLOB_vm_resume,
  GLOB_vm_pcall,
  GLOB_vm_call,
  GLOB_vm_call_dispatch,
  GLOB_vmeta_call,
  GLOB_vm_call_dispatch_f,
  GLOB_vm_cpcall,
  GLOB_cont_ffi_callback,
  GLOB_vm_call_tail,
  GLOB_cont_cat,
  GLOB_BC_CAT_Z,
  GLOB_cont_nop,
  GLOB_vmeta_tgets1,
  GLOB_vmeta_tgets,
  GLOB_vmeta_tgetb,
  GLOB_vmeta_tgetv,
  GLOB_vmeta_tsets1,
  GLOB_vmeta_tsets,
  GLOB_vmeta_tsetb,
  GLOB_vmeta_tsetv,
  GLOB_vmeta_comp,
  GLOB_vmeta_binop,
  GLOB_cont_ra,
  GLOB_cont_condt,
  GLOB_cont_condf,
  GLOB_vmeta_equal,
  GLOB_vmeta_equal_cd,
  GLOB_vmeta_arith_vn,
  GLOB_vmeta_arith_nv,
  GLOB_vmeta_unm,
  GLOB_vmeta_arith_vv,
  GLOB_vmeta_len,
  GLOB_BC_LEN_Z,
  GLOB_vmeta_callt,
  GLOB_BC_CALLT2_Z,
  GLOB_vmeta_for,
  GLOB_ff_assert,
  GLOB_fff_fallback,
  GLOB_fff_res,
  GLOB_ff_type,
  GLOB_fff_restv,
  GLOB_ff_getmetatable,
  GLOB_ff_setmetatable,
  GLOB_ff_rawget,
  GLOB_ff_tonumber,
  GLOB_ff_tostring,
  GLOB_fff_gcstep,
  GLOB_ff_next,
  GLOB_ff_pairs,
  GLOB_ff_ipairs_aux,
  GLOB_ff_ipairs,
  GLOB_ff_pcall,
  GLOB_ff_xpcall,
  GLOB_ff_coroutine_resume,
  GLOB_ff_coroutine_wrap_aux,
  GLOB_ff_coroutine_yield,
  GLOB_ff_math_floor,
  GLOB_vm_floor_sf,
  GLOB_ff_math_ceil,
  GLOB_vm_ceil_sf,
  GLOB_ff_math_abs,
  GLOB_fff_res1,
  GLOB_ff_math_sqrt,
  GLOB_fff_resd,
  GLOB_ff_math_log,
  GLOB_ff_math_log10,
  GLOB_ff_math_exp,
  GLOB_ff_math_sin,
  GLOB_ff_math_cos,
  GLOB_ff_math_tan,
  GLOB_ff_math_asin,
  GLOB_ff_math_acos,
  GLOB_ff_math_atan,
  GLOB_ff_math_sinh,
  GLOB_ff_math_cosh,
  GLOB_ff_math_tanh,
  GLOB_ff_math_pow,
  GLOB_ff_math_atan2,
  GLOB_ff_math_fmod,
  GLOB_ff_math_deg,
  GLOB_ff_math_rad,
  GLOB_ff_math_ldexp,
  GLOB_ff_math_frexp,
  GLOB_ff_math_modf,
  GLOB_ff_math_min,
  GLOB_ff_math_max,
  GLOB_ff_string_len,
  GLOB_ff_string_byte,
  GLOB_ff_string_char,
  GLOB_fff_newstr,
  GLOB_ff_string_sub,
  GLOB_fff_emptystr,
  GLOB_ff_string_rep,
  GLOB_ff_string_reverse,
  GLOB_ff_string_lower,
  GLOB_ff_string_upper,
  GLOB_ff_table_getn,
  GLOB_vm_tobit_fb,
  GLOB_vm_tobit,
  GLOB_ff_bit_tobit,
  GLOB_ff_bit_band,
  GLOB_ff_bit_bor,
  GLOB_ff_bit_bxor,
  GLOB_ff_bit_bswap,
  GLOB_ff_bit_bnot,
  GLOB_ff_bit_lshift,
  GLOB_ff_bit_rshift,
  GLOB_ff_bit_arshift,
  GLOB_ff_bit_rol,
  GLOB_ff_bit_ror,
  GLOB_vm_record,
  GLOB_vm_rethook,
  GLOB_vm_inshook,
  GLOB_cont_hook,
  GLOB_vm_hotloop,
  GLOB_vm_callhook,
  GLOB_vm_hotcall,
  GLOB_vm_exit_handler,
  GLOB_vm_exit_interp,
  GLOB_vm_floor,
  GLOB_vm_ceil,
  GLOB_vm_trunc,
  GLOB_vm_trunc_sf,
  GLOB_vm_mod,
  GLOB_vm_modi,
  GLOB_vm_ffi_callback,
  GLOB_vm_ffi_call,
  GLOB_BC_ISEQN_Z,
  GLOB_BC_ISNEN_Z,
  GLOB_BC_TGETS_Z,
  GLOB_BC_TSETS_Z,
  GLOB_BC_CALL_Z,
  GLOB_BC_CALLT1_Z,
  GLOB_BC_RETM_Z,
  GLOB_BC_RETV2_Z,
  GLOB_BC_RETV1_Z,
  GLOB__MAX
};
# 10 "vm_arm.dasc"
//|.globalnames globnames
static const char *const globnames[] = {
  "vm_returnp",
  "cont_dispatch",
  "vm_returnc",
  "vm_unwind_c_eh",
  "BC_RET_Z",
  "vm_return",
  "vm_leave_cp",
  "vm_leave_unw",
  "vm_unwind_c",
  "vm_unwind_ff",
  "vm_unwind_ff_eh",
  "vm_growstack_c",
  "vm_growstack_l",
  "vm_resume",
  "vm_pcall",
  "vm_call",
  "vm_call_dispatch",
  "vmeta_call",
  "vm_call_dispatch_f",
  "vm_cpcall",
  "cont_ffi_callback",
  "vm_call_tail",
  "cont_cat",
  "BC_CAT_Z",
  "cont_nop",
  "vmeta_tgets1",
  "vmeta_tgets",
  "vmeta_tgetb",
  "vmeta_tgetv",
  "vmeta_tsets1",
  "vmeta_tsets",
  "vmeta_tsetb",
  "vmeta_tsetv",
  "vmeta_comp",
  "vmeta_binop",
  "cont_ra",
  "cont_condt",
  "cont_condf",
  "vmeta_equal",
  "vmeta_equal_cd",
  "vmeta_arith_vn",
  "vmeta_arith_nv",
  "vmeta_unm",
  "vmeta_arith_vv",
  "vmeta_len",
  "BC_LEN_Z",
  "vmeta_callt",
  "BC_CALLT2_Z",
  "vmeta_for",
  "ff_assert",
  "fff_fallback",
  "fff_res",
  "ff_type",
  "fff_restv",
  "ff_getmetatable",
  "ff_setmetatable",
  "ff_rawget",
  "ff_tonumber",
  "ff_tostring",
  "fff_gcstep",
  "ff_next",
  "ff_pairs",
  "ff_ipairs_aux",
  "ff_ipairs",
  "ff_pcall",
  "ff_xpcall",
  "ff_coroutine_resume",
  "ff_coroutine_wrap_aux",
  "ff_coroutine_yield",
  "ff_math_floor",
  "vm_floor_sf",
  "ff_math_ceil",
  "vm_ceil_sf",
  "ff_math_abs",
  "fff_res1",
  "ff_math_sqrt",
  "fff_resd",
  "ff_math_log",
  "ff_math_log10",
  "ff_math_exp",
  "ff_math_sin",
  "ff_math_cos",
  "ff_math_tan",
  "ff_math_asin",
  "ff_math_acos",
  "ff_math_atan",
  "ff_math_sinh",
  "ff_math_cosh",
  "ff_math_tanh",
  "ff_math_pow",
  "ff_math_atan2",
  "ff_math_fmod",
  "ff_math_deg",
  "ff_math_rad",
  "ff_math_ldexp",
  "ff_math_frexp",
  "ff_math_modf",
  "ff_math_min",
  "ff_math_max",
  "ff_string_len",
  "ff_string_byte",
  "ff_string_char",
  "fff_newstr",
  "ff_string_sub",
  "fff_emptystr",
  "ff_string_rep",
  "ff_string_reverse",
  "ff_string_lower",
  "ff_string_upper",
  "ff_table_getn",
  "vm_tobit_fb",
  "vm_tobit",
  "ff_bit_tobit",
  "ff_bit_band",
  "ff_bit_bor",
  "ff_bit_bxor",
  "ff_bit_bswap",
  "ff_bit_bnot",
  "ff_bit_lshift",
  "ff_bit_rshift",
  "ff_bit_arshift",
  "ff_bit_rol",
  "ff_bit_ror",
  "vm_record",
  "vm_rethook",
  "vm_inshook",
  "cont_hook",
  "vm_hotloop",
  "vm_callhook",
  "vm_hotcall",
  "vm_exit_handler",
  "vm_exit_interp",
  "vm_floor",
  "vm_ceil",
  "vm_trunc",
  "vm_trunc_sf",
  "vm_mod",
  "vm_modi",
  "vm_ffi_callback",
  "vm_ffi_call",
  "BC_ISEQN_Z",
  "BC_ISNEN_Z",
  "BC_TGETS_Z",
  "BC_TSETS_Z",
  "BC_CALL_Z",
  "BC_CALLT1_Z",
  "BC_RETM_Z",
  "BC_RETV2_Z",
  "BC_RETV1_Z",
  (const char *)0
};
# 11 "vm_arm.dasc"
//|.externnames extnames
static const char *const extnames[] = {
  "lj_state_growstack",
  "lj_meta_tget",
  "lj_meta_tset",
  "lj_meta_comp",
  "lj_meta_equal",
  "lj_meta_equal_cd",
  "lj_meta_arith",
  "lj_meta_len",
  "lj_meta_call",
  "lj_meta_for",
  "lj_tab_get",
  "lj_str_fromnumber",
  "lj_tab_next",
  "lj_tab_getinth",
  "lj_ffh_coroutine_wrap_err",
  "log",
  "log10",
  "exp",
  "sin",
  "cos",
  "tan",
  "asin",
  "acos",
  "atan",
  "sinh",
  "cosh",
  "tanh",
  "pow",
  "atan2",
  "fmod",
  "ldexp",
  "frexp",
  "modf",
  "lj_str_new",
  "lj_tab_len",
  "lj_gc_step",
  "lj_dispatch_ins",
  "lj_trace_hot",
  "lj_dispatch_call",
  "lj_trace_exit",
  "lj_err_throw",
  "lj_ccallback_enter",
  "lj_ccallback_leave",
  "lj_meta_cat",
  "lj_gc_barrieruv",
  "lj_func_closeuv",
  "lj_func_newL_gc",
  "lj_tab_new",
  "lj_tab_dup",
  "lj_gc_step_fixtop",
  "lj_tab_newkey",
  "lj_tab_reasize",
  (const char *)0
};
# 12 "vm_arm.dasc"
//|
//|// Note: The ragged indentation of the instructions is intentional.
//|//       The starting columns indicate data dependencies.
//|
//|//-----------------------------------------------------------------------
//|
//|// Fixed register assignments for the interpreter.
//|
//|// The following must be C callee-save.
//|.define MASKR8,	r4	// 255*8 constant for fast bytecode decoding.
//|.define KBASE,		r5	// Constants of current Lua function.
//|.define PC,		r6	// Next PC.
//|.define DISPATCH,	r7	// Opcode dispatch table.
//|.define LREG,		r8	// Register holding lua_State (also in SAVE_L).
//|
//|// C callee-save in EABI, but often refetched. Temporary in iOS 3.0+.
//|.define BASE,		r9	// Base of current Lua stack frame.
//|
//|// The following temporaries are not saved across C calls, except for RA/RC.
//|.define RA,		r10	// Callee-save.
//|.define RC,		r11	// Callee-save.
//|.define RB,		r12
//|.define OP,		r12	// Overlaps RB, must not be lr.
//|.define INS,		lr
//|
//|// Calling conventions. Also used as temporaries.
//|.define CARG1,		r0
//|.define CARG2,		r1
//|.define CARG3,		r2
//|.define CARG4,		r3
//|.define CARG12,	r0	// For 1st soft-fp double.
//|.define CARG34,	r2	// For 2nd soft-fp double.
//|
//|.define CRET1,		r0
//|.define CRET2,		r1
//|
//|// Stack layout while in interpreter. Must match with lj_frame.h.
//|.define SAVE_R4,	[sp, #28]
//|.define CFRAME_SPACE,	#28
//|.define SAVE_ERRF,	[sp, #24]
//|.define SAVE_NRES,	[sp, #20]
//|.define SAVE_CFRAME,	[sp, #16]
//|.define SAVE_L,	[sp, #12]
//|.define SAVE_PC,	[sp, #8]
//|.define SAVE_MULTRES,	[sp, #4]
//|.define ARG5,		[sp]
//|
//|.define TMPDhi,	[sp, #4]
//|.define TMPDlo,	[sp]
//|.define TMPD,		[sp]
//|.define TMPDp,		sp
//|
//|.if FPU
//|.macro saveregs
//|  push {r5, r6, r7, r8, r9, r10, r11, lr}
//|  vpush {d8-d15}
//|  sub sp, sp, CFRAME_SPACE+4
//|  str r4, SAVE_R4
//|.endmacro
//|.macro restoreregs_ret
//|  ldr r4, SAVE_R4
//|  add sp, sp, CFRAME_SPACE+4
//|  vpop {d8-d15}
//|  pop {r5, r6, r7, r8, r9, r10, r11, pc}
//|.endmacro
//|.else
//|.macro saveregs
//|  push {r4, r5, r6, r7, r8, r9, r10, r11, lr}
//|  sub sp, sp, CFRAME_SPACE
//|.endmacro
//|.macro restoreregs_ret
//|  add sp, sp, CFRAME_SPACE
//|  pop {r4, r5, r6, r7, r8, r9, r10, r11, pc}
//|.endmacro
//|.endif
//|
//|// Type definitions. Some of these are only used for documentation.
//|.type L,		lua_State,	LREG
#define Dt1(_V) (int)(ptrdiff_t)&(((lua_State *)0)_V)
# 90 "vm_arm.dasc"
//|.type GL,		global_State
#define Dt2(_V) (int)(ptrdiff_t)&(((global_State *)0)_V)
# 91 "vm_arm.dasc"
//|.type TVALUE,		TValue
#define Dt3(_V) (int)(ptrdiff_t)&(((TValue *)0)_V)
# 92 "vm_arm.dasc"
//|.type GCOBJ,		GCobj
#define Dt4(_V) (int)(ptrdiff_t)&(((GCobj *)0)_V)
# 93 "vm_arm.dasc"
//|.type STR,		GCstr
#define Dt5(_V) (int)(ptrdiff_t)&(((GCstr *)0)_V)
# 94 "vm_arm.dasc"
//|.type TAB,		GCtab
#define Dt6(_V) (int)(ptrdiff_t)&(((GCtab *)0)_V)
# 95 "vm_arm.dasc"
//|.type LFUNC,		GCfuncL
#define Dt7(_V) (int)(ptrdiff_t)&(((GCfuncL *)0)_V)
# 96 "vm_arm.dasc"
//|.type CFUNC,		GCfuncC
#define Dt8(_V) (int)(ptrdiff_t)&(((GCfuncC *)0)_V)
# 97 "vm_arm.dasc"
//|.type PROTO,		GCproto
#define Dt9(_V) (int)(ptrdiff_t)&(((GCproto *)0)_V)
# 98 "vm_arm.dasc"
//|.type UPVAL,		GCupval
#define DtA(_V) (int)(ptrdiff_t)&(((GCupval *)0)_V)
# 99 "vm_arm.dasc"
//|.type NODE,		Node
#define DtB(_V) (int)(ptrdiff_t)&(((Node *)0)_V)
# 100 "vm_arm.dasc"
//|.type NARGS8,		int
#define DtC(_V) (int)(ptrdiff_t)&(((int *)0)_V)
# 101 "vm_arm.dasc"
//|.type TRACE,		GCtrace
#define DtD(_V) (int)(ptrdiff_t)&(((GCtrace *)0)_V)
# 102 "vm_arm.dasc"
//|
//|//-----------------------------------------------------------------------
//|
//|// Trap for not-yet-implemented parts.
//|.macro NYI; ud; .endmacro
//|
//|//-----------------------------------------------------------------------
//|
//|// Access to frame relative to BASE.
//|.define FRAME_FUNC,	#-8
//|.define FRAME_PC,	#-4
//|
//|.macro decode_RA8, dst, ins; and dst, MASKR8, ins, lsr #5; .endmacro
//|.macro decode_RB8, dst, ins; and dst, MASKR8, ins, lsr #21; .endmacro
//|.macro decode_RC8, dst, ins; and dst, MASKR8, ins, lsr #13; .endmacro
//|.macro decode_RD, dst, ins; lsr dst, ins, #16; .endmacro
//|.macro decode_OP, dst, ins; and dst, ins, #255; .endmacro
//|
//|// Instruction fetch.
//|.macro ins_NEXT1
//|  ldrb OP, [PC]
//|.endmacro
//|.macro ins_NEXT2
//|   ldr INS, [PC], #4
//|.endmacro
//|// Instruction decode+dispatch.
//|.macro ins_NEXT3
//|  ldr OP, [DISPATCH, OP, lsl #2]
//|   decode_RA8 RA, INS
//|   decode_RD RC, INS
//|  bx OP
//|.endmacro
//|.macro ins_NEXT
//|  ins_NEXT1
//|  ins_NEXT2
//|  ins_NEXT3
//|.endmacro
//|
//|// Instruction footer.
//|.if 1
//|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
//|  .define ins_next, ins_NEXT
//|  .define ins_next_, ins_NEXT
//|  .define ins_next1, ins_NEXT1
//|  .define ins_next2, ins_NEXT2
//|  .define ins_next3, ins_NEXT3
//|.else
//|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
//|  // Affects only certain kinds of benchmarks (and only with -j off).
//|  .macro ins_next
//|    b ->ins_next
//|  .endmacro
//|  .macro ins_next1
//|  .endmacro
//|  .macro ins_next2
//|  .endmacro
//|  .macro ins_next3
//|    b ->ins_next
//|  .endmacro
//|  .macro ins_next_
//|  ->ins_next:
//|    ins_NEXT
//|  .endmacro
//|.endif
//|
//|// Avoid register name substitution for field name.
#define field_pc	pc
//|
//|// Call decode and dispatch.
//|.macro ins_callt
//|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
//|  ldr PC, LFUNC:CARG3->field_pc
//|  ldrb OP, [PC]  // STALL: load PC. early PC.
//|   ldr INS, [PC], #4
//|  ldr OP, [DISPATCH, OP, lsl #2]  // STALL: load OP. early OP.
//|   decode_RA8 RA, INS
//|   add RA, RA, BASE
//|  bx OP
//|.endmacro
//|
//|.macro ins_call
//|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, PC = caller PC
//|  str PC, [BASE, FRAME_PC]
//|  ins_callt  // STALL: locked PC.
//|.endmacro
//|
//|//-----------------------------------------------------------------------
//|
//|// Macros to test operand types.
//|.macro checktp, reg, tp; cmn reg, #-tp; .endmacro
//|.macro checktpeq, reg, tp; cmneq reg, #-tp; .endmacro
//|.macro checktpne, reg, tp; cmnne reg, #-tp; .endmacro
//|.macro checkstr, reg, target; checktp reg, LJ_TSTR; bne target; .endmacro
//|.macro checktab, reg, target; checktp reg, LJ_TTAB; bne target; .endmacro
//|.macro checkfunc, reg, target; checktp reg, LJ_TFUNC; bne target; .endmacro
//|
//|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)	(GG_DISP2G + (int)offsetof(global_State, field))
#define DISPATCH_J(field)	(GG_DISP2J + (int)offsetof(jit_State, field))
//|
#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
//|
//|.macro hotcheck, delta
//|  lsr CARG1, PC, #1
//|  and CARG1, CARG1, #126
//|  sub CARG1, CARG1, #-GG_DISP2HOT
//|  ldrh CARG2, [DISPATCH, CARG1]
//|  subs CARG2, CARG2, #delta
//|  strh CARG2, [DISPATCH, CARG1]
//|.endmacro
//|
//|.macro hotloop
//|  hotcheck HOTCOUNT_LOOP
//|  blo ->vm_hotloop
//|.endmacro
//|
//|.macro hotcall
//|  hotcheck HOTCOUNT_CALL
//|  blo ->vm_hotcall
//|.endmacro
//|
//|// Set current VM state.
//|.macro mv_vmstate, reg, st; mvn reg, #LJ_VMST_..st; .endmacro
//|.macro st_vmstate, reg; str reg, [DISPATCH, #DISPATCH_GL(vmstate)]; .endmacro
//|
//|// Move table write barrier back. Overwrites mark and tmp.
//|.macro barrierback, tab, mark, tmp
//|  ldr tmp, [DISPATCH, #DISPATCH_GL(gc.grayagain)]
//|   bic mark, mark, #LJ_GC_BLACK		// black2gray(tab)
//|  str tab, [DISPATCH, #DISPATCH_GL(gc.grayagain)]
//|   strb mark, tab->marked
//|  str tmp, tab->gclist
//|.endmacro
//|
//|.macro .IOS, a, b
//|.if IOS
//|  a, b
//|.endif
//|.endmacro
//|
//|//-----------------------------------------------------------------------

#if !LJ_DUALNUM
#error "Only dual-number mode supported for ARM target"
#endif

/* Generate subroutines used by opcodes and other parts of the VM. */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
  //|.code_sub
  dasm_put(Dst, 0);
# 253 "vm_arm.dasc"
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Return handling ----------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_returnp:
  //|  // See vm_return. Also: RB = previous base.
  //|  tst PC, #FRAME_P
  //|  beq ->cont_dispatch
  //|
  //|  // Return from pcall or xpcall fast func.
  //|  ldr PC, [RB, FRAME_PC]		// Fetch PC of previous frame.
  //|   mvn CARG2, #~LJ_TTRUE
  //|  mov BASE, RB
  //|  // Prepending may overwrite the pcall frame, so do it at the end.
  //|   str CARG2, [RA, FRAME_PC]		// Prepend true to results.
  //|  sub RA, RA, #8
  //|
  //|->vm_returnc:
  //|  adds RC, RC, #8			// RC = (nresults+1)*8.
  //|  mov CRET1, #LUA_YIELD
  //|  beq ->vm_unwind_c_eh
  //|  str RC, SAVE_MULTRES
  //|  ands CARG1, PC, #FRAME_TYPE
  //|  beq ->BC_RET_Z			// Handle regular return to Lua.
  //|
  //|->vm_return:
  //|  // BASE = base, RA = resultptr, RC/MULTRES = (nresults+1)*8, PC = return
  //|  // CARG1 = PC & FRAME_TYPE
  //|  bic RB, PC, #FRAME_TYPEP
  //|   cmp CARG1, #FRAME_C
  //|  sub RB, BASE, RB			// RB = previous base.
  //|   bne ->vm_returnp
  //|
  //|  str RB, L->base
  //|   ldr KBASE, SAVE_NRES
  //|    mv_vmstate CARG4, C
  //|   sub BASE, BASE, #8
  //|  subs CARG3, RC, #8
  //|   lsl KBASE, KBASE, #3		// KBASE = (nresults_wanted+1)*8
  //|    st_vmstate CARG4
  //|  beq >2
  //|1:
  //|  subs CARG3, CARG3, #8
  //|   ldrd CARG12, [RA], #8
  //|   strd CARG12, [BASE], #8
  //|  bne <1
  //|2:
  //|  cmp KBASE, RC			// More/less results wanted?
  //|  bne >6
  //|3:
  //|  str BASE, L->top			// Store new top.
  dasm_put(Dst, 1, FRAME_P, ~LJ_TTRUE, LUA_YIELD, FRAME_TYPE, FRAME_TYPEP, FRAME_C, Dt1(->base), LJ_VMST_C, DISPATCH_GL(vmstate));
# 305 "vm_arm.dasc"
  //|
  //|->vm_leave_cp:
  //|  ldr RC, SAVE_CFRAME		// Restore previous C frame.
  //|   mov CRET1, #0			// Ok return status for vm_pcall.
  //|  str RC, L->cframe
  //|
  //|->vm_leave_unw:
  //|  restoreregs_ret
  //|
  //|6:
  //|  blt >7				// Less results wanted?
  //|  // More results wanted. Check stack size and fill up results with nil.
  //|  ldr CARG3, L->maxstack
  //|   mvn CARG2, #~LJ_TNIL
  //|  cmp BASE, CARG3
  //|  bhs >8
  //|   str CARG2, [BASE, #4]
  //|  add RC, RC, #8
  //|  add BASE, BASE, #8
  //|  b <2
  //|
  //|7:  // Less results wanted.
  //|  sub CARG1, RC, KBASE
  //|  cmp KBASE, #0			// LUA_MULTRET+1 case?
  //|  subne BASE, BASE, CARG1		// Either keep top or shrink it.
  //|  b <3
  //|
  //|8:  // Corner case: need to grow stack for filling up results.
  //|  // This can happen if:
  //|  // - A C function grows the stack (a lot).
  //|  // - The GC shrinks the stack in between.
  //|  // - A return back from a lua_call() with (high) nresults adjustment.
  //|  str BASE, L->top			// Save current top held in BASE (yes).
  //|  mov CARG2, KBASE
  //|  mov CARG1, L
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  ldr BASE, L->top			// Need the (realloced) L->top in BASE.
  //|  b <2
  //|
  //|->vm_unwind_c:			// Unwind C stack, return from vm_pcall.
  //|  // (void *cframe, int errcode)
  //|  mov sp, CARG1
  //|  mov CRET1, CARG2
  //|->vm_unwind_c_eh:			// Landing pad for external unwinder.
  //|  ldr L, SAVE_L
  //|   mv_vmstate CARG4, C
  //|  ldr GL:CARG3, L->glref
  //|   str CARG4, GL:CARG3->vmstate
  dasm_put(Dst, 55, Dt1(->top), Dt1(->cframe), 28+4, Dt1(->maxstack), ~LJ_TNIL, Dt1(->top), Dt1(->top), LJ_VMST_C, Dt1(->glref));
# 353 "vm_arm.dasc"
  //|  b ->vm_leave_unw
  //|
  //|->vm_unwind_ff:			// Unwind C stack, return from ff pcall.
  //|  // (void *cframe)
  //|  bic CARG1, CARG1, #~CFRAME_RAWMASK	// Use two steps: bic sp is deprecated.
  //|  mov sp, CARG1
  //|->vm_unwind_ff_eh:			// Landing pad for external unwinder.
  //|  ldr L, SAVE_L
  //|   mov MASKR8, #255
  //|    mov RC, #16			// 2 results: false + error message.
  //|   lsl MASKR8, MASKR8, #3		// MASKR8 = 255*8.
  //|  ldr BASE, L->base
  //|   ldr DISPATCH, L->glref		// Setup pointer to dispatch table.
  //|    mvn CARG1, #~LJ_TFALSE
  //|  sub RA, BASE, #8			// Results start at BASE-8.
  //|  ldr PC, [BASE, FRAME_PC]		// Fetch PC of previous frame.
  //|   add DISPATCH, DISPATCH, #GG_G2DISP
  //|   mv_vmstate CARG2, INTERP
  //|    str CARG1, [BASE, #-4]		// Prepend false to error message.
  //|   st_vmstate CARG2
  //|  b ->vm_returnc
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Grow stack for calls -----------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_growstack_c:			// Grow stack for C function.
  //|  // CARG1 = L
  //|  mov CARG2, #LUA_MINSTACK
  //|  b >2
  //|
  //|->vm_growstack_l:			// Grow stack for Lua function.
  //|  // BASE = new base, RA = BASE+framesize*8, RC = nargs*8, PC = first PC
  //|  add RC, BASE, RC
  //|   sub RA, RA, BASE
  //|    mov CARG1, L
  //|  str BASE, L->base
  //|   add PC, PC, #4			// Must point after first instruction.
  //|  str RC, L->top
  //|   lsr CARG3, RA, #3
  //|2:
  //|  // L->base = new base, L->top = top
  //|  str PC, SAVE_PC
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  ldr BASE, L->base
  //|   ldr RC, L->top
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  dasm_put(Dst, 110, Dt2(->vmstate), ~CFRAME_RAWMASK, Dt1(->base), Dt1(->glref), ~LJ_TFALSE, GG_G2DISP, LJ_VMST_INTERP, DISPATCH_GL(vmstate), LUA_MINSTACK, Dt1(->base), Dt1(->top), Dt1(->base), Dt1(->top));
# 400 "vm_arm.dasc"
  //|   sub NARGS8:RC, RC, BASE
  //|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
  //|  ins_callt				// Just retry the call.
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Entry points into the assembler VM ---------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_resume:				// Setup C frame and resume thread.
  //|  // (lua_State *L, TValue *base, int nres1 = 0, ptrdiff_t ef = 0)
  //|  saveregs
  //|  mov L, CARG1
  //|    ldr DISPATCH, L:CARG1->glref	// Setup pointer to dispatch table.
  //|  mov BASE, CARG2
  //|    add DISPATCH, DISPATCH, #GG_G2DISP
  //|   str L, SAVE_L
  //|  mov PC, #FRAME_CP
  //|   str CARG3, SAVE_NRES
  //|    add CARG2, sp, #CFRAME_RESUME
  //|  ldrb CARG1, L->status
  //|   str CARG3, SAVE_ERRF
  //|    str CARG2, L->cframe
  //|   str CARG3, SAVE_CFRAME
  //|  cmp CARG1, #0
  //|   str L, SAVE_PC			// Any value outside of bytecode is ok.
  //|  beq >3
  //|
  //|  // Resume after yield (like a return).
  //|  mov RA, BASE
  //|   ldr BASE, L->base
  //|   ldr CARG1, L->top
  //|    mov MASKR8, #255
  //|     strb CARG3, L->status
  //|   sub RC, CARG1, BASE
  //|  ldr PC, [BASE, FRAME_PC]
  //|    lsl MASKR8, MASKR8, #3		// MASKR8 = 255*8.
  //|     mv_vmstate CARG2, INTERP
  //|   add RC, RC, #8
  //|  ands CARG1, PC, #FRAME_TYPE
  //|     st_vmstate CARG2
  //|   str RC, SAVE_MULTRES
  //|  beq ->BC_RET_Z
  //|  b ->vm_return
  //|
  //|->vm_pcall:				// Setup protected C frame and enter VM.
  //|  // (lua_State *L, TValue *base, int nres1, ptrdiff_t ef)
  //|  saveregs
  //|  mov PC, #FRAME_CP
  //|  str CARG4, SAVE_ERRF
  //|  b >1
  //|
  //|->vm_call:				// Setup C frame and enter VM.
  //|  // (lua_State *L, TValue *base, int nres1)
  //|  saveregs
  dasm_put(Dst, 164, Dt7(->field_pc), 28+4, Dt1(->glref), GG_G2DISP, FRAME_CP, CFRAME_RESUME, Dt1(->status), Dt1(->cframe), Dt1(->base), Dt1(->top), Dt1(->status), LJ_VMST_INTERP, FRAME_TYPE, DISPATCH_GL(vmstate), 28+4, FRAME_CP);
# 454 "vm_arm.dasc"
  //|  mov PC, #FRAME_C
  //|
  //|1:  // Entry point for vm_pcall above (PC = ftype).
  //|  ldr RC, L:CARG1->cframe
  //|   str CARG3, SAVE_NRES
  //|    mov L, CARG1
  //|   str CARG1, SAVE_L
  //|    mov BASE, CARG2
  //|  str sp, L->cframe			// Add our C frame to cframe chain.
  //|    ldr DISPATCH, L->glref		// Setup pointer to dispatch table.
  //|   str CARG1, SAVE_PC		// Any value outside of bytecode is ok.
  //|  str RC, SAVE_CFRAME
  //|    add DISPATCH, DISPATCH, #GG_G2DISP
  //|
  //|3:  // Entry point for vm_cpcall/vm_resume (BASE = base, PC = ftype).
  //|  ldr RB, L->base			// RB = old base (for vmeta_call).
  //|   ldr CARG1, L->top
  //|    mov MASKR8, #255
  //|  add PC, PC, BASE
  //|    lsl MASKR8, MASKR8, #3		// MASKR8 = 255*8.
  //|  sub PC, PC, RB			// PC = frame delta + frame type
  //|    mv_vmstate CARG2, INTERP
  //|   sub NARGS8:RC, CARG1, BASE
  //|    st_vmstate CARG2
  //|
  //|->vm_call_dispatch:
  //|  // RB = old base, BASE = new base, RC = nargs*8, PC = caller PC
  //|  ldrd CARG34, [BASE, FRAME_FUNC]
  //|  checkfunc CARG4, ->vmeta_call
  //|
  //|->vm_call_dispatch_f:
  //|  ins_call
  //|  // BASE = new base, CARG3 = func, RC = nargs*8, PC = caller PC
  //|
  //|->vm_cpcall:				// Setup protected C frame, call C.
  //|  // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)
  //|  saveregs
  //|  mov L, CARG1
  //|   ldr RA, L:CARG1->stack
  //|  str CARG1, SAVE_L
  //|   ldr RB, L->top
  //|  str CARG1, SAVE_PC			// Any value outside of bytecode is ok.
  //|  ldr RC, L->cframe
  //|   sub RA, RA, RB			// Compute -savestack(L, L->top).
  dasm_put(Dst, 238, 28+4, FRAME_C, Dt1(->cframe), Dt1(->cframe), Dt1(->glref), GG_G2DISP, Dt1(->base), Dt1(->top), LJ_VMST_INTERP, DISPATCH_GL(vmstate), -LJ_TFUNC, Dt7(->field_pc), 28+4, Dt1(->stack), Dt1(->top), Dt1(->cframe));
# 498 "vm_arm.dasc"
  //|  str sp, L->cframe			// Add our C frame to cframe chain.
  //|  mov RB, #0
  //|   str RA, SAVE_NRES			// Neg. delta means cframe w/o frame.
  //|  str RB, SAVE_ERRF			// No error function.
  //|  str RC, SAVE_CFRAME
  //|  blx CARG4			// (lua_State *L, lua_CFunction func, void *ud)
  //|   ldr DISPATCH, L->glref		// Setup pointer to dispatch table.
  //|  movs BASE, CRET1
  //|    mov PC, #FRAME_CP
  //|   add DISPATCH, DISPATCH, #GG_G2DISP
  //|  bne <3				// Else continue with the call.
  //|  b ->vm_leave_cp			// No base? Just remove C frame.
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Metamethod handling ------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|//-- Continuation dispatch ----------------------------------------------
  //|
  //|->cont_dispatch:
  //|  // BASE = meta base, RA = resultptr, RC = (nresults+1)*8
  //|  ldr LFUNC:CARG3, [RB, FRAME_FUNC]
  //|    ldr CARG1, [BASE, #-16]		// Get continuation.
  //|   mov CARG4, BASE
  //|   mov BASE, RB			// Restore caller BASE.
  //|.if FFI
  //|    cmp CARG1, #1
  //|.endif
  //|   ldr PC, [CARG4, #-12]		// Restore PC from [cont|PC].
  //|  ldr CARG3, LFUNC:CARG3->field_pc
  //|    mvn INS, #~LJ_TNIL
  //|    add CARG2, RA, RC
  //|    str INS, [CARG2, #-4]		// Ensure one valid arg.
  //|.if FFI
  //|    bls >1
  //|.endif
  //|  ldr KBASE, [CARG3, #PC2PROTO(k)]
  //|  // BASE = base, RA = resultptr, CARG4 = meta base
  //|    bx CARG1
  //|
  //|.if FFI
  //|1:
  //|  beq ->cont_ffi_callback		// cont = 1: return from FFI callback.
  //|  // cont = 0: tailcall from C function.
  //|  ldr CARG3, [BASE, FRAME_FUNC]
  //|   sub CARG4, CARG4, #16
  //|   sub RC, CARG4, BASE
  //|  b ->vm_call_tail
  //|.endif
  //|
  //|->cont_cat:				// RA = resultptr, CARG4 = meta base
  //|  ldr INS, [PC, #-4]
  //|   sub CARG2, CARG4, #16
  //|   ldrd CARG34, [RA]
  //|     str BASE, L->base
  //|  decode_RB8 RC, INS
  //|   decode_RA8 RA, INS
  //|  add CARG1, BASE, RC
  //|  subs CARG1, CARG2, CARG1
  //|   strdne CARG34, [CARG2]
  //|   movne CARG3, CARG1
  //|  bne ->BC_CAT_Z
  //|   strd CARG34, [BASE, RA]
  //|  b ->cont_nop
  //|
  //|//-- Table indexing metamethods -----------------------------------------
  //|
  //|->vmeta_tgets1:
  //|  add CARG2, BASE, RB
  //|  b >2
  //|
  //|->vmeta_tgets:
  //|  sub CARG2, DISPATCH, #-DISPATCH_GL(tmptv)
  //|   mvn CARG4, #~LJ_TTAB
  dasm_put(Dst, 306, Dt1(->cframe), Dt1(->glref), FRAME_CP, GG_G2DISP, Dt7(->field_pc), ~LJ_TNIL, PC2PROTO(k), Dt1(->base), -DISPATCH_GL(tmptv));
# 572 "vm_arm.dasc"
  //|  str TAB:RB, [CARG2]
  //|   str CARG4, [CARG2, #4]
  //|2:
  //|   mvn CARG4, #~LJ_TSTR
  //|  str STR:RC, TMPDlo
  //|   str CARG4, TMPDhi
  //|  mov CARG3, TMPDp
  //|  b >1
  //|
  //|->vmeta_tgetb:			// RC = index
  //|  decode_RB8 RB, INS
  //|   str RC, TMPDlo
  //|   mvn CARG4, #~LJ_TISNUM
  //|  add CARG2, BASE, RB
  //|   str CARG4, TMPDhi
  //|  mov CARG3, TMPDp
  //|  b >1
  //|
  //|->vmeta_tgetv:
  //|  add CARG2, BASE, RB
  //|   add CARG3, BASE, RC
  //|1:
  //|   str BASE, L->base
  //|  mov CARG1, L
  //|   str PC, SAVE_PC
  //|  bl extern lj_meta_tget		// (lua_State *L, TValue *o, TValue *k)
  //|  // Returns TValue * (finished) or NULL (metamethod).
  //|  .IOS ldr BASE, L->base
  //|  cmp CRET1, #0
  //|  beq >3
  //|  ldrd CARG34, [CRET1]
  //|   ins_next1
  //|   ins_next2
  //|  strd CARG34, [BASE, RA]
  //|   ins_next3
  //|
  //|3:  // Call __index metamethod.
  //|  // BASE = base, L->top = new base, stack = cont/func/t/k
  //|   rsb CARG1, BASE, #FRAME_CONT
  //|  ldr BASE, L->top
  //|    mov NARGS8:RC, #16		// 2 args for func(t, k).
  //|    str PC, [BASE, #-12]		// [cont|PC]
  //|   add PC, CARG1, BASE
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  //|  b ->vm_call_dispatch_f
  //|
  //|//-----------------------------------------------------------------------
  //|
  //|->vmeta_tsets1:
  //|  add CARG2, BASE, RB
  //|  b >2
  //|
  //|->vmeta_tsets:
  //|  sub CARG2, DISPATCH, #-DISPATCH_GL(tmptv)
  //|   mvn CARG4, #~LJ_TTAB
  //|  str TAB:RB, [CARG2]
  //|   str CARG4, [CARG2, #4]
  //|2:
  //|   mvn CARG4, #~LJ_TSTR
  dasm_put(Dst, 376, ~LJ_TTAB, ~LJ_TSTR, ~LJ_TISNUM, Dt1(->base), FRAME_CONT, Dt1(->top), -DISPATCH_GL(tmptv), ~LJ_TTAB);
# 631 "vm_arm.dasc"
  //|  str STR:RC, TMPDlo
  //|   str CARG4, TMPDhi
  //|  mov CARG3, TMPDp
  //|  b >1
  //|
  //|->vmeta_tsetb:			// RC = index
  //|  decode_RB8 RB, INS
  //|   str RC, TMPDlo
  //|   mvn CARG4, #~LJ_TISNUM
  //|  add CARG2, BASE, RB
  //|   str CARG4, TMPDhi
  //|  mov CARG3, TMPDp
  //|  b >1
  //|
  //|->vmeta_tsetv:
  //|  add CARG2, BASE, RB
  //|   add CARG3, BASE, RC
  //|1:
  //|   str BASE, L->base
  //|  mov CARG1, L
  //|   str PC, SAVE_PC
  //|  bl extern lj_meta_tset		// (lua_State *L, TValue *o, TValue *k)
  //|  // Returns TValue * (finished) or NULL (metamethod).
  //|  .IOS ldr BASE, L->base
  //|  cmp CRET1, #0
  //|   ldrd CARG34, [BASE, RA]
  //|  beq >3
  //|   ins_next1
  //|  // NOBARRIER: lj_meta_tset ensures the table is not black.
  //|  strd CARG34, [CRET1]
  //|   ins_next2
  //|   ins_next3
  //|
  //|3:  // Call __newindex metamethod.
  //|  // BASE = base, L->top = new base, stack = cont/func/t/k/(v)
  //|   rsb CARG1, BASE, #FRAME_CONT
  //|  ldr BASE, L->top
  //|    mov NARGS8:RC, #24		// 3 args for func(t, k, v).
  //|   strd CARG34, [BASE, #16]		// Copy value to third argument.
  //|    str PC, [BASE, #-12]		// [cont|PC]
  //|   add PC, CARG1, BASE
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  //|  b ->vm_call_dispatch_f
  //|
  //|//-- Comparison metamethods ---------------------------------------------
  //|
  //|->vmeta_comp:
  //|  mov CARG1, L
  //|   sub PC, PC, #4
  //|  mov CARG2, RA
  //|   str BASE, L->base
  //|  mov CARG3, RC
  //|   str PC, SAVE_PC
  //|  decode_OP CARG4, INS
  //|  bl extern lj_meta_comp  // (lua_State *L, TValue *o1, *o2, int op)
  //|  // Returns 0/1 or TValue * (metamethod).
  //|3:
  //|  .IOS ldr BASE, L->base
  //|  cmp CRET1, #1
  //|  bhi ->vmeta_binop
  //|4:
  //|  ldrh RB, [PC, #2]
  //|   add PC, PC, #4
  //|  add RB, PC, RB, lsl #2
  //|  subhs PC, RB, #0x20000
  //|->cont_nop:
  //|  ins_next
  //|
  //|->cont_ra:				// RA = resultptr
  //|  ldr INS, [PC, #-4]
  dasm_put(Dst, 443, ~LJ_TSTR, ~LJ_TISNUM, Dt1(->base), FRAME_CONT, Dt1(->top), Dt1(->base));
# 701 "vm_arm.dasc"
  //|   ldrd CARG12, [RA]
  //|  decode_RA8 CARG3, INS
  //|   strd CARG12, [BASE, CARG3]
  //|  b ->cont_nop
  //|
  //|->cont_condt:			// RA = resultptr
  //|  ldr CARG2, [RA, #4]
  //|   mvn CARG1, #~LJ_TTRUE
  //|  cmp CARG1, CARG2			// Branch if result is true.
  //|  b <4
  //|
  //|->cont_condf:			// RA = resultptr
  //|  ldr CARG2, [RA, #4]
  //|  checktp CARG2, LJ_TFALSE		// Branch if result is false.
  //|  b <4
  //|
  //|->vmeta_equal:
  //|  // CARG2, CARG3, CARG4 are already set by BC_ISEQV/BC_ISNEV.
  //|  sub PC, PC, #4
  //|   str BASE, L->base
  //|   mov CARG1, L
  //|  str PC, SAVE_PC
  //|  bl extern lj_meta_equal  // (lua_State *L, GCobj *o1, *o2, int ne)
  //|  // Returns 0/1 or TValue * (metamethod).
  //|  b <3
  //|
  //|->vmeta_equal_cd:
  //|.if FFI
  //|  sub PC, PC, #4
  //|   str BASE, L->base
  //|   mov CARG1, L
  //|   mov CARG2, INS
  //|  str PC, SAVE_PC
  //|  bl extern lj_meta_equal_cd		// (lua_State *L, BCIns op)
  //|  // Returns 0/1 or TValue * (metamethod).
  //|  b <3
  //|.endif
  //|
  //|//-- Arithmetic metamethods ---------------------------------------------
  //|
  //|->vmeta_arith_vn:
  //|  decode_RB8 RB, INS
  //|   decode_RC8 RC, INS
  //|  add CARG3, BASE, RB
  //|   add CARG4, KBASE, RC
  //|  b >1
  //|
  //|->vmeta_arith_nv:
  //|  decode_RB8 RB, INS
  //|   decode_RC8 RC, INS
  //|  add CARG4, BASE, RB
  //|   add CARG3, KBASE, RC
  //|  b >1
  //|
  //|->vmeta_unm:
  //|  ldr INS, [PC, #-8]
  //|   sub PC, PC, #4
  //|  add CARG3, BASE, RC
  //|  add CARG4, BASE, RC
  //|  b >1
  //|
  //|->vmeta_arith_vv:
  //|  decode_RB8 RB, INS
  dasm_put(Dst, 522, ~LJ_TTRUE, -LJ_TFALSE, Dt1(->base), Dt1(->base));
# 764 "vm_arm.dasc"
  //|   decode_RC8 RC, INS
  //|  add CARG3, BASE, RB
  //|   add CARG4, BASE, RC
  //|1:
  //|  decode_OP OP, INS
  //|   add CARG2, BASE, RA
  //|    str BASE, L->base
  //|   mov CARG1, L
  //|    str PC, SAVE_PC
  //|  str OP, ARG5
  //|  bl extern lj_meta_arith  // (lua_State *L, TValue *ra,*rb,*rc, BCReg op)
  //|  // Returns NULL (finished) or TValue * (metamethod).
  //|  .IOS ldr BASE, L->base
  //|  cmp CRET1, #0
  //|  beq ->cont_nop
  //|
  //|  // Call metamethod for binary op.
  //|->vmeta_binop:
  //|  // BASE = old base, CRET1 = new base, stack = cont/func/o1/o2
  //|  sub CARG2, CRET1, BASE
  //|   str PC, [CRET1, #-12]		// [cont|PC]
  //|  add PC, CARG2, #FRAME_CONT
  //|   mov BASE, CRET1
  //|    mov NARGS8:RC, #16		// 2 args for func(o1, o2).
  //|  b ->vm_call_dispatch
  //|
  //|->vmeta_len:
  //|  add CARG2, BASE, RC
  //|   str BASE, L->base
  //|  mov CARG1, L
  //|   str PC, SAVE_PC
  //|  bl extern lj_meta_len		// (lua_State *L, TValue *o)
  //|  // Returns NULL (retry) or TValue * (metamethod base).
  //|  .IOS ldr BASE, L->base
  dasm_put(Dst, 585, Dt1(->base), FRAME_CONT, Dt1(->base));
# 798 "vm_arm.dasc"
#if LJ_52
  //|  cmp CRET1, #0
  //|  bne ->vmeta_binop			// Binop call for compatibility.
  //|  ldr TAB:CARG1, [BASE, RC]
  //|  b ->BC_LEN_Z
  dasm_put(Dst, 620);
# 803 "vm_arm.dasc"
#else
  //|  b ->vmeta_binop			// Binop call for compatibility.
  dasm_put(Dst, 627);
# 805 "vm_arm.dasc"
#endif
  //|
  //|//-- Call metamethod ----------------------------------------------------
  //|
  //|->vmeta_call:			// Resolve and call __call metamethod.
  //|  // RB = old base, BASE = new base, RC = nargs*8
  //|  mov CARG1, L
  //|   str RB, L->base			// This is the callers base!
  //|  sub CARG2, BASE, #8
  //|   str PC, SAVE_PC
  //|  add CARG3, BASE, NARGS8:RC
  //|  .IOS mov RA, BASE
  //|  bl extern lj_meta_call	// (lua_State *L, TValue *func, TValue *top)
  //|  .IOS mov BASE, RA
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  //|   add NARGS8:RC, NARGS8:RC, #8	// Got one more argument now.
  //|  ins_call
  //|
  //|->vmeta_callt:			// Resolve __call for BC_CALLT.
  //|  // BASE = old base, RA = new base, RC = nargs*8
  //|  mov CARG1, L
  //|   str BASE, L->base
  //|  sub CARG2, RA, #8
  //|   str PC, SAVE_PC
  //|  add CARG3, RA, NARGS8:RC
  //|  bl extern lj_meta_call	// (lua_State *L, TValue *func, TValue *top)
  //|  .IOS ldr BASE, L->base
  //|  ldr LFUNC:CARG3, [RA, FRAME_FUNC]  // Guaranteed to be a function here.
  //|   ldr PC, [BASE, FRAME_PC]
  //|    add NARGS8:RC, NARGS8:RC, #8	// Got one more argument now.
  //|  b ->BC_CALLT2_Z
  //|
  //|//-- Argument coercion for 'for' statement ------------------------------
  //|
  //|->vmeta_for:
  //|  mov CARG1, L
  //|   str BASE, L->base
  //|  mov CARG2, RA
  //|   str PC, SAVE_PC
  //|  bl extern lj_meta_for	// (lua_State *L, TValue *base)
  //|  .IOS ldr BASE, L->base
  //|.if JIT
  //|   ldrb OP, [PC, #-4]
  //|.endif
  //|  ldr INS, [PC, #-4]
  //|.if JIT
  //|   cmp OP, #BC_JFORI
  //|.endif
  //|  decode_RA8 RA, INS
  //|  decode_RD RC, INS
  //|.if JIT
  //|   beq =>BC_JFORI
  //|.endif
  //|  b =>BC_FORI
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Fast functions -----------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|.macro .ffunc, name
  //|->ff_ .. name:
  //|.endmacro
  //|
  //|.macro .ffunc_1, name
  //|->ff_ .. name:
  //|  ldrd CARG12, [BASE]
  //|   cmp NARGS8:RC, #8
  //|   blo ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_2, name
  //|->ff_ .. name:
  //|  ldrd CARG12, [BASE]
  //|   ldrd CARG34, [BASE, #8]
  //|    cmp NARGS8:RC, #16
  //|    blo ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_n, name
  //|  .ffunc_1 name
  //|  checktp CARG2, LJ_TISNUM
  //|  bhs ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_nn, name
  //|  .ffunc_2 name
  //|  checktp CARG2, LJ_TISNUM
  //|  cmnlo CARG4, #-LJ_TISNUM
  //|  bhs ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_d, name
  //|  .ffunc name
  //|  ldr CARG2, [BASE, #4]
  //|   cmp NARGS8:RC, #8
  //|  vldr d0, [BASE]
  //|   blo ->fff_fallback
  //|  checktp CARG2, LJ_TISNUM
  //|  bhs ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_dd, name
  //|  .ffunc name
  //|  ldr CARG2, [BASE, #4]
  //|  ldr CARG4, [BASE, #12]
  //|   cmp NARGS8:RC, #16
  //|  vldr d0, [BASE]
  //|  vldr d1, [BASE, #8]
  //|   blo ->fff_fallback
  //|  checktp CARG2, LJ_TISNUM
  //|  cmnlo CARG4, #-LJ_TISNUM
  //|  bhs ->fff_fallback
  //|.endmacro
  //|
  //|// Inlined GC threshold check. Caveat: uses CARG1 and CARG2.
  //|.macro ffgccheck
  //|  ldr CARG1, [DISPATCH, #DISPATCH_GL(gc.total)]
  //|  ldr CARG2, [DISPATCH, #DISPATCH_GL(gc.threshold)]
  //|  cmp CARG1, CARG2
  //|  blge ->fff_gcstep
  //|.endmacro
  //|
  //|//-- Base library: checks -----------------------------------------------
  //|
  //|.ffunc_1 assert
  //|  checktp CARG2, LJ_TTRUE
  //|  bhi ->fff_fallback
  //|   ldr PC, [BASE, FRAME_PC]
  //|  strd CARG12, [BASE, #-8]
  //|  mov RB, BASE
  //|  subs RA, NARGS8:RC, #8
  //|   add RC, NARGS8:RC, #8		// Compute (nresults+1)*8.
  //|  beq ->fff_res			// Done if exactly 1 argument.
  //|1:
  //|   ldrd CARG12, [RB, #8]
  //|  subs RA, RA, #8
  //|   strd CARG12, [RB], #8
  //|  bne <1
  //|  b ->fff_res
  //|
  //|.ffunc type
  //|  ldr CARG2, [BASE, #4]
  dasm_put(Dst, 630, Dt1(->base), Dt7(->field_pc), Dt1(->base), Dt1(->base), BC_JFORI, BC_JFORI, BC_FORI, -LJ_TTRUE);
# 947 "vm_arm.dasc"
  //|   cmp NARGS8:RC, #8
  //|   blo ->fff_fallback
  //|  checktp CARG2, LJ_TISNUM
  //|  mvnlo CARG2, #~LJ_TISNUM
  //|  rsb CARG4, CARG2, #(int)(offsetof(GCfuncC, upvalue)>>3)-1
  //|  lsl CARG4, CARG4, #3
  //|  ldrd CARG12, [CFUNC:CARG3, CARG4]
  //|  b ->fff_restv
  //|
  //|//-- Base library: getters and setters ---------------------------------
  //|
  //|.ffunc_1 getmetatable
  //|  checktp CARG2, LJ_TTAB
  //|  cmnne CARG2, #-LJ_TUDATA
  //|  bne >6
  //|1:  // Field metatable must be at same offset for GCtab and GCudata!
  //|  ldr TAB:RB, TAB:CARG1->metatable
  //|2:
  //|   mvn CARG2, #~LJ_TNIL
  //|   ldr STR:RC, [DISPATCH, #DISPATCH_GL(gcroot[GCROOT_MMNAME+MM_metatable])]
  //|  cmp TAB:RB, #0
  //|  beq ->fff_restv
  //|  ldr CARG3, TAB:RB->hmask
  //|   ldr CARG4, STR:RC->hash
  //|    ldr NODE:INS, TAB:RB->node
  //|  and CARG3, CARG3, CARG4		// idx = str->hash & tab->hmask
  //|  add CARG3, CARG3, CARG3, lsl #1
  //|    add NODE:INS, NODE:INS, CARG3, lsl #3	// node = tab->node + idx*3*8
  //|3:  // Rearranged logic, because we expect _not_ to find the key.
  //|  ldrd CARG34, NODE:INS->key  // STALL: early NODE:INS.
  //|   ldrd CARG12, NODE:INS->val
  //|    ldr NODE:INS, NODE:INS->next
  dasm_put(Dst, 708, -LJ_TISNUM, ~LJ_TISNUM, (int)(offsetof(GCfuncC, upvalue)>>3)-1, -LJ_TTAB, -LJ_TUDATA, Dt6(->metatable), ~LJ_TNIL, DISPATCH_GL(gcroot[GCROOT_MMNAME+MM_metatable]), Dt6(->hmask), Dt5(->hash), Dt6(->node), DtB(->key), DtB(->val));
# 979 "vm_arm.dasc"
  //|  checktp CARG4, LJ_TSTR
  //|  cmpeq CARG3, STR:RC
  //|  beq >5
  //|  cmp NODE:INS, #0
  //|  bne <3
  //|4:
  //|  mov CARG1, RB			// Use metatable as default result.
  //|  mvn CARG2, #~LJ_TTAB
  //|  b ->fff_restv
  //|5:
  //|  checktp CARG2, LJ_TNIL
  //|  bne ->fff_restv
  //|  b <4
  //|
  //|6:
  //|  checktp CARG2, LJ_TISNUM
  //|  mvnhs CARG2, CARG2
  //|  movlo CARG2, #~LJ_TISNUM
  //|  add CARG4, DISPATCH, CARG2, lsl #2
  //|  ldr TAB:RB, [CARG4, #DISPATCH_GL(gcroot[GCROOT_BASEMT])]
  //|  b <2
  //|
  //|.ffunc_2 setmetatable
  //|  // Fast path: no mt for table yet and not clearing the mt.
  //|  checktp CARG2, LJ_TTAB
  //|   ldreq TAB:RB, TAB:CARG1->metatable
  //|  checktpeq CARG4, LJ_TTAB
  //|    ldrbeq CARG4, TAB:CARG1->marked
  //|   cmpeq TAB:RB, #0
  dasm_put(Dst, 759, DtB(->next), -LJ_TSTR, ~LJ_TTAB, -LJ_TNIL, -LJ_TISNUM, ~LJ_TISNUM, DISPATCH_GL(gcroot[GCROOT_BASEMT]), -LJ_TTAB, Dt6(->metatable), -LJ_TTAB, Dt6(->marked));
# 1008 "vm_arm.dasc"
  //|  bne ->fff_fallback
  //|    tst CARG4, #LJ_GC_BLACK		// isblack(table)
  //|     str TAB:CARG3, TAB:CARG1->metatable
  //|    beq ->fff_restv
  //|  barrierback TAB:CARG1, CARG4, CARG3
  //|  b ->fff_restv
  //|
  //|.ffunc rawget
  //|  ldrd CARG34, [BASE]
  //|   cmp NARGS8:RC, #16
  //|   blo ->fff_fallback
  //|   mov CARG2, CARG3
  //|  checktab CARG4, ->fff_fallback
  //|   mov CARG1, L
  //|   add CARG3, BASE, #8
  //|  .IOS mov RA, BASE
  //|  bl extern lj_tab_get  // (lua_State *L, GCtab *t, cTValue *key)
  //|  // Returns cTValue *.
  //|  .IOS mov BASE, RA
  //|  ldrd CARG12, [CRET1]
  //|  b ->fff_restv
  //|
  //|//-- Base library: conversions ------------------------------------------
  //|
  //|.ffunc tonumber
  //|  // Only handles the number case inline (without a base argument).
  //|  ldrd CARG12, [BASE]
  //|   cmp NARGS8:RC, #8
  //|   bne ->fff_fallback
  //|  checktp CARG2, LJ_TISNUM
  //|  bls ->fff_restv
  //|  b ->fff_fallback
  //|
  //|.ffunc_1 tostring
  dasm_put(Dst, 808, LJ_GC_BLACK, Dt6(->metatable), DISPATCH_GL(gc.grayagain), LJ_GC_BLACK, DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist), -LJ_TTAB, -LJ_TISNUM);
# 1042 "vm_arm.dasc"
  //|  // Only handles the string or number case inline.
  //|  checktp CARG2, LJ_TSTR
  //|  // A __tostring method in the string base metatable is ignored.
  //|  beq ->fff_restv
  //|  // Handle numbers inline, unless a number base metatable is present.
  //|  ldr CARG4, [DISPATCH, #DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM])]
  //|   str BASE, L->base
  //|  checktp CARG2, LJ_TISNUM
  //|  cmpls CARG4, #0
  //|   str PC, SAVE_PC			// Redundant (but a defined value).
  //|  bhi ->fff_fallback
  //|  ffgccheck
  //|  mov CARG1, L
  //|  mov CARG2, BASE
  //|  bl extern lj_str_fromnumber	// (lua_State *L, cTValue *o)
  //|  // Returns GCstr *.
  //|  ldr BASE, L->base
  //|  mvn CARG2, #~LJ_TSTR
  //|  b ->fff_restv
  //|
  //|//-- Base library: iterators -------------------------------------------
  //|
  //|.ffunc_1 next
  //|   mvn CARG4, #~LJ_TNIL
  //|  checktab CARG2, ->fff_fallback
  //|   strd CARG34, [BASE, NARGS8:RC]	// Set missing 2nd arg to nil.
  //|   ldr PC, [BASE, FRAME_PC]
  //|  mov CARG2, CARG1
  //|    str BASE, L->base		// Add frame since C call can throw.
  //|  mov CARG1, L
  //|    str BASE, L->top			// Dummy frame length is ok.
  //|  add CARG3, BASE, #8
  //|   str PC, SAVE_PC
  //|  bl extern lj_tab_next	// (lua_State *L, GCtab *t, TValue *key)
  //|  // Returns 0 at end of traversal.
  //|  .IOS ldr BASE, L->base
  //|  cmp CRET1, #0
  dasm_put(Dst, 859, -LJ_TSTR, DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM]), Dt1(->base), -LJ_TISNUM, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), Dt1(->base), ~LJ_TSTR, ~LJ_TNIL, -LJ_TTAB, Dt1(->base), Dt1(->top));
# 1079 "vm_arm.dasc"
  //|  mvneq CRET2, #~LJ_TNIL
  //|  beq ->fff_restv			// End of traversal: return nil.
  //|  ldrd CARG12, [BASE, #8]		// Copy key and value to results.
  //|   ldrd CARG34, [BASE, #16]
  //|    mov RC, #(2+1)*8
  //|  strd CARG12, [BASE, #-8]
  //|   strd CARG34, [BASE]
  //|  b ->fff_res
  //|
  //|.ffunc_1 pairs
  //|  checktab CARG2, ->fff_fallback
  dasm_put(Dst, 918, ~LJ_TNIL, (2+1)*8, -LJ_TTAB);
# 1090 "vm_arm.dasc"
#if LJ_52
  //|  ldr TAB:RB, TAB:CARG1->metatable
  dasm_put(Dst, 941, Dt6(->metatable));
# 1092 "vm_arm.dasc"
#endif
  //|   ldrd CFUNC:CARG34, CFUNC:CARG3->upvalue[0]
  //|    ldr PC, [BASE, FRAME_PC]
  dasm_put(Dst, 944, Dt8(->upvalue[0]));
# 1095 "vm_arm.dasc"
#if LJ_52
  //|  cmp TAB:RB, #0
  //|  bne ->fff_fallback
  dasm_put(Dst, 948);
# 1098 "vm_arm.dasc"
#endif
  //|  mvn CARG2, #~LJ_TNIL
  //|    mov RC, #(3+1)*8
  //|   strd CFUNC:CARG34, [BASE, #-8]
  //|  str CARG2, [BASE, #12]
  //|  b ->fff_res
  //|
  //|.ffunc_2 ipairs_aux
  //|  checktp CARG2, LJ_TTAB
  //|  checktpeq CARG4, LJ_TISNUM
  //|  bne ->fff_fallback
  //|  ldr RB, TAB:CARG1->asize
  //|   ldr RC, TAB:CARG1->array
  //|  add CARG3, CARG3, #1
  //|    ldr PC, [BASE, FRAME_PC]
  //|  cmp CARG3, RB
  //|   add RC, RC, CARG3, lsl #3
  //|  strd CARG34, [BASE, #-8]
  //|   ldrdlo CARG12, [RC]
  //|   mov RC, #(0+1)*8
  //|  bhs >2				// Not in array part?
  //|1:
  //|   checktp CARG2, LJ_TNIL
  //|   movne RC, #(2+1)*8
  //|   strdne CARG12, [BASE]
  //|  b ->fff_res
  //|2:  // Check for empty hash part first. Otherwise call C function.
  //|  ldr RB, TAB:CARG1->hmask
  //|   mov CARG2, CARG3
  //|  cmp RB, #0
  //|  beq ->fff_res
  //|  .IOS mov RA, BASE
  //|  bl extern lj_tab_getinth		// (GCtab *t, int32_t key)
  //|  // Returns cTValue * or NULL.
  //|  .IOS mov BASE, RA
  //|  cmp CRET1, #0
  //|  beq ->fff_res
  //|  ldrd CARG12, [CRET1]
  //|  b <1
  //|
  //|.ffunc_1 ipairs
  dasm_put(Dst, 952, ~LJ_TNIL, (3+1)*8, -LJ_TTAB, -LJ_TISNUM, Dt6(->asize), Dt6(->array), (0+1)*8, -LJ_TNIL, (2+1)*8, Dt6(->hmask));
# 1139 "vm_arm.dasc"
  //|  checktab CARG2, ->fff_fallback
  dasm_put(Dst, 1011, -LJ_TTAB);
# 1140 "vm_arm.dasc"
#if LJ_52
  //|  ldr TAB:RB, TAB:CARG1->metatable
  dasm_put(Dst, 1020, Dt6(->metatable));
# 1142 "vm_arm.dasc"
#endif
  //|   ldrd CFUNC:CARG34, CFUNC:CARG3->upvalue[0]
  //|    ldr PC, [BASE, FRAME_PC]
  dasm_put(Dst, 1023, Dt8(->upvalue[0]));
# 1145 "vm_arm.dasc"
#if LJ_52
  //|  cmp TAB:RB, #0
  //|  bne ->fff_fallback
  dasm_put(Dst, 1027);
# 1148 "vm_arm.dasc"
#endif
  //|  mov CARG1, #0
  //|  mvn CARG2, #~LJ_TISNUM
  //|    mov RC, #(3+1)*8
  //|   strd CFUNC:CARG34, [BASE, #-8]
  //|  strd CARG12, [BASE, #8]
  //|  b ->fff_res
  //|
  //|//-- Base library: catch errors ----------------------------------------
  //|
  //|.ffunc pcall
  //|  ldrb RA, [DISPATCH, #DISPATCH_GL(hookmask)]
  //|   cmp NARGS8:RC, #8
  //|   blo ->fff_fallback
  //|  tst RA, #HOOK_ACTIVE		// Remember active hook before pcall.
  //|   mov RB, BASE
  //|   add BASE, BASE, #8
  //|  moveq PC, #8+FRAME_PCALL
  //|  movne PC, #8+FRAME_PCALLH
  //|   sub NARGS8:RC, NARGS8:RC, #8
  //|  b ->vm_call_dispatch
  //|
  //|.ffunc_2 xpcall
  //|  ldrb RA, [DISPATCH, #DISPATCH_GL(hookmask)]
  //|  checkfunc CARG4, ->fff_fallback	// Traceback must be a function.
  //|   mov RB, BASE
  //|  strd CARG12, [BASE, #8]		// Swap function and traceback.
  //|   strd CARG34, [BASE]
  //|  tst RA, #HOOK_ACTIVE		// Remember active hook before pcall.
  //|   add BASE, BASE, #16
  //|  moveq PC, #16+FRAME_PCALL
  //|  movne PC, #16+FRAME_PCALLH
  //|   sub NARGS8:RC, NARGS8:RC, #16
  //|  b ->vm_call_dispatch
  //|
  //|//-- Coroutine library --------------------------------------------------
  //|
  //|.macro coroutine_resume_wrap, resume
  //|.if resume
  //|.ffunc_1 coroutine_resume
  //|  checktp CARG2, LJ_TTHREAD
  //|  bne ->fff_fallback
  //|.else
  //|.ffunc coroutine_wrap_aux
  //|  ldr L:CARG1, CFUNC:CARG3->upvalue[0].gcr
  //|.endif
  //|   ldr PC, [BASE, FRAME_PC]
  //|     str BASE, L->base
  //|  ldr CARG2, L:CARG1->top
  //|   ldrb RA, L:CARG1->status
  //|    ldr RB, L:CARG1->base
  //|  add CARG3, CARG2, NARGS8:RC
  //|  add CARG4, CARG2, RA
  //|   str PC, SAVE_PC
  //|  cmp CARG4, RB
  //|  beq ->fff_fallback
  //|   ldr CARG4, L:CARG1->maxstack
  //|    ldr RB, L:CARG1->cframe
  //|   cmp RA, #LUA_YIELD
  //|   cmpls CARG3, CARG4
  //|    cmpls RB, #0
  //|    bhi ->fff_fallback
  //|1:
  //|.if resume
  //|  sub CARG3, CARG3, #8		// Keep resumed thread in stack for GC.
  //|  add BASE, BASE, #8
  //|  sub NARGS8:RC, NARGS8:RC, #8
  //|.endif
  //|  str CARG3, L:CARG1->top
  //|  str BASE, L->top
  //|2:  // Move args to coroutine.
  //|   ldrd CARG34, [BASE, RB]
  //|  cmp RB, NARGS8:RC
  //|   strdne CARG34, [CARG2, RB]
  //|  add RB, RB, #8
  //|  bne <2
  //|
  //|  mov CARG3, #0
  //|   mov L:RA, L:CARG1
  //|  mov CARG4, #0
  //|  bl ->vm_resume			// (lua_State *L, TValue *base, 0, 0)
  //|  // Returns thread status.
  //|4:
  //|  ldr CARG3, L:RA->base
  //|    mv_vmstate CARG2, INTERP
  //|  ldr CARG4, L:RA->top
  //|    st_vmstate CARG2
  //|   cmp CRET1, #LUA_YIELD
  //|  ldr BASE, L->base
  //|   bhi >8
  //|  subs RC, CARG4, CARG3
  //|   ldr CARG1, L->maxstack
  //|   add CARG2, BASE, RC
  //|  beq >6				// No results?
  //|  cmp CARG2, CARG1
  //|   mov RB, #0
  //|  bhi >9				// Need to grow stack?
  //|
  //|  sub CARG4, RC, #8
  //|   str CARG3, L:RA->top		// Clear coroutine stack.
  //|5:  // Move results from coroutine.
  //|   ldrd CARG12, [CARG3, RB]
  //|  cmp RB, CARG4
  //|   strd CARG12, [BASE, RB]
  //|  add RB, RB, #8
  //|  bne <5
  //|6:
  //|.if resume
  //|  mvn CARG3, #~LJ_TTRUE
  //|   add RC, RC, #16
  //|7:
  //|  str CARG3, [BASE, #-4]		// Prepend true/false to results.
  //|   sub RA, BASE, #8
  //|.else
  //|   mov RA, BASE
  //|   add RC, RC, #8
  //|.endif
  //|  ands CARG1, PC, #FRAME_TYPE
  //|   str PC, SAVE_PC
  //|   str RC, SAVE_MULTRES
  //|  beq ->BC_RET_Z
  //|  b ->vm_return
  //|
  //|8:  // Coroutine returned with error (at co->top-1).
  //|.if resume
  //|  ldrd CARG12, [CARG4, #-8]!
  //|   mvn CARG3, #~LJ_TFALSE
  //|    mov RC, #(2+1)*8
  //|  str CARG4, L:RA->top		// Remove error from coroutine stack.
  //|  strd CARG12, [BASE]		// Copy error message.
  //|  b <7
  //|.else
  //|  mov CARG1, L
  //|  mov CARG2, L:RA
  //|  bl extern lj_ffh_coroutine_wrap_err  // (lua_State *L, lua_State *co)
  //|  // Never returns.
  //|.endif
  //|
  //|9:  // Handle stack expansion on return from yield.
  //|  mov CARG1, L
  //|  lsr CARG2, RC, #3
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  mov CRET1, #0
  //|  b <4
  //|.endmacro
  //|
  //|  coroutine_resume_wrap 1		// coroutine.resume
  dasm_put(Dst, 1031, ~LJ_TISNUM, (3+1)*8, DISPATCH_GL(hookmask), HOOK_ACTIVE, 8+FRAME_PCALL, 8+FRAME_PCALLH, DISPATCH_GL(hookmask), -LJ_TFUNC, HOOK_ACTIVE, 16+FRAME_PCALL, 16+FRAME_PCALLH, -LJ_TTHREAD);
  dasm_put(Dst, 1090, Dt1(->base), Dt1(->top), Dt1(->status), Dt1(->base), Dt1(->maxstack), Dt1(->cframe), LUA_YIELD, Dt1(->top), Dt1(->top), Dt1(->base), LJ_VMST_INTERP, Dt1(->top), DISPATCH_GL(vmstate), LUA_YIELD);
# 1295 "vm_arm.dasc"
  //|  coroutine_resume_wrap 0		// coroutine.wrap
  dasm_put(Dst, 1149, Dt1(->base), Dt1(->maxstack), Dt1(->top), ~LJ_TTRUE, FRAME_TYPE, ~LJ_TFALSE, (2+1)*8, Dt1(->top));
  dasm_put(Dst, 1209, Dt8(->upvalue[0].gcr), Dt1(->base), Dt1(->top), Dt1(->status), Dt1(->base), Dt1(->maxstack), Dt1(->cframe), LUA_YIELD, Dt1(->top), Dt1(->top), Dt1(->base), LJ_VMST_INTERP, Dt1(->top), DISPATCH_GL(vmstate), LUA_YIELD);
# 1296 "vm_arm.dasc"
  //|
  //|.ffunc coroutine_yield
  //|  ldr CARG1, L->cframe
  //|   add CARG2, BASE, NARGS8:RC
  //|   str BASE, L->base
  //|  tst CARG1, #CFRAME_RESUME
  //|   str CARG2, L->top
  //|    mov CRET1, #LUA_YIELD
  dasm_put(Dst, 1265, Dt1(->base), Dt1(->maxstack), Dt1(->top), FRAME_TYPE, Dt1(->cframe), Dt1(->base), CFRAME_RESUME, Dt1(->top));
# 1304 "vm_arm.dasc"
  //|   mov CARG3, #0
  //|  beq ->fff_fallback
  //|   str CARG3, L->cframe
  //|    strb CRET1, L->status
  //|  b ->vm_leave_unw
  //|
  //|//-- Math library -------------------------------------------------------
  //|
  //|.macro math_round, func
  //|  .ffunc_1 math_ .. func
  //|  checktp CARG2, LJ_TISNUM
  //|  beq ->fff_restv
  //|  bhi ->fff_fallback
  //|  // Round FP value and normalize result.
  //|  lsl CARG3, CARG2, #1
  //|  adds RB, CARG3, #0x00200000
  //|  bpl >2				// |x| < 1?
  //|  mvn CARG4, #0x3e0
  //|    subs RB, CARG4, RB, asr #21
  //|  lsl CARG4, CARG2, #11
  //|   lsl CARG3, CARG1, #11
  //|  orr CARG4, CARG4, #0x80000000
  //|   rsb INS, RB, #32
  //|  orr CARG4, CARG4, CARG1, lsr #21
  //|    bls >3				// |x| >= 2^31?
  //|   orr CARG3, CARG3, CARG4, lsl INS
  //|  lsr CARG1, CARG4, RB
  //|.if "func" == "floor"
  //|   tst CARG3, CARG2, asr #31
  //|   addne CARG1, CARG1, #1
  //|.else
  //|   bics CARG3, CARG3, CARG2, asr #31
  //|   addsne CARG1, CARG1, #1
  //|   ldrdvs CARG12, >9
  //|   bvs ->fff_restv
  //|.endif
  //|    cmp CARG2, #0
  //|    rsblt CARG1, CARG1, #0
  //|1:
  //|   mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|
  //|2:  // |x| < 1
  //|  bcs ->fff_restv			// |x| is not finite.
  //|  orr CARG3, CARG3, CARG1		// ztest = abs(hi) | lo
  //|.if "func" == "floor"
  //|  tst CARG3, CARG2, asr #31		// return (ztest & sign) == 0 ? 0 : -1
  //|  moveq CARG1, #0
  //|  mvnne CARG1, #0
  //|.else
  //|  bics CARG3, CARG3, CARG2, asr #31	// return (ztest & ~sign) == 0 ? 0 : 1
  //|  moveq CARG1, #0
  //|  movne CARG1, #1
  //|.endif
  //|  mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|
  //|3:  // |x| >= 2^31. Check for x == -(2^31).
  //|  cmpeq CARG4, #0x80000000
  //|.if "func" == "floor"
  //|  cmpeq CARG3, #0
  //|.endif
  //|  bne >4
  //|  cmp CARG2, #0
  //|  movmi CARG1, #0x80000000
  //|  bmi <1
  //|4:
  //|  bl ->vm_..func.._sf
  //|  b ->fff_restv
  //|.endmacro
  //|
  //|  math_round floor
  dasm_put(Dst, 1324, LUA_YIELD, Dt1(->cframe), Dt1(->status), -LJ_TISNUM, ~LJ_TISNUM, ~LJ_TISNUM);
# 1376 "vm_arm.dasc"
  //|  math_round ceil
  dasm_put(Dst, 1392, -LJ_TISNUM, ~LJ_TISNUM, ~LJ_TISNUM);
# 1377 "vm_arm.dasc"
  //|
  //|.align 8
  //|9:
  //|  .long 0x00000000, 0x41e00000	// 2^31.
  //|
  //|.ffunc_1 math_abs
  //|  checktp CARG2, LJ_TISNUM
  //|  bhi ->fff_fallback
  //|  bicne CARG2, CARG2, #0x80000000
  //|  bne ->fff_restv
  //|  cmp CARG1, #0
  //|  rsbslt CARG1, CARG1, #0
  //|  ldrdvs CARG12, <9
  //|  // Fallthrough.
  //|
  //|->fff_restv:
  //|  // CARG12 = TValue result.
  //|  ldr PC, [BASE, FRAME_PC]
  //|  strd CARG12, [BASE, #-8]
  //|->fff_res1:
  //|  // PC = return.
  //|  mov RC, #(1+1)*8
  //|->fff_res:
  //|  // RC = (nresults+1)*8, PC = return.
  //|  ands CARG1, PC, #FRAME_TYPE
  //|  ldreq INS, [PC, #-4]
  //|   str RC, SAVE_MULTRES
  //|  sub RA, BASE, #8
  //|  bne ->vm_return
  //|  decode_RB8 RB, INS
  //|5:
  //|  cmp RB, RC				// More results expected?
  //|  bhi >6
  //|  decode_RA8 CARG1, INS
  //|   ins_next1
  //|   ins_next2
  //|  // Adjust BASE. KBASE is assumed to be set for the calling frame.
  //|  sub BASE, RA, CARG1
  //|   ins_next3
  //|
  //|6:  // Fill up results with nil.
  //|  add CARG2, RA, RC
  //|  mvn CARG1, #~LJ_TNIL
  //|   add RC, RC, #8
  //|  str CARG1, [CARG2, #-4]
  //|  b <5
  //|
  //|.macro math_extern, func
  //|.if HFABI
  //|  .ffunc_d math_ .. func
  //|.else
  //|  .ffunc_n math_ .. func
  //|.endif
  //|  .IOS mov RA, BASE
  //|  bl extern func
  //|  .IOS mov BASE, RA
  //|.if HFABI
  //|  b ->fff_resd
  //|.else
  //|  b ->fff_restv
  //|.endif
  //|.endmacro
  //|
  //|.macro math_extern2, func
  //|.if HFABI
  //|  .ffunc_dd math_ .. func
  //|.else
  //|  .ffunc_nn math_ .. func
  //|.endif
  //|  .IOS mov RA, BASE
  //|  bl extern func
  //|  .IOS mov BASE, RA
  //|.if HFABI
  //|  b ->fff_resd
  //|.else
  //|  b ->fff_restv
  //|.endif
  //|.endmacro
  //|
  //|.if FPU
  //|  .ffunc_d math_sqrt
  dasm_put(Dst, 1456, -LJ_TISNUM, (1+1)*8, FRAME_TYPE, ~LJ_TNIL);
# 1458 "vm_arm.dasc"
  //|  vsqrt.f64 d0, d0
  //|->fff_resd:
  //|  ldr PC, [BASE, FRAME_PC]
  //|  vstr d0, [BASE, #-8]
  //|  b ->fff_res1
  //|.else
  //|  math_extern sqrt
  //|.endif
  //|
  //|.ffunc math_log
  //|.if HFABI
  //|  ldr CARG2, [BASE, #4]
  //|   cmp NARGS8:RC, #8			// Need exactly 1 argument.
  //|  vldr d0, [BASE]
  //|   bne ->fff_fallback
  //|.else
  //|  ldrd CARG12, [BASE]
  //|   cmp NARGS8:RC, #8			// Need exactly 1 argument.
  //|   bne ->fff_fallback
  //|.endif
  //|  checktp CARG2, LJ_TISNUM
  //|  bhs ->fff_fallback
  //|  .IOS mov RA, BASE
  //|  bl extern log
  //|  .IOS mov BASE, RA
  //|.if HFABI
  //|  b ->fff_resd
  //|.else
  //|  b ->fff_restv
  //|.endif
  //|
  //|  math_extern log10
  //|  math_extern exp
  dasm_put(Dst, 1518, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM);
# 1491 "vm_arm.dasc"
  //|  math_extern sin
  //|  math_extern cos
  //|  math_extern tan
  //|  math_extern asin
  dasm_put(Dst, 1571, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM);
# 1495 "vm_arm.dasc"
  //|  math_extern acos
  //|  math_extern atan
  //|  math_extern sinh
  //|  math_extern cosh
  dasm_put(Dst, 1620, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM);
# 1499 "vm_arm.dasc"
  //|  math_extern tanh
  //|  math_extern2 pow
  //|  math_extern2 atan2
  dasm_put(Dst, 1667, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM);
# 1502 "vm_arm.dasc"
  //|  math_extern2 fmod
  //|
  //|->ff_math_deg:
  //|.if FPU
  //|  .ffunc_d math_rad
  //|  vldr d1, CFUNC:CARG3->upvalue[0]
  //|  vmul.f64 d0, d0, d1
  //|  b ->fff_resd
  //|.else
  //|  .ffunc_n math_rad
  //|  ldrd CARG34, CFUNC:CARG3->upvalue[0]
  //|  bl extern __aeabi_dmul
  //|  b ->fff_restv
  //|.endif
  //|
  //|.if HFABI
  //|  .ffunc math_ldexp
  //|  ldr CARG4, [BASE, #4]
  //|  ldrd CARG12, [BASE, #8]
  //|   cmp NARGS8:RC, #16
  //|   blo ->fff_fallback
  //|  vldr d0, [BASE]
  //|  checktp CARG4, LJ_TISNUM
  //|  bhs ->fff_fallback
  //|  checktp CARG2, LJ_TISNUM
  //|  bne ->fff_fallback
  //|  .IOS mov RA, BASE
  //|  bl extern ldexp			// (double x, int exp)
  //|  .IOS mov BASE, RA
  //|  b ->fff_resd
  //|.else
  //|.ffunc_2 math_ldexp
  //|  checktp CARG2, LJ_TISNUM
  //|  bhs ->fff_fallback
  //|  checktp CARG4, LJ_TISNUM
  //|  bne ->fff_fallback
  dasm_put(Dst, 1719, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, Dt8(->upvalue[0]), -LJ_TISNUM, -LJ_TISNUM);
# 1538 "vm_arm.dasc"
  //|  .IOS mov RA, BASE
  //|  bl extern ldexp			// (double x, int exp)
  //|  .IOS mov BASE, RA
  //|  b ->fff_restv
  //|.endif
  //|
  //|.if HFABI
  //|.ffunc_d math_frexp
  //|  mov CARG1, sp
  //|  .IOS mov RA, BASE
  //|  bl extern frexp
  //|  .IOS mov BASE, RA
  //|   ldr CARG3, [sp]
  //|   mvn CARG4, #~LJ_TISNUM
  //|    ldr PC, [BASE, FRAME_PC]
  //|  vstr d0, [BASE, #-8]
  //|    mov RC, #(2+1)*8
  //|   strd CARG34, [BASE]
  //|  b ->fff_res
  //|.else
  //|.ffunc_n math_frexp
  //|  mov CARG3, sp
  //|  .IOS mov RA, BASE
  //|  bl extern frexp
  //|  .IOS mov BASE, RA
  //|   ldr CARG3, [sp]
  //|   mvn CARG4, #~LJ_TISNUM
  //|    ldr PC, [BASE, FRAME_PC]
  //|  strd CARG12, [BASE, #-8]
  //|    mov RC, #(2+1)*8
  //|   strd CARG34, [BASE]
  //|  b ->fff_res
  //|.endif
  //|
  //|.if HFABI
  //|.ffunc_d math_modf
  //|  sub CARG1, BASE, #8
  //|   ldr PC, [BASE, FRAME_PC]
  //|  .IOS mov RA, BASE
  //|  bl extern modf
  //|  .IOS mov BASE, RA
  //|   mov RC, #(2+1)*8
  //|  vstr d0, [BASE]
  //|  b ->fff_res
  //|.else
  //|.ffunc_n math_modf
  //|  sub CARG3, BASE, #8
  //|   ldr PC, [BASE, FRAME_PC]
  //|  .IOS mov RA, BASE
  //|  bl extern modf
  //|  .IOS mov BASE, RA
  //|   mov RC, #(2+1)*8
  //|  strd CARG12, [BASE]
  //|  b ->fff_res
  //|.endif
  //|
  //|.macro math_minmax, name, cond, fcond
  //|.if FPU
  //|  .ffunc_1 name
  //|   add RB, BASE, RC
  //|  checktp CARG2, LJ_TISNUM
  //|   add RA, BASE, #8
  //|  bne >4
  //|1:  // Handle integers.
  //|  ldrd CARG34, [RA]
  //|   cmp RA, RB
  //|   bhs ->fff_restv
  //|  checktp CARG4, LJ_TISNUM
  //|  bne >3
  //|  cmp CARG1, CARG3
  //|   add RA, RA, #8
  //|  mov..cond CARG1, CARG3
  //|  b <1
  //|3:  // Convert intermediate result to number and continue below.
  //|  vmov s4, CARG1
  //|  bhi ->fff_fallback
  //|  vldr d1, [RA]
  //|  vcvt.f64.s32 d0, s4
  //|  b >6
  //|
  //|4:
  //|  vldr d0, [BASE]
  //|  bhi ->fff_fallback
  //|5:  // Handle numbers.
  //|  ldrd CARG34, [RA]
  //|  vldr d1, [RA]
  //|   cmp RA, RB
  //|   bhs ->fff_resd
  //|  checktp CARG4, LJ_TISNUM
  //|  bhs >7
  //|6:
  //|  vcmp.f64 d0, d1
  //|  vmrs
  //|   add RA, RA, #8
  //|  vmov..fcond.f64 d0, d1
  //|  b <5
  //|7:  // Convert integer to number and continue above.
  //|  vmov s4, CARG3
  //|  bhi ->fff_fallback
  //|  vcvt.f64.s32 d1, s4
  //|  b <6
  //|
  //|.else
  //|
  //|  .ffunc_1 name
  //|  checktp CARG2, LJ_TISNUM
  //|   mov RA, #8
  //|  bne >4
  //|1:  // Handle integers.
  //|  ldrd CARG34, [BASE, RA]
  //|   cmp RA, RC
  //|   bhs ->fff_restv
  //|  checktp CARG4, LJ_TISNUM
  //|  bne >3
  //|  cmp CARG1, CARG3
  //|   add RA, RA, #8
  //|  mov..cond CARG1, CARG3
  //|  b <1
  //|3:  // Convert intermediate result to number and continue below.
  //|  bhi ->fff_fallback
  //|  bl extern __aeabi_i2d
  //|  ldrd CARG34, [BASE, RA]
  //|  b >6
  //|
  //|4:
  //|  bhi ->fff_fallback
  //|5:  // Handle numbers.
  //|  ldrd CARG34, [BASE, RA]
  //|   cmp RA, RC
  //|   bhs ->fff_restv
  //|  checktp CARG4, LJ_TISNUM
  //|  bhs >7
  //|6:
  //|  bl extern __aeabi_cdcmple
  //|   add RA, RA, #8
  //|  mov..fcond CARG1, CARG3
  //|  mov..fcond CARG2, CARG4
  //|  b <5
  //|7:  // Convert integer to number and continue above.
  //|  bhi ->fff_fallback
  //|  strd CARG12, TMPD
  //|  mov CARG1, CARG3
  //|  bl extern __aeabi_i2d
  //|  ldrd CARG34, TMPD
  //|  b <6
  //|.endif
  //|.endmacro
  //|
  //|  math_minmax math_min, gt, hi
  dasm_put(Dst, 1770, -LJ_TISNUM, ~LJ_TISNUM, (2+1)*8, -LJ_TISNUM, (2+1)*8, -LJ_TISNUM);
# 1687 "vm_arm.dasc"
  //|  math_minmax math_max, lt, lo
  dasm_put(Dst, 1829, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM);
# 1688 "vm_arm.dasc"
  //|
  //|//-- String library -----------------------------------------------------
  //|
  //|.ffunc_1 string_len
  //|  checkstr CARG2, ->fff_fallback
  //|  ldr CARG1, STR:CARG1->len
  dasm_put(Dst, 1891, -LJ_TISNUM, -LJ_TISNUM, -LJ_TSTR);
# 1694 "vm_arm.dasc"
  //|  mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|
  //|.ffunc string_byte			// Only handle the 1-arg case here.
  //|  ldrd CARG12, [BASE]
  //|    ldr PC, [BASE, FRAME_PC]
  //|   cmp NARGS8:RC, #8
  //|   checktpeq CARG2, LJ_TSTR		// Need exactly 1 argument.
  //|   bne ->fff_fallback
  //|  ldr CARG3, STR:CARG1->len
  //|   ldrb CARG1, STR:CARG1[1]		// Access is always ok (NUL at end).
  //|   mvn CARG2, #~LJ_TISNUM
  //|  cmp CARG3, #0
  //|  moveq RC, #(0+1)*8
  //|  movne RC, #(1+1)*8
  //|   strd CARG12, [BASE, #-8]
  //|  b ->fff_res
  //|
  //|.ffunc string_char			// Only handle the 1-arg case here.
  //|  ffgccheck
  //|  ldrd CARG12, [BASE]
  //|    ldr PC, [BASE, FRAME_PC]
  //|   cmp NARGS8:RC, #8			// Need exactly 1 argument.
  //|   checktpeq CARG2, LJ_TISNUM
  //|   bicseq CARG4, CARG1, #255
  //|  mov CARG3, #1
  //|   bne ->fff_fallback
  //|  str CARG1, TMPD
  //|  mov CARG2, TMPDp			// Points to stack. Little-endian.
  //|->fff_newstr:
  //|  // CARG2 = str, CARG3 = len.
  //|   str BASE, L->base
  //|  mov CARG1, L
  //|   str PC, SAVE_PC
  //|  bl extern lj_str_new		// (lua_State *L, char *str, size_t l)
  //|  // Returns GCstr *.
  //|  ldr BASE, L->base
  //|   mvn CARG2, #~LJ_TSTR
  dasm_put(Dst, 1950, Dt5(->len), ~LJ_TISNUM, -LJ_TSTR, Dt5(->len), Dt5([1]), ~LJ_TISNUM, (0+1)*8, (1+1)*8, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), -LJ_TISNUM, Dt1(->base), Dt1(->base));
# 1732 "vm_arm.dasc"
  //|  b ->fff_restv
  //|
  //|.ffunc string_sub
  //|  ffgccheck
  //|  ldrd CARG12, [BASE]
  //|   ldrd CARG34, [BASE, #16]
  //|    cmp NARGS8:RC, #16
  //|     mvn RB, #0
  //|    beq >1
  //|    blo ->fff_fallback
  //|   checktp CARG4, LJ_TISNUM
  //|    mov RB, CARG3
  //|   bne ->fff_fallback
  //|1:
  //|  ldrd CARG34, [BASE, #8]
  //|  checktp CARG2, LJ_TSTR
  //|   ldreq CARG2, STR:CARG1->len
  //|  checktpeq CARG4, LJ_TISNUM
  //|  bne ->fff_fallback
  //|  // CARG1 = str, CARG2 = str->len, CARG3 = start, RB = end
  //|  add CARG4, CARG2, #1
  //|  cmp CARG3, #0			// if (start < 0) start += len+1
  //|  addlt CARG3, CARG3, CARG4
  //|  cmp CARG3, #1			// if (start < 1) start = 1
  //|  movlt CARG3, #1
  //|  cmp RB, #0				// if (end < 0) end += len+1
  //|  addlt RB, RB, CARG4
  //|  bic RB, RB, RB, asr #31		// if (end < 0) end = 0
  //|  cmp RB, CARG2			// if (end > len) end = len
  //|   add CARG1, STR:CARG1, #sizeof(GCstr)-1
  //|  movgt RB, CARG2
  //|   add CARG2, CARG1, CARG3
  //|  subs CARG3, RB, CARG3		// len = end - start
  //|   add CARG3, CARG3, #1		// len += 1
  //|  bge ->fff_newstr
  //|->fff_emptystr:
  //|  sub STR:CARG1, DISPATCH, #-DISPATCH_GL(strempty)
  //|  mvn CARG2, #~LJ_TSTR
  //|  b ->fff_restv
  //|
  //|.ffunc string_rep			// Only handle the 1-char case inline.
  //|  ffgccheck
  dasm_put(Dst, 2007, ~LJ_TSTR, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), -LJ_TISNUM, -LJ_TSTR, Dt5(->len), -LJ_TISNUM, sizeof(GCstr)-1, -DISPATCH_GL(strempty), ~LJ_TSTR);
# 1774 "vm_arm.dasc"
  //|  ldrd CARG12, [BASE]
  //|   ldrd CARG34, [BASE, #8]
  //|    cmp NARGS8:RC, #16
  //|    bne ->fff_fallback		// Exactly 2 arguments
  //|  checktp CARG2, LJ_TSTR
  //|   checktpeq CARG4, LJ_TISNUM
  //|   bne ->fff_fallback
  //|  subs CARG4, CARG3, #1
  //|   ldr CARG2, STR:CARG1->len
  //|  blt ->fff_emptystr			// Count <= 0?
  //|   cmp CARG2, #1
  //|   blo ->fff_emptystr		// Zero-length string?
  //|   bne ->fff_fallback		// Fallback for > 1-char strings.
  //|  ldr RB, [DISPATCH, #DISPATCH_GL(tmpbuf.sz)]
  //|   ldr CARG2, [DISPATCH, #DISPATCH_GL(tmpbuf.buf)]
  //|   ldr CARG1, STR:CARG1[1]
  //|  cmp RB, CARG3
  //|  blo ->fff_fallback
  //|1:  // Fill buffer with char.
  //|   strb CARG1, [CARG2, CARG4]
  //|  subs CARG4, CARG4, #1
  //|  bge <1
  //|  b ->fff_newstr
  //|
  //|.ffunc string_reverse
  //|  ffgccheck
  //|  ldrd CARG12, [BASE]
  dasm_put(Dst, 2068, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), -LJ_TSTR, -LJ_TISNUM, Dt5(->len), DISPATCH_GL(tmpbuf.sz), DISPATCH_GL(tmpbuf.buf), Dt5([1]), DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold));
# 1801 "vm_arm.dasc"
  //|   cmp NARGS8:RC, #8
  //|   blo ->fff_fallback
  //|  checkstr CARG2, ->fff_fallback
  //|  ldr CARG3, STR:CARG1->len
  //|   ldr RB, [DISPATCH, #DISPATCH_GL(tmpbuf.sz)]
  //|    ldr CARG2, [DISPATCH, #DISPATCH_GL(tmpbuf.buf)]
  //|  mov CARG4, CARG3
  //|  add CARG1, STR:CARG1, #sizeof(GCstr)
  //|   cmp RB, CARG3
  //|   blo ->fff_fallback
  //|1:  // Reverse string copy.
  //|  ldrb RB, [CARG1], #1
  //|   subs CARG4, CARG4, #1
  //|   blt ->fff_newstr
  //|  strb RB, [CARG2, CARG4]
  //|  b <1
  //|
  //|.macro ffstring_case, name, lo
  //|  .ffunc name
  //|  ffgccheck
  //|  ldrd CARG12, [BASE]
  //|   cmp NARGS8:RC, #8
  //|   blo ->fff_fallback
  //|  checkstr CARG2, ->fff_fallback
  //|  ldr CARG3, STR:CARG1->len
  //|   ldr RB, [DISPATCH, #DISPATCH_GL(tmpbuf.sz)]
  //|    ldr CARG2, [DISPATCH, #DISPATCH_GL(tmpbuf.buf)]
  //|  mov CARG4, #0
  //|  add CARG1, STR:CARG1, #sizeof(GCstr)
  //|   cmp RB, CARG3
  //|   blo ->fff_fallback
  //|1:  // ASCII case conversion.
  //|  ldrb RB, [CARG1, CARG4]
  //|   cmp CARG4, CARG3
  //|   bhs ->fff_newstr
  //|  sub RC, RB, #lo
  //|  cmp RC, #26
  //|  eorlo RB, RB, #0x20
  //|  strb RB, [CARG2, CARG4]
  //|   add CARG4, CARG4, #1
  //|  b <1
  //|.endmacro
  //|
  //|ffstring_case string_lower, 65
  dasm_put(Dst, 2121, -LJ_TSTR, Dt5(->len), DISPATCH_GL(tmpbuf.sz), DISPATCH_GL(tmpbuf.buf), sizeof(GCstr), DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), -LJ_TSTR, Dt5(->len), DISPATCH_GL(tmpbuf.sz), DISPATCH_GL(tmpbuf.buf), sizeof(GCstr));
# 1845 "vm_arm.dasc"
  //|ffstring_case string_upper, 97
  //|
  //|//-- Table library ------------------------------------------------------
  //|
  //|.ffunc_1 table_getn
  //|  checktab CARG2, ->fff_fallback
  dasm_put(Dst, 2175, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), -LJ_TSTR, Dt5(->len), DISPATCH_GL(tmpbuf.sz), DISPATCH_GL(tmpbuf.buf), sizeof(GCstr), -LJ_TTAB);
# 1851 "vm_arm.dasc"
  //|  .IOS mov RA, BASE
  //|  bl extern lj_tab_len		// (GCtab *t)
  //|  // Returns uint32_t (but less than 2^31).
  //|  .IOS mov BASE, RA
  //|  mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|
  //|//-- Bit library --------------------------------------------------------
  //|
  //|// FP number to bit conversion for soft-float. Clobbers r0-r3.
  //|->vm_tobit_fb:
  //|  bhi ->fff_fallback
  //|->vm_tobit:
  //|  lsl RB, CARG2, #1
  //|  adds RB, RB, #0x00200000
  //|  movpl CARG1, #0			// |x| < 1?
  //|  bxpl lr
  //|  mvn CARG4, #0x3e0
  //|  subs RB, CARG4, RB, asr #21
  //|  bmi >1				// |x| >= 2^32?
  //|  lsl CARG4, CARG2, #11
  //|  orr CARG4, CARG4, #0x80000000
  //|  orr CARG4, CARG4, CARG1, lsr #21
  //|   cmp CARG2, #0
  //|  lsr CARG1, CARG4, RB
  //|   rsblt CARG1, CARG1, #0
  //|  bx lr
  //|1:
  //|  add RB, RB, #21
  //|  lsr CARG4, CARG1, RB
  //|  rsb RB, RB, #20
  //|  lsl CARG1, CARG2, #12
  //|   cmp CARG2, #0
  //|  orr CARG1, CARG4, CARG1, lsl RB
  //|   rsblt CARG1, CARG1, #0
  //|  bx lr
  //|
  //|.macro .ffunc_bit, name
  //|  .ffunc_1 bit_..name
  //|  checktp CARG2, LJ_TISNUM
  //|  blne ->vm_tobit_fb
  //|.endmacro
  //|
  //|.ffunc_bit tobit
  //|  mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|
  //|.macro .ffunc_bit_op, name, ins
  //|  .ffunc_bit name
  //|  mov CARG3, CARG1
  //|  mov RA, #8
  //|1:
  //|  ldrd CARG12, [BASE, RA]
  //|   cmp RA, NARGS8:RC
  //|    add RA, RA, #8
  //|   bge >2
  //|  checktp CARG2, LJ_TISNUM
  //|  blne ->vm_tobit_fb
  //|  ins CARG3, CARG3, CARG1
  //|  b <1
  //|.endmacro
  //|
  //|.ffunc_bit_op band, and
  dasm_put(Dst, 2238, ~LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM);
# 1914 "vm_arm.dasc"
  //|.ffunc_bit_op bor, orr
  //|.ffunc_bit_op bxor, eor
  //|
  //|2:
  //|  mvn CARG4, #~LJ_TISNUM
  //|   ldr PC, [BASE, FRAME_PC]
  dasm_put(Dst, 2307, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM);
# 1920 "vm_arm.dasc"
  //|  strd CARG34, [BASE, #-8]
  //|  b ->fff_res1
  //|
  //|.ffunc_bit bswap
  //|  eor CARG3, CARG1, CARG1, ror #16
  //|  bic CARG3, CARG3, #0x00ff0000
  //|  ror CARG1, CARG1, #8
  //|   mvn CARG2, #~LJ_TISNUM
  //|  eor CARG1, CARG1, CARG3, lsr #8
  //|  b ->fff_restv
  //|
  //|.ffunc_bit bnot
  //|  mvn CARG1, CARG1
  //|  mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|
  //|.macro .ffunc_bit_sh, name, ins, shmod
  //|  .ffunc bit_..name
  //|  ldrd CARG12, [BASE, #8]
  //|   cmp NARGS8:RC, #16
  //|   blo ->fff_fallback
  //|  checktp CARG2, LJ_TISNUM
  //|  blne ->vm_tobit_fb
  //|.if shmod == 0
  //|  and RA, CARG1, #31
  //|.else
  //|  rsb RA, CARG1, #0
  //|.endif
  //|  ldrd CARG12, [BASE]
  //|  checktp CARG2, LJ_TISNUM
  //|  blne ->vm_tobit_fb
  //|  ins CARG1, CARG1, RA
  //|  mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|.endmacro
  //|
  //|.ffunc_bit_sh lshift, lsl, 0
  //|.ffunc_bit_sh rshift, lsr, 0
  dasm_put(Dst, 2364, -LJ_TISNUM, ~LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM);
# 1958 "vm_arm.dasc"
  //|.ffunc_bit_sh arshift, asr, 0
  //|.ffunc_bit_sh rol, ror, 1
  dasm_put(Dst, 2421, -LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM);
# 1960 "vm_arm.dasc"
  //|.ffunc_bit_sh ror, ror, 0
  //|
  //|//-----------------------------------------------------------------------
  //|
  //|->fff_fallback:			// Call fast function fallback handler.
  //|  // BASE = new base, RC = nargs*8
  //|   ldr CARG3, [BASE, FRAME_FUNC]
  //|  ldr CARG2, L->maxstack
  //|  add CARG1, BASE, NARGS8:RC
  //|    ldr PC, [BASE, FRAME_PC]		// Fallback may overwrite PC.
  //|  str CARG1, L->top
  //|   ldr CARG3, CFUNC:CARG3->f
  //|    str BASE, L->base
  //|  add CARG1, CARG1, #8*LUA_MINSTACK
  //|    str PC, SAVE_PC			// Redundant (but a defined value).
  //|  cmp CARG1, CARG2
  //|   mov CARG1, L
  //|  bhi >5				// Need to grow stack.
  //|   blx CARG3				// (lua_State *L)
  //|  // Either throws an error, or recovers and returns -1, 0 or nresults+1.
  //|   ldr BASE, L->base
  //|  cmp CRET1, #0
  //|   lsl RC, CRET1, #3
  //|   sub RA, BASE, #8
  //|  bgt ->fff_res			// Returned nresults+1?
  //|1:  // Returned 0 or -1: retry fast path.
  //|   ldr CARG1, L->top
  //|    ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  //|   sub NARGS8:RC, CARG1, BASE
  //|  bne ->vm_call_tail			// Returned -1?
  //|  ins_callt				// Returned 0: retry fast path.
  dasm_put(Dst, 2479, -LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM, Dt1(->maxstack), Dt1(->top), Dt8(->f), Dt1(->base), 8*LUA_MINSTACK, Dt1(->base), Dt1(->top), Dt7(->field_pc));
# 1991 "vm_arm.dasc"
  //|
  //|// Reconstruct previous base for vmeta_call during tailcall.
  //|->vm_call_tail:
  //|  ands CARG1, PC, #FRAME_TYPE
  //|   bic CARG2, PC, #FRAME_TYPEP
  //|  ldreq INS, [PC, #-4]
  //|  andeq CARG2, MASKR8, INS, lsr #5	// Conditional decode_RA8.
  //|  addeq CARG2, CARG2, #8
  //|  sub RB, BASE, CARG2
  //|  b ->vm_call_dispatch		// Resolve again for tailcall.
  //|
  //|5:  // Grow stack for fallback handler.
  //|  mov CARG2, #LUA_MINSTACK
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  ldr BASE, L->base
  //|  cmp CARG1, CARG1			// Set zero-flag to force retry.
  //|  b <1
  //|
  //|->fff_gcstep:			// Call GC step function.
  //|  // BASE = new base, RC = nargs*8
  //|  mov RA, lr
  //|   str BASE, L->base
  //|  add CARG2, BASE, NARGS8:RC
  //|   str PC, SAVE_PC			// Redundant (but a defined value).
  //|  str CARG2, L->top
  //|  mov CARG1, L
  //|  bl extern lj_gc_step		// (lua_State *L)
  //|   ldr BASE, L->base
  //|  mov lr, RA				// Help return address predictor.
  //|   ldr CFUNC:CARG3, [BASE, FRAME_FUNC]
  //|  bx lr
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Special dispatch targets -------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_record:				// Dispatch target for recording phase.
  //|.if JIT
  //|  ldrb CARG1, [DISPATCH, #DISPATCH_GL(hookmask)]
  //|  tst CARG1, #HOOK_VMEVENT		// No recording while in vmevent.
  //|  bne >5
  //|  // Decrement the hookcount for consistency, but always do the call.
  //|   ldr CARG2, [DISPATCH, #DISPATCH_GL(hookcount)]
  //|  tst CARG1, #HOOK_ACTIVE
  //|  bne >1
  //|   sub CARG2, CARG2, #1
  //|  tst CARG1, #LUA_MASKLINE|LUA_MASKCOUNT
  //|   strne CARG2, [DISPATCH, #DISPATCH_GL(hookcount)]
  dasm_put(Dst, 2538, FRAME_TYPE, FRAME_TYPEP, LUA_MINSTACK, Dt1(->base), Dt1(->base), Dt1(->top), Dt1(->base), DISPATCH_GL(hookmask), HOOK_VMEVENT, DISPATCH_GL(hookcount), HOOK_ACTIVE, LUA_MASKLINE|LUA_MASKCOUNT);
# 2039 "vm_arm.dasc"
  //|  b >1
  //|.endif
  //|
  //|->vm_rethook:			// Dispatch target for return hooks.
  //|  ldrb CARG1, [DISPATCH, #DISPATCH_GL(hookmask)]
  //|  tst CARG1, #HOOK_ACTIVE		// Hook already active?
  //|  beq >1
  //|5:  // Re-dispatch to static ins.
  //|  decode_OP OP, INS
  //|  add OP, DISPATCH, OP, lsl #2
  //|  ldr pc, [OP, #GG_DISP2STATIC]
  //|
  //|->vm_inshook:			// Dispatch target for instr/line hooks.
  //|  ldrb CARG1, [DISPATCH, #DISPATCH_GL(hookmask)]
  //|   ldr CARG2, [DISPATCH, #DISPATCH_GL(hookcount)]
  //|  tst CARG1, #HOOK_ACTIVE		// Hook already active?
  //|  bne <5
  //|  tst CARG1, #LUA_MASKLINE|LUA_MASKCOUNT
  //|  beq <5
  //|   subs CARG2, CARG2, #1
  //|   str CARG2, [DISPATCH, #DISPATCH_GL(hookcount)]
  //|   beq >1
  //|  tst CARG1, #LUA_MASKLINE
  //|  beq <5
  //|1:
  //|  mov CARG1, L
  //|   str BASE, L->base
  //|  mov CARG2, PC
  //|  // SAVE_PC must hold the _previous_ PC. The callee updates it with PC.
  //|  bl extern lj_dispatch_ins		// (lua_State *L, const BCIns *pc)
  //|3:
  //|  ldr BASE, L->base
  dasm_put(Dst, 2599, DISPATCH_GL(hookcount), DISPATCH_GL(hookmask), HOOK_ACTIVE, GG_DISP2STATIC, DISPATCH_GL(hookmask), DISPATCH_GL(hookcount), HOOK_ACTIVE, LUA_MASKLINE|LUA_MASKCOUNT, DISPATCH_GL(hookcount), LUA_MASKLINE, Dt1(->base));
# 2071 "vm_arm.dasc"
  //|4:  // Re-dispatch to static ins.
  //|  ldrb OP, [PC, #-4]
  //|   ldr INS, [PC, #-4]
  //|  add OP, DISPATCH, OP, lsl #2
  //|  ldr OP, [OP, #GG_DISP2STATIC]
  //|   decode_RA8 RA, INS
  //|   decode_RD RC, INS
  //|  bx OP
  //|
  //|->cont_hook:				// Continue from hook yield.
  //|  ldr CARG1, [CARG4, #-24]
  //|   add PC, PC, #4
  //|  str CARG1, SAVE_MULTRES		// Restore MULTRES for *M ins.
  //|  b <4
  //|
  //|->vm_hotloop:			// Hot loop counter underflow.
  //|.if JIT
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]  // Same as curr_topL(L).
  //|   sub CARG1, DISPATCH, #-GG_DISP2J
  //|   str PC, SAVE_PC
  //|  ldr CARG3, LFUNC:CARG3->field_pc
  //|   mov CARG2, PC
  //|   str L, [DISPATCH, #DISPATCH_J(L)]
  //|  ldrb CARG3, [CARG3, #PC2PROTO(framesize)]
  //|   str BASE, L->base
  //|  add CARG3, BASE, CARG3, lsl #3
  //|  str CARG3, L->top
  //|  bl extern lj_trace_hot		// (jit_State *J, const BCIns *pc)
  //|  b <3
  //|.endif
  //|
  //|->vm_callhook:			// Dispatch target for call hooks.
  //|  mov CARG2, PC
  //|.if JIT
  //|  b >1
  //|.endif
  //|
  //|->vm_hotcall:			// Hot call counter underflow.
  //|.if JIT
  //|  orr CARG2, PC, #1
  //|1:
  //|.endif
  //|  add CARG4, BASE, RC
  //|   str PC, SAVE_PC
  //|    mov CARG1, L
  //|   str BASE, L->base
  //|    sub RA, RA, BASE
  //|  str CARG4, L->top
  //|  bl extern lj_dispatch_call		// (lua_State *L, const BCIns *pc)
  //|  // Returns ASMFunction.
  //|  ldr BASE, L->base
  //|   ldr CARG4, L->top
  dasm_put(Dst, 2646, Dt1(->base), GG_DISP2STATIC, -GG_DISP2J, Dt7(->field_pc), DISPATCH_J(L), PC2PROTO(framesize), Dt1(->base), Dt1(->top), Dt1(->base), Dt1(->top), Dt1(->base));
# 2123 "vm_arm.dasc"
  //|    mov CARG2, #0
  //|  add RA, BASE, RA
  //|   sub NARGS8:RC, CARG4, BASE
  //|    str CARG2, SAVE_PC		// Invalidate for subsequent line hook.
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  //|   ldr INS, [PC, #-4]
  //|  bx CRET1
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Trace exit handler -------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_exit_handler:
  //|.if JIT
  //|  sub sp, sp, #12
  //|  push {r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12}
  //|  ldr CARG1, [sp, #64]	// Load original value of lr.
  //|   ldr DISPATCH, [lr]	// Load DISPATCH.
  //|    add CARG3, sp, #64	// Recompute original value of sp.
  //|   mv_vmstate CARG4, EXIT
  //|    str CARG3, [sp, #52]	// Store sp in RID_SP
  //|   st_vmstate CARG4
  //|  ldr CARG2, [CARG1, #-4]!	// Get exit instruction.
  //|   str CARG1, [sp, #56]	// Store exit pc in RID_LR and RID_PC.
  //|   str CARG1, [sp, #60]
  //|.if FPU
  //|  vpush {d0-d15}
  //|.endif
  //|  lsl CARG2, CARG2, #8
  //|  add CARG1, CARG1, CARG2, asr #6
  //|   ldr CARG2, [lr, #4]	// Load exit stub group offset.
  //|   sub CARG1, CARG1, lr
  //|  ldr L, [DISPATCH, #DISPATCH_GL(jit_L)]
  //|   add CARG1, CARG2, CARG1, lsr #2	// Compute exit number.
  //|    ldr BASE, [DISPATCH, #DISPATCH_GL(jit_base)]
  //|   str CARG1, [DISPATCH, #DISPATCH_J(exitno)]
  //|   mov CARG4, #0
  //|  str L, [DISPATCH, #DISPATCH_J(L)]
  //|    str BASE, L->base
  //|   str CARG4, [DISPATCH, #DISPATCH_GL(jit_L)]
  //|  sub CARG1, DISPATCH, #-GG_DISP2J
  //|  mov CARG2, sp
  //|  bl extern lj_trace_exit		// (jit_State *J, ExitState *ex)
  //|  // Returns MULTRES (unscaled) or negated error code.
  //|  ldr CARG2, L->cframe
  //|   ldr BASE, L->base
  //|  bic CARG2, CARG2, #~CFRAME_RAWMASK	// Use two steps: bic sp is deprecated.
  //|  mov sp, CARG2
  //|   ldr PC, SAVE_PC			// Get SAVE_PC.
  //|  str L, SAVE_L			// Set SAVE_L (on-trace resume/yield).
  //|  b >1
  //|.endif
  //|->vm_exit_interp:
  //|  // CARG1 = MULTRES or negated error code, BASE, PC and DISPATCH set.
  //|.if JIT
  //|  ldr L, SAVE_L
  //|1:
  //|  cmp CARG1, #0
  //|  blt >3				// Check for error from exit.
  //|   lsl RC, CARG1, #3
  //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
  //|   str RC, SAVE_MULTRES
  //|   mov CARG3, #0
  //|  ldr CARG2, LFUNC:CARG2->field_pc
  //|   str CARG3, [DISPATCH, #DISPATCH_GL(jit_L)]
  //|    mv_vmstate CARG4, INTERP
  //|  ldr KBASE, [CARG2, #PC2PROTO(k)]
  dasm_put(Dst, 2704, Dt1(->top), LJ_VMST_EXIT, DISPATCH_GL(vmstate), DISPATCH_GL(jit_L), DISPATCH_GL(jit_base), DISPATCH_J(exitno), DISPATCH_J(L), Dt1(->base), DISPATCH_GL(jit_L), -GG_DISP2J, Dt1(->cframe), Dt1(->base), ~CFRAME_RAWMASK, Dt7(->field_pc), DISPATCH_GL(jit_L), LJ_VMST_INTERP);
# 2190 "vm_arm.dasc"
  //|  // Modified copy of ins_next which handles function header dispatch, too.
  //|  ldrb OP, [PC]
  //|     mov MASKR8, #255
  //|   ldr INS, [PC], #4
  //|     lsl MASKR8, MASKR8, #3		// MASKR8 = 255*8.
  //|    st_vmstate CARG4
  //|  cmp OP, #BC_FUNCF			// Function header?
  //|  ldr OP, [DISPATCH, OP, lsl #2]
  //|   decode_RA8 RA, INS
  //|   lsrlo RC, INS, #16	// No: Decode operands A*8 and D.
  //|   subhs RC, RC, #8
  //|   addhs RA, RA, BASE	// Yes: RA = BASE+framesize*8, RC = nargs*8
  //|  bx OP
  //|
  //|3:  // Rethrow error from the right C frame.
  //|  rsb CARG2, CARG1, #0
  //|  mov CARG1, L
  //|  bl extern lj_err_throw		// (lua_State *L, int errcode)
  //|.endif
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Math helper functions ----------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|// FP value rounding. Called from JIT code.
  //|//
  //|// double lj_vm_floor/ceil/trunc(double x);
  //|.macro vm_round, func, hf
  //|.if hf == 1
  //|  vmov CARG1, CARG2, d0
  //|.endif
  //|  lsl CARG3, CARG2, #1
  //|  adds RB, CARG3, #0x00200000
  //|  bpl >2				// |x| < 1?
  //|  mvn CARG4, #0x3cc
  //|  subs RB, CARG4, RB, asr #21	// 2^0: RB = 51, 2^51: RB = 0.
  //|  bxlo lr				// |x| >= 2^52: done.
  //|  mvn CARG4, #1
  //|   bic CARG3, CARG1, CARG4, lsl RB	// ztest = lo & ~lomask
  //|  and CARG1, CARG1, CARG4, lsl RB	// lo &= lomask
  //|  subs RB, RB, #32
  //|   bicpl CARG4, CARG2, CARG4, lsl RB	// |x| <= 2^20: ztest |= hi & ~himask
  //|   orrpl CARG3, CARG3, CARG4
  //|   mvnpl CARG4, #1
  //|  andpl CARG2, CARG2, CARG4, lsl RB	// |x| <= 2^20: hi &= himask
  //|.if "func" == "floor"
  //|   tst CARG3, CARG2, asr #31		// iszero = ((ztest & signmask) == 0)
  //|.else
  //|   bics CARG3, CARG3, CARG2, asr #31	// iszero = ((ztest & ~signmask) == 0)
  //|.endif
  //|.if hf == 1
  //|  vmoveq d0, CARG1, CARG2
  //|.endif
  //|  bxeq lr				// iszero: done.
  //|  mvn CARG4, #1
  //|  cmp RB, #0
  //|  lslpl CARG3, CARG4, RB
  //|  mvnmi CARG3, #0
  //|  add RB, RB, #32
  //|  subs CARG1, CARG1, CARG4, lsl RB	// lo = lo-lomask
  //|  sbc CARG2, CARG2, CARG3		// hi = hi-himask+carry
  //|.if hf == 1
  //|  vmov d0, CARG1, CARG2
  //|.endif
  //|  bx lr
  //|
  //|2:  // |x| < 1:
  //|  bxcs lr				// |x| is not finite.
  //|  orr CARG3, CARG3, CARG1		// ztest = (2*hi) | lo
  //|.if "func" == "floor"
  //|  tst CARG3, CARG2, asr #31		// iszero = ((ztest & signmask) == 0)
  //|.else
  //|  bics CARG3, CARG3, CARG2, asr #31	// iszero = ((ztest & ~signmask) == 0)
  //|.endif
  //|  mov CARG1, #0			// lo = 0
  //|  and CARG2, CARG2, #0x80000000
  //|  ldrne CARG4, <9			// hi = sign(x) | (iszero ? 0.0 : 1.0)
  //|  orrne CARG2, CARG2, CARG4
  //|.if hf == 1
  //|  vmov d0, CARG1, CARG2
  //|.endif
  //|  bx lr
  //|.endmacro
  //|
  //|9:
  //|  .long 0x3ff00000			// hiword(+1.0)
  //|
  //|->vm_floor:
  //|.if HFABI
  //|  vm_round floor, 1
  //|.endif
  //|->vm_floor_sf:
  //|  vm_round floor, 0
  //|
  //|->vm_ceil:
  //|.if HFABI
  //|  vm_round ceil, 1
  //|.endif
  //|->vm_ceil_sf:
  //|  vm_round ceil, 0
  //|
  //|.macro vm_trunc, hf
  //|.if JIT
  //|.if hf == 1
  //|  vmov CARG1, CARG2, d0
  //|.endif
  //|  lsl CARG3, CARG2, #1
  //|  adds RB, CARG3, #0x00200000
  //|  andpl CARG2, CARG2, #0x80000000	// |x| < 1? hi = sign(x), lo = 0.
  //|  movpl CARG1, #0
  //|.if hf == 1
  //|  vmovpl d0, CARG1, CARG2
  //|.endif
  //|  bxpl lr
  //|  mvn CARG4, #0x3cc
  //|  subs RB, CARG4, RB, asr #21	// 2^0: RB = 51, 2^51: RB = 0.
  //|  bxlo lr				// |x| >= 2^52: already done.
  //|  mvn CARG4, #1
  //|  and CARG1, CARG1, CARG4, lsl RB	// lo &= lomask
  //|  subs RB, RB, #32
  //|  andpl CARG2, CARG2, CARG4, lsl RB	// |x| <= 2^20: hi &= himask
  //|.if hf == 1
  //|  vmov d0, CARG1, CARG2
  //|.endif
  //|  bx lr
  //|.endif
  //|.endmacro
  //|
  //|->vm_trunc:
  //|.if HFABI
  //|  vm_trunc 1
  //|.endif
  //|->vm_trunc_sf:
  //|  vm_trunc 0
  //|
  //|  // double lj_vm_mod(double dividend, double divisor);
  //|->vm_mod:
  //|.if FPU
  //|  // Special calling convention. Also, RC (r11) is not preserved.
  //|  vdiv.f64 d0, d6, d7
  //|   mov RC, lr
  //|  vmov CARG1, CARG2, d0
  //|  bl ->vm_floor_sf
  //|  vmov d0, CARG1, CARG2
  //|  vmul.f64 d0, d0, d7
  //|   mov lr, RC
  //|  vsub.f64 d6, d6, d0
  //|  bx lr
  //|.else
  //|  push {r0, r1, r2, r3, r4, lr}
  //|  bl extern __aeabi_ddiv
  //|  bl ->vm_floor_sf
  //|  ldrd CARG34, [sp, #8]
  //|  bl extern __aeabi_dmul
  //|  ldrd CARG34, [sp]
  //|  eor CARG2, CARG2, #0x80000000
  //|  bl extern __aeabi_dadd
  //|  add sp, sp, #20
  //|  pop {pc}
  //|.endif
  //|
  //|  // int lj_vm_modi(int dividend, int divisor);
  //|->vm_modi:
  //|  ands RB, CARG1, #0x80000000
  //|  rsbmi CARG1, CARG1, #0		// a = |dividend|
  //|  eor RB, RB, CARG2, asr #1		// Keep signdiff and sign(divisor).
  //|  cmp CARG2, #0
  //|  rsbmi CARG2, CARG2, #0		// b = |divisor|
  //|  subs CARG4, CARG2, #1
  //|  cmpne CARG1, CARG2
  //|  moveq CARG1, #0			// if (b == 1 || a == b) a = 0
  //|  tsthi CARG2, CARG4
  //|  andeq CARG1, CARG1, CARG4		// else if ((b & (b-1)) == 0) a &= b-1
  //|  bls >1
  //|  // Use repeated subtraction to get the remainder.
  //|  clz CARG3, CARG1
  dasm_put(Dst, 2779, PC2PROTO(k), DISPATCH_GL(vmstate), BC_FUNCF);
# 2366 "vm_arm.dasc"
  //|  clz CARG4, CARG2
  //|  sub CARG4, CARG4, CARG3
  //|  rsbs CARG3, CARG4, #31		// entry = (31-(clz(b)-clz(a)))*8
  //|  addne pc, pc, CARG3, lsl #3	// Duff's device.
  //|  nop
  dasm_put(Dst, 2917);
# 2371 "vm_arm.dasc"
  {
    int i;
    for (i = 31; i >= 0; i--) {
      //|  cmp CARG1, CARG2, lsl #i
      //|  subhs CARG1, CARG1, CARG2, lsl #i
      dasm_put(Dst, 2924, i, i);
# 2376 "vm_arm.dasc"
    }
  }
  //|1:
  //|  cmp CARG1, #0
  //|  cmpne RB, #0
  //|  submi CARG1, CARG1, CARG2		// if (y != 0 && signdiff) y = y - b
  //|  eors CARG2, CARG1, RB, lsl #1
  //|  rsbmi CARG1, CARG1, #0		// if (sign(divisor) != sign(y)) y = -y
  //|  bx lr
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Miscellaneous functions --------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|//-----------------------------------------------------------------------
  //|//-- FFI helper functions -----------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|// Handler for callback functions.
  //|// Saveregs already performed. Callback slot number in [sp], g in r12.
  //|->vm_ffi_callback:
  //|.if FFI
  //|.type CTSTATE, CTState, PC
#define DtE(_V) (int)(ptrdiff_t)&(((CTState *)0)_V)
# 2399 "vm_arm.dasc"
  //|  ldr CTSTATE, GL:r12->ctype_state
  //|   add DISPATCH, r12, #GG_G2DISP
  //|.if FPU
  //|  str r4, SAVE_R4
  //|  add r4, sp, CFRAME_SPACE+4+8*8
  //|  vstmdb r4!, {d8-d15}
  //|.endif
  //|.if HFABI
  //|  add r12, CTSTATE, #offsetof(CTState, cb.fpr[8])
  //|.endif
  //|  strd CARG34, CTSTATE->cb.gpr[2]
  //|  strd CARG12, CTSTATE->cb.gpr[0]
  //|.if HFABI
  //|  vstmdb r12!, {d0-d7}
  //|.endif
  //|  ldr CARG4, [sp]
  //|   add CARG3, sp, #CFRAME_SIZE
  //|    mov CARG1, CTSTATE
  //|  lsr CARG4, CARG4, #3
  //|   str CARG3, CTSTATE->cb.stack
  //|    mov CARG2, sp
  //|  str CARG4, CTSTATE->cb.slot
  //|  str CTSTATE, SAVE_PC		// Any value outside of bytecode is ok.
  //|  bl extern lj_ccallback_enter	// (CTState *cts, void *cf)
  //|  // Returns lua_State *.
  //|  ldr BASE, L:CRET1->base
  //|    mv_vmstate CARG2, INTERP
  //|  ldr RC, L:CRET1->top
  //|    mov MASKR8, #255
  //|   ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  //|    mov L, CRET1
  //|  sub RC, RC, BASE
  //|    lsl MASKR8, MASKR8, #3		// MASKR8 = 255*8.
  //|    st_vmstate CARG2
  //|  ins_callt
  //|.endif
  //|
  //|->cont_ffi_callback:			// Return from FFI callback.
  //|.if FFI
  //|  ldr CTSTATE, [DISPATCH, #DISPATCH_GL(ctype_state)]
  //|   str BASE, L->base
  //|   str CARG4, L->top
  //|  str L, CTSTATE->L
  //|  mov CARG1, CTSTATE
  //|  mov CARG2, RA
  //|  bl extern lj_ccallback_leave	// (CTState *cts, TValue *o)
  //|  ldrd CARG12, CTSTATE->cb.gpr[0]
  dasm_put(Dst, 2929, Dt2(->ctype_state), GG_G2DISP, 28+4+8*8, DtE(->cb.gpr[2]), DtE(->cb.gpr[0]), CFRAME_SIZE, DtE(->cb.stack), DtE(->cb.slot), Dt1(->base), LJ_VMST_INTERP, Dt1(->top), DISPATCH_GL(vmstate), Dt7(->field_pc), DISPATCH_GL(ctype_state), Dt1(->base), Dt1(->top), DtE(->L));
# 2446 "vm_arm.dasc"
  //|.if HFABI
  //|  vldr d0, CTSTATE->cb.fpr[0]
  //|.endif
  //|  b ->vm_leave_unw
  //|.endif
  //|
  //|->vm_ffi_call:			// Call C function via FFI.
  //|  // Caveat: needs special frame unwinding, see below.
  //|.if FFI
  //|  .type CCSTATE, CCallState, r4
#define DtF(_V) (int)(ptrdiff_t)&(((CCallState *)0)_V)
# 2456 "vm_arm.dasc"
  //|  push {CCSTATE, r5, r11, lr}
  //|  mov CCSTATE, CARG1
  //|  ldr CARG1, CCSTATE:CARG1->spadj
  //|   ldrb CARG2, CCSTATE->nsp
  //|    add CARG3, CCSTATE, #offsetof(CCallState, stack)
  //|.if HFABI
  //|  add RB, CCSTATE, #offsetof(CCallState, fpr[0])
  //|.endif
  //|  mov r11, sp
  //|  sub sp, sp, CARG1			// Readjust stack.
  //|   subs CARG2, CARG2, #1
  //|.if HFABI
  //|  vldm RB, {d0-d7}
  //|.endif
  //|    ldr RB, CCSTATE->func
  //|   bmi >2
  //|1:  // Copy stack slots.
  //|  ldr CARG4, [CARG3, CARG2, lsl #2]
  //|  str CARG4, [sp, CARG2, lsl #2]
  //|  subs CARG2, CARG2, #1
  //|  bpl <1
  //|2:
  //|  ldrd CARG12, CCSTATE->gpr[0]
  //|  ldrd CARG34, CCSTATE->gpr[2]
  //|  blx RB
  //|  mov sp, r11
  //|.if HFABI
  //|  add r12, CCSTATE, #offsetof(CCallState, fpr[4])
  //|.endif
  //|  strd CRET1, CCSTATE->gpr[0]
  //|.if HFABI
  //|  vstmdb r12!, {d0-d3}
  //|.endif
  //|  pop {CCSTATE, r5, r11, pc}
  //|.endif
  //|// Note: vm_ffi_call must be the last function in this object file!
  //|
  //|//-----------------------------------------------------------------------
  dasm_put(Dst, 2997, DtE(->cb.gpr[0]), DtF(->spadj), DtF(->nsp), offsetof(CCallState, stack), DtF(->func), DtF(->gpr[0]), DtF(->gpr[2]), DtF(->gpr[0]));
# 2494 "vm_arm.dasc"
}

/* Generate the code for a single instruction. */
static void build_ins(BuildCtx *ctx, BCOp op, int defop)
{
  int vk = 0;
  //|=>defop:
  dasm_put(Dst, 3034, defop);
# 2501 "vm_arm.dasc"

  switch (op) {

  /* -- Comparison ops ---------------------------------------------------- */

  /* Remember: all ops branch for a true comparison, fall through otherwise. */

  case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
    //|  // RA = src1*8, RC = src2, JMP with RC = target
    //|   lsl RC, RC, #3
    //|  ldrd CARG12, [RA, BASE]!
    //|    ldrh RB, [PC, #2]
    //|   ldrd CARG34, [RC, BASE]!
    //|    add PC, PC, #4
    //|    add RB, PC, RB, lsl #2
    //|  checktp CARG2, LJ_TISNUM
    //|  bne >3
    //|  checktp CARG4, LJ_TISNUM
    //|  bne >4
    //|  cmp CARG1, CARG3
    dasm_put(Dst, 3036, -LJ_TISNUM, -LJ_TISNUM);
# 2521 "vm_arm.dasc"
    if (op == BC_ISLT) {
      //|  sublt PC, RB, #0x20000
      dasm_put(Dst, 3052);
# 2523 "vm_arm.dasc"
    } else if (op == BC_ISGE) {
      //|  subge PC, RB, #0x20000
      dasm_put(Dst, 3054);
# 2525 "vm_arm.dasc"
    } else if (op == BC_ISLE) {
      //|  suble PC, RB, #0x20000
      dasm_put(Dst, 3056);
# 2527 "vm_arm.dasc"
    } else {
      //|  subgt PC, RB, #0x20000
      dasm_put(Dst, 3058);
# 2529 "vm_arm.dasc"
    }
    //|1:
    //|  ins_next
    //|
    //|3: // CARG12 is not an integer.
    //|.if FPU
    //|   vldr d0, [RA]
    //|  bhi ->vmeta_comp
    //|  // d0 is a number.
    //|  checktp CARG4, LJ_TISNUM
    //|   vldr d1, [RC]
    //|  blo >5
    //|  bhi ->vmeta_comp
    //|  // d0 is a number, CARG3 is an integer.
    //|  vmov s4, CARG3
    //|  vcvt.f64.s32 d1, s4
    //|  b >5
    //|4:  // CARG1 is an integer, CARG34 is not an integer.
    //|   vldr d1, [RC]
    //|  bhi ->vmeta_comp
    //|  // CARG1 is an integer, d1 is a number.
    //|  vmov s4, CARG1
    //|  vcvt.f64.s32 d0, s4
    //|5:  // d0 and d1 are numbers.
    //|  vcmp.f64 d0, d1
    //|  vmrs
    //|  // To preserve NaN semantics GE/GT branch on unordered, but LT/LE don't.
    dasm_put(Dst, 3060, -LJ_TISNUM);
# 2556 "vm_arm.dasc"
    if (op == BC_ISLT) {
      //|  sublo PC, RB, #0x20000
      dasm_put(Dst, 3092);
# 2558 "vm_arm.dasc"
    } else if (op == BC_ISGE) {
      //|  subhs PC, RB, #0x20000
      dasm_put(Dst, 3094);
# 2560 "vm_arm.dasc"
    } else if (op == BC_ISLE) {
      //|  subls PC, RB, #0x20000
      dasm_put(Dst, 3096);
# 2562 "vm_arm.dasc"
    } else {
      //|  subhi PC, RB, #0x20000
      dasm_put(Dst, 3098);
# 2564 "vm_arm.dasc"
    }
    //|  b <1
    //|.else
    //|  bhi ->vmeta_comp
    //|  // CARG12 is a number.
    //|  checktp CARG4, LJ_TISNUM
    //|  movlo RA, RB			// Save RB.
    //|  blo >5
    //|  bhi ->vmeta_comp
    //|  // CARG12 is a number, CARG3 is an integer.
    //|  mov CARG1, CARG3
    //|  mov RC, RA
    //|  mov RA, RB			// Save RB.
    //|  bl extern __aeabi_i2d
    //|  mov CARG3, CARG1
    //|  mov CARG4, CARG2
    //|  ldrd CARG12, [RC]		// Restore first operand.
    //|  b >5
    //|4:  // CARG1 is an integer, CARG34 is not an integer.
    //|  bhi ->vmeta_comp
    //|  // CARG1 is an integer, CARG34 is a number.
    //|  mov RA, RB			// Save RB.
    //|  bl extern __aeabi_i2d
    //|  ldrd CARG34, [RC]		// Restore second operand.
    //|5:  // CARG12 and CARG34 are numbers.
    //|  bl extern __aeabi_cdcmple
    //|  // To preserve NaN semantics GE/GT branch on unordered, but LT/LE don't.
    dasm_put(Dst, 3100);
# 2591 "vm_arm.dasc"
    if (op == BC_ISLT) {
      //|  sublo PC, RA, #0x20000
    } else if (op == BC_ISGE) {
      //|  subhs PC, RA, #0x20000
    } else if (op == BC_ISLE) {
      //|  subls PC, RA, #0x20000
    } else {
      //|  subhi PC, RA, #0x20000
    }
    //|  b <1
    //|.endif
    break;

  case BC_ISEQV: case BC_ISNEV:
    vk = op == BC_ISEQV;
    //|  // RA = src1*8, RC = src2, JMP with RC = target
    //|   lsl RC, RC, #3
    //|  ldrd CARG12, [RA, BASE]!
    //|    ldrh RB, [PC, #2]
    //|   ldrd CARG34, [RC, BASE]!
    //|    add PC, PC, #4
    //|    add RB, PC, RB, lsl #2
    //|  checktp CARG2, LJ_TISNUM
    //|  cmnls CARG4, #-LJ_TISNUM
    dasm_put(Dst, 3103, -LJ_TISNUM, -LJ_TISNUM);
# 2615 "vm_arm.dasc"
    if (vk) {
      //|  bls ->BC_ISEQN_Z
      dasm_put(Dst, 3114);
# 2617 "vm_arm.dasc"
    } else {
      //|  bls ->BC_ISNEN_Z
      dasm_put(Dst, 3117);
# 2619 "vm_arm.dasc"
    }
    //|  // Either or both types are not numbers.
    //|.if FFI
    //|  checktp CARG2, LJ_TCDATA
    //|  checktpne CARG4, LJ_TCDATA
    //|  beq ->vmeta_equal_cd
    //|.endif
    //|  cmp CARG2, CARG4			// Compare types.
    //|  bne >2				// Not the same type?
    //|  checktp CARG2, LJ_TISPRI
    //|  bhs >1				// Same type and primitive type?
    //|
    //|  // Same types and not a primitive type. Compare GCobj or pvalue.
    //|  cmp CARG1, CARG3
    dasm_put(Dst, 3120, -LJ_TCDATA, -LJ_TCDATA, -LJ_TISPRI);
# 2633 "vm_arm.dasc"
    if (vk) {
      //|  bne >3				// Different GCobjs or pvalues?
      //|1:  // Branch if same.
      //|  sub PC, RB, #0x20000
      //|2:  // Different.
      //|  ins_next
      //|3:
      //|  checktp CARG2, LJ_TISTABUD
      //|  bhi <2				// Different objects and not table/ud?
      dasm_put(Dst, 3135, -LJ_TISTABUD);
# 2642 "vm_arm.dasc"
    } else {
      //|  beq >1				// Same GCobjs or pvalues?
      //|  checktp CARG2, LJ_TISTABUD
      //|  bhi >2				// Different objects and not table/ud?
      dasm_put(Dst, 3152, -LJ_TISTABUD);
# 2646 "vm_arm.dasc"
    }
    //|  // Different tables or userdatas. Need to check __eq metamethod.
    //|  // Field metatable must be at same offset for GCtab and GCudata!
    //|  ldr TAB:RA, TAB:CARG1->metatable
    //|  cmp TAB:RA, #0
    dasm_put(Dst, 3159, Dt6(->metatable));
# 2651 "vm_arm.dasc"
    if (vk) {
      //|  beq <2			// No metatable?
      dasm_put(Dst, 3163);
# 2653 "vm_arm.dasc"
    } else {
      //|  beq >2			// No metatable?
      dasm_put(Dst, 3166);
# 2655 "vm_arm.dasc"
    }
    //|  ldrb RA, TAB:RA->nomm
    //|   mov CARG4, #1-vk		// ne = 0 or 1.
    //|   mov CARG2, CARG1
    //|  tst RA, #1<<MM_eq
    //|  beq ->vmeta_equal		// 'no __eq' flag not set?
    dasm_put(Dst, 3169, Dt6(->nomm), 1-vk, 1<<MM_eq);
# 2661 "vm_arm.dasc"
    if (vk) {
      //|  b <2
      dasm_put(Dst, 3179);
# 2663 "vm_arm.dasc"
    } else {
      //|2:  // Branch if different.
      //|  sub PC, RB, #0x20000
      //|1:  // Same.
      //|  ins_next
      dasm_put(Dst, 3182);
# 2668 "vm_arm.dasc"
    }
    break;

  case BC_ISEQS: case BC_ISNES:
    vk = op == BC_ISEQS;
    //|  // RA = src*8, RC = str_const (~), JMP with RC = target
    //|   mvn RC, RC
    //|  ldrd CARG12, [BASE, RA]
    //|    ldrh RB, [PC, #2]
    //|   ldr STR:CARG3, [KBASE, RC, lsl #2]
    //|    add PC, PC, #4
    //|    add RB, PC, RB, lsl #2
    //|  checktp CARG2, LJ_TSTR
    //|.if FFI
    //|  bne >7
    //|  cmp CARG1, CARG3
    //|.else
    //|  cmpeq CARG1, CARG3
    //|.endif
    dasm_put(Dst, 3192, -LJ_TSTR);
# 2687 "vm_arm.dasc"
    if (vk) {
      //|  subeq PC, RB, #0x20000
      //|1:
      dasm_put(Dst, 3204);
# 2690 "vm_arm.dasc"
    } else {
      //|1:
      //|  subne PC, RB, #0x20000
      dasm_put(Dst, 3207);
# 2693 "vm_arm.dasc"
    }
    //|  ins_next
    //|
    //|.if FFI
    //|7:
    //|  checktp CARG2, LJ_TCDATA
    //|  bne <1
    //|  b ->vmeta_equal_cd
    //|.endif
    dasm_put(Dst, 3210, -LJ_TCDATA);
# 2702 "vm_arm.dasc"
    break;

  case BC_ISEQN: case BC_ISNEN:
    vk = op == BC_ISEQN;
    //|  // RA = src*8, RC = num_const (~), JMP with RC = target
    //|   lsl RC, RC, #3
    //|  ldrd CARG12, [RA, BASE]!
    //|    ldrh RB, [PC, #2]
    //|   ldrd CARG34, [RC, KBASE]!
    //|    add PC, PC, #4
    //|    add RB, PC, RB, lsl #2
    dasm_put(Dst, 3224);
# 2713 "vm_arm.dasc"
    if (vk) {
      //|->BC_ISEQN_Z:
      dasm_put(Dst, 3231);
# 2715 "vm_arm.dasc"
    } else {
      //|->BC_ISNEN_Z:
      dasm_put(Dst, 3233);
# 2717 "vm_arm.dasc"
    }
    //|  checktp CARG2, LJ_TISNUM
    //|  bne >3
    //|  checktp CARG4, LJ_TISNUM
    //|  bne >4
    //|  cmp CARG1, CARG3
    dasm_put(Dst, 3235, -LJ_TISNUM, -LJ_TISNUM);
# 2723 "vm_arm.dasc"
    if (vk) {
      //|  subeq PC, RB, #0x20000
      //|1:
      dasm_put(Dst, 3245);
# 2726 "vm_arm.dasc"
    } else {
      //|1:
      //|  subne PC, RB, #0x20000
      dasm_put(Dst, 3248);
# 2729 "vm_arm.dasc"
    }
    //|2:
    //|  ins_next
    //|
    //|3:  // CARG12 is not an integer.
    //|.if FFI
    //|  bhi >7
    //|.else
    dasm_put(Dst, 3251);
# 2737 "vm_arm.dasc"
    if (!vk) {
      //|  subhi PC, RB, #0x20000
    }
    //|  bhi <2
    //|.endif
    //|.if FPU
    //|  checktp CARG4, LJ_TISNUM
    //|  vmov s4, CARG3
    //|   vldr d0, [RA]
    //|  vldrlo d1, [RC]
    //|  vcvths.f64.s32 d1, s4
    //|  b >5
    //|4:  // CARG1 is an integer, d1 is a number.
    //|  vmov s4, CARG1
    //|   vldr d1, [RC]
    //|  vcvt.f64.s32 d0, s4
    //|5:  // d0 and d1 are numbers.
    //|  vcmp.f64 d0, d1
    //|  vmrs
    dasm_put(Dst, 3262, -LJ_TISNUM);
# 2756 "vm_arm.dasc"
    if (vk) {
      //|  subeq PC, RB, #0x20000
      dasm_put(Dst, 3278);
# 2758 "vm_arm.dasc"
    } else {
      //|  subne PC, RB, #0x20000
      dasm_put(Dst, 3280);
# 2760 "vm_arm.dasc"
    }
    //|  b <2
    //|.else
    //|  // CARG12 is a number.
    //|  checktp CARG4, LJ_TISNUM
    //|  movlo RA, RB			// Save RB.
    //|  blo >5
    //|  // CARG12 is a number, CARG3 is an integer.
    //|  mov CARG1, CARG3
    //|  mov RC, RA
    //|4:  // CARG1 is an integer, CARG34 is a number.
    //|  mov RA, RB			// Save RB.
    //|  bl extern __aeabi_i2d
    //|  ldrd CARG34, [RC]		// Restore other operand.
    //|5:  // CARG12 and CARG34 are numbers.
    //|  bl extern __aeabi_cdcmpeq
    dasm_put(Dst, 3282);
# 2776 "vm_arm.dasc"
    if (vk) {
      //|  subeq PC, RA, #0x20000
    } else {
      //|  subne PC, RA, #0x20000
    }
    //|  b <2
    //|.endif
    //|
    //|.if FFI
    //|7:
    //|  checktp CARG2, LJ_TCDATA
    //|  bne <1
    //|  b ->vmeta_equal_cd
    //|.endif
    dasm_put(Dst, 3285, -LJ_TCDATA);
# 2790 "vm_arm.dasc"
    break;

  case BC_ISEQP: case BC_ISNEP:
    vk = op == BC_ISEQP;
    //|  // RA = src*8, RC = primitive_type (~), JMP with RC = target
    //|  ldrd CARG12, [BASE, RA]
    //|   ldrh RB, [PC, #2]
    //|   add PC, PC, #4
    //|  mvn RC, RC
    //|   add RB, PC, RB, lsl #2
    //|.if FFI
    //|  checktp CARG2, LJ_TCDATA
    //|  beq ->vmeta_equal_cd
    //|.endif
    //|  cmp CARG2, RC
    dasm_put(Dst, 3293, -LJ_TCDATA);
# 2805 "vm_arm.dasc"
    if (vk) {
      //|  subeq PC, RB, #0x20000
      dasm_put(Dst, 3304);
# 2807 "vm_arm.dasc"
    } else {
      //|  subne PC, RB, #0x20000
      dasm_put(Dst, 3306);
# 2809 "vm_arm.dasc"
    }
    //|  ins_next
    dasm_put(Dst, 3308);
# 2811 "vm_arm.dasc"
    break;

  /* -- Unary test and copy ops ------------------------------------------- */

  case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
    //|  // RA = dst*8 or unused, RC = src, JMP with RC = target
    //|  add RC, BASE, RC, lsl #3
    //|   ldrh RB, [PC, #2]
    //|  ldrd CARG12, [RC]
    //|   add PC, PC, #4
    //|   add RB, PC, RB, lsl #2
    //|  checktp CARG2, LJ_TTRUE
    dasm_put(Dst, 3315, -LJ_TTRUE);
# 2823 "vm_arm.dasc"
    if (op == BC_ISTC || op == BC_IST) {
      //|  subls PC, RB, #0x20000
      dasm_put(Dst, 3323);
# 2825 "vm_arm.dasc"
      if (op == BC_ISTC) {
	//|  strdls CARG12, [BASE, RA]
	dasm_put(Dst, 3325);
# 2827 "vm_arm.dasc"
      }
    } else {
      //|  subhi PC, RB, #0x20000
      dasm_put(Dst, 3327);
# 2830 "vm_arm.dasc"
      if (op == BC_ISFC) {
	//|  strdhi CARG12, [BASE, RA]
	dasm_put(Dst, 3329);
# 2832 "vm_arm.dasc"
      }
    }
    //|  ins_next
    dasm_put(Dst, 3331);
# 2835 "vm_arm.dasc"
    break;

  /* -- Unary ops --------------------------------------------------------- */

  case BC_MOV:
    //|  // RA = dst*8, RC = src
    //|  lsl RC, RC, #3
    //|   ins_next1
    //|  ldrd CARG12, [BASE, RC]
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    dasm_put(Dst, 3338);
# 2847 "vm_arm.dasc"
    break;
  case BC_NOT:
    //|  // RA = dst*8, RC = src
    //|  add RC, BASE, RC, lsl #3
    //|   ins_next1
    //|  ldr CARG1, [RC, #4]
    //|   add RA, BASE, RA
    //|   ins_next2
    //|  checktp CARG1, LJ_TTRUE
    //|  mvnls CARG2, #~LJ_TFALSE
    //|  mvnhi CARG2, #~LJ_TTRUE
    //|  str CARG2, [RA, #4]
    //|   ins_next3
    dasm_put(Dst, 3348, -LJ_TTRUE, ~LJ_TFALSE, ~LJ_TTRUE);
# 2860 "vm_arm.dasc"
    break;
  case BC_UNM:
    //|  // RA = dst*8, RC = src
    //|  lsl RC, RC, #3
    //|  ldrd CARG12, [BASE, RC]
    //|   ins_next1
    //|   ins_next2
    //|  checktp CARG2, LJ_TISNUM
    //|  bhi ->vmeta_unm
    //|  eorne CARG2, CARG2, #0x80000000
    //|  bne >5
    //|  rsbseq CARG1, CARG1, #0
    //|  ldrdvs CARG12, >9
    //|5:
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    //|
    //|.align 8
    //|9:
    //|  .long 0x00000000, 0x41e00000	// 2^31.
    dasm_put(Dst, 3365, -LJ_TISNUM);
# 2880 "vm_arm.dasc"
    break;
  case BC_LEN:
    //|  // RA = dst*8, RC = src
    //|  lsl RC, RC, #3
    //|  ldrd CARG12, [BASE, RC]
    //|  checkstr CARG2, >2
    //|  ldr CARG1, STR:CARG1->len
    //|1:
    //|  mvn CARG2, #~LJ_TISNUM
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    //|2:
    //|  checktab CARG2, ->vmeta_len
    dasm_put(Dst, 3391, -LJ_TSTR, Dt5(->len), ~LJ_TISNUM, -LJ_TTAB);
# 2895 "vm_arm.dasc"
#if LJ_52
    //|  ldr TAB:CARG3, TAB:CARG1->metatable
    //|  cmp TAB:CARG3, #0
    //|  bne >9
    //|3:
    dasm_put(Dst, 3415, Dt6(->metatable));
# 2900 "vm_arm.dasc"
#endif
    //|->BC_LEN_Z:
    //|  .IOS mov RC, BASE
    //|  bl extern lj_tab_len		// (GCtab *t)
    //|  // Returns uint32_t (but less than 2^31).
    //|  .IOS mov BASE, RC
    //|  b <1
    dasm_put(Dst, 3422);
# 2907 "vm_arm.dasc"
#if LJ_52
    //|9:
    //|  ldrb CARG4, TAB:CARG3->nomm
    //|  tst CARG4, #1<<MM_len
    //|  bne <3				// 'no __len' flag set: done.
    //|  b ->vmeta_len
    dasm_put(Dst, 3428, Dt6(->nomm), 1<<MM_len);
# 2913 "vm_arm.dasc"
#endif
    break;

  /* -- Binary ops -------------------------------------------------------- */

    //|.macro ins_arithcheck, cond, ncond, target
    //||if (vk == 1) {
    //|   cmn CARG4, #-LJ_TISNUM
    //|    cmn..cond CARG2, #-LJ_TISNUM
    //||} else {
    //|   cmn CARG2, #-LJ_TISNUM
    //|    cmn..cond CARG4, #-LJ_TISNUM
    //||}
    //|  b..ncond target
    //|.endmacro
    //|.macro ins_arithcheck_int, target
    //|  ins_arithcheck eq, ne, target
    //|.endmacro
    //|.macro ins_arithcheck_num, target
    //|  ins_arithcheck lo, hs, target
    //|.endmacro
    //|
    //|.macro ins_arithpre
    //|  decode_RB8 RB, INS
    //|   decode_RC8 RC, INS
    //|  // RA = dst*8, RB = src1*8, RC = src2*8 | num_const*8
    //||vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    //||switch (vk) {
    //||case 0:
    //|   .if FPU
    //|   ldrd CARG12, [RB, BASE]!
    //|    ldrd CARG34, [RC, KBASE]!
    //|   .else
    //|   ldrd CARG12, [BASE, RB]
    //|    ldrd CARG34, [KBASE, RC]
    //|   .endif
    //||  break;
    //||case 1:
    //|   .if FPU
    //|   ldrd CARG34, [RB, BASE]!
    //|    ldrd CARG12, [RC, KBASE]!
    //|   .else
    //|   ldrd CARG34, [BASE, RB]
    //|    ldrd CARG12, [KBASE, RC]
    //|   .endif
    //||  break;
    //||default:
    //|   .if FPU
    //|   ldrd CARG12, [RB, BASE]!
    //|    ldrd CARG34, [RC, BASE]!
    //|   .else
    //|   ldrd CARG12, [BASE, RB]
    //|    ldrd CARG34, [BASE, RC]
    //|   .endif
    //||  break;
    //||}
    //|.endmacro
    //|
    //|.macro ins_arithpre_fpu, reg1, reg2
    //|.if FPU
    //||if (vk == 1) {
    //|  vldr reg2, [RB]
    //|  vldr reg1, [RC]
    //||} else {
    //|  vldr reg1, [RB]
    //|  vldr reg2, [RC]
    //||}
    //|.endif
    //|.endmacro
    //|
    //|.macro ins_arithpost_fpu, reg
    //|   ins_next1
    //|  add RA, BASE, RA
    //|   ins_next2
    //|  vstr reg, [RA]
    //|   ins_next3
    //|.endmacro
    //|
    //|.macro ins_arithfallback, ins
    //||switch (vk) {
    //||case 0:
    //|   ins ->vmeta_arith_vn
    //||  break;
    //||case 1:
    //|   ins ->vmeta_arith_nv
    //||  break;
    //||default:
    //|   ins ->vmeta_arith_vv
    //||  break;
    //||}
    //|.endmacro
    //|
    //|.macro ins_arithdn, intins, fpins, fpcall
    //|  ins_arithpre
    //|.if "intins" ~= "vm_modi" and not FPU
    //|   ins_next1
    //|.endif
    //|  ins_arithcheck_int >5
    //|.if "intins" == "smull"
    //|  smull CARG1, RC, CARG3, CARG1
    //|  cmp RC, CARG1, asr #31
    //|  ins_arithfallback bne
    //|.elif "intins" == "vm_modi"
    //|  movs CARG2, CARG3
    //|  ins_arithfallback beq
    //|  bl ->vm_modi
    //|  mvn CARG2, #~LJ_TISNUM
    //|.else
    //|  intins CARG1, CARG1, CARG3
    //|  ins_arithfallback bvs
    //|.endif
    //|4:
    //|.if "intins" == "vm_modi" or FPU
    //|   ins_next1
    //|.endif
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    //|5:  // FP variant.
    //|  ins_arithpre_fpu d6, d7
    //|  ins_arithfallback ins_arithcheck_num
    //|.if FPU
    //|.if "intins" == "vm_modi"
    //|  bl fpcall
    //|.else
    //|  fpins d6, d6, d7
    //|.endif
    //|  ins_arithpost_fpu d6
    //|.else
    //|  bl fpcall
    //|.if "intins" ~= "vm_modi"
    //|  ins_next1
    //|.endif
    //|  b <4
    //|.endif
    //|.endmacro
    //|
    //|.macro ins_arithfp, fpins, fpcall
    //|  ins_arithpre
    //|.if "fpins" ~= "extern" or HFABI
    //|  ins_arithpre_fpu d0, d1
    //|.endif
    //|  ins_arithfallback ins_arithcheck_num
    //|.if "fpins" == "extern"
    //|  .IOS mov RC, BASE
    //|  bl fpcall
    //|  .IOS mov BASE, RC
    //|.elif FPU
    //|  fpins d0, d0, d1
    //|.else
    //|  bl fpcall
    //|.endif
    //|.if ("fpins" ~= "extern" or HFABI) and FPU
    //|  ins_arithpost_fpu d0
    //|.else
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    //|.endif
    //|.endmacro

  case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:
    //|  ins_arithdn adds, vadd.f64, extern __aeabi_dadd
    dasm_put(Dst, 3438);
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3441);
      break;
    case 1:
    dasm_put(Dst, 3444);
      break;
    default:
    dasm_put(Dst, 3447);
      break;
    }
    if (vk == 1) {
    dasm_put(Dst, 3450, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3455, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3460);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3464);
      break;
    case 1:
    dasm_put(Dst, 3467);
      break;
    default:
    dasm_put(Dst, 3470);
      break;
    }
    dasm_put(Dst, 3473);
    if (vk == 1) {
    dasm_put(Dst, 3483);
    } else {
    dasm_put(Dst, 3486);
    }
    switch (vk) {
    case 0:
    if (vk == 1) {
    dasm_put(Dst, 3489, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3494, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3499);
      break;
    case 1:
    if (vk == 1) {
    dasm_put(Dst, 3502, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3507, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3512);
      break;
    default:
    if (vk == 1) {
    dasm_put(Dst, 3515, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3520, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3525);
      break;
    }
    dasm_put(Dst, 3528);
# 3077 "vm_arm.dasc"
    break;
  case BC_SUBVN: case BC_SUBNV: case BC_SUBVV:
    //|  ins_arithdn subs, vsub.f64, extern __aeabi_dsub
    dasm_put(Dst, 3538);
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3541);
      break;
    case 1:
    dasm_put(Dst, 3544);
      break;
    default:
    dasm_put(Dst, 3547);
      break;
    }
    if (vk == 1) {
    dasm_put(Dst, 3550, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3555, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3560);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3564);
      break;
    case 1:
    dasm_put(Dst, 3567);
      break;
    default:
    dasm_put(Dst, 3570);
      break;
    }
    dasm_put(Dst, 3573);
    if (vk == 1) {
    dasm_put(Dst, 3583);
    } else {
    dasm_put(Dst, 3586);
    }
    switch (vk) {
    case 0:
    if (vk == 1) {
    dasm_put(Dst, 3589, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3594, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3599);
      break;
    case 1:
    if (vk == 1) {
    dasm_put(Dst, 3602, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3607, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3612);
      break;
    default:
    if (vk == 1) {
    dasm_put(Dst, 3615, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3620, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3625);
      break;
    }
    dasm_put(Dst, 3628);
# 3080 "vm_arm.dasc"
    break;
  case BC_MULVN: case BC_MULNV: case BC_MULVV:
    //|  ins_arithdn smull, vmul.f64, extern __aeabi_dmul
    dasm_put(Dst, 3638);
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3641);
      break;
    case 1:
    dasm_put(Dst, 3644);
      break;
    default:
    dasm_put(Dst, 3647);
      break;
    }
    if (vk == 1) {
    dasm_put(Dst, 3650, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3655, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3660);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3665);
      break;
    case 1:
    dasm_put(Dst, 3668);
      break;
    default:
    dasm_put(Dst, 3671);
      break;
    }
    dasm_put(Dst, 3674);
    if (vk == 1) {
    dasm_put(Dst, 3684);
    } else {
    dasm_put(Dst, 3687);
    }
    switch (vk) {
    case 0:
    if (vk == 1) {
    dasm_put(Dst, 3690, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3695, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3700);
      break;
    case 1:
    if (vk == 1) {
    dasm_put(Dst, 3703, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3708, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3713);
      break;
    default:
    if (vk == 1) {
    dasm_put(Dst, 3716, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3721, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3726);
      break;
    }
    dasm_put(Dst, 3729);
# 3083 "vm_arm.dasc"
    break;
  case BC_DIVVN: case BC_DIVNV: case BC_DIVVV:
    //|  ins_arithfp vdiv.f64, extern __aeabi_ddiv
    dasm_put(Dst, 3739);
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3742);
      break;
    case 1:
    dasm_put(Dst, 3745);
      break;
    default:
    dasm_put(Dst, 3748);
      break;
    }
    if (vk == 1) {
    dasm_put(Dst, 3751);
    } else {
    dasm_put(Dst, 3754);
    }
    switch (vk) {
    case 0:
    if (vk == 1) {
    dasm_put(Dst, 3757, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3762, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3767);
      break;
    case 1:
    if (vk == 1) {
    dasm_put(Dst, 3770, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3775, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3780);
      break;
    default:
    if (vk == 1) {
    dasm_put(Dst, 3783, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3788, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3793);
      break;
    }
    dasm_put(Dst, 3796);
# 3086 "vm_arm.dasc"
    break;
  case BC_MODVN: case BC_MODNV: case BC_MODVV:
    //|  ins_arithdn vm_modi, vm_mod, ->vm_mod
    dasm_put(Dst, 3806);
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3809);
      break;
    case 1:
    dasm_put(Dst, 3812);
      break;
    default:
    dasm_put(Dst, 3815);
      break;
    }
    if (vk == 1) {
    dasm_put(Dst, 3818, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3823, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3828);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3832);
      break;
    case 1:
    dasm_put(Dst, 3835);
      break;
    default:
    dasm_put(Dst, 3838);
      break;
    }
    dasm_put(Dst, 3841, ~LJ_TISNUM);
    if (vk == 1) {
    dasm_put(Dst, 3855);
    } else {
    dasm_put(Dst, 3858);
    }
    switch (vk) {
    case 0:
    if (vk == 1) {
    dasm_put(Dst, 3861, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3866, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3871);
      break;
    case 1:
    if (vk == 1) {
    dasm_put(Dst, 3874, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3879, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3884);
      break;
    default:
    if (vk == 1) {
    dasm_put(Dst, 3887, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3892, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3897);
      break;
    }
    dasm_put(Dst, 3900);
# 3089 "vm_arm.dasc"
    break;
  case BC_POW:
    //|  // NYI: (partial) integer arithmetic.
    //|  ins_arithfp extern, extern pow
    dasm_put(Dst, 3911);
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3914);
      break;
    case 1:
    dasm_put(Dst, 3917);
      break;
    default:
    dasm_put(Dst, 3920);
      break;
    }
    switch (vk) {
    case 0:
    if (vk == 1) {
    dasm_put(Dst, 3923, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3928, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3933);
      break;
    case 1:
    if (vk == 1) {
    dasm_put(Dst, 3936, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3941, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3946);
      break;
    default:
    if (vk == 1) {
    dasm_put(Dst, 3949, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3954, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3959);
      break;
    }
    dasm_put(Dst, 3962);
# 3093 "vm_arm.dasc"
    break;

  case BC_CAT:
    //|  decode_RB8 RC, INS
    //|   decode_RC8 RB, INS
    //|  // RA = dst*8, RC = src_start*8, RB = src_end*8  (note: RB/RC swapped!)
    //|  sub CARG3, RB, RC
    //|   str BASE, L->base
    //|  add CARG2, BASE, RB
    //|->BC_CAT_Z:
    //|  // RA = dst*8, RC = src_start*8, CARG2 = top-1
    //|  mov CARG1, L
    //|   str PC, SAVE_PC
    //|  lsr CARG3, CARG3, #3
    //|  bl extern lj_meta_cat		// (lua_State *L, TValue *top, int left)
    //|  // Returns NULL (finished) or TValue * (metamethod).
    //|  ldr BASE, L->base
    //|  cmp CRET1, #0
    //|  bne ->vmeta_binop
    //|  ldrd CARG34, [BASE, RC]
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG34, [BASE, RA]		// Copy result to RA.
    //|   ins_next3
    dasm_put(Dst, 3972, Dt1(->base), Dt1(->base));
# 3117 "vm_arm.dasc"
    break;

  /* -- Constant ops ------------------------------------------------------ */

  case BC_KSTR:
    //|  // RA = dst*8, RC = str_const (~)
    //|  mvn RC, RC
    //|   ins_next1
    //|  ldr CARG1, [KBASE, RC, lsl #2]
    //|  mvn CARG2, #~LJ_TSTR
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    dasm_put(Dst, 3998, ~LJ_TSTR);
# 3130 "vm_arm.dasc"
    break;
  case BC_KCDATA:
    //|.if FFI
    //|  // RA = dst*8, RC = cdata_const (~)
    //|  mvn RC, RC
    //|   ins_next1
    //|  ldr CARG1, [KBASE, RC, lsl #2]
    //|  mvn CARG2, #~LJ_TCDATA
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    //|.endif
    dasm_put(Dst, 4010, ~LJ_TCDATA);
# 3142 "vm_arm.dasc"
    break;
  case BC_KSHORT:
    //|  // RA = dst*8, (RC = int16_literal)
    //|  mov CARG1, INS, asr #16			// Refetch sign-extended reg.
    //|  mvn CARG2, #~LJ_TISNUM
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    dasm_put(Dst, 4022, ~LJ_TISNUM);
# 3151 "vm_arm.dasc"
    break;
  case BC_KNUM:
    //|  // RA = dst*8, RC = num_const
    //|  lsl RC, RC, #3
    //|   ins_next1
    //|  ldrd CARG12, [KBASE, RC]
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    dasm_put(Dst, 4033);
# 3160 "vm_arm.dasc"
    break;
  case BC_KPRI:
    //|  // RA = dst*8, RC = primitive_type (~)
    //|  add RA, BASE, RA
    //|  mvn RC, RC
    //|   ins_next1
    //|   ins_next2
    //|  str RC, [RA, #4]
    //|   ins_next3
    dasm_put(Dst, 4043);
# 3169 "vm_arm.dasc"
    break;
  case BC_KNIL:
    //|  // RA = base*8, RC = end
    //|  add RA, BASE, RA
    //|   add RC, BASE, RC, lsl #3
    //|  mvn CARG1, #~LJ_TNIL
    //|  str CARG1, [RA, #4]
    //|   add RA, RA, #8
    //|1:
    //|  str CARG1, [RA, #4]
    //|  cmp RA, RC
    //|   add RA, RA, #8
    //|  blt <1
    //|  ins_next_
    dasm_put(Dst, 4053, ~LJ_TNIL);
# 3183 "vm_arm.dasc"
    break;

  /* -- Upvalue and function ops ------------------------------------------ */

  case BC_UGET:
    //|  // RA = dst*8, RC = uvnum
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   lsl RC, RC, #2
    //|   add RC, RC, #offsetof(GCfuncL, uvptr)
    //|  ldr UPVAL:CARG2, [LFUNC:CARG2, RC]
    //|  ldr CARG2, UPVAL:CARG2->v
    //|  ldrd CARG34, [CARG2]
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG34, [BASE, RA]
    //|   ins_next3
    dasm_put(Dst, 4072, offsetof(GCfuncL, uvptr), DtA(->v));
# 3199 "vm_arm.dasc"
    break;
  case BC_USETV:
    //|  // RA = uvnum*8, RC = src
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   lsr RA, RA, #1
    //|   add RA, RA, #offsetof(GCfuncL, uvptr)
    //|    lsl RC, RC, #3
    //|  ldr UPVAL:CARG2, [LFUNC:CARG2, RA]
    //|    ldrd CARG34, [BASE, RC]
    //|  ldrb RB, UPVAL:CARG2->marked
    //|  ldrb RC, UPVAL:CARG2->closed
    //|    ldr CARG2, UPVAL:CARG2->v
    //|  tst RB, #LJ_GC_BLACK		// isblack(uv)
    //|   add RB, CARG4, #-LJ_TISGCV
    //|  cmpne RC, #0
    //|   strd CARG34, [CARG2]
    //|  bne >2				// Upvalue is closed and black?
    //|1:
    //|   ins_next
    //|
    //|2:  // Check if new value is collectable.
    //|  cmn RB, #-(LJ_TISNUM - LJ_TISGCV)
    //|   ldrbhi RC, GCOBJ:CARG3->gch.marked
    //|  bls <1				// tvisgcv(v)
    //|    sub CARG1, DISPATCH, #-GG_DISP2G
    //|   tst RC, #LJ_GC_WHITES
    //|  // Crossed a write barrier. Move the barrier forward.
    //|.if IOS
    //|  beq <1
    //|  mov RC, BASE
    //|  bl extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
    //|  mov BASE, RC
    //|.else
    //|  blne extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
    //|.endif
    //|  b <1
    dasm_put(Dst, 4088, offsetof(GCfuncL, uvptr), DtA(->marked), DtA(->closed), DtA(->v), LJ_GC_BLACK, -LJ_TISGCV, -(LJ_TISNUM - LJ_TISGCV), Dt4(->gch.marked), -GG_DISP2G, LJ_GC_WHITES);
# 3235 "vm_arm.dasc"
    break;
  case BC_USETS:
    //|  // RA = uvnum*8, RC = str_const (~)
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   lsr RA, RA, #1
    //|   add RA, RA, #offsetof(GCfuncL, uvptr)
    //|    mvn RC, RC
    //|  ldr UPVAL:CARG2, [LFUNC:CARG2, RA]
    //|    ldr STR:CARG3, [KBASE, RC, lsl #2]
    //|    mvn CARG4, #~LJ_TSTR
    //|  ldrb RB, UPVAL:CARG2->marked
    //|   ldr CARG2, UPVAL:CARG2->v
    //|     ldrb RC, UPVAL:CARG2->closed
    //|  tst RB, #LJ_GC_BLACK		// isblack(uv)
    //|    ldrb RB, STR:CARG3->marked
    //|   strd CARG34, [CARG2]
    //|  bne >2
    //|1:
    //|   ins_next
    //|
    //|2:  // Check if string is white and ensure upvalue is closed.
    //|  tst RB, #LJ_GC_WHITES		// iswhite(str)
    //|  cmpne RC, #0
    //|   sub CARG1, DISPATCH, #-GG_DISP2G
    //|  // Crossed a write barrier. Move the barrier forward.
    //|.if IOS
    //|  beq <1
    //|  mov RC, BASE
    //|  bl extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
    //|  mov BASE, RC
    //|.else
    //|  blne extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
    //|.endif
    //|  b <1
    dasm_put(Dst, 4132, offsetof(GCfuncL, uvptr), ~LJ_TSTR, DtA(->marked), DtA(->v), DtA(->closed), LJ_GC_BLACK, Dt5(->marked), LJ_GC_WHITES, -GG_DISP2G);
# 3269 "vm_arm.dasc"
    break;
  case BC_USETN:
    //|  // RA = uvnum*8, RC = num_const
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   lsr RA, RA, #1
    //|   add RA, RA, #offsetof(GCfuncL, uvptr)
    //|    lsl RC, RC, #3
    //|  ldr UPVAL:CARG2, [LFUNC:CARG2, RA]
    //|    ldrd CARG34, [KBASE, RC]
    //|  ldr CARG2, UPVAL:CARG2->v
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG34, [CARG2]
    //|   ins_next3
    dasm_put(Dst, 4172, offsetof(GCfuncL, uvptr), DtA(->v));
# 3283 "vm_arm.dasc"
    break;
  case BC_USETP:
    //|  // RA = uvnum*8, RC = primitive_type (~)
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   lsr RA, RA, #1
    //|   add RA, RA, #offsetof(GCfuncL, uvptr)
    //|  ldr UPVAL:CARG2, [LFUNC:CARG2, RA]
    //|   mvn RC, RC
    //|  ldr CARG2, UPVAL:CARG2->v
    //|   ins_next1
    //|   ins_next2
    //|  str RC, [CARG2, #4]
    //|   ins_next3
    dasm_put(Dst, 4189, offsetof(GCfuncL, uvptr), DtA(->v));
# 3296 "vm_arm.dasc"
    break;

  case BC_UCLO:
    //|  // RA = level*8, RC = target
    //|  ldr CARG3, L->openupval
    //|   add RC, PC, RC, lsl #2
    //|   str BASE, L->base
    //|  cmp CARG3, #0
    //|   sub PC, RC, #0x20000
    //|  beq >1
    //|   mov CARG1, L
    //|   add CARG2, BASE, RA
    //|  bl extern lj_func_closeuv	// (lua_State *L, TValue *level)
    //|  ldr BASE, L->base
    //|1:
    //|  ins_next
    dasm_put(Dst, 4205, Dt1(->openupval), Dt1(->base), Dt1(->base));
# 3312 "vm_arm.dasc"
    break;

  case BC_FNEW:
    //|  // RA = dst*8, RC = proto_const (~) (holding function prototype)
    //|  mvn RC, RC
    //|   str BASE, L->base
    //|  ldr CARG2, [KBASE, RC, lsl #2]
    //|   str PC, SAVE_PC
    //|  ldr CARG3, [BASE, FRAME_FUNC]
    //|   mov CARG1, L
    //|  // (lua_State *L, GCproto *pt, GCfuncL *parent)
    //|  bl extern lj_func_newL_gc
    //|  // Returns GCfuncL *.
    //|  ldr BASE, L->base
    //|  mvn CARG2, #~LJ_TFUNC
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    dasm_put(Dst, 4228, Dt1(->base), Dt1(->base), ~LJ_TFUNC);
# 3331 "vm_arm.dasc"
    break;

  /* -- Table ops --------------------------------------------------------- */

  case BC_TNEW:
  case BC_TDUP:
    //|  // RA = dst*8, RC = (hbits|asize) | tab_const (~)
    if (op == BC_TDUP) {
      //|  mvn RC, RC
      dasm_put(Dst, 4249);
# 3340 "vm_arm.dasc"
    }
    //|  ldr CARG3, [DISPATCH, #DISPATCH_GL(gc.total)]
    //|   ldr CARG4, [DISPATCH, #DISPATCH_GL(gc.threshold)]
    //|    str BASE, L->base
    //|    str PC, SAVE_PC
    //|  cmp CARG3, CARG4
    //|   mov CARG1, L
    //|  bhs >5
    //|1:
    dasm_put(Dst, 4251, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), Dt1(->base));
# 3349 "vm_arm.dasc"
    if (op == BC_TNEW) {
      //|  lsl CARG2, RC, #21
      //|   lsr CARG3, RC, #11
      //|  asr RC, CARG2, #21
      //|  lsr CARG2, CARG2, #21
      //|  cmn RC, #1
      //|  addeq CARG2, CARG2, #2
      //|  bl extern lj_tab_new  // (lua_State *L, int32_t asize, uint32_t hbits)
      //|  // Returns GCtab *.
      dasm_put(Dst, 4264);
# 3358 "vm_arm.dasc"
    } else {
      //|  ldr CARG2, [KBASE, RC, lsl #2]
      //|  bl extern lj_tab_dup  // (lua_State *L, Table *kt)
      //|  // Returns GCtab *.
      dasm_put(Dst, 4273);
# 3362 "vm_arm.dasc"
    }
    //|  ldr BASE, L->base
    //|  mvn CARG2, #~LJ_TTAB
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    //|5:
    //|  bl extern lj_gc_step_fixtop  // (lua_State *L)
    //|  mov CARG1, L
    //|  b <1
    dasm_put(Dst, 4277, Dt1(->base), ~LJ_TTAB);
# 3373 "vm_arm.dasc"
    break;

  case BC_GGET:
    //|  // RA = dst*8, RC = str_const (~)
  case BC_GSET:
    //|  // RA = dst*8, RC = str_const (~)
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   mvn RC, RC
    //|  ldr TAB:CARG1, LFUNC:CARG2->env
    //|   ldr STR:RC, [KBASE, RC, lsl #2]
    dasm_put(Dst, 4295, Dt7(->env));
# 3383 "vm_arm.dasc"
    if (op == BC_GGET) {
      //|  b ->BC_TGETS_Z
      dasm_put(Dst, 4301);
# 3385 "vm_arm.dasc"
    } else {
      //|  b ->BC_TSETS_Z
      dasm_put(Dst, 4304);
# 3387 "vm_arm.dasc"
    }
    break;

  case BC_TGETV:
    //|  decode_RB8 RB, INS
    //|   decode_RC8 RC, INS
    //|  // RA = dst*8, RB = table*8, RC = key*8
    //|  ldrd TAB:CARG12, [BASE, RB]
    //|   ldrd CARG34, [BASE, RC]
    //|  checktab CARG2, ->vmeta_tgetv  // STALL: load CARG12.
    //|   checktp CARG4, LJ_TISNUM	// Integer key?
    //|  ldreq CARG4, TAB:CARG1->array
    //|    ldreq CARG2, TAB:CARG1->asize
    //|   bne >9
    //|
    //|  add CARG4, CARG4, CARG3, lsl #3
    //|    cmp CARG3, CARG2		// In array part?
    //|  ldrdlo CARG34, [CARG4]
    //|    bhs ->vmeta_tgetv
    //|   ins_next1  // Overwrites RB!
    //|  checktp CARG4, LJ_TNIL
    //|  beq >5
    //|1:
    //|   ins_next2
    //|  strd CARG34, [BASE, RA]
    //|   ins_next3
    //|
    //|5:  // Check for __index if table value is nil.
    //|  ldr TAB:CARG2, TAB:CARG1->metatable
    //|  cmp TAB:CARG2, #0
    //|  beq <1				// No metatable: done.
    //|  ldrb CARG2, TAB:CARG2->nomm
    //|  tst CARG2, #1<<MM_index
    //|  bne <1				// 'no __index' flag set: done.
    //|  decode_RB8 RB, INS		// Restore RB.
    //|  b ->vmeta_tgetv
    //|
    //|9:
    //|  checktp CARG4, LJ_TSTR		// String key?
    //|   moveq STR:RC, CARG3
    //|  beq ->BC_TGETS_Z
    //|  b ->vmeta_tgetv
    dasm_put(Dst, 4307, -LJ_TTAB, -LJ_TISNUM, Dt6(->array), Dt6(->asize), -LJ_TNIL, Dt6(->metatable), Dt6(->nomm), 1<<MM_index, -LJ_TSTR);
# 3429 "vm_arm.dasc"
    break;
  case BC_TGETS:
    //|  decode_RB8 RB, INS
    //|   and RC, RC, #255
    //|  // RA = dst*8, RB = table*8, RC = str_const (~)
    //|  ldrd CARG12, [BASE, RB]
    //|   mvn RC, RC
    //|   ldr STR:RC, [KBASE, RC, lsl #2]  // STALL: early RC.
    //|  checktab CARG2, ->vmeta_tgets1
    //|->BC_TGETS_Z:
    //|  // (TAB:RB =) TAB:CARG1 = GCtab *, STR:RC = GCstr *, RA = dst*8
    //|  ldr CARG3, TAB:CARG1->hmask
    //|   ldr CARG4, STR:RC->hash
    //|    ldr NODE:INS, TAB:CARG1->node
    //|     mov TAB:RB, TAB:CARG1
    //|  and CARG3, CARG3, CARG4			// idx = str->hash & tab->hmask
    //|  add CARG3, CARG3, CARG3, lsl #1
    //|    add NODE:INS, NODE:INS, CARG3, lsl #3	// node = tab->node + idx*3*8
    //|1:
    //|  ldrd CARG12, NODE:INS->key  // STALL: early NODE:INS.
    //|   ldrd CARG34, NODE:INS->val
    //|    ldr NODE:INS, NODE:INS->next
    //|  checktp CARG2, LJ_TSTR
    //|  cmpeq CARG1, STR:RC
    //|  bne >4
    //|   checktp CARG4, LJ_TNIL
    //|   beq >5
    //|3:
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG34, [BASE, RA]
    //|   ins_next3
    //|
    //|4:  // Follow hash chain.
    //|  cmp NODE:INS, #0
    //|  bne <1
    //|  // End of hash chain: key not found, nil result.
    //|
    //|5:  // Check for __index if table value is nil.
    //|  ldr TAB:CARG1, TAB:RB->metatable
    //|   mov CARG3, #0  // Optional clear of undef. value (during load stall).
    //|   mvn CARG4, #~LJ_TNIL
    //|  cmp TAB:CARG1, #0
    //|  beq <3				// No metatable: done.
    //|  ldrb CARG2, TAB:CARG1->nomm
    //|  tst CARG2, #1<<MM_index
    dasm_put(Dst, 4364, -LJ_TTAB, Dt6(->hmask), Dt5(->hash), Dt6(->node), DtB(->key), DtB(->val), DtB(->next), -LJ_TSTR, -LJ_TNIL, Dt6(->metatable), ~LJ_TNIL, Dt6(->nomm));
# 3475 "vm_arm.dasc"
    //|  bne <3				// 'no __index' flag set: done.
    //|  b ->vmeta_tgets
    dasm_put(Dst, 4424, 1<<MM_index);
# 3477 "vm_arm.dasc"
    break;
  case BC_TGETB:
    //|  decode_RB8 RB, INS
    //|   and RC, RC, #255
    //|  // RA = dst*8, RB = table*8, RC = index
    //|  ldrd CARG12, [BASE, RB]
    //|  checktab CARG2, ->vmeta_tgetb  // STALL: load CARG12.
    //|   ldr CARG3, TAB:CARG1->asize
    //|  ldr CARG4, TAB:CARG1->array
    //|  lsl CARG2, RC, #3
    //|   cmp RC, CARG3
    //|  ldrdlo CARG34, [CARG4, CARG2]
    //|   bhs ->vmeta_tgetb
    //|   ins_next1  // Overwrites RB!
    //|  checktp CARG4, LJ_TNIL
    //|  beq >5
    //|1:
    //|   ins_next2
    //|  strd CARG34, [BASE, RA]
    //|   ins_next3
    //|
    //|5:  // Check for __index if table value is nil.
    //|  ldr TAB:CARG2, TAB:CARG1->metatable
    //|  cmp TAB:CARG2, #0
    //|  beq <1				// No metatable: done.
    //|  ldrb CARG2, TAB:CARG2->nomm
    //|  tst CARG2, #1<<MM_index
    //|  bne <1				// 'no __index' flag set: done.
    //|  b ->vmeta_tgetb
    dasm_put(Dst, 4431, -LJ_TTAB, Dt6(->asize), Dt6(->array), -LJ_TNIL, Dt6(->metatable), Dt6(->nomm), 1<<MM_index);
# 3506 "vm_arm.dasc"
    break;

  case BC_TSETV:
    //|  decode_RB8 RB, INS
    //|   decode_RC8 RC, INS
    //|  // RA = src*8, RB = table*8, RC = key*8
    //|  ldrd TAB:CARG12, [BASE, RB]
    //|   ldrd CARG34, [BASE, RC]
    //|  checktab CARG2, ->vmeta_tsetv  // STALL: load CARG12.
    //|   checktp CARG4, LJ_TISNUM	// Integer key?
    //|  ldreq CARG2, TAB:CARG1->array
    //|    ldreq CARG4, TAB:CARG1->asize
    //|   bne >9
    //|
    //|  add CARG2, CARG2, CARG3, lsl #3
    //|    cmp CARG3, CARG4		// In array part?
    //|  ldrlo INS, [CARG2, #4]
    //|    bhs ->vmeta_tsetv
    //|   ins_next1  // Overwrites RB!
    //|  checktp INS, LJ_TNIL
    //|  ldrb INS, TAB:CARG1->marked
    //|   ldrd CARG34, [BASE, RA]
    //|  beq >5
    //|1:
    //|  tst INS, #LJ_GC_BLACK		// isblack(table)
    //|   strd CARG34, [CARG2]
    //|  bne >7
    //|2:
    //|   ins_next2
    //|   ins_next3
    //|
    //|5:  // Check for __newindex if previous value is nil.
    //|  ldr TAB:RA, TAB:CARG1->metatable
    //|  cmp TAB:RA, #0
    //|  beq <1				// No metatable: done.
    //|  ldrb RA, TAB:RA->nomm
    //|  tst RA, #1<<MM_newindex
    //|  bne <1				// 'no __newindex' flag set: done.
    //|  ldr INS, [PC, #-4]		// Restore RA and RB.
    //|  decode_RB8 RB, INS
    //|  decode_RA8 RA, INS
    //|  b ->vmeta_tsetv
    //|
    //|7:  // Possible table write barrier for the value. Skip valiswhite check.
    //|  barrierback TAB:CARG1, INS, CARG3
    dasm_put(Dst, 4474, -LJ_TTAB, -LJ_TISNUM, Dt6(->array), Dt6(->asize), -LJ_TNIL, Dt6(->marked), LJ_GC_BLACK, Dt6(->metatable), Dt6(->nomm), 1<<MM_newindex);
# 3551 "vm_arm.dasc"
    //|  b <2
    //|
    //|9:
    //|  checktp CARG4, LJ_TSTR		// String key?
    //|   moveq STR:RC, CARG3
    //|  beq ->BC_TSETS_Z
    //|  b ->vmeta_tsetv
    dasm_put(Dst, 4534, DISPATCH_GL(gc.grayagain), LJ_GC_BLACK, DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist), -LJ_TSTR);
# 3558 "vm_arm.dasc"
    break;
  case BC_TSETS:
    //|  decode_RB8 RB, INS
    //|   and RC, RC, #255
    //|  // RA = src*8, RB = table*8, RC = str_const (~)
    //|  ldrd CARG12, [BASE, RB]
    //|   mvn RC, RC
    //|   ldr STR:RC, [KBASE, RC, lsl #2]  // STALL: early RC.
    //|  checktab CARG2, ->vmeta_tsets1
    //|->BC_TSETS_Z:
    //|  // (TAB:RB =) TAB:CARG1 = GCtab *, STR:RC = GCstr *, RA = dst*8
    //|  ldr CARG3, TAB:CARG1->hmask
    //|   ldr CARG4, STR:RC->hash
    //|    ldr NODE:INS, TAB:CARG1->node
    //|     mov TAB:RB, TAB:CARG1
    //|  and CARG3, CARG3, CARG4			// idx = str->hash & tab->hmask
    //|  add CARG3, CARG3, CARG3, lsl #1
    //|   mov CARG4, #0
    //|    add NODE:INS, NODE:INS, CARG3, lsl #3	// node = tab->node + idx*3*8
    //|   strb CARG4, TAB:RB->nomm		// Clear metamethod cache.
    //|1:
    //|  ldrd CARG12, NODE:INS->key
    //|   ldr CARG4, NODE:INS->val.it
    //|    ldr NODE:CARG3, NODE:INS->next
    //|  checktp CARG2, LJ_TSTR
    //|  cmpeq CARG1, STR:RC
    //|  bne >5
    //|  ldrb CARG2, TAB:RB->marked
    //|   checktp CARG4, LJ_TNIL		// Key found, but nil value?
    //|    ldrd CARG34, [BASE, RA]
    //|   beq >4
    //|2:
    //|  tst CARG2, #LJ_GC_BLACK		// isblack(table)
    //|    strd CARG34, NODE:INS->val
    //|  bne >7
    //|3:
    //|   ins_next
    //|
    //|4:  // Check for __newindex if previous value is nil.
    //|  ldr TAB:CARG1, TAB:RB->metatable
    dasm_put(Dst, 4555, -LJ_TTAB, Dt6(->hmask), Dt5(->hash), Dt6(->node), Dt6(->nomm), DtB(->key), DtB(->val.it), DtB(->next), -LJ_TSTR, Dt6(->marked), -LJ_TNIL, LJ_GC_BLACK, DtB(->val));
# 3598 "vm_arm.dasc"
    //|  cmp TAB:CARG1, #0
    //|  beq <2				// No metatable: done.
    //|  ldrb CARG1, TAB:CARG1->nomm
    //|  tst CARG1, #1<<MM_newindex
    //|  bne <2				// 'no __newindex' flag set: done.
    //|  b ->vmeta_tsets
    //|
    //|5:  // Follow hash chain.
    //|  movs NODE:INS, NODE:CARG3
    //|  bne <1
    //|  // End of hash chain: key not found, add a new one.
    //|
    //|  // But check for __newindex first.
    //|  ldr TAB:CARG1, TAB:RB->metatable
    //|   mov CARG3, TMPDp
    //|   str PC, SAVE_PC
    //|  cmp TAB:CARG1, #0		// No metatable: continue.
    //|   str BASE, L->base
    //|  ldrbne CARG2, TAB:CARG1->nomm
    //|   mov CARG1, L
    //|  beq >6
    //|  tst CARG2, #1<<MM_newindex
    //|  beq ->vmeta_tsets		// 'no __newindex' flag NOT set: check.
    //|6:
    //|  mvn CARG4, #~LJ_TSTR
    //|   str STR:RC, TMPDlo
    //|   mov CARG2, TAB:RB
    //|  str CARG4, TMPDhi
    //|  bl extern lj_tab_newkey		// (lua_State *L, GCtab *t, TValue *k)
    //|  // Returns TValue *.
    //|  ldr BASE, L->base
    //|  ldrd CARG34, [BASE, RA]
    //|  strd CARG34, [CRET1]
    //|  b <3				// No 2nd write barrier needed.
    //|
    //|7:  // Possible table write barrier for the value. Skip valiswhite check.
    //|  barrierback TAB:RB, CARG2, CARG3
    dasm_put(Dst, 4613, Dt6(->metatable), Dt6(->nomm), 1<<MM_newindex, Dt6(->metatable), Dt1(->base), Dt6(->nomm), 1<<MM_newindex, ~LJ_TSTR, Dt1(->base), DISPATCH_GL(gc.grayagain), LJ_GC_BLACK);
# 3635 "vm_arm.dasc"
    //|  b <3
    dasm_put(Dst, 4666, DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist));
# 3636 "vm_arm.dasc"
    break;
  case BC_TSETB:
    //|  decode_RB8 RB, INS
    //|   and RC, RC, #255
    //|  // RA = src*8, RB = table*8, RC = index
    //|  ldrd CARG12, [BASE, RB]
    //|  checktab CARG2, ->vmeta_tsetb  // STALL: load CARG12.
    //|   ldr CARG3, TAB:CARG1->asize
    //|  ldr RB, TAB:CARG1->array
    //|  lsl CARG2, RC, #3
    //|   cmp RC, CARG3
    //|  ldrdlo CARG34, [CARG2, RB]!
    //|   bhs ->vmeta_tsetb
    //|   ins_next1  // Overwrites RB!
    //|  checktp CARG4, LJ_TNIL
    //|  ldrb INS, TAB:CARG1->marked
    //|   ldrd CARG34, [BASE, RA]
    //|  beq >5
    //|1:
    //|  tst INS, #LJ_GC_BLACK		// isblack(table)
    //|    strd CARG34, [CARG2]
    //|  bne >7
    //|2:
    //|   ins_next2
    //|   ins_next3
    //|
    //|5:  // Check for __newindex if previous value is nil.
    //|  ldr TAB:RA, TAB:CARG1->metatable
    //|  cmp TAB:RA, #0
    //|  beq <1				// No metatable: done.
    //|  ldrb RA, TAB:RA->nomm
    //|  tst RA, #1<<MM_newindex
    //|  bne <1				// 'no __newindex' flag set: done.
    //|  ldr INS, [PC, #-4]		// Restore INS.
    //|  decode_RA8 RA, INS
    //|  b ->vmeta_tsetb
    //|
    //|7:  // Possible table write barrier for the value. Skip valiswhite check.
    //|  barrierback TAB:CARG1, INS, CARG3
    dasm_put(Dst, 4675, -LJ_TTAB, Dt6(->asize), Dt6(->array), -LJ_TNIL, Dt6(->marked), LJ_GC_BLACK, Dt6(->metatable), Dt6(->nomm), 1<<MM_newindex, DISPATCH_GL(gc.grayagain), LJ_GC_BLACK);
# 3675 "vm_arm.dasc"
    //|  b <2
    dasm_put(Dst, 4733, DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist));
# 3676 "vm_arm.dasc"
    break;

  case BC_TSETM:
    //|  // RA = base*8 (table at base-1), RC = num_const (start index)
    //|  add RA, BASE, RA
    //|1:
    //|   ldr RB, SAVE_MULTRES
    //|  ldr TAB:CARG2, [RA, #-8]		// Guaranteed to be a table.
    //|  ldr CARG1, [KBASE, RC, lsl #3]	// Integer constant is in lo-word.
    //|   subs RB, RB, #8
    //|  ldr CARG4, TAB:CARG2->asize
    //|   beq >4				// Nothing to copy?
    //|  add CARG3, CARG1, RB, lsr #3
    //|  cmp CARG3, CARG4
    //|   ldr CARG4, TAB:CARG2->array
    //|    add RB, RA, RB
    //|  bhi >5
    //|   add INS, CARG4, CARG1, lsl #3
    //|    ldrb CARG1, TAB:CARG2->marked
    //|3:  // Copy result slots to table.
    //|   ldrd CARG34, [RA], #8
    //|   strd CARG34, [INS], #8
    //|  cmp RA, RB
    //|  blo <3
    //|    tst CARG1, #LJ_GC_BLACK	// isblack(table)
    //|    bne >7
    //|4:
    //|  ins_next
    //|
    //|5:  // Need to resize array part.
    //|   str BASE, L->base
    //|  mov CARG1, L
    //|   str PC, SAVE_PC
    //|  bl extern lj_tab_reasize		// (lua_State *L, GCtab *t, int nasize)
    //|  // Must not reallocate the stack.
    //|  .IOS ldr BASE, L->base
    //|  b <1
    //|
    //|7:  // Possible table write barrier for any value. Skip valiswhite check.
    //|  barrierback TAB:CARG2, CARG1, CARG3
    //|  b <4
    dasm_put(Dst, 4742, Dt6(->asize), Dt6(->array), Dt6(->marked), LJ_GC_BLACK, Dt1(->base), DISPATCH_GL(gc.grayagain), LJ_GC_BLACK, DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist));
# 3717 "vm_arm.dasc"
    break;

  /* -- Calls and vararg handling ----------------------------------------- */

  case BC_CALLM:
    //|  // RA = base*8, (RB = nresults+1,) RC = extra_nargs
    //|  ldr CARG1, SAVE_MULTRES
    //|  decode_RC8 NARGS8:RC, INS
    //|  add NARGS8:RC, NARGS8:RC, CARG1
    //|  b ->BC_CALL_Z
    dasm_put(Dst, 4802);
# 3727 "vm_arm.dasc"
    break;
  case BC_CALL:
    //|  decode_RC8 NARGS8:RC, INS
    //|  // RA = base*8, (RB = nresults+1,) RC = (nargs+1)*8
    //|->BC_CALL_Z:
    //|  mov RB, BASE			// Save old BASE for vmeta_call.
    //|  ldrd CARG34, [BASE, RA]!
    //|   sub NARGS8:RC, NARGS8:RC, #8
    //|   add BASE, BASE, #8
    //|  checkfunc CARG4, ->vmeta_call
    //|  ins_call
    dasm_put(Dst, 4808, -LJ_TFUNC, Dt7(->field_pc));
# 3738 "vm_arm.dasc"
    break;

  case BC_CALLMT:
    //|  // RA = base*8, (RB = 0,) RC = extra_nargs
    //|  ldr CARG1, SAVE_MULTRES
    //|  add NARGS8:RC, CARG1, RC, lsl #3
    //|  b ->BC_CALLT1_Z
    dasm_put(Dst, 4828);
# 3745 "vm_arm.dasc"
    break;
  case BC_CALLT:
    //|  lsl NARGS8:RC, RC, #3
    //|  // RA = base*8, (RB = 0,) RC = (nargs+1)*8
    //|->BC_CALLT1_Z:
    //|  ldrd LFUNC:CARG34, [RA, BASE]!
    //|   sub NARGS8:RC, NARGS8:RC, #8
    //|   add RA, RA, #8
    //|  checkfunc CARG4, ->vmeta_callt
    //|  ldr PC, [BASE, FRAME_PC]
    //|->BC_CALLT2_Z:
    //|   mov RB, #0
    //|   ldrb CARG4, LFUNC:CARG3->ffid
    //|  tst PC, #FRAME_TYPE
    //|  bne >7
    //|1:
    //|  str LFUNC:CARG3, [BASE, FRAME_FUNC]  // Copy function down, but keep PC.
    //|  cmp NARGS8:RC, #0
    //|  beq >3
    //|2:
    //|  ldrd CARG12, [RA, RB]
    //|   add INS, RB, #8
    //|   cmp INS, NARGS8:RC
    //|  strd CARG12, [BASE, RB]
    //|    mov RB, INS
    //|   bne <2
    //|3:
    //|  cmp CARG4, #1			// (> FF_C) Calling a fast function?
    //|  bhi >5
    //|4:
    //|  ins_callt
    //|
    //|5:  // Tailcall to a fast function with a Lua frame below.
    //|  ldr INS, [PC, #-4]
    //|  decode_RA8 RA, INS
    //|  sub CARG1, BASE, RA
    //|  ldr LFUNC:CARG1, [CARG1, #-16]
    //|  ldr CARG1, LFUNC:CARG1->field_pc
    //|  ldr KBASE, [CARG1, #PC2PROTO(k)]
    //|  b <4
    //|
    //|7:  // Tailcall from a vararg function.
    //|  eor PC, PC, #FRAME_VARG
    //|  tst PC, #FRAME_TYPEP		// Vararg frame below?
    //|  movne CARG4, #0			// Clear ffid if no Lua function below.
    dasm_put(Dst, 4833, -LJ_TFUNC, Dt7(->ffid), FRAME_TYPE, Dt7(->field_pc), Dt7(->field_pc), PC2PROTO(k), FRAME_VARG, FRAME_TYPEP);
# 3790 "vm_arm.dasc"
    //|  bne <1
    //|  sub BASE, BASE, PC
    //|  ldr PC, [BASE, FRAME_PC]
    //|  tst PC, #FRAME_TYPE
    //|  movne CARG4, #0			// Clear ffid if no Lua function below.
    //|  b <1
    dasm_put(Dst, 4894, FRAME_TYPE);
# 3796 "vm_arm.dasc"
    break;

  case BC_ITERC:
    //|  // RA = base*8, (RB = nresults+1, RC = nargs+1 (2+1))
    //|  add RA, BASE, RA
    //|   mov RB, BASE			// Save old BASE for vmeta_call.
    //|  ldrd CARG34, [RA, #-16]
    //|   ldrd CARG12, [RA, #-8]
    //|    add BASE, RA, #8
    //|  strd CARG34, [RA, #8]		// Copy state.
    //|   strd CARG12, [RA, #16]		// Copy control var.
    //|  // STALL: locked CARG34.
    //|  ldrd LFUNC:CARG34, [RA, #-24]
    //|    mov NARGS8:RC, #16		// Iterators get 2 arguments.
    //|  // STALL: load CARG34.
    //|  strd LFUNC:CARG34, [RA]		// Copy callable.
    //|  checkfunc CARG4, ->vmeta_call
    //|  ins_call
    dasm_put(Dst, 4905, -LJ_TFUNC, Dt7(->field_pc));
# 3814 "vm_arm.dasc"
    break;

  case BC_ITERN:
    //|  // RA = base*8, (RB = nresults+1, RC = nargs+1 (2+1))
    //|.if JIT
    //|  // NYI: add hotloop, record BC_ITERN.
    //|.endif
    //|  add RA, BASE, RA
    //|  ldr TAB:RB, [RA, #-16]
    //|  ldr CARG1, [RA, #-8]		// Get index from control var.
    //|  ldr INS, TAB:RB->asize
    //|   ldr CARG2, TAB:RB->array
    //|    add PC, PC, #4
    //|1:  // Traverse array part.
    //|  subs RC, CARG1, INS
    //|   add CARG3, CARG2, CARG1, lsl #3
    //|  bhs >5				// Index points after array part?
    //|   ldrd CARG34, [CARG3]
    //|   checktp CARG4, LJ_TNIL
    //|   addeq CARG1, CARG1, #1		// Skip holes in array part.
    //|   beq <1
    //|  ldrh RC, [PC, #-2]
    //|   mvn CARG2, #~LJ_TISNUM
    //|    strd CARG34, [RA, #8]
    //|  add RC, PC, RC, lsl #2
    //|    add RB, CARG1, #1
    //|   strd CARG12, [RA]
    //|  sub PC, RC, #0x20000
    //|    str RB, [RA, #-8]		// Update control var.
    //|3:
    //|  ins_next
    //|
    //|5:  // Traverse hash part.
    //|  ldr CARG4, TAB:RB->hmask
    //|   ldr NODE:RB, TAB:RB->node
    //|6:
    //|   add CARG1, RC, RC, lsl #1
    //|  cmp RC, CARG4			// End of iteration? Branch to ITERL+1.
    //|   add NODE:CARG3, NODE:RB, CARG1, lsl #3  // node = tab->node + idx*3*8
    //|  bhi <3
    //|   ldrd CARG12, NODE:CARG3->val
    //|   checktp CARG2, LJ_TNIL
    //|   add RC, RC, #1
    //|   beq <6				// Skip holes in hash part.
    //|  ldrh RB, [PC, #-2]
    //|   add RC, RC, INS
    //|    ldrd CARG34, NODE:CARG3->key
    //|   str RC, [RA, #-8]		// Update control var.
    //|   strd CARG12, [RA, #8]
    //|  add RC, PC, RB, lsl #2
    //|  sub PC, RC, #0x20000
    //|    strd CARG34, [RA]
    //|  b <3
    dasm_put(Dst, 4929, Dt6(->asize), Dt6(->array), -LJ_TNIL, ~LJ_TISNUM, Dt6(->hmask), Dt6(->node), DtB(->val), -LJ_TNIL, DtB(->key));
# 3867 "vm_arm.dasc"
    break;

  case BC_ISNEXT:
    //|  // RA = base*8, RC = target (points to ITERN)
    //|  add RA, BASE, RA
    //|     add RC, PC, RC, lsl #2
    //|  ldrd CFUNC:CARG12, [RA, #-24]
    //|   ldr CARG3, [RA, #-12]
    //|    ldr CARG4, [RA, #-4]
    //|  checktp CARG2, LJ_TFUNC
    //|  ldrbeq CARG1, CFUNC:CARG1->ffid
    //|   checktpeq CARG3, LJ_TTAB
    //|    checktpeq CARG4, LJ_TNIL
    //|  cmpeq CARG1, #FF_next_N
    //|     subeq PC, RC, #0x20000
    //|  bne >5
    //|   ins_next1
    //|   ins_next2
    //|  mov CARG1, #0
    //|  mvn CARG2, #0x00018000
    //|  strd CARG1, [RA, #-8]		// Initialize control var.
    //|1:
    //|   ins_next3
    //|5:  // Despecialize bytecode if any of the checks fail.
    //|  mov CARG1, #BC_JMP
    //|   mov OP, #BC_ITERC
    //|  strb CARG1, [PC, #-4]
    //|   sub PC, RC, #0x20000
    //|   strb OP, [PC]			// Subsumes ins_next1.
    //|   ins_next2
    //|  b <1
    dasm_put(Dst, 4994, -LJ_TFUNC, Dt8(->ffid), -LJ_TTAB, -LJ_TNIL, FF_next_N, BC_JMP, BC_ITERC);
# 3898 "vm_arm.dasc"
    break;

  case BC_VARG:
    //|  decode_RB8 RB, INS
    //|   decode_RC8 RC, INS
    //|  // RA = base*8, RB = (nresults+1)*8, RC = numparams*8
    //|  ldr CARG1, [BASE, FRAME_PC]
    //|  add RC, BASE, RC
    //|   add RA, BASE, RA
    //|  add RC, RC, #FRAME_VARG
    //|   add CARG4, RA, RB
    //|  sub CARG3, BASE, #8		// CARG3 = vtop
    //|  sub RC, RC, CARG1		// RC = vbase
    //|  // Note: RC may now be even _above_ BASE if nargs was < numparams.
    //|  cmp RB, #0
    //|   sub CARG1, CARG3, RC
    //|  beq >5				// Copy all varargs?
    //|   sub CARG4, CARG4, #16
    //|1:  // Copy vararg slots to destination slots.
    //|  cmp RC, CARG3
    //|  ldrdlo CARG12, [RC], #8
    //|  mvnhs CARG2, #~LJ_TNIL
    //|   cmp RA, CARG4
    //|  strd CARG12, [RA], #8
    //|   blo <1
    //|2:
    //|  ins_next
    //|
    //|5:  // Copy all varargs.
    //|  ldr CARG4, L->maxstack
    //|   cmp CARG1, #0
    //|   movle RB, #8			// MULTRES = (0+1)*8
    //|   addgt RB, CARG1, #8
    //|  add CARG2, RA, CARG1
    //|   str RB, SAVE_MULTRES
    //|   ble <2
    //|  cmp CARG2, CARG4
    //|  bhi >7
    //|6:
    //|   ldrd CARG12, [RC], #8
    //|   strd CARG12, [RA], #8
    //|  cmp RC, CARG3
    //|  blo <6
    //|  b <2
    //|
    //|7:  // Grow stack for varargs.
    //|  lsr CARG2, CARG1, #3
    //|   str RA, L->top
    //|  mov CARG1, L
    //|   str BASE, L->base
    //|  sub RC, RC, BASE			// Need delta, because BASE may change.
    //|   str PC, SAVE_PC
    //|  sub RA, RA, BASE
    //|  bl extern lj_state_growstack	// (lua_State *L, int n)
    //|  ldr BASE, L->base
    //|  add RA, BASE, RA
    //|  add RC, BASE, RC
    //|  sub CARG3, BASE, #8
    //|  b <6
    dasm_put(Dst, 5034, FRAME_VARG, ~LJ_TNIL, Dt1(->maxstack), Dt1(->top), Dt1(->base), Dt1(->base));
# 3957 "vm_arm.dasc"
    break;

  /* -- Returns ----------------------------------------------------------- */

  case BC_RETM:
    //|  // RA = results*8, RC = extra results
    //|  ldr CARG1, SAVE_MULTRES
    //|   ldr PC, [BASE, FRAME_PC]
    //|    add RA, BASE, RA
    //|  add RC, CARG1, RC, lsl #3
    //|  b ->BC_RETM_Z
    dasm_put(Dst, 5106);
# 3968 "vm_arm.dasc"
    break;

  case BC_RET:
    //|  // RA = results*8, RC = nresults+1
    //|  ldr PC, [BASE, FRAME_PC]
    //|   lsl RC, RC, #3
    //|    add RA, BASE, RA
    //|->BC_RETM_Z:
    //|   str RC, SAVE_MULTRES
    //|1:
    //|  ands CARG1, PC, #FRAME_TYPE
    //|   eor CARG2, PC, #FRAME_VARG
    //|  bne ->BC_RETV2_Z
    //|
    //|->BC_RET_Z:
    //|  // BASE = base, RA = resultptr, RC = (nresults+1)*8, PC = return
    //|  ldr INS, [PC, #-4]
    //|  subs CARG4, RC, #8
    //|   sub CARG3, BASE, #8
    //|  beq >3
    //|2:
    //|  ldrd CARG12, [RA], #8
    //|   add BASE, BASE, #8
    //|   subs CARG4, CARG4, #8
    //|  strd CARG12, [BASE, #-16]
    //|   bne <2
    //|3:
    //|  decode_RA8 RA, INS
    //|  sub CARG4, CARG3, RA
    //|   decode_RB8 RB, INS
    //|  ldr LFUNC:CARG1, [CARG4, FRAME_FUNC]
    //|5:
    //|  cmp RB, RC			// More results expected?
    //|  bhi >6
    //|  mov BASE, CARG4
    //|  ldr CARG2, LFUNC:CARG1->field_pc
    //|   ins_next1
    //|   ins_next2
    //|  ldr KBASE, [CARG2, #PC2PROTO(k)]
    //|   ins_next3
    //|
    //|6:  // Fill up results with nil.
    //|  mvn CARG2, #~LJ_TNIL
    //|  add BASE, BASE, #8
    //|   add RC, RC, #8
    //|  str CARG2, [BASE, #-12]
    //|  b <5
    //|
    //|->BC_RETV1_Z:  // Non-standard return case.
    //|  add RA, BASE, RA
    //|->BC_RETV2_Z:
    //|  tst CARG2, #FRAME_TYPEP
    //|  bne ->vm_return
    //|  // Return from vararg function: relocate BASE down.
    //|  sub BASE, BASE, CARG2
    //|  ldr PC, [BASE, FRAME_PC]
    //|  b <1
    dasm_put(Dst, 5113, FRAME_TYPE, FRAME_VARG, Dt7(->field_pc), PC2PROTO(k), ~LJ_TNIL, FRAME_TYPEP);
# 4025 "vm_arm.dasc"
    break;

  case BC_RET0: case BC_RET1:
    //|  // RA = results*8, RC = nresults+1
    //|  ldr PC, [BASE, FRAME_PC]
    //|   lsl RC, RC, #3
    //|   str RC, SAVE_MULTRES
    //|  ands CARG1, PC, #FRAME_TYPE
    //|   eor CARG2, PC, #FRAME_VARG
    //|   ldreq INS, [PC, #-4]
    //|  bne ->BC_RETV1_Z
    dasm_put(Dst, 5178, FRAME_TYPE, FRAME_VARG);
# 4036 "vm_arm.dasc"
    if (op == BC_RET1) {
      //|  ldrd CARG12, [BASE, RA]
      dasm_put(Dst, 5189);
# 4038 "vm_arm.dasc"
    }
    //|  sub CARG4, BASE, #8
    //|   decode_RA8 RA, INS
    dasm_put(Dst, 5191);
# 4041 "vm_arm.dasc"
    if (op == BC_RET1) {
      //|  strd CARG12, [CARG4]
      dasm_put(Dst, 5194);
# 4043 "vm_arm.dasc"
    }
    //|  sub BASE, CARG4, RA
    //|   decode_RB8 RB, INS
    //|  ldr LFUNC:CARG1, [BASE, FRAME_FUNC]
    //|5:
    //|  cmp RB, RC
    //|  bhi >6
    //|  ldr CARG2, LFUNC:CARG1->field_pc
    //|   ins_next1
    //|   ins_next2
    //|  ldr KBASE, [CARG2, #PC2PROTO(k)]
    //|   ins_next3
    //|
    //|6:  // Fill up results with nil.
    //|  sub CARG2, CARG4, #4
    //|  mvn CARG3, #~LJ_TNIL
    //|  str CARG3, [CARG2, RC]
    //|  add RC, RC, #8
    //|  b <5
    dasm_put(Dst, 5196, Dt7(->field_pc), PC2PROTO(k), ~LJ_TNIL);
# 4062 "vm_arm.dasc"
    break;

  /* -- Loops and branches ------------------------------------------------ */

  //|.define FOR_IDX,  [RA];      .define FOR_TIDX,  [RA, #4]
  //|.define FOR_STOP, [RA, #8];  .define FOR_TSTOP, [RA, #12]
  //|.define FOR_STEP, [RA, #16]; .define FOR_TSTEP, [RA, #20]
  //|.define FOR_EXT,  [RA, #24]; .define FOR_TEXT,  [RA, #28]

  case BC_FORL:
    //|.if JIT
    //|  hotloop
    //|.endif
    //|  // Fall through. Assumes BC_IFORL follows.
    dasm_put(Dst, 5222, -GG_DISP2HOT, HOTCOUNT_LOOP);
# 4076 "vm_arm.dasc"
    break;

  case BC_JFORI:
  case BC_JFORL:
#if !LJ_HASJIT
    break;
#endif
  case BC_FORI:
  case BC_IFORL:
    //|  // RA = base*8, RC = target (after end of loop or start of loop)
    vk = (op == BC_IFORL || op == BC_JFORL);
    //|  ldrd CARG12, [RA, BASE]!
    dasm_put(Dst, 5233);
# 4088 "vm_arm.dasc"
    if (op != BC_JFORL) {
      //|   add RC, PC, RC, lsl #2
      dasm_put(Dst, 5235);
# 4090 "vm_arm.dasc"
    }
    if (!vk) {
      //|  ldrd CARG34, FOR_STOP
      //|   checktp CARG2, LJ_TISNUM
      //|  ldr RB, FOR_TSTEP
      //|   bne >5
      //|  checktp CARG4, LJ_TISNUM
      //|   ldr CARG4, FOR_STEP
      //|  checktpeq RB, LJ_TISNUM
      //|  bne ->vmeta_for
      //|  cmp CARG4, #0
      //|  blt >4
      //|  cmp CARG1, CARG3
      dasm_put(Dst, 5237, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM);
# 4103 "vm_arm.dasc"
    } else {
      //|  ldrd CARG34, FOR_STEP
      //|   checktp CARG2, LJ_TISNUM
      //|   bne >5
      //|  adds CARG1, CARG1, CARG3
      //|   ldr CARG4, FOR_STOP
      dasm_put(Dst, 5255, -LJ_TISNUM);
# 4109 "vm_arm.dasc"
      if (op == BC_IFORL) {
	//|  addvs RC, PC, #0x20000		// Overflow: prevent branch.
	dasm_put(Dst, 5263);
# 4111 "vm_arm.dasc"
      } else {
	//|  bvs >2				// Overflow: do not enter mcode.
	dasm_put(Dst, 5265);
# 4113 "vm_arm.dasc"
      }
      //|  cmp CARG3, #0
      //|  blt >4
      //|  cmp CARG1, CARG4
      dasm_put(Dst, 5268);
# 4117 "vm_arm.dasc"
    }
    //|1:
    dasm_put(Dst, 5273);
# 4119 "vm_arm.dasc"
    if (op == BC_FORI) {
      //|  subgt PC, RC, #0x20000
      dasm_put(Dst, 5275);
# 4121 "vm_arm.dasc"
    } else if (op == BC_JFORI) {
      //|  sub PC, RC, #0x20000
      //|  ldrhle RC, [PC, #-2]
      dasm_put(Dst, 5277);
# 4124 "vm_arm.dasc"
    } else if (op == BC_IFORL) {
      //|  suble PC, RC, #0x20000
      dasm_put(Dst, 5280);
# 4126 "vm_arm.dasc"
    }
    if (vk) {
      //|  strd CARG12, FOR_IDX
      dasm_put(Dst, 5282);
# 4129 "vm_arm.dasc"
    }
    //|2:
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG12, FOR_EXT
    dasm_put(Dst, 5284);
# 4134 "vm_arm.dasc"
    if (op == BC_JFORI || op == BC_JFORL) {
      //|  ble =>BC_JLOOP
      dasm_put(Dst, 5289, BC_JLOOP);
# 4136 "vm_arm.dasc"
    }
    //|3:
    //|   ins_next3
    //|
    //|4:  // Invert check for negative step.
    dasm_put(Dst, 5292);
# 4141 "vm_arm.dasc"
    if (!vk) {
      //|  cmp CARG3, CARG1
      dasm_put(Dst, 5299);
# 4143 "vm_arm.dasc"
    } else {
      //|  cmp CARG4, CARG1
      dasm_put(Dst, 5301);
# 4145 "vm_arm.dasc"
    }
    //|  b <1
    //|
    //|5:  // FP loop.
    dasm_put(Dst, 5303);
# 4149 "vm_arm.dasc"
    if (!vk) {
      //|  cmnlo CARG4, #-LJ_TISNUM
      //|  cmnlo RB, #-LJ_TISNUM
      //|  bhs ->vmeta_for
      //|.if FPU
      //|  vldr d0, FOR_IDX
      //|  vldr d1, FOR_STOP
      //|  cmp RB, #0
      //|  vstr d0, FOR_EXT
      //|.else
      //|  cmp RB, #0
      //|   strd CARG12, FOR_EXT
      //|  blt >8
      //|.endif
      dasm_put(Dst, 5307, -LJ_TISNUM, -LJ_TISNUM);
# 4163 "vm_arm.dasc"
    } else {
      //|.if FPU
      //|  vldr d0, FOR_IDX
      //|  vldr d2, FOR_STEP
      //|  vldr d1, FOR_STOP
      //|  cmp CARG4, #0
      //|  vadd.f64 d0, d0, d2
      //|.else
      //|  cmp CARG4, #0
      //|  blt >8
      //|  bl extern __aeabi_dadd
      //|   strd CARG12, FOR_IDX
      //|  ldrd CARG34, FOR_STOP
      //|   strd CARG12, FOR_EXT
      //|.endif
      dasm_put(Dst, 5318);
# 4178 "vm_arm.dasc"
    }
    //|6:
    //|.if FPU
    //|  vcmpge.f64 d0, d1
    //|  vcmplt.f64 d1, d0
    //|  vmrs
    //|.else
    //|  bl extern __aeabi_cdcmple
    //|.endif
    dasm_put(Dst, 5324);
# 4187 "vm_arm.dasc"
    if (vk) {
      //|.if FPU
      //|  vstr d0, FOR_IDX
      //|  vstr d0, FOR_EXT
      //|.endif
      dasm_put(Dst, 5329);
# 4192 "vm_arm.dasc"
    }
    if (op == BC_FORI) {
      //|  subhi PC, RC, #0x20000
      dasm_put(Dst, 5332);
# 4195 "vm_arm.dasc"
    } else if (op == BC_JFORI) {
      //|  sub PC, RC, #0x20000
      //|  ldrhls RC, [PC, #-2]
      //|  bls =>BC_JLOOP
      dasm_put(Dst, 5334, BC_JLOOP);
# 4199 "vm_arm.dasc"
    } else if (op == BC_IFORL) {
      //|  subls PC, RC, #0x20000
      dasm_put(Dst, 5339);
# 4201 "vm_arm.dasc"
    } else {
      //|  bls =>BC_JLOOP
      dasm_put(Dst, 5341, BC_JLOOP);
# 4203 "vm_arm.dasc"
    }
    //|  ins_next1
    //|  ins_next2
    //|  b <3
    //|
    //|.if not FPU
    //|8:  // Invert check for negative step.
    dasm_put(Dst, 5344);
# 4210 "vm_arm.dasc"
    if (vk) {
      //|  bl extern __aeabi_dadd
      //|  strd CARG12, FOR_IDX
      //|  strd CARG12, FOR_EXT
    }
    //|  mov CARG3, CARG1
    //|  mov CARG4, CARG2
    //|  ldrd CARG12, FOR_STOP
    //|  b <6
    //|.endif
    break;

  case BC_ITERL:
    //|.if JIT
    //|  hotloop
    //|.endif
    //|  // Fall through. Assumes BC_IITERL follows.
    dasm_put(Dst, 5349, -GG_DISP2HOT, HOTCOUNT_LOOP);
# 4227 "vm_arm.dasc"
    break;

  case BC_JITERL:
#if !LJ_HASJIT
    break;
#endif
  case BC_IITERL:
    //|  // RA = base*8, RC = target
    //|  ldrd CARG12, [RA, BASE]!
    dasm_put(Dst, 5360);
# 4236 "vm_arm.dasc"
    if (op == BC_JITERL) {
      //|  cmn CARG2, #-LJ_TNIL		// Stop if iterator returned nil.
      //|  strdne CARG12, [RA, #-8]
      //|  bne =>BC_JLOOP
      dasm_put(Dst, 5362, -LJ_TNIL, BC_JLOOP);
# 4240 "vm_arm.dasc"
    } else {
      //|   add RC, PC, RC, lsl #2
      //|  // STALL: load CARG12.
      //|  cmn CARG2, #-LJ_TNIL		// Stop if iterator returned nil.
      //|  subne PC, RC, #0x20000		// Otherwise save control var + branch.
      //|  strdne CARG12, [RA, #-8]
      dasm_put(Dst, 5368, -LJ_TNIL);
# 4246 "vm_arm.dasc"
    }
    //|  ins_next
    dasm_put(Dst, 5374);
# 4248 "vm_arm.dasc"
    break;

  case BC_LOOP:
    //|  // RA = base*8, RC = target (loop extent)
    //|  // Note: RA/RC is only used by trace recorder to determine scope/extent
    //|  // This opcode does NOT jump, it's only purpose is to detect a hot loop.
    //|.if JIT
    //|  hotloop
    //|.endif
    //|  // Fall through. Assumes BC_ILOOP follows.
    dasm_put(Dst, 5381, -GG_DISP2HOT, HOTCOUNT_LOOP);
# 4258 "vm_arm.dasc"
    break;

  case BC_ILOOP:
    //|  // RA = base*8, RC = target (loop extent)
    //|  ins_next
    dasm_put(Dst, 5392);
# 4263 "vm_arm.dasc"
    break;

  case BC_JLOOP:
    //|.if JIT
    //|  // RA = base (ignored), RC = traceno
    //|  ldr CARG1, [DISPATCH, #DISPATCH_J(trace)]
    //|   mov CARG2, #0  // Traces on ARM don't store the trace number, so use 0.
    //|  ldr TRACE:RC, [CARG1, RC, lsl #2]
    //|   st_vmstate CARG2
    //|  ldr RA, TRACE:RC->mcode
    //|   str BASE, [DISPATCH, #DISPATCH_GL(jit_base)]
    //|   str L, [DISPATCH, #DISPATCH_GL(jit_L)]
    //|  bx RA
    //|.endif
    dasm_put(Dst, 5399, DISPATCH_J(trace), DISPATCH_GL(vmstate), DtD(->mcode), DISPATCH_GL(jit_base), DISPATCH_GL(jit_L));
# 4277 "vm_arm.dasc"
    break;

  case BC_JMP:
    //|  // RA = base*8 (only used by trace recorder), RC = target
    //|  add RC, PC, RC, lsl #2
    //|  sub PC, RC, #0x20000
    //|  ins_next
    dasm_put(Dst, 5413);
# 4284 "vm_arm.dasc"
    break;

  /* -- Function headers -------------------------------------------------- */

  case BC_FUNCF:
    //|.if JIT
    //|  hotcall
    //|.endif
    dasm_put(Dst, 5422, -GG_DISP2HOT, HOTCOUNT_CALL);
# 4292 "vm_arm.dasc"
  case BC_FUNCV:  /* NYI: compiled vararg functions. */
    //|  // Fall through. Assumes BC_IFUNCF/BC_IFUNCV follow.
    break;

  case BC_JFUNCF:
#if !LJ_HASJIT
    break;
#endif
  case BC_IFUNCF:
    //|  // BASE = new base, RA = BASE+framesize*8, CARG3 = LFUNC, RC = nargs*8
    //|  ldr CARG1, L->maxstack
    //|   ldrb CARG2, [PC, #-4+PC2PROTO(numparams)]
    //|    ldr KBASE, [PC, #-4+PC2PROTO(k)]
    //|  cmp RA, CARG1
    //|  bhi ->vm_growstack_l
    dasm_put(Dst, 5433, Dt1(->maxstack), -4+PC2PROTO(numparams), -4+PC2PROTO(k));
# 4307 "vm_arm.dasc"
    if (op != BC_JFUNCF) {
      //|  ins_next1
      //|  ins_next2
      dasm_put(Dst, 5443);
# 4310 "vm_arm.dasc"
    }
    //|2:
    //|  cmp NARGS8:RC, CARG2, lsl #3	// Check for missing parameters.
    //|   mvn CARG4, #~LJ_TNIL
    //|  blo >3
    dasm_put(Dst, 5446, ~LJ_TNIL);
# 4315 "vm_arm.dasc"
    if (op == BC_JFUNCF) {
      //|  decode_RD RC, INS
      //|  b =>BC_JLOOP
      dasm_put(Dst, 5453, BC_JLOOP);
# 4318 "vm_arm.dasc"
    } else {
      //|  ins_next3
      dasm_put(Dst, 5457);
# 4320 "vm_arm.dasc"
    }
    //|
    //|3:  // Clear missing parameters.
    //|  strd CARG34, [BASE, NARGS8:RC]
    //|  add NARGS8:RC, NARGS8:RC, #8
    //|  b <2
    dasm_put(Dst, 5462);
# 4326 "vm_arm.dasc"
    break;

  case BC_JFUNCV:
#if !LJ_HASJIT
    break;
#endif
    //|  NYI  // NYI: compiled vararg functions
    dasm_put(Dst, 5468);
# 4333 "vm_arm.dasc"
    break;  /* NYI: compiled vararg functions. */

  case BC_IFUNCV:
    //|  // BASE = new base, RA = BASE+framesize*8, CARG3 = LFUNC, RC = nargs*8
    //|  ldr CARG1, L->maxstack
    //|   add CARG4, BASE, RC
    //|  add RA, RA, RC
    //|   str LFUNC:CARG3, [CARG4]	// Store copy of LFUNC.
    //|   add CARG2, RC, #8+FRAME_VARG
    //|    ldr KBASE, [PC, #-4+PC2PROTO(k)]
    //|  cmp RA, CARG1
    //|   str CARG2, [CARG4, #4]		// Store delta + FRAME_VARG.
    //|  bhs ->vm_growstack_l
    //|  ldrb RB, [PC, #-4+PC2PROTO(numparams)]
    //|   mov RA, BASE
    //|   mov RC, CARG4
    //|  cmp RB, #0
    //|   add BASE, CARG4, #8
    //|  beq >3
    //|  mvn CARG3, #~LJ_TNIL
    //|1:
    //|  cmp RA, RC			// Less args than parameters?
    //|   ldrdlo CARG12, [RA], #8
    //|   movhs CARG2, CARG3
    //|    strlo CARG3, [RA, #-4]		// Clear old fixarg slot (help the GC).
    //|2:
    //|  subs RB, RB, #1
    //|   strd CARG12, [CARG4, #8]!
    //|  bne <1
    //|3:
    //|  ins_next
    dasm_put(Dst, 5470, Dt1(->maxstack), 8+FRAME_VARG, -4+PC2PROTO(k), -4+PC2PROTO(numparams), ~LJ_TNIL);
# 4364 "vm_arm.dasc"
    break;

  case BC_FUNCC:
  case BC_FUNCCW:
    //|  // BASE = new base, RA = BASE+framesize*8, CARG3 = CFUNC, RC = nargs*8
    if (op == BC_FUNCC) {
      //|  ldr CARG4, CFUNC:CARG3->f
      dasm_put(Dst, 5511, Dt8(->f));
# 4371 "vm_arm.dasc"
    } else {
      //|  ldr CARG4, [DISPATCH, #DISPATCH_GL(wrapf)]
      dasm_put(Dst, 5514, DISPATCH_GL(wrapf));
# 4373 "vm_arm.dasc"
    }
    //|   add CARG2, RA, NARGS8:RC
    //|   ldr CARG1, L->maxstack
    //|  add RC, BASE, NARGS8:RC
    //|    str BASE, L->base
    //|   cmp CARG2, CARG1
    //|  str RC, L->top
    dasm_put(Dst, 5517, Dt1(->maxstack), Dt1(->base), Dt1(->top));
# 4380 "vm_arm.dasc"
    if (op == BC_FUNCCW) {
      //|  ldr CARG2, CFUNC:CARG3->f
      dasm_put(Dst, 5527, Dt8(->f));
# 4382 "vm_arm.dasc"
    }
    //|    mv_vmstate CARG3, C
    //|  mov CARG1, L
    //|   bhi ->vm_growstack_c		// Need to grow stack.
    //|    st_vmstate CARG3
    //|  blx CARG4			// (lua_State *L [, lua_CFunction f])
    //|  // Returns nresults.
    //|  ldr BASE, L->base
    //|    mv_vmstate CARG3, INTERP
    //|   ldr CRET2, L->top
    //|   lsl RC, CRET1, #3
    //|    st_vmstate CARG3
    //|  ldr PC, [BASE, FRAME_PC]
    //|   sub RA, CRET2, RC		// RA = L->top - nresults*8
    //|  b ->vm_returnc
    dasm_put(Dst, 5530, LJ_VMST_C, DISPATCH_GL(vmstate), Dt1(->base), LJ_VMST_INTERP, Dt1(->top), DISPATCH_GL(vmstate));
# 4397 "vm_arm.dasc"
    break;

  /* ---------------------------------------------------------------------- */

  default:
    fprintf(stderr, "Error: undefined opcode BC_%s\n", bc_names[op]);
    exit(2);
    break;
  }
}

static int build_backend(BuildCtx *ctx)
{
  int op;

  dasm_growpc(Dst, BC__MAX);

  build_subroutines(ctx);

  //|.code_op
  dasm_put(Dst, 5552);
# 4417 "vm_arm.dasc"
  for (op = 0; op < BC__MAX; op++)
    build_ins(ctx, (BCOp)op, op);

  return BC__MAX;
}

/* Emit pseudo frame-info for all assembler functions. */
static void emit_asm_debug(BuildCtx *ctx)
{
  int fcofs = (int)((uint8_t *)ctx->glob[GLOB_vm_ffi_call] - ctx->code);
  int i;
  switch (ctx->mode) {
  case BUILD_elfasm:
    fprintf(ctx->fp, "\t.section .debug_frame,\"\",%%progbits\n");
    fprintf(ctx->fp,
	".Lframe0:\n"
	"\t.long .LECIE0-.LSCIE0\n"
	".LSCIE0:\n"
	"\t.long 0xffffffff\n"
	"\t.byte 0x1\n"
	"\t.string \"\"\n"
	"\t.uleb128 0x1\n"
	"\t.sleb128 -4\n"
	"\t.byte 0xe\n"				/* Return address is in lr. */
	"\t.byte 0xc\n\t.uleb128 0xd\n\t.uleb128 0\n"	/* def_cfa sp */
	"\t.align 2\n"
	".LECIE0:\n\n");
    fprintf(ctx->fp,
	".LSFDE0:\n"
	"\t.long .LEFDE0-.LASFDE0\n"
	".LASFDE0:\n"
	"\t.long .Lframe0\n"
	"\t.long .Lbegin\n"
	"\t.long %d\n"
	"\t.byte 0xe\n\t.uleb128 %d\n"		/* def_cfa_offset */
	"\t.byte 0x8e\n\t.uleb128 1\n",		/* offset lr */
	fcofs, CFRAME_SIZE);
    for (i = 11; i >= (LJ_ARCH_HASFPU ? 5 : 4); i--)  /* offset r4-r11 */
      fprintf(ctx->fp, "\t.byte %d\n\t.uleb128 %d\n", 0x80+i, 2+(11-i));
#if LJ_ARCH_HASFPU
    for (i = 15; i >= 8; i--)  /* offset d8-d15 */
      fprintf(ctx->fp, "\t.byte 5\n\t.uleb128 %d, %d\n",
	64+2*i, 10+2*(15-i));
    fprintf(ctx->fp, "\t.byte 0x84\n\t.uleb128 %d\n", 25);  /* offset r4 */
#endif
    fprintf(ctx->fp,
	"\t.align 2\n"
	".LEFDE0:\n\n");
#if LJ_HASFFI
    fprintf(ctx->fp,
	".LSFDE1:\n"
	"\t.long .LEFDE1-.LASFDE1\n"
	".LASFDE1:\n"
	"\t.long .Lframe0\n"
	"\t.long lj_vm_ffi_call\n"
	"\t.long %d\n"
	"\t.byte 0xe\n\t.uleb128 16\n"		/* def_cfa_offset */
	"\t.byte 0x8e\n\t.uleb128 1\n"		/* offset lr */
	"\t.byte 0x8b\n\t.uleb128 2\n"		/* offset r11 */
	"\t.byte 0x85\n\t.uleb128 3\n"		/* offset r5 */
	"\t.byte 0x84\n\t.uleb128 4\n"		/* offset r4 */
	"\t.byte 0xd\n\t.uleb128 0xb\n"		/* def_cfa_register r11 */
	"\t.align 2\n"
	".LEFDE1:\n\n", (int)ctx->codesz - fcofs);
#endif
    break;
  default:
    break;
  }
}

